<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JMeter基础篇详解教程-22</title>
      <link href="/2020/09/01/jmeter/"/>
      <url>/2020/09/01/jmeter/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Jmeter(二十二) - 从入门到精通 - JMeter断言 - 下篇（详解教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>断言组件用来对服务器的响应数据做验证，常用的断言是响应断言，其支持正则表达式。虽然我们的通过响应断言能够完成绝大多数的结果验证工作，但是JMeter还是为我们提供了适合多个场景的断言元件，辅助我们来更好的完成结果验证工作。在使用JMeter进行性能测试或者接口自动化测试工作中，经常会用到的一个功能，就是断言，断言相当于检查点，它是用来判断系统返回的响应结果是否正确，以此帮我们判断测试是否通过。</p><h4 id="2-预览断言"><a href="#2-预览断言" class="headerlink" title="2.预览断言"></a>2.预览断言</h4><p>　　首先我们来看一下JMeter的断言，路径：线程组（用户）-&gt;添加-&gt;断言；我们可以清楚地看到JMeter5中共有13个断言（不包括jp@gc开头的断言，这个是宏哥安装的插件），如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/8aSDkAbCgVcqmf1.png" alt="1232840-20200722090456854-246813506.png"></p><p>如果上图您看得不是很清楚的话，宏哥总结了一个思维导图，关于JMeter5的断言类型，如下图所示： </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/Yofh8lGmdeBcnPZ.png" alt="1232840-20200723130527688-282348624.png"></p><p>通过以上的了解，我们对断言有了一个大致的了解和认识。下面宏哥就给小伙伴或则童鞋们分享讲解一些通常在工作中会用到的断言。 </p><h4 id="3-常用断言详解"><a href="#3-常用断言详解" class="headerlink" title="3.常用断言详解"></a>3.常用断言详解</h4><p>这一小节，宏哥就由上而下地详细地讲解一下常用的断言。</p><h5 id="3-1-HTML断言"><a href="#3-1-HTML断言" class="headerlink" title="3.1 HTML断言"></a>3.1 HTML断言</h5><p>对响应类为XML类型的文件进行断言；</p><p>作用对象：针对sampler中的SOAP/XML-RPC Request而使用的断言</p><p>1、我们先来看看这个 HTML断言 长得是啥样子，路径：线程组 &gt; 添加 &gt; 断言 &gt; HTML断言，如下图所示： </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/1Gl46osKyDk7UxN.png" alt="1232840-20200723132011819-54779036.png"></p><p>2、关键参数说明如下：</p><p>名称：控制器的描述性名称，显示在左边节点上，并用于命名事务 </p><p>注释：控制器注释信息，非必填项 </p><p>Tidy Settings:Tidy 环境（Tidy是一个HTML语法检查器和打印工具，可以将HTML转换为XML类型的文件）</p><p>Doctype:文档类型（可通过下拉框选择不同文档类型→ omit疏忽遗漏的/auto动态的/strict严格的/loose）</p><p>Format：文件格式（可选择HTML/XHTML/XML三种不同类型的文件格式来检查返回内容）</p><p>Errors only：误差校正（能接受的最大值）</p><p>Error threshold：误差/错误范围（可选择误差/错误数量的范围，最大值）</p><p>Warning threshold：警告范围（可选择误差警告的数量范围，最大值）</p><p>如果勾选“Error only”这里忽略Warning，只对误差作统计检查；如果对返回内容的检查结果不超过指定结果，则断言通过，否则失败。</p><p>Write JTidy report to file:写入JTidy报告的文件（JTidy是Tidy的一个java移植，可以将它当成一个处理HTML文件的DOM解析器）</p><h5 id="3-2MD5-Hex断言"><a href="#3-2MD5-Hex断言" class="headerlink" title="3.2MD5 Hex断言"></a>3.2MD5 Hex断言</h5><p>MD5是一种消息摘要算法，用以提供消息的完整性保护，对返回的MD5结果进行断言，使用简单，直接跳入MD5值。执行服务器响应的MD5哈希并将其与给定的Md5哈希进行比较。它非常适合您要检查下载文件是否完整的情况。</p><p>作用对象：针对参数类型为MD5Hex加密的参数的断言</p><p>1、我们先来看看这个 MD5 Hex断言 长得是啥样子，路径：线程组 &gt; 添加 &gt; 断言 &gt; MD5 Hex断言，如下图所示： </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/lyitx9YKmCTIsZb.png" alt="1232840-20200723132050265-887107958.png"></p><p>2、关键参数说明如下：</p><p>名称：控制器的描述性名称，显示在左边节点上，并用于命名事务 </p><p>注释：控制器注释信息，非必填项 </p><p>MD5Hex：将已被MD5加密的参数写入其中，添加取样器等其他元件</p><h5 id="3-3SMIME断言"><a href="#3-3SMIME断言" class="headerlink" title="3.3SMIME断言"></a>3.3SMIME断言</h5><p>SMIME是一种多用途网际邮件扩充协议，相比于之前的SMAP邮件传输协议，增加了安全性，对邮件主题进行保护；</p><p>作用对象：针对采用了该种邮件传输协议的信息</p><p>1、我们先来看看这个 SMIME断言长得是啥样子，路径：线程组 &gt; 添加 &gt; 断言 &gt; SMIME断言，如下图所示： </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/aOQfAPESwm8IHzq.png" alt="1232840-20200723132128105-897998871.png"></p><p>2、关键参数说明如下：</p><p>名称：控制器的描述性名称，显示在左边节点上，并用于命名事务 </p><p>注释：控制器注释信息，非必填项 </p><p>signature:签名（可选择对协议的签名验证状态）</p><pre><code>      Verify signature:验证签名      Message not signed:没有签名消息</code></pre><p>Signer certificate：签名证书（因为SMIME协议增加了安全传输，需要证书验证）</p><pre><code>      No check：不检查      Check values:检查</code></pre><p>Signer distinguished name:签名证书者名称（证书注册者的名称）</p><p>Sigmer email address:签名者的邮件地址（注册的邮件地址）</p><p>Issuer distinguished name:发行者名称（由谁发行的证书）</p><p>Serial Number:证书序号</p><p>Certificate file:选择证书文件</p><p>Execute assertion message at position:执行断言消息的位置（在返回消息的具体哪个位置执行断言）</p><h5 id="3-4XML断言"><a href="#3-4XML断言" class="headerlink" title="3.4XML断言"></a>3.4XML断言</h5><p>XML(可扩展标记语言) 提供一种描述结构化数据的方法。与主要用于控制数据的显示和外观的 HTML 标记不同，XML 标记用于定义数据本身的结构和数据类型；</p><p>作用对象：判断返回结果是否和xml的格式即&lt;&gt;&lt;/&gt;成对出现</p><p>1、我们先来看看这个 XML断言长得是啥样子，路径：线程组 &gt; 添加 &gt; 断言 &gt; XML断言，如下图所示： </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/MsANEFmLkHGce6b.png" alt="1232840-20200723132203143-1115929205.png"></p><p>2、关键参数说明如下：</p><p>名称：控制器的描述性名称，显示在左边节点上，并用于命名事务 </p><p>注释：控制器注释信息，非必填项 </p><h5 id="3-5-XML-Schema断言"><a href="#3-5-XML-Schema断言" class="headerlink" title="3.5 XML Schema断言"></a>3.5 XML Schema断言</h5><p>亦可以称为XML模型断言/XML数据类型断言；XML Schema 定义了两种主要的数据类型：①xml document schema 文档架构 ;② 文档架构xml-schema xml模式</p><p>作用对象：返回结果为XML概要断言的2中数据类型的消息</p><p>1、我们先来看看这个 XML Schema断言 长得是啥样子，路径：线程组 &gt; 添加 &gt; 断言 &gt; XML Schema断言，如下图所示： </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/KD6xnc2FwpIylU5.png" alt="1232840-20200723132240507-1289452731.png"></p><p>2、关键参数说明如下：</p><p>名称：控制器的描述性名称，显示在左边节点上，并用于命名事务 </p><p>注释：控制器注释信息，非必填项 </p><p>文件名：载入文件名 ，（写入需要断言的文件名称）</p><h5 id="3-6-Bean-Shell断言"><a href="#3-6-Bean-Shell断言" class="headerlink" title="3.6 Bean Shell断言"></a>3.6 Bean Shell断言</h5><p>BeanShell是一种松散类型的脚本语言（这点和JS类似），一种完全符合java语法的java脚本语言，并且又拥有自己的一些语法和方法；</p><p>BeanShell断言支持各种开发语言，本文介绍使用java编写断言，使用BeanShell断言的好处是可以自由发挥，比如当断言失败，提示预期结果、实际结果，或者失败时把结果输出到日志。</p><p>作用对象：针对sampler中的Bean Shell sampler而使用的断言</p><p>1、我们先来看看这个 BeanShell断言 长得是啥样子，路径：线程组 &gt; 添加 &gt; 断言 &gt; BeanShell断言，如下图所示： </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/17/5wTu6nS7osAaRGf.png" alt="1232840-20200723132321520-1058492710.png"></p><p>2、关键参数说明如下：</p><p>名称：控制器的描述性名称，显示在左边节点上，并用于命名事务 </p><p>注释：控制器注释信息，非必填项 </p><p>Reset bsh.interpreter before each call:在每次调用Bean Shell之前重置bsh.interpreter类（bsh.interpreter是Bean Shell脚本语言的一种类，也可以理解为一种解析器）</p><p>Parameters（String Parameters and String []bsh.args）:String参数（String []bsh.args是主类main函数的形式参数,是一个String 对象数组，可以用来获取命令行用户输入进去的参数）</p><p>Script file：脚本文件（可以填入脚本文件路径）</p><p>Script（see below for variables that are defined）:参照下文定义的变量（使脚本文件参照定义的变量来运行）</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p> 　　好了，今天到这里JMeter5的所有断言基础就介绍和分享完了，感谢您耐心的阅读和一路支持宏哥！！！</p>]]></content>
      
      
      <categories>
          
          <category> Jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》进阶系列教程-拿捏Fiddler抓包教程(10)-Fiddler如何设置捕获Firefox浏览器的Https会话   -10</title>
      <link href="/2016/06/18/fiddler/"/>
      <url>/2016/06/18/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》进阶系列教程-拿捏Fiddler抓包教程(10)-Fiddler如何设置捕获Firefox浏览器的Https会话 </p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>经过上一篇对Fiddler的配置后，绝大多数的Https的会话，我们可以成功捕获抓取到，但是有些版本的Firefox浏览器仍然是捕获不到其的Https会话，需要我们更进一步的配置才能捕获到会话进行抓包。</p><h2 id="2-宏哥环境"><a href="#2-宏哥环境" class="headerlink" title="2.宏哥环境"></a>2.宏哥环境</h2><p>1.宏哥的环境是Windows 10版本 64位系统（32位的同学自己想办法哦），如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211314681.png" alt></p><p>2.宏哥安装的FireFox的版本是：56.0 。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315172.png" alt></p><h2 id="3-FireFox代理设置"><a href="#3-FireFox代理设置" class="headerlink" title="3.FireFox代理设置"></a>3.FireFox代理设置</h2><p>一般来说对于Firefox 浏览器只要你开启系统代理或者手动设置代理就能正常的抓包。在Firefox中的设置下找到网络设置选择系统代理或者手动设置代理都可以，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211317212.gif" alt></p><h2 id="4-Firefox-证书设置"><a href="#4-Firefox-证书设置" class="headerlink" title="4.Firefox 证书设置"></a>4.Firefox 证书设置</h2><p>一般情况下，经过前边的配置，就可以抓取FireFox的Https会话，但是有些Firefox的版本需要手动去安装一下证书，才可以正常的去抓取信息。否则用fiddler抓包时候，打开百度网页：<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 就会出现提示：网页不安全。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315151.png" alt></p><p>上边图中的这个提示我们应该再熟悉不过了，就是因为客户端（浏览器）没有安装证书才会有这个不安全的提示信息。那么要解决这个问题我们只需要在Firefox浏览器里安装证书即可。</p><p>那么问题随之而来，证书从何而来呢？？？宏哥想让大家想一下，我们正常情况下是安装服务器配置好的证书就可以了，现在在客户端和服务器中间插入了Fiddler这个第三者。因此不用想了，证书当然是从Fiddler这里来的了。</p><h3 id="4-1Fiddler生成证书"><a href="#4-1Fiddler生成证书" class="headerlink" title="4.1Fiddler生成证书"></a>4.1Fiddler生成证书</h3><p>首先我们可以从Fiddler中手动的导出证书,前提是已经按照宏哥前边的操作已经配置好了Fiddler，可以直接导出。具体操作步骤如下：</p><p>1.打开菜单栏选择Tools–&gt;Options–&gt;HTTPS，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315056.gif" alt></p><p>2.点击Actions选择Export Root Certificate to Desktop(将根证书导出到桌面)，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211317234.gif" alt></p><p>3.导出到桌面，此时桌面上会多一个文件：FiddlerRoot.cer,如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315193.webp" alt></p><h3 id="4-2安装证书到Firefox中"><a href="#4-2安装证书到Firefox中" class="headerlink" title="4.2安装证书到Firefox中"></a>4.2安装证书到Firefox中</h3><p>1.打开右上角浏览器设置–&gt;选项–&gt;下面的隐藏与安全—-&gt;找到证书—&gt;点击查看证书（打开证书管理器）–&gt;证书机构–&gt;导入。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315467.gif" alt></p><p>2.选中刚刚导出在桌面的证书文件：FiddlerRoot.cer 导入，点击“打开”，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211317599.gif" alt></p><p>3.打开文件后，会弹出个框，勾选三个选项，点击“确定”就完成操作啦。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315161.gif" alt></p><p>安装证书后，Fiddler就能捕获FireFox发出的Https请求了。如果其他浏览器也有同样的问题，也可以单独安装证书。这是针对比较老一点的FireFox浏览器解密 HTTPS 流量的解决办法如果已经安装了证书会提示已经存在。</p><h2 id="5-检查是否能捕获FireFox的Https会话"><a href="#5-检查是否能捕获FireFox的Https会话" class="headerlink" title="5.检查是否能捕获FireFox的Https会话"></a>5.检查是否能捕获FireFox的Https会话</h2><p>可以看到没有安全提示了，而且Fiddler已经抓包成功了，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211317550.gif" alt></p><h2 id="6-Fiddler请求基本过滤"><a href="#6-Fiddler请求基本过滤" class="headerlink" title="6.Fiddler请求基本过滤"></a>6.Fiddler请求基本过滤</h2><p>Fiddler默认上抓到的是我们web端和移动端所有的请求请求，如果web端上打开了网页并且同时手机也在发送请求会话的时候， 那么这时候就需要开启过滤功能了。</p><p>我们通过Fiddler菜单栏中的Tools—&gt;Options–&gt;HTTPS修改..from all processes这一项，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315225.png" alt></p><p>选项含义如下表:</p><table><thead><tr><th>选择项</th><th>描述</th></tr></thead><tbody><tr><td><code>from all processes</code></td><td>抓所有进程所产生的请求会话</td></tr><tr><td><code>from browsers only</code></td><td>只抓浏览器进程所产生的请求会话</td></tr><tr><td><code>from non-browsers only</code></td><td>只抓非浏览器的请求</td></tr><tr><td><code>from remote clients only</code></td><td>只抓远程客户端请求, 一般手机抓包会用!</td></tr></tbody></table><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>如果还不能成功，那就重启浏览器，重启电脑了。其他浏览器也基本上是这样操作的。</p><h3 id="6-1可能遇到的坑"><a href="#6-1可能遇到的坑" class="headerlink" title="6.1可能遇到的坑"></a>6.1可能遇到的坑</h3><p>重启电脑和浏览器后，如果还是有问题，不能够成功。请执行下边的操作：</p><h4 id="6-1-1fiddler设置"><a href="#6-1-1fiddler设置" class="headerlink" title="6.1.1fiddler设置"></a>6.1.1fiddler设置</h4><p>1.打开菜单栏选择Tools–&gt;Options–&gt;HTTPS，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315173.gif" alt></p><p>2.点击Actions，点击里面的子菜单的Reset All Certificates，点击确定，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/hongduhong/blog-image/202207211315710.gif" alt></p><p>3.重启浏览器，重启Fiddler后。就OK了。</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》进阶系列教程-拿捏Fiddler抓包教程(9)-Fiddler如何设置捕获Https会话  -09</title>
      <link href="/2016/06/17/fiddler/"/>
      <url>/2016/06/17/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》进阶系列教程-拿捏Fiddler抓包教程(9)-Fiddler如何设置捕获Https会话 </p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>由于近几年来各大网站越来越注重安全性都改成了https协议，不像前十几年前直接是http协议直接裸奔在互联网。还有的小伙伴或者童鞋们按照上一篇宏哥的配置都配置好了，想大展身手抓一下百度的包，结果一试傻眼了，竟然毛都没有抓到，怀疑是不是上了宏哥的当了。不是的哈，今天宏哥趁热打铁接着讲解如何抓取https协议会话。</p><h4 id="2-什么是HTTPS？"><a href="#2-什么是HTTPS？" class="headerlink" title="2.什么是HTTPS？"></a>2.什么是HTTPS？</h4><p>HTTPS就是加过密的HTTP。使用HTTPS后，浏览器客户端和Web服务器传输的数据是加密的，只有浏览器和服务器端知道内容。</p><p>HTTPS = HTTP + TLS或者SSL。采用HTTPS的网站需要数字证书认证机构（Certificate Authority，CA）申请证书。</p><p>通过这个证书，浏览器在请求数据前与Web服务器有几次握手验证，以证明相互的身份，然后对HTTP请求和响应进行加密。</p><h4 id="3-HTTPS协议传输的原理"><a href="#3-HTTPS协议传输的原理" class="headerlink" title="3.HTTPS协议传输的原理"></a>3.HTTPS协议传输的原理</h4><p>HTTPS协议传输的原理和过程简图如下所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/iGhXMlouP5ktvVT.png" alt="img"></p><h4 id="4-Fiddler捕获Http协议会话"><a href="#4-Fiddler捕获Http协议会话" class="headerlink" title="4.Fiddler捕获Http协议会话"></a>4.Fiddler捕获Http协议会话</h4><p>Fiddler是一个很好的抓包工具，默认是抓Http协议请求的（经过上一篇的配置就可以成功捕获），但是不会捕获Https协议会话，需要你进一步配置才能抓取Https会话。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/hcu5yW3xzNnISa6.png" alt="img"></p><h4 id="5-Fiddler抓取HTTPS原理"><a href="#5-Fiddler抓取HTTPS原理" class="headerlink" title="5.Fiddler抓取HTTPS原理"></a>5.Fiddler抓取HTTPS原理</h4><p>现在无论是网站还是APP中的数据传输基本上都使用HTTS传输，传输的数据都是经过加密的，这增加了我们分析数据包的难度，还好Fiddler除了可以抓取HTTP数据包，还可以抓取HTTPS数据包。由于HTTPS传输需要使用到CA证书，所以抓取抓取HTTPS数据包时需要做一些特殊配置。Fiddler截取HTTPS报文的流程大致如下：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/tDkUWOZlcRAHzsV.png" alt="img"></p><p><strong>上图图解说明：</strong></p><p>1) 客户端请求建立HTTPS链接，发送客户端支持的加密协议及版本列表等信息给服务器端。</p><p>2) Fiddler接受客户端请求并伪装成客户端向WEB服务器发送相同的请求。</p><p>3) WEB服务器收到Fiddler的请求以后，从请求中筛选合适的加密协议。并返回服务器CA证书，证书中包括公钥信息。</p><p>4) Fiddler收到WEB服务器的响应后保存服务器证书并自签名一个CA证书，伪装成服务器，把该证书下发给客户端。</p><p>5) 客户端验证证书合法性。（Fiddler能否抓取到HTTPS报文关键看这一步）。</p><p>6) 客户端生产对称密钥，通过证书的公钥加密发送给服务器。</p><p>7) Fiddler拦截客户端的请求以后，使用私钥解密该报文，获取对称加密秘钥，并使用服务器证书中带的公钥加密该对称密钥发送给WEB服务器。此时对称密钥已经泄露了，以后可以使用该秘钥界面客户端和服务器端传输的数据。</p><p>8) WEB服务器接收到客户端发送的加密的对称密钥后使用私钥解密，并使用对称密钥加密测试数据传给客户端。</p><p>9) Fiddler使用前面获取的对称密钥解密报文。</p><p>10) 客户端验证数据无误以后HTTPS连接就建立完成，客户端开始向服务器发送使用对称密钥加密的业务数据。</p><p>11) Fiddler使用前面获取的对称密钥解密客户端发送的数据并重新加密转发给客户端。</p><h4 id="6-Fiddler捕获Https协议会话"><a href="#6-Fiddler捕获Https协议会话" class="headerlink" title="6.Fiddler捕获Https协议会话"></a>6.Fiddler捕获Https协议会话</h4><p>默认情况下，Fiddler不会捕获HTTPS请求，需要进行设置。</p><p>当浏览器访问HTTPS网页的时候，Fiddler能捕获到很多握手验证的请求，比如用浏览器访问：Https://<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ,在Fiddler中就能抓到很多“Tunnel to”的请求，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/nJbt9DcyI4lTWZe.png" alt="img"></p><p>1.在没有进一步配置之前用Fiddler抓包时候，分别用FireFox和Chrome浏览器打开百度网页：<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 可以在会话面板看到百度信息，但是进行查看是Fiddler的监控面板出现黄色的告警“Https decryption is disabled click to configure”（翻译：https 解密被禁用 ，点击配置）。至于IE浏览器，微软已经官宣它已经要落幕退役，宏哥这里就不做过多的介绍了。当然了Firefox浏览器有些版本也会有特殊情况需要你进一步配置，这个宏哥在后边会做介绍的。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/nJbt9DcyI4lTWZe.png" alt="img"></p><p>从上图中我们可以清楚地看到Host列中出现Tunnel to…字样”，总之以后如果会话列表中的Host列中出现Tunnel to…字样都说明是证书的问题, 这种就不能抓取到我们想要的会话。那么要抓取https协议的会话需要打开配置安装证书才可以,毕竟目前很多网站都是https协议的, 所以在抓包之前，我们还要配置一下证书 否则无法抓包。那么接下来跟随宏哥看看Fiddler如何配置证书。</p><h5 id="6-1Fiddler证书配置"><a href="#6-1Fiddler证书配置" class="headerlink" title="6.1Fiddler证书配置"></a>6.1Fiddler证书配置</h5><p>1.启动FIddler，然后在菜单栏点击Tools—-&gt;Options—-&gt;HTTPS 。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/Q14ToLXBP2f73OR.gif" alt="img"></p><p>2.依次勾选“Capture HTTPS CONNECTs”（捕获HTTPS连接）和勾选“Decrypt HTTPS traffic”(解密HTTPS流量)，然后会弹出一个对话框 直接点击YES即可。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/uHhJkW7Z6rMsTiD.png" alt="img"></p><p><strong>敲黑板！！！</strong></p><p>你是第一次安装的Fiddler那么正常情况下会弹出证书安装的相关提示。如果有的小伙伴或者童鞋们没有弹出提示，你也不要着急上火和担心，你可以点击Actions—&gt; Trust Root Certificate(信任根证书)就会弹出一模一样的证书安装相关提示。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/3LFSZJl4jXCE1GU.gif" alt="img"></p><p>3.点击“Yes”后，接下来弹出的对话框全部傻瓜式地点击“是”即可。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/KkcSGPAOMh328ws.png" alt="img"></p><p>4.弹出“Added Fiddler’s root certificate to the Machine Root list”(将Fiddler的证书添加到机器根目录列表中) ，点击“确定”。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/NDkqAy6ZrvEndCt.png" alt="img"></p><p>5.最后把下面的:“Ignore server certificate errors(unsafe)”忽略服务器证书错误（不安全）和“check for certificate revocation ”(证书撤销检查)这两个选项也勾选上。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/lIsLefFxdmpzcO9.png" alt="img"></p><p>到此证书也已经安装到Fiddler上了。</p><h5 id="6-2查看安装到Fiddler的证书"><a href="#6-2查看安装到Fiddler的证书" class="headerlink" title="6.2查看安装到Fiddler的证书"></a>6.2查看安装到Fiddler的证书</h5><h6 id="6-2-1方法一"><a href="#6-2-1方法一" class="headerlink" title="6.2.1方法一"></a>6.2.1方法一</h6><p>1.我们可以点击Actions中选择Open Windows Certificate Manager这一个选项, 打开打开Windows证书管理器去查看。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/TILguoAQvJZKfPW.gif" alt="img"></p><p>2.打开打开Windows证书管理器 之后点击菜单栏上的 操作—&gt;查找证书然后输入Fiddler 就会查找出证书了（如果没有说明没有安装成功），如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/s2fLr7GPuSwRCHi.gif" alt="img"></p><p>3.证书名为DO_NOT_TRUST_FiddlerRoot 大家可以对照着看看。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/Ea2noObIVMfLHpX.png" alt="img"></p><h6 id="6-2-2方法二"><a href="#6-2-2方法二" class="headerlink" title="6.2.2方法二"></a>6.2.2方法二</h6><p>1.WIN+R打开运行，输入certmgr.msc回车，点击“受信任的根证书颁发机构—&gt;点击“证书”。查看，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/tSikEG1xJb3QZqM.png" alt="img"></p><h5 id="6-3信任证书"><a href="#6-3信任证书" class="headerlink" title="6.3信任证书"></a>6.3信任证书</h5><p>证书安装了之后 还要设置一下信任才行。具体操作步骤如下：</p><p>1.直接选择Tools—&gt;Options—-&gt;HTTPS—-&gt;Actions—&gt;Trust Root Certificate 。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/AyVoWvQfb3Sg1jL.gif" alt="img"></p><p>2.在接下来弹出的对话框中直接点击确定或yes就行了，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/9a5CG6veIgMiFnz.png" alt="img"></p><p> 好了到此为止，大功告成！现在如果不出意外的话就可以进行正常的抓取HTTPS包了。</p><p><strong>敲黑板！！！</strong></p><p>如果还是不行，那么最好重置一下证书 在Actions中选择Reset All Certificates(重置所有证书) 然后点击确定删除Fiddler所配置的证书,最后重新执行之前的步骤就可以了。</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/SgTcsbD8oZYO7Xn.png" alt="img"></p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p> 今天宏哥主要简单的讲解和分享了Fiddler如何设置捕获Https会话 ，后边会一一展开进行详细的分享和讲解，好了时间不早了今天就到这里，感谢大家耐心地阅读！！！</p><p>会遇到的问题：</p><p>证书导出失败，出现如下提示：Unable to configure Windows to Trust the Fiddler Root…. 如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/Ff97HZqkeQvcd1t.png" alt="img"></p><p>解决方案：</p><p>找到fiddler-&gt;工具栏tools-&gt;options，再选择HTTPS，点击CertEnroll engine，选择MakeCert即可点击OK保存，最后切记重启fiddler！！！</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/jpASCVm4vfIRDtl.png" alt="img"></p><h4 id="8-拓展"><a href="#8-拓展" class="headerlink" title="8.拓展"></a>8.拓展</h4><p>我们在Skip decryption中输入ip地址或者域名可以用来跳过该主机或域名的https数据抓取，这个也相当于一种过滤功能吧！如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/21/m8D2c1KsZMn4gCh.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》进阶系列教程-拿捏Fiddler抓包教程(8)-Fiddler如何设置捕获会话 -08</title>
      <link href="/2016/06/16/fiddler/"/>
      <url>/2016/06/16/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》进阶系列教程-拿捏Fiddler抓包教程(8)-Fiddler如何设置捕获会话</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p> 前边几篇宏哥介绍了Fiddler界面内容以及作用。今天宏哥就讲解和分享如何设置Fiddler后，我们就可以捕获会话，进行抓包了。</p><h4 id="2-捕获会话的设备"><a href="#2-捕获会话的设备" class="headerlink" title="2.捕获会话的设备"></a>2.捕获会话的设备</h4><p>常见的捕获会话的设备分为PC（电脑）端和手机（Android和IOS苹果）端。</p><h4 id="3-PC（电脑）端"><a href="#3-PC（电脑）端" class="headerlink" title="3.PC（电脑）端"></a>3.PC（电脑）端</h4><p>电脑端我们一般抓取的都是web网站请求和响应信息。那么我们看一下如何设置进行抓包。</p><h5 id="3-1Fiddler抓web网站请求"><a href="#3-1Fiddler抓web网站请求" class="headerlink" title="3.1Fiddler抓web网站请求"></a>3.1Fiddler抓web网站请求</h5><h6 id="3-1-1方法一"><a href="#3-1-1方法一" class="headerlink" title="3.1.1方法一"></a>3.1.1方法一</h6><p>1.手动设置方法：Tools—&gt;WinINET Options—&gt;连接—&gt;局域网设置—&gt;代理服务器勾选后“高级”—&gt;服务器地址：127.0.0.1，端口8888；如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/TUCX5k8bYoOpRQB.png" alt></p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/GVBJS9EKOpWb4Ro.png" alt></p><h6 id="3-1-2方法二"><a href="#3-1-2方法二" class="headerlink" title="3.1.2方法二"></a>3.1.2方法二</h6><p>1.手动设置方法：①、File—&gt;勾选Capture Traffic； 如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ZQuy4Wfpq6hSgak.png" alt></p><p>  ②、点击左下角Capturing进行选择或取消；如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/oEqMapejTz1mGby.png" alt></p><p>2.自动设置步骤：Tools—&gt; Options—&gt;Connections—&gt;勾选Act as system proxy on startup(作为系统启动代理)，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/cp57a3lmQVJ6xSu.png" alt></p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/mTy9g4kxCS5wtsL.png" alt></p><h5 id="3-2浏览器设置"><a href="#3-2浏览器设置" class="headerlink" title="3.2浏览器设置"></a>3.2浏览器设置</h5><h6 id="3-2-1-IE浏览器"><a href="#3-2-1-IE浏览器" class="headerlink" title="3.2.1 IE浏览器"></a>3.2.1 IE浏览器</h6><p>1.打开IE，点击右上角的”工具“，选择”Internet选项“。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/OPbE75npGjzgcok.png" alt></p><p>2.连接—&gt;局域网设置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/b4gJ9OLaRqAtlhf.png" alt></p><p>3.代理服务器勾选后“高级”—&gt;填写服务器地址：127.0.0.1，端口8888。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/xauZkimYhlI1Pqy.png" alt></p><h6 id="3-2-2chrome设置代理"><a href="#3-2-2chrome设置代理" class="headerlink" title="3.2.2chrome设置代理"></a><strong>3.2.2chrome设置代理</strong></h6><p>1.点击右上角三点标志-&gt;点击设置-&gt;高级-&gt;打开您计算机的代理设置（进入代理设置页），如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/lMOQigRfwE3VmSs.gif" alt="img"></p><p>2.设置代理【输入代理地址：127.0.0.1 端口：8888（若设置了其他端口，输入自己设置的端口号）】，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/M5XV9iFcoHx8mSJ.png" alt="img"></p><h6 id="3-2-3firefox设置代理"><a href="#3-2-3firefox设置代理" class="headerlink" title="3.2.3firefox设置代理"></a><strong>3.2.3firefox设置代理</strong></h6><p>1.点击设置-&gt;选项-&gt;网络设置（设置）&gt;进入代理设置页，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/iIwOe58gmbLRuTY.png" alt></p><p><img src="/images/loading.gif" data-original="https://img2018.cnblogs.com/blog/1707637/201908/1707637-20190802193501826-595424653.png" alt></p><p>2.勾选手动代理配置，设置代理【输入代理地址：127.0.0.1 端口：8888（若设置了其他端口，输入自己设置的端口号）】，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Alniepjd6uMTxbS.png" alt></p><p>3.浏览器设置好代理后，访问页面，fiddler便会抓取访问请求，访问淘宝为例，fiddler抓取请求，如下图所示：</p><p> <img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/EqyxuHdntib3GBL.gif" alt></p><h4 id="4-Fiddler抓APP请求"><a href="#4-Fiddler抓APP请求" class="headerlink" title="4.Fiddler抓APP请求"></a>4.Fiddler抓APP请求</h4><p>手机端我们一般抓取的都是APP请求和响应信息。那么我们看一下如何设置进行抓包。</p><h5 id="4-1常用设置"><a href="#4-1常用设置" class="headerlink" title="4.1常用设置"></a>4.1常用设置</h5><p>1.设置步骤一：Tools—&gt; Options—&gt;HTTPS—&gt;勾选Decrypt HTTPS traffic—&gt;选择…from remote clients only(从远程客户端)，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/cp57a3lmQVJ6xSu.png" alt></p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/BE4O5nKVNsDHJZa.png" alt></p><p>2.设置步骤二：Tools—&gt; Options—&gt;Connections—&gt;设置Fiddler listens on port:8888—&gt;勾选Allow remote computers to connect(允许远程设备连接)，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/yOcmZxW3koF7Ka6.png" alt></p><p>3.设置步骤三：①.查看fiddler所在计算机的IP（cmd—&gt; ipconfig或者点击fiddler右上角Online），如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/fVJkCHmIrZ9Us6t.png" alt></p><p>或者查看电脑ipv4地址，打开cmd窗口输入：ipconfig。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/q81R2BfvySUpO3T.png" alt></p><p> ②.手机上进行设置：同一个wifi下设置代理，服务器地址：计算机的IP（192.168.0.163），端口8888；如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/r8ngxFmEMLC6VbY.png" alt></p><h5 id="4-2附加设置（常用设置后无法进行抓包）"><a href="#4-2附加设置（常用设置后无法进行抓包）" class="headerlink" title="4.2附加设置（常用设置后无法进行抓包）"></a>4.2附加设置（常用设置后无法进行抓包）</h5><h6 id="4-2-1方法一"><a href="#4-2-1方法一" class="headerlink" title="4.2.1方法一"></a>4.2.1方法一</h6><p>  方法：因为有些APP对安全上要求没有那么高时候，不需要下载证书，但是有的APP对安全要求比较高，就需要下载证书，下载证书步骤：在手机浏览器输入网址：<a href="http://[fiddlerserver]:[port]/FiddlerRoot.cer" target="_blank" rel="noopener">http://[FIDDLERSERVER]:[Port]/FiddlerRoot.cer</a>或者[FIDDLERSERVER]:[Port]，例如：<a href="http://192.168.0.163:8888/FiddlerRoot.cer或者192.168.0.163:8888" target="_blank" rel="noopener">http://192.168.0.163:8888/FiddlerRoot.cer或者192.168.0.163:8888</a></p><p> <img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/5Z41AIuYwVPFxSR.png" alt></p><p>  安装的证书在手机的位置如下，可以进行删除、重新安装；</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/fpboW5ICgZsx8YE.png" alt></p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Oxbzhp2dw9I7rtD.png" alt></p><h6 id="4-2-2方法二"><a href="#4-2-2方法二" class="headerlink" title="4.2.2方法二"></a>4.2.2方法二</h6><p>方法：1.启动Fiddler，然后Rules—&gt; Customize Rules打开代码编辑器，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/TRIq2e5JnEtzQGj.png" alt></p><p>2.按Ctrl+F—&gt;打开Find and Replace—&gt;输入查询关键字：OnBeforeResponse。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/XwhDFogf6kjM4PV.png" alt></p><p>3.在函数OnBeforeResponse中添加如下代码：</p><p>苹果手机：</p><pre><code>if (oSession.oRequest[&quot;User-Agent&quot;].indexOf(&quot;iPhone/9.2.1&quot;)&gt; -1 &amp;&amp; oSession.HTTPMethodIs(&quot;CONNECT&quot;)){    oSession.oResponse.headers[&quot;Connection&quot;] = &quot;Keep-Alive&quot;;}</code></pre><p>安卓手机：</p><pre><code>if (oSession.oRequest[&quot;User-Agent&quot;].indexOf(&quot;Android&quot;)&gt; -1 &amp;&amp; oSession.HTTPMethodIs(&quot;CONNECT&quot;)){    oSession.oResponse.headers[&quot;Connection&quot;] = &quot;Keep-Alive&quot;;}</code></pre><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p> 好了，今天就简单的说明一些配置和技巧，后边关于手机端，宏哥会单独列出章节进行详细讲解。小伙伴或者童鞋们在这里先入入门有个印象就好。</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(7)-Fiddler状态面板-QuickExec命令行 -07</title>
      <link href="/2016/06/15/fiddler/"/>
      <url>/2016/06/15/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(7)-Fiddler状态面板-QuickExec命令行 </p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p> Fiddler成了网页调试必备的工具，抓包看数据。Fiddler自带命令行控制，并提供以下用法。Fiddler的快捷命令框让你快速的输入脚本命令。</p><p>除了输入默认命令，也可以自定义命令，你可以通过编辑 FiddlerScript 来增加新命令，找到 OnExecAction 函数增加新命令。多数命令是存在本地 CustomRules.js 文件中，如果不是最新版 Fiddler，可能没有最新的命令。如果要得到最新的命令，要么删除你的 CustomRules.js，要么复制 SampleRules.js 的 ExecAction 到 CustomRules.js 中。</p><h4 id="2-官网使用教程"><a href="#2-官网使用教程" class="headerlink" title="2.官网使用教程"></a>2.官网使用教程</h4><p>在fiddler官网有QuickExec使用教程，地址是：<a href="http://docs.telerik.com/fiddler/knowledgebase/quickexec" target="_blank" rel="noopener">http://docs.telerik.com/fiddler/knowledgebase/quickexec</a> </p><h4 id="3-QuickExec命令行窗口概览"><a href="#3-QuickExec命令行窗口概览" class="headerlink" title="3.QuickExec命令行窗口概览"></a>3.QuickExec命令行窗口概览</h4><p>QuickExec命令行窗口位于Fiddler左下角黑色输入框，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/fzIClMEWpyHseow.png" alt></p><h4 id="4-键盘快捷键"><a href="#4-键盘快捷键" class="headerlink" title="4.键盘快捷键"></a>4.键盘快捷键</h4><p>1.在 Fiddler 中使用快捷键 Alt + Q 可以快速将焦点定位到QuickExec 命令行</p><p>2.如果当前在 Web Sessions 面板选择了一个 Session，可以使用快捷键 Ctrl + I 快速将 Session URL 直接插入到命令行当前光标处</p><p>3.如果Fiddler没有激活，按 Ctrl+Alt+F 首先 激活Fiddler</p><h4 id="5-命令列表"><a href="#5-命令列表" class="headerlink" title="5.命令列表"></a>5.命令列表</h4><p>以下列表中的命令只能确保在最新版本的 Fiddler 中才生效。</p><table><thead><tr><th>命令</th><th>含义</th><th>栗子</th></tr></thead><tbody><tr><td></td><td><strong>筛选高亮类</strong></td><td></td></tr><tr><td>=</td><td>高亮 = 号后面的状态码和请求方式session</td><td>1，=post ：然后点击enter键回车，可以看到所有的post请求都是以蓝色的底色显示 2，=200 ：也可以用这个方法迅速找出响应代码的，=200 =404等情况</td></tr><tr><td>?</td><td>高亮 ? 号后面的字符session，文本搜索功能，使用Ctrl + F 和 工具栏中的 Find 按钮都可以对session中的字符进行搜索</td><td>? 关键字 例如：?baidu</td></tr><tr><td>&gt;size</td><td>高亮响应大于或小于指定的session</td><td>1，&gt;50000 直接接数字就可以了，表示选择响应大于50kb的请求 2，&lt;5k 表示选择响应小于5kb的请求</td></tr><tr><td>@host</td><td>高亮包含指定host的session</td><td>@google.com</td></tr><tr><td></td><td><strong>断点类</strong></td><td></td></tr><tr><td>bpu</td><td>指定URL字符请求断点</td><td>1，bpu /myservice.asmx （中断所有请求 URL 中包含指定字符的 session） 2，bpu （不带参数表示清空所有设置断点的 session）</td></tr><tr><td>bpafter</td><td>指定URL字符响应断点,中断 URL 包含指定字符的全部 session 响应</td><td>1，bpafter google (中断所有带google请求的返回值) 2，bpafter （不带参数表示清空所有设置的断点）</td></tr><tr><td>bps</td><td>指定状态码响应断点</td><td>1，bps 404 （表示中断所有响应404的session） 2，bps （不带参数表示清空所有设置的断点session）</td></tr><tr><td>bpv or bpm</td><td>指定请求方式响应断点</td><td>1，bpv POST （中断所有 POST 请求的 session） 2，bpv （不带参数表示清空所有设置断点的 session）</td></tr><tr><td>g or go</td><td>继续中断的断点，放行</td><td></td></tr><tr><td></td><td><strong>select</strong></td><td></td></tr><tr><td>select <em>MIME</em></td><td>选择响应类型 (Content-Type) 为指定字符的所有 session</td><td>1. select image 2. select css 3. select htm</td></tr><tr><td>select <em>HeaderOrFlag PartialValue</em></td><td>选择Header或SessionFlag中包含指定字符串内容的session</td><td>1，select ui-comments slow （查找带slow的注释） 2，select ui-bold * （如果<em>号前面没有一个斜杠进行转义，则意味着任何值） 3，select ui-comments \</em> （查找带一个*号的注释） 4，select @Request.Accept html （查找request包含html的session） 5，select @Response.Set-Cookie domain （在所有Session的Response中，查找name为Set-Cookie值为域名如baidu.com的Session）</td></tr><tr><td></td><td><strong>其他</strong></td><td></td></tr><tr><td>PREFS SET</td><td>设置详情页自动定位tab，定位 request/response 在特定的tab上，用于在很多条session中，查看每条session，都右侧的详情数据页面都会自动定位到我们需要的tab上面，不用每条单独操作</td><td>1，PREFS SET fiddler.ui.inspectors.response.alwaysuse “json” ：查看任何 session，Response tab被自动定位到JSON上 2，PREFS SET fiddler.ui.inspectors.request.alwaysuse “webforms” ：查看任何 session的resquest默认显示在webforms的tab上</td></tr><tr><td>allbut or keeponly</td><td>筛选非，选择响应类型 (Content-Type) 不是指定字符的所有 session</td><td>1，allbut xml （只显示所有Content-Type为非xml的session项） 2，allbut java</td></tr><tr><td>bold</td><td>加粗指定字符的session</td><td>1， bold关键字 例如：bold google，回车后，需要重新请求一次，就可以看见加粗了 2，状态栏，显示着：Bolding request for baidu 表示正在加粗。菜单栏中的 Tool &gt; Rest Script 可以重置加粗状态 3，bold （不带参数表示清空所有加粗显示的session）</td></tr><tr><td>cls or clear</td><td>清除所有session</td><td></td></tr><tr><td>start</td><td>将 Fiddler 设为系统代理</td><td></td></tr><tr><td>stop</td><td>将 Fiddler 从系统代理注销</td><td></td></tr><tr><td>dump</td><td>打包session到zip压缩包中</td><td>将所有 session 打包到 C 盘根目录下（C:\）的一个 zip 压缩包中</td></tr><tr><td>urlreplace</td><td>替换URL中的字符串</td><td>将 URL 中的字符串替换成特定的字符串 1，urlreplace SeekStr ReplaceWithStr 2，urlreplace （不带参数表示清空所有之前的设置）</td></tr><tr><td>help</td><td>打开 QuickExec 在线帮助页</td><td>就是这个网址：<a href="http://docs.telerik.com/fiddler/knowledgebase/quickexec" target="_blank" rel="noopener">http://docs.telerik.com/fiddler/knowledgebase/quickexec</a></td></tr><tr><td>hide</td><td>将 Fiddler 隐藏到任务栏图标中</td><td></td></tr><tr><td>show</td><td>Fiddler 从任务栏图标恢复为图形界面</td><td>此命令在命令行工具 ExecAction.exe 中使用</td></tr><tr><td>quit</td><td>退出 Fiddler</td><td></td></tr><tr><td>!dns</td><td>输出IP地址</td><td>对目标主机执行DNS查找，并在LOG选项卡上显示结果 1，!dns <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> （将<a href="http://www.baidu.com对应的IP地址解析并输出）" target="_blank" rel="noopener">www.baidu.com对应的IP地址解析并输出）</a> 2，!nslookup <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> （作用和上面这个一样）<img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/1wc8kI2QD7GfvXh.gif" alt="img"></td></tr><tr><td>!listen</td><td>监听多个端口号</td><td>在另一个端口上设置一个额外的监听器，可选由HTTPS证书保护 1，!listen 8889 （同时截获通过8080端口的网络请求。） 2，!listen 4443 localhost 3，!listen 444 secure.example.com</td></tr></tbody></table><h4 id="6-自定义命令"><a href="#6-自定义命令" class="headerlink" title="6.自定义命令"></a>6.自定义命令</h4><p>你可以通过编辑你的 FiddlerScript 来增加新命令。找到 OnExecAction 函数增加新命令。编辑方式：</p><p>1.主菜单 Rules -&gt; Customize Rules… 如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/XFEGKqBfl54icCj.gif" alt></p><p>2.安装插件 Syntax-Highlighting Addons（右键另存为），安装后会增加一个 FiddlerScript 页签，在这里可以直接编辑保存。（这个是针对低版本的Fiddler，最新的都自带了。）如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Xr8PshJOt4EDL5c.png" alt></p><p>3.如果安装了此插件，主菜单的菜单项也会使用 Fiddler 脚本编辑器打开。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/lfprCZc4eS2bhuD.png" alt></p><p>4.安装了此插件后，Inspectors 页签的响应部分也会增加一个 SyntaxView，用于高亮显示响应的body。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/M26Rnb1odUCYKE8.png" alt></p><h4 id="7-默认命令"><a href="#7-默认命令" class="headerlink" title="7.默认命令"></a>7.默认命令</h4><p>为什么输入默认命令，会有作用，这因为Fiddler已经定义好了，在OnExecAction函数中，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/5XHkSJCAytj3Mw9.gif" alt></p><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h4><p> 到此对Fiddler做一些界面的介绍基本上就差不多了，当然了宏哥没有介绍到的你遇到了自己可以看资料查一下，接下来宏哥将会讲解和分享Fiddler的重头戏-各种配置和操作技巧。各位小伙伴或者童鞋们敬请期待，千万不要错过哦！</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(6)-Fiddler状态面板详解 -06</title>
      <link href="/2016/06/14/fiddler/"/>
      <url>/2016/06/14/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(6)-Fiddler状态面板详解</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p> 按照从上往下，从左往右的计划，今天就轮到介绍和分享Fiddler的状态面板了。</p><h4 id="2-状态面板概览"><a href="#2-状态面板概览" class="headerlink" title="2.状态面板概览"></a>2.状态面板概览</h4><p>Fiddler的状态面板概览，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/gheldSLXbA4IYR3.png" alt></p><h4 id="3-状态面板详解"><a href="#3-状态面板详解" class="headerlink" title="3.状态面板详解"></a>3.状态面板详解</h4><p>Fiddler底端状态栏面板详解，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/8X1STHMtoZEkbj7.png" alt></p><h5 id="3-1Capturing"><a href="#3-1Capturing" class="headerlink" title="3.1Capturing"></a>3.1Capturing</h5><p>显示的 Fiddler 是否处于捕捉状态，<img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/nXS9PZHzLJUtD1b.gif" alt>（开启状态）、<img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/CVeTahqgUyt9b52.gif" alt>（关闭状态），可以用快捷键 F12 切换或者点击该区域切换。此处与菜单栏中 File→Capture Traffic 效果是一致的，默认底端状态栏此处是有 Caturing，有它才表示 fiddler 捕获请求。</p><h5 id="3-2All-Processes"><a href="#3-2All-Processes" class="headerlink" title="3.2All Processes"></a>3.2All Processes</h5><p>这里有 All Processes，Web Browsers，Non-Browser，Hide All 几个选项，这个几个选项顾名思义，但要注意的是这些不是筛选当前 session 框中的 session，而是选中需要筛选的状态之后，后面的请求会按照此状态来筛选。显示当前捕捉哪些进程的通讯。前提是被捕获的进程必须使用 HTTP 代理：127.0.0.1:8888</p><ul><li><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/K9ho3aVcvBsZ6dA.gif" alt><strong>All Processes</strong> —— 捕获所有进程的请求</li><li><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/gDsHQj5bL2JM1a8.gif" alt><strong>Web Browsers</strong> —— 捕获 Web 浏览器的请求，应该特指 IE</li><li><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/DAw1RClipYz2LXU.gif" alt><strong>Non-Browser</strong> —— 捕获非 Web 浏览器的请求</li><li><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/1YQI7Hjr4DseXz5.gif" alt><strong>Hide All</strong> —— 隐藏所有请求</li></ul><p>All Processes（进程筛选）可以对抓包进行筛选，可以根据自己情况选择。也就是说在抓包的时候，是显示所有会话进程还是浏览器请求的会话进程 还是不是浏览器请求的会话进程 或者全部隐藏，根据自己的需求进行选择就行了。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Zy8ugI5WXkFYNG4.png" alt></p><h5 id="3-3断点"><a href="#3-3断点" class="headerlink" title="3.3断点"></a>3.3断点</h5><p>空白小区域，这个小区域，如果你用鼠标点击一下就会出现<code>断点</code>的设置，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/mzMcWHrSGq69e8R.png" alt></p><p>显示当前断点设置状态，通过鼠标点击切换。可以有三种：</p><ul><li><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/5Hto7iqcWfb3lR6.gif" alt> —— 不设置断点</li><li><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/YNUeuBwlniDKQyx.gif" alt> —— 所有请求在断点处被暂停，意思就是请求之前<code>断点</code>， 也就是当这个状态启动的时候，那么你发送的请求就会卡在这里。</li><li><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/EPk9a32nYXQrA6q.gif" alt> —— 所有响应在断点处被暂停， 也就是说服务器已经返回请求的数据了，但是被<code>Fiddler</code>在中间卡住了，还没有到客户端这一边。</li></ul><h5 id="3-4数字-数字"><a href="#3-4数字-数字" class="headerlink" title="3.4数字/数字"></a>3.4数字/数字</h5><p>显示当前共捕获了多少 session（如：300，表示共捕获了 300 个）。</p><p>如果选择了 session，会显示共选择了多少 session 及 session 总数（如：10/300，表示当前选择 10 个 session，共 300 个 session）。</p><p>第一个数字表示选中的session，第二个数字表示 session 框中共有多少 session。</p><h5 id="3-5URL"><a href="#3-5URL" class="headerlink" title="3.5URL"></a>3.5URL</h5><p>此处显示请求的 url 网址。描述当前状态。</p><p>如果是刚打开 Fiddler，会显示什么时间加载了 CustomRules.js；如果选择了一个 Session，会显示该 Session 的 URL；如果在 QuickExec 命令行输入一个命令，就会显示命令相关信息。</p><h4 id="4-Fiddler-底端自带命令行控制台"><a href="#4-Fiddler-底端自带命令行控制台" class="headerlink" title="4.Fiddler 底端自带命令行控制台"></a>4.Fiddler 底端自带命令行控制台</h4><p>Fiddler 控制台有许多自己的快捷键和命令来方便快速的操作 fiddler，拿到自己想要的 session，这一块的功能性内容将放在另一篇博文中讲解。</p><h5 id="4-1快速执行命令框-QuickExec"><a href="#4-1快速执行命令框-QuickExec" class="headerlink" title="4.1快速执行命令框(QuickExec)"></a>4.1快速执行命令框(QuickExec)</h5><p>这个输入框的作用就是允许用户快速输入并启动一些脚本命令。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/aR8LmWcGpEF1U6X.png" alt></p><p>一些关于QuickExec的键盘快捷键，比如：</p><p>QuickExec 命令行允许你快速执行脚本命令，在 Fiddler 中使用快捷键 Alt + Q 可以快速将焦点设置到命令行。如果 Fiddler 未处于活动状态，请先按Ctrl+ALT+F激活 Fiddler（这个是Fiddler的系统级别的热键，无论当前活动的应用是什么，都可以激活Fiddler。在选项Tools-&gt;Fiddler Options-&gt;General中可以修改这个热键。）如果当前在 Web Sessions 面板选择了一个 Session，可以使用快捷键 Ctrl + I 快速将 Session URL 直接插入到命令行当前光标处。</p><p>除了这个全局热键，启动Fiddler，还可以应用很多其他热键，具体如下表所示：</p><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td><code>ALT+Q</code></td><td>把光标定位在QuickExec对话框</td></tr><tr><td><code>CTRL+R</code></td><td>打开FiddlerScript规则编辑器</td></tr><tr><td><code>CTRL+E</code></td><td>打开TextWizard</td></tr><tr><td><code>CTRL+Down</code></td><td>选中会话列表中下一个Session</td></tr><tr><td><code>CTRL+Up</code></td><td>选中会话列表中上一个Session</td></tr><tr><td><code>CTRL+T</code></td><td>激活TextView Inspectors</td></tr><tr><td><code>CTRL+H</code></td><td>激活HeaderView Inspectors</td></tr><tr><td><code>CTRL+0</code></td><td>把字体大小设置为8.25pt（默认值）</td></tr><tr><td><code>CTRL+Plus</code></td><td>字体大小增加1pt（最多到32pt）</td></tr><tr><td><code>CTRL+Minus</code></td><td>字体大小减少1pt（最少到7pt）</td></tr><tr><td><code>CTRL+M</code></td><td>最小化Fiddler</td></tr><tr><td><code>CTRL+SHIFT+DEL</code></td><td>清除WinINET缓存</td></tr><tr><td><code>F12</code></td><td>开关，把Fiddler注册为系统代理或者从系统代理注销</td></tr></tbody></table><p>宏哥可以在快速执行命令框输入 cls 或 clear命令来快速的清空会话列表，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ForXlYa3c2Dqn8t.gif" alt></p><p> 常见命令如下表所示：</p><table><thead><tr><th>命令</th><th>对应栏位</th><th>描述</th><th>案例</th></tr></thead><tbody><tr><td><code>?</code></td><td><code>all</code></td><td>问号后边跟一个字符串，可以从<code>会话列表</code>中筛选出包含这个字符串的所有请求</td><td><code>?baidu</code></td></tr><tr><td><code>&gt;</code></td><td><code>Body</code></td><td>可以从<code>会话列表</code>中筛选出请求大小的会话，也就是<code>大于</code>这个数字请求</td><td><code>&gt;100</code></td></tr><tr><td><code>&lt;</code></td><td><code>Body</code></td><td>可以从<code>会话列表</code>中筛选出请求大小的会话，也就是<code>小于</code>这个数字请求</td><td><code>&lt;100</code></td></tr><tr><td><code>=</code></td><td><code>Result</code></td><td>等于号后面跟数字，可以从<code>会话列表</code>中筛选出对应的HTTP状态码的会话</td><td><code>=404</code></td></tr><tr><td><code>@</code></td><td><code>Host</code></td><td>@后面跟Host，可以从<code>会话列表</code>中筛选出相应的域名</td><td><code>@www.baidu.com</code></td></tr><tr><td><code>select</code></td><td><code>Content-Type</code></td><td>select后面跟响应类型，可以从<code>会话列表</code>中筛选出相关的会话类型</td><td><code>select image</code></td></tr><tr><td><code>cls</code></td><td><code>All</code></td><td>清空当前所有请求</td><td><code>cls</code></td></tr><tr><td><code>dump</code></td><td><code>All</code></td><td>将所有请求打包成<code>.saz压缩包</code>，默认会保存到C:\Users\用户名\Documents\Fiddler2\Captures目录下</td><td><code>dump</code></td></tr><tr><td><code>start</code></td><td><code>All</code></td><td>开始监听请求</td><td><code>start</code></td></tr><tr><td><code>stop</code></td><td><code>All</code></td><td>停止监听请求</td><td><code>stop</code></td></tr></tbody></table><p>更多命令 可以查看官方文档, 这里就不再过多赘述了，关于<code>快速执行命令框</code>后面的<code>断点</code>中还会用到。</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(5)-Fiddler监控面板详解-05</title>
      <link href="/2016/06/13/fiddler/"/>
      <url>/2016/06/13/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(5)-Fiddler监控面板详解</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p> 按照从上往下，从左往右的计划，今天就轮到介绍和分享Fiddler的监控面板了。监控面板主要是一些辅助标签工具栏。有了这些就会让你的会话请求和响应时刻处监控中毫无隐私可言。监控面板是fiddler最核心的功能之一。记录了来自于服务器端（webServer）的请求会话。包括页面的请求和静态文件的请求。状态面板主要显示的是会话及会话的状态。</p><h4 id="2-监控面板概览"><a href="#2-监控面板概览" class="headerlink" title="2.监控面板概览"></a>2.监控面板概览</h4><p>位于软件界面右边的这一大块面板，即为辅助标签 + 工具，宏哥称之为监控面板，它拥有 10 个小标签，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/zJNx2TF3ulvnoq1.png" alt></p><h4 id="3-辅助标签-工具详解"><a href="#3-辅助标签-工具详解" class="headerlink" title="3.辅助标签 + 工具详解"></a>3.辅助标签 + 工具详解</h4><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/AY5ma6i9xpev7Du.png" alt></p><h4 id="3-1Get-Started-欢迎页签"><a href="#3-1Get-Started-欢迎页签" class="headerlink" title="3.1Get Started 欢迎页签"></a>3.1Get Started 欢迎页签</h4><p>左侧START快速开始检查数据包、构建请求；右侧LEARN有Fiddler官方文档、推荐博客、学习Video；右侧TOP ARTICLES显示当前热门文章。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/FN8kWpMZuEIR5Ha.png" alt></p><p>######## 3.2Statistics</p><p>（Statistics）数据统计：显示一些性能指标，这些性能指标有助于分析和优化web性能。用于查看请求的性能数据,统计与分析, 也就是说它就是对当前请求的性能分析数据。Http或Https请求的性能和其他数据分析，如DNS解析时间，TCP/TP建立连接的时间（TCP三次握手的时间）、SSL连接的时间（针对https请求）等信息。当你点击一个HTTP请求会话的时候，就可以看到Statistics里面有关于当前HTTP请求的性能以及数据分析。</p><p>（1）请求总数、请求包大小、响应包大小。</p><p>（2）请求起始时间、响应结束时间、握手时间、等待时间、路由时间、TCP/IP、传输时间。</p><p>（3）HTTP状态码统计。</p><p>（4）返回的各种类型数据的大小统计以及饼图展现。</p><p>1.例如: 一些TCP/IP的连接时间，DNS的解析时间、资源消耗、各个国家的请求网络带宽对比等信息。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/d3Khx6CM1i5GjmP.webp" alt></p><p>2.Show chart：把请求的数据以饼图的形式显示，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/gFTp1Pza2wuY9tj.png" alt></p><p>2.Copy this chart：可以将该饼图复制到剪贴板，粘贴到图形处理软件或者 WORD 中。</p><p>3.Collapse Chart：收起饼图展示。</p><p>通过陈列出所有的HTTP通信量，Fiddler可以很容易的向您展示哪些文件生成了您当前请求的页面。使用Statistics页签，用户可以通过选择多个会话来得来这几个会话的总的信息统计，比如多个请求和传输的字节数。</p><p>选择第一个请求和最后一个请求，可获得整个页面加载所消耗的总体时间。从条形图表中还可以分别出哪些请求耗时最多，从而对页面的访问进行访问速度优化。</p><p>RTT（往返时间）：一个请求从发送时间到返回来的时间。是衡量一个请求的性能的一个重要的数据指标。</p><h5 id="3-3Inspectors"><a href="#3-3Inspectors" class="headerlink" title="3.3Inspectors"></a>3.3Inspectors</h5><p>（Inspectors）对请求解包：可以对抓到的请求包查看一些详细的内容，例如：请求头（Header）：包括用户的使用的浏览器、请求携带的cookies、以及发送请求的域名。以不同的形式展示请求或部分请求报文、响应或部分响应报文。</p><p>你有没有想过在Fiddler中如何快速查看http请求与响应报文呢?</p><p>其实当我们在会话列表中双击某一个会话请求就会自动跳转到Inspectors选项卡。</p><p>也就是当抓包成功之后, 就可以在左侧窗口中选择你要查看的地址来进行查看抓取的http信息数据，当选择了相应的地址之后，在右侧选项卡中 选择Inspectors(检查器), 然后再点击一下Raw就可以按照原生形式来进行查看到相应的http请求报文与http响应报文, 分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/QprtKhEaUzyCIV2.webp" alt></p><p>对于每一部分,提供了多种不同格式查看每个请求和响应的内容, <code>Inspectors</code>选项卡中还有其他的</p><p><strong>Inspectors选项卡上半部分HTTP请求内容的子集选项卡如下表所示：</strong></p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td><code>Headers</code></td><td>以层级的形式来显示HTTP请求头部的相关内容信息</td></tr><tr><td><code>TextView</code></td><td>以文本的形式展示</td></tr><tr><td><code>SytaxView</code></td><td>查看具体的请求体 或者附带的键与值</td></tr><tr><td><code>WebForms</code></td><td>可以通过它看到url提交的相关参数信息</td></tr><tr><td><code>HexView</code></td><td>以16进制进行查看请求!</td></tr><tr><td><code>Auth</code></td><td>查看请求数据权限</td></tr><tr><td><code>Cookie</code></td><td>查看请求<code>cookie</code>信息</td></tr><tr><td><code>Raw</code></td><td>原生查看http</td></tr><tr><td><code>JSON</code></td><td>以<code>JSON</code>格式展开查看请求信息!</td></tr><tr><td><code>XML</code></td><td>以<code>xml</code>格式展开查看请求信息!</td></tr></tbody></table><p><strong>Inspectors选项卡下半部分HTTP响应内容 的子集选项卡如下表所示：</strong></p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td><code>Transformer</code></td><td></td></tr><tr><td><code>Headers</code></td><td>以<code>层级</code>方式来展示<code>HTTP响应头部</code>信息</td></tr><tr><td><code>TextView</code></td><td>以<code>文本</code>方式来展示<code>HTTP响应正文</code>信息</td></tr><tr><td><code>SyntaxView</code></td><td>以<code>语法高亮</code>来展示<code>HTTP响应正文</code>信息</td></tr><tr><td><code>ImageView</code></td><td>以<code>图片的形式</code>来展示响应信息, 前提是你选择的会话是一个图片响应</td></tr><tr><td><code>HexView</code></td><td>以<code>16进制</code>来查看响应信息</td></tr><tr><td><code>Webview</code></td><td>以<code>html编译显示之后</code>的形式来查看响应结果</td></tr><tr><td><code>Auth</code></td><td>查看响应权限</td></tr><tr><td><code>Caching</code></td><td>查看响应缓存相关信息</td></tr><tr><td><code>cookie</code></td><td>查看响应<code>cookie</code>信息</td></tr><tr><td><code>Raw</code></td><td>以<code>原生格式</code>展示响应信息</td></tr><tr><td><code>JSON</code></td><td>以<code>json</code>展示响应信息</td></tr><tr><td><code>xml</code></td><td>以<code>xml</code>展示响应信息</td></tr></tbody></table><h5 id="3-4AutoResponder"><a href="#3-4AutoResponder" class="headerlink" title="3.4AutoResponder"></a>3.4AutoResponder</h5><p>（AutoResponder）文件代理：也叫自动拦截请求或者自动响应器，可以把想要的服务器上返回的文件使用本地的文件做代理。可以定位线上bug。可用于拦截某一请求，进行如下操作：1、重定向到本地的资源，2、使用Fiddler的内置响应，3、自定义响应</p><p>它允许你拦截指定规则的请求，并把响应结果重定向到一个本地资源 或 直接使用Fiddler内置的资源，从而代替服务器来自定义一个你想要的响应。 说白一点就是篡改响应。这个功能在我们做测试的时候也是非常有用的 ，使用它我们可以不影响用户体验的前提下进行测试。此功能启用后，可以将某一请求的响应结果替换成指定的资源，可以是本地文件，也可以是 Fiddler 内置的各种 HTTP 响应。主要用于临时拦截某一请求的响应，而无需修改服务器上的环境和代码，保证在最真实的环境中进行调试，也无需在 BUG 查找的时候就寻求相关部门的配合。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/MvZg3WxSAErPKO4.png" alt></p><p>启用该功能，请将 Enable rules打勾。Unmatched requests passthrough表示允许未匹配到的请求正常响应。应该打勾才能让其他的请求继续；否则其他未匹配到的请求都会以 404 状态返回。</p><p>页签上部是一个规则编辑器，可以进行编辑当前用户选择的匹配规则、保存编辑、删除此匹配规则等操作。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://img2022.cnblogs.com/blog/1232840/202207/1232840-20220701101256712-1297382748.png" alt></p><p> 上边Combox 要劫持的地址，是匹配的条件，可以自行输入字符串，也可以选择 Fiddler 内置的三个正则（都是匹配图片的，没什么用）。</p><p>######## 3.4.1Fiddler支持几种匹配模式</p><p>Fiddler支持几种匹配模式：</p><p>（1）String Literals —— 字符匹配：这种模式将匹配指定的字符串，不存在大小写敏感。范例：</p><pre><code>*通配符，匹配任何地址，如： http://www.example.com/Path1/query=exampleEXAMPLE匹配 http://www.example.com/Path1/query=examplepath1/匹配 http://www.example.com/Path1/query=examplequery匹配 http://www.example.com/Path1/q=Query</code></pre><p>（2）Exact Match —— 精确匹配：这种模式一 EXACT: 开头，将严格匹配字符串，包括大小写。范例：</p><pre><code>EXACT:http://www.example.com/path匹配 http://www.example.com/path不匹配 http://www.example.com/Path（大小写不符）不匹配 http://www.example.com/path/q=Query（有多余字符串）</code></pre><p>（3）Regular Expressions —— 正则表达式：这种模式一 regex: 开头，使用正则表达式来匹配 session 的 URL。范例：</p><pre><code>regex:.*通配符，匹配任何地址，如 http://www.example.com/Path1/query=exampleregex:.*\.jpg —— 匹配包含 .JPG 的 URL匹配 http://www.example.com/Path1/query=foo.jpg&amp;bar匹配 http://www.example.com/Path1/query=example.jpgregex:.*\.jpg$ —— 匹配 .jpg 结束的 URL不匹配 http://www.example.com/Path1/query=foo.jpg&amp;bar（不是 .jpg 结尾）匹配 http://www.example.com/Path1/query=example.jpgregex:.*\.(jpg|gif|bmp)$ —— 匹配 .jpg 或 .gif 或 .bmp 结束的 URL不匹配 http://www.example.com/Path1/query=foo.bmp&amp;bar（不是 .bmp 结尾）匹配 http://www.example.com/Path1/query=example.gif不匹配 http://www.example.com/Path1/query=example.Gif （是 .gif 结尾，但大小写不匹配）匹配 http://www.example.com/Path1/query=example.bmpregex:(?insx).*\.(jpg|gif|bmp)$ —— 匹配 .jpg 或 .gif 或 .bmp 结束的 URL，忽略大小写不匹配 http://www.example.com/Path1/query=foo.bmp&amp;bar（不是 .bmp 结尾）匹配 http://www.example.com/Path1/query=example.gif匹配 http://www.example.com/Path1/query=example.Gif匹配 http://www.example.com/Path1/query=example.bmp</code></pre><p> 其中：<br> i表示不区分大小写<br> n表示指定的唯一有效的捕获是显式命名或编号的形式<br> s表示单行模式<br> x表示空格说明</p><p>下边Combox是响应的结果，是真正要访问的地址。可以选择：Fiddler 内置的 HTTP 200/204/302/303/304/307/401/403/404/407/502 等各种响应范例、*bpu 和 *bpafter（ 表示在此中断，关于 bpu 和 bpfater 见 QuickExec 命令参考）、本地文件 (Find a file…)。</p><p>Save 按钮是保存对此匹配规则的修改，Remove 按钮是删除此匹配规则。</p><p>页签中间是一个列表，显示当前创建的匹配规则，左侧是匹配的条件，右侧是响应的结果。即：如果请求的地址包含左侧的字符串，那么就用右边设定的资源来替换来自服务器的响应。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/uMN37W5T9iSXvEl.png" alt></p><p>对匹配规则操作，可以选中匹配规则，右键点击对应的操作即可，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/RvTbrtLqiwfJHEQ.gif" alt></p><p>######## 3.4.2增加匹配规则</p><p><strong>具体操作步骤如下：</strong></p><p>1.在AutoResponder面板下，点击<img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/d8WnlbTRaQjMpDm.png" alt>，单击选择需要拦截的请求，复制请求的URL（请求右键 &gt;&gt; Copy &gt;&gt; Just Url），粘贴至右侧面板Rule Editor（或者左键按住，并拖动需要请求的url到右侧面板，此时url自动填充在Rule Editor处）</p><p>2.设置响应的内容，可以选择Fiddler的内置响应或者是用户本地文件（或者点击规则，鼠标右键，选择Edit Response，进行自定义响应）</p><p>3.同时选中<img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/odJzuHUDSy9Oh1q.png" alt>（使用规则）和<img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/b4WVAdK3CUoMc52.png" alt="img">（放行未匹配的请求）。</p><p><strong>或者这样操作也可以：</strong></p><p>点击 Add rule,打勾Unmatche按钮，新增一条规则。</p><p>此时会激活页签底部的 Rule Editor。如果你在 Web Sessions 面板里选择了一个 Session，则匹配规则是该 Session 的 URL，否则是 StringtoMatch[数字]。然后可以使用 Rule Editor 编辑它。</p><p>点击 Import… 按钮，导入在 Web Sessions 中保存下来的压缩包 (*.saz)。</p><p>在 Web Sessions 面板中选择你要捕获的请求，直接拖拽到 AutoResponder 的列表中。</p><h5 id="3-5Composer"><a href="#3-5Composer" class="headerlink" title="3.5Composer"></a>3.5Composer</h5><p>（Composer）前后端接口联调：可以伪造数据进行请求。可以不介入写任何JavaScript代码的情况下就可以实现与服务器之间的接口调试。　设计请求，修改请求参数，进行简单的接口测试。具体操作：鼠标左键拖动请求的url至右侧Composer面板处，请求信息会自动填充，修改请求参数，点击Execute。做前后端的接口联调实际上就是用的Composer功能。</p><p>我们可以把请求拖进去，我们就可以看到请求参数就调了进去，我们可以通过修改请求参数重新向服务器发送请求，比如删掉referer删掉，点击excute，实际上就算伪造了一个请求。</p><p>它可以允许我们自定义请求报文来发送到服务端，当然也可以手动创建一个新的请求，也可以从会话列表中拖拽一个现有的请求去发送!</p><p>在Parsed(解析模式)下我们只需要提供简单的URL地址就可以了, 并且还可以在RequestBody中去定制一些属性，例如模拟浏览器消息头User-Agent</p><p>但是Composer通常在我们开发项目当中用于接口测试 也是经常用于测试一些api接口的最好方法!</p><p>当然有时候也可以通过Composer来校验后端接口的严谨,从而跳过一些前端的限制,去直接访问后端代码的逻辑，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/SGt91iqoEZaI5Fv.png" alt></p><p><strong>Composer下还有几个子集选项卡:Parsed、Raw、Scratchpad、Options。具体解释如下表所示:</strong></p><table><thead><tr><th>选项卡</th><th>描述</th></tr></thead><tbody><tr><td><code>Parsed</code></td><td>表示已经被解析的整个HTTP请求,包括请求行,请求头和请求体,说通俗一点也就是最直观的看到<code>Request请求</code>的详细展示</td></tr><tr><td><code>Raw</code></td><td>按照真实原生<code>HTTP</code>请求标准来进行展示的格式!</td></tr><tr><td><code>Scratchpad</code></td><td>可以存储已经收集好的HTTP请求，可存储多个不同的请求, 你可以理解为请求回放功能， 鼠标连续点击三次即可选中要选择的请求来进行发送!</td></tr><tr><td><code>Options</code></td><td>设置一些请求选项</td></tr></tbody></table><p><strong>其中<code>options</code>中的设置项如下表:</strong></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Inspect Session</td><td>检查会话，当开启此功能并重放的时候，会自动跳入Inspectors功能模块，进行检查HTTP请求和响应。</td></tr><tr><td>Fix Content-Length header</td><td>当使用POST请求进行重放的时候，如果没有Content-Length的请求头，Fiddler会自动加上此请求头，如果有但是请求正文大小错误，则它会自动修正。默认勾选。</td></tr><tr><td>Follow Redirects</td><td>会自动重定向301，302的请求。</td></tr><tr><td>Automatically Authenticate</td><td>自动进行身份认证，包括认证NTLM，http 401，http 407</td></tr><tr><td>UI Options</td><td>此功能是在原有的Fiddler功能选项里面，将Composer这个功能弹出一个浮动窗口，如果不需要直接关闭这个窗口就会恢复原样。</td></tr></tbody></table><p>######## 3.5.1Parsed(详细展示请求结构)</p><p>我们用得最多的就是Parsed，详细展示请求结构如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/9hEOjIQqdXYcrZS.webp" alt></p><h5 id="3-6Fiddler-Orchestra-Beta"><a href="#3-6Fiddler-Orchestra-Beta" class="headerlink" title="3.6Fiddler Orchestra Beta"></a>3.6Fiddler Orchestra Beta</h5><p>Fiddler Orchestra Beta页签是新版fiddler新增功能，用于抓包远程计算机的数据，其中Fiddler Orchestra涉及到两个角色，控制器（Controller）和客户端（Client），控制器就是我们正在使用的Fiddler软件，其功能是用来收集数据和控制任何一个客户端，而客户端则是向任何其运行所在的Windows，Linux，Mac主机上收集接收过来的流量将其通过加密的方式报告发送给控制器，控制器会在Fiddler软件上的会话端显示。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/EXVHG9JeSab8Wup.png" alt></p><h5 id="3-7Fiddler-Script"><a href="#3-7Fiddler-Script" class="headerlink" title="3.7Fiddler Script"></a>3.7<strong>Fiddler Script</strong></h5><p>打开Fiddler脚本编辑。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/FTWRg5q6UXjwlQd.png" alt></p><h5 id="3-8log"><a href="#3-8log" class="headerlink" title="3.8log"></a>3.8log</h5><p>记录Fiddler的log日志。用来收集日志消息字符串，这些字符串是由扩展、FiddlerScript或者Fiddler本身生成的。Fiddler会记录应用事件（如当保存或加载SAZ文件）以及系统事件（如系统的网络连接丢失或者恢复）的响应通知。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/k7OHPwmFao5NXts.png" alt></p><p>Log支持简单的宏命令，可以从QuitExec文本框中调用这些命令。输入<a href="mailto:log@Log.Clear" target="_blank" rel="noopener">log@Log.Clear</a>可以清空日志。输入<a href="mailto:log@Log.Save" target="_blank" rel="noopener">log@Log.Save</a>可以在会话列表中生成新的会话，该会话的响应体包含Log选项卡的文本。输入log”@Log.Erport&quot;filename&quot;“可以把Log选项卡的文本保存到指定的文件。文件名以.rtf结尾，可将文件保存为富文本格式，保存大小和权重，或者以文件名以.txt结尾保存的纯文本。</p><h5 id="3-9Filters"><a href="#3-9Filters" class="headerlink" title="3.9Filters"></a>3.9Filters</h5><p>Filters多维度的过滤规则，可根据主机、进程、请求头、响应头、状态码、响应类型和大小、断点进行请求的过滤。作用：忽略不想显示的请求，过滤出想要的请求，是一个多维度的过滤器。过滤器要起作用，必须选中<img src="/images/loading.gif" data-original="https://img2020.cnblogs.com/blog/2228199/202012/2228199-20201211114129660-1417238444.png" alt>。</p><p>Filters中文意思就是过滤的意思, 它的主要作用就是用来过滤请求用的， 要知道有的时候 会话列表中或存在大量的请求会话, 那么有些时候会根据用户的条件进行一个会话筛选, 也就是说通过过滤规则来过滤掉那些不想看到的请求。</p><p>Filters选项卡也是在我们抓包过程中使用频率非常高的，其中功能也比较多，这里我把它内部的功能逐一拆解分成7个部分来进行讲解。具体功能如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/GmKcfavSU8TbBeY.png" alt></p><p>######## 3.9.1Hosts</p><p>Hosts这是Filters对主机的过滤规则配置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/2HUBvr5OhVRPmKs.png" alt></p><p>1.使用Filters的时候就必须要勾选左上角的Use Filters(选择过滤器)开启过滤器, 勾选了之后Filters选项卡会出现绿色对钩, 记住这个勾选之后，过滤器才会生效，否则后边的7大部分都是灰色的不允许配置和操作。</p><p>2.“Action”按钮功能如下图所示：</p><p> <img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ysjvaGEcUxNeikH.png" alt></p><p>“Run Filterset now”：根据设置过滤已存在的Session列表；</p><p>“Load Filterset”：打开本地Filters配置文件；</p><p>“Save Filterset”：保存当前配置到本地；</p><p>“Help”：打开官方文档；</p><p>注：Filters配置后，是即时生效的。</p><p>并且Hosts这里还有两个请求过滤条件:Zone和Host。</p><p><strong>（1）Zone(区域): 下拉列表中可以选择如下:</strong></p><p>　　①、No Zone Filter：无区域限制，不用区域过滤（默认设置，一般无特殊要求就用默认的）</p><p>　　②、Show only Intranet Hosts：仅显示局域网的请求（一般不用）</p><p>　　③、Show only Internet Hosts：仅显示广域网的请求（一般不用）</p><p>如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/giMYl4PZr9XuNKo.png" alt></p><p>接下来和宏哥通过一个请求百度这个例子来直观的看一下这几个选项到底什么意思了，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/wTvKN7QmprhAxfe.gif" alt></p><p>从上图中我们可以清楚地看出：如果设置为了No Zone Filter那么内网和外网的请求都可以获取到，如果设置为了show only Intranet Hosts 那么外网的请求会话是无法获取到的,仅仅能获取内网请求，如果设置为了show only Internet Hosts那么相反也仅仅能获取外网的请求，而内网的请求是无法获取到的。</p><p>平常如果我们没有其他特殊需求的情况下Zone都被默认设置为了No Zone Filter(不用区域过滤)</p><p>注意:各位要留意 Intranet(内网) 和 Internet(因特网) 这两个单词很多人容易搞混!</p><p><strong>（2）Host(主机):下拉列表中可以选择如下:</strong></p><p>　　①、No Host Filter：无主机限制</p><p>　　②、Hide the following Hosts：隐藏输入到下面文本框的主机（域名或者IP）的请求（选择请求，单击右键，Copy &gt;&gt; This Column）</p><p>　　③、Show only the following Hosts：仅显示输入到下面文本框的主机（域名或者IP）的请求</p><p>　　④、Flag the following Hosts：含有下面文本框的主机（域名或者IP）的请求做标记（即加粗显示）</p><p> 如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/uNx6rap5eMAQzUo.png" alt></p><p>同理为了直观宏哥这里再举例说明比如说: 我设置其中一个show only the following Hosts (仅展示以下指定主机的请求) 那么会话列表中只会出现我所指定的主机请求会话，其他一概不显示。</p><p>注意: 这里设置之后 要点击一下Actions中的Run Filterset now(运行过滤)</p><p>如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/HxzO6TGdqcQgmJo.gif" alt></p><p>另外两个根据自己需求设置就行了, 平常没特殊需求我们也是设置的No Host Filter。</p><p>######## 3.9.2Client Process（应用比较少）</p><p> Client Process 这是对客户端进程的一些过滤配置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/YktcyoFTZC79fvP.png" alt></p><p>从上图可以清楚地看到有三个复选框：</p><p>①、Show only traffic from：仅显示某一进程的请求</p><p>②、Show only Internet Explorer traffic：仅显示IE浏览器发出的请求</p><p>③、Hide traffic from Service Host：隐藏来自service host（即由svchost.exe进程）发出的请求</p><p>宏哥这里勾选：Show only Internet Explorer traffic的选项，看一下是否是：仅显示ie浏览器的请求会话,其他浏览器的请求会话一概不显示。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/OnXNck2QFVjsdZh.gif" alt></p><p>######## 3.9.3Request Headers</p><p>Request Headers这是对请求头的一些过滤规则进行配置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/jn4eCVtcPBloAL7.png" alt></p><p>从上图可以清楚地看到有五个复选框：</p><p>①、Show only if URL contains：仅显示url中包含输入的字符串的请求（可以是url的一部分、正则、或完整的URL）</p><p>②、Hide if URL contains：与①相反，隐藏url中包含输入的字符串的请求</p><p>③、Flag requests with headers：标记请求头中有指定内容的请求，用头标记请求, 标记带有特定header的请求，如果在web session列表中存在该请求,会加粗显示。 例如，我想突出显示header信息中带有cookie字段的URL请求,即可以勾选上这项,并在后面输入：cookie。</p><p>④、Delete request headers：删除请求头中的指定内容，也就是说在请求的过程当中会删除指定的Header字段。我们在进行测试时非常有用，比如说去掉URL中的Content-Type信息。</p><p>⑤、Set request header：设置请求头中添加指定的内容，也就是说可以在请求头中自定义请求头信息，前面输入字段，后面输入值, 这就是我们可以进行自定义请求头内容。</p><p>宏哥这里勾选：show only if URL contains只会显示指定包含这个内容的响应会话，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/i9hQ4EsYjzLqtVW.gif" alt></p><p>######## 3.9.4Breakpionts</p><p> Breakpionts 断点配置，这个功能有的时候也非常重要。后边宏哥会详细介绍这一部分的内容的。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/cBZ94JAno1CmkMr.png" alt></p><p>从上图可以清楚地看到有四个复选框：</p><p>①、Break request on POST：在POST请求中设置断点（请求前设置断点）</p><p>②、Break request on GET with query string：在带有请求参数的GET请求中设置断点（请求前设置断点）</p><p>③、Break on XMLHTTpRequest：在Ajax请求中设置断点（请求前设置断点）</p><p>④、Break response on Content-type：在响应中含有指定Content-type的请求中设置断点（响应后设置断点）</p><p>######## 3.9.5Response Status Code</p><p> Response Status Code(响应状态码过滤)，这一部分的功能，很简单就是看状态码进行会话的过滤配置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/qkilPjNMZ1TKQ8C.png" alt></p><p> 从上图可以清楚地看到有五个复选框：</p><p>①、Hide success(2xx)：隐藏响应状态码为2XX的请求</p><p>②、Hide non-2xx：隐藏响应状态码非2xx的请求</p><p>③、Hide redirects(300, 301, 302, 303, 307)：隐藏状态码为300、301、302、303、307的重定向请求</p><p>④、Hide Authentication demands(401,407)：隐藏状态码为401，407的响应。需要用户进一步确认证书的请求</p><p>⑤、Hide Not Modified(304)：隐藏状态码为304的响应，隐藏不是缓存的状态码（304）的URL请求, 因为304是请求的资源从上次起没有发生变更返回的状态码。</p><p>######## 3.9.6Response Type and Size</p><p> Response Type and Size：根据响应类型和大小进行过滤配置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/K7ysSDM8d1ZxYFP.png" alt></p><p> 从上图可以清楚地看到有很多选项：</p><p>Show all Content-Type 这一项比较常用, 意思为显示所有指定Content-Type类型的请求，其中的选项描述如下表:</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td><code>Show only IMAGE/*</code></td><td>仅显示响应类型为图片的请求, 即响应header中Content-Type=IMAGE/的请求，*为通配符</td></tr><tr><td><code>Show only HTML</code></td><td>仅显示响应类型为<code>HTML</code>的请求。</td></tr><tr><td><code>Show only TEXT/CSS</code></td><td>仅显示响应类型为<code>text/css</code>的请求。</td></tr><tr><td><code>Show only SCRIPTS</code></td><td>仅显示响应类型为<code>Scripts</code>的请求</td></tr><tr><td><code>Show only XML</code></td><td>仅显示响应类型为<code>XML</code>的请求。</td></tr><tr><td><code>Show only JSON</code></td><td>仅显示响应类型为<code>json</code>的请求。</td></tr><tr><td><code>Hide IMAGE/*</code></td><td>隐藏所有响应类型为图片的请求。</td></tr></tbody></table><p>其他功能项如下表：</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td><code>Hide smaller than</code></td><td>隐藏小于指定大小响应结果的请求,大小可以在 Inpsectors 中响应结果部分的 Transformer 中查看</td></tr><tr><td><code>Hide larger than</code></td><td>隐藏大于指定大小响应结果的请求</td></tr><tr><td><code>Time HeatMap</code></td><td>时间的热图。</td></tr><tr><td><code>Block script files</code></td><td>阻止返回正常JS文件。如果响应是脚本文件，那么响应 404。</td></tr><tr><td><code>Block image files</code></td><td>阻止返回正常图片文件。如果响应是图片文件，那么响应 404</td></tr><tr><td><code>Block SWF files</code></td><td>阻止返回正常SWF文件。如果响应是SWF 文件，那么响应 404。科普一下<code>swf(shock wave flash)</code>：是<code>Macromedia公司的</code>目前已被adobe公司收购）公司的动画设计软件Flash的专用格式</td></tr><tr><td><code>Block CSS files</code></td><td>阻止返回正常CSS文件。如果响应是 CSS 文件，那么响应 404</td></tr></tbody></table><p>1.宏哥禁止掉页面上的css js 图片等资源看看请求的结果，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/9yYOVuWIfZx3KS5.webp" alt></p><p>2.那么此时请求的页面将会失去css 、js、图片等资源, 让他们都响应为404状态，看看响应结果，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/WduxELNoDBwJf6A.webp" alt></p><p>######## 3.9.7Response Headers</p><p>Response Header ：根据响应头信息进行过滤配置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Nv7meSVTBYwPzCX.png" alt></p><p> 从上图可以清楚地看到有四个复选框：</p><p>①、Flag responses that setcookies：将响应中设置了cookies的请求标记显示（斜体显示）</p><p>②、Flag responses with headers：将响应头中包含指定内容的请求标记显示（加粗显示）</p><p>③、Delete responseheaders：删除响应中指定的响应头</p><p>④、Set response header：将响应头中添加指定的内容</p><h5 id="3-10Timeline"><a href="#3-10Timeline" class="headerlink" title="3.10Timeline"></a>3.10Timeline</h5><p>（Timeline）网站性能分析：需要选中网站的多条请求才有意义，是性能优化的重要依据之一。Timeline 页签：显示 session 请求到响应的时间表，横向为时间轴，纵向为 session 列表，鼠标移到 timeline 页签上，在底部会显示四个数据：session 编号和 URL、session 的响应类型、发送字节数和接收字节数。每个网络请求都会经历域名解析、建立连接、发送请求、接受数据等阶段。把多个请求以时间作为 X 轴，用图表的形式展现出来，就形成了瀑布图。在Fiddler中，只要在左侧选中一些请求，右侧选择Timeline标签，就可以看到这些请求的瀑布图。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/YVs3U5hGlatg1Le.gif" alt></p><p>时间轴</p><p>绿色的请求表示这是一个“有条件的请求”。HTTP 协议定义了 5 个条件请求头部，最常见的两个是“If-Modified-Since”和“If-None-Match”。服务器根据这两个头部来验证本地缓存是否过期，如果过期则正常返回资源的最新版本；否则仅返回 304 Not Modified，浏览器继续使用本地缓存。包含条件请求头部的请求用绿色显示，否则用黑色。</p><p>有阴影线的请求是缓冲模式下的请求，实心的是流模式下的请求。Fiddler 提供了缓冲（Buffering）和流（Streaming）两种抓包模式：缓冲模式下，Fiddler 会在响应完成时才将数据返回给应用程序（通常是浏览器），这种模式下可以控制响应，方便地修改响应内容；流模式下，Fiddler 会实时返回响应数据给浏览器，但没办法控制响应。一般使用流模式，瀑布图会更真实一些。这两种模式可以通过 Fiddler 的工具栏选择。特别的，通过 Fiddler 的“AutoResponder”功能返回的响应，只能是缓冲模式。</p><p>请求条的不同颜色对应着不同类型的响应，根据响应头的 MIME Type 来归类。如浅绿色表示图片类型的响应；深绿色是 JavaScript；紫色是 CSS；其它都是蓝色。</p><p>请求中的黑色竖线，表示的是浏览器收到服务端响应的第一个字节这一时刻。这个时间受 DNS 解析、建立连接、发送请求、等待服务端响应等步骤的影响。</p><p>请求条后面的图标表示响应的某些特征。如软盘图标表示这个响应正文从本地获得，也就是说服务端返回了 304；闪电表示这是 Fiddler 的“AutoResponder”的响应；向下的箭头表示响应是 302，需要重定向；红色感叹号说明这个请求有错误发生（状态码是 4XX 或 5XX）。特别的，如果请求条后面有一个红色的X，说明服务端响应完这个请求之后，断开了连接。出现这种情况一般有两种可能：HTTP/1.0 的响应中没有 Connection: Keep-Alive；或者是 HTTP/1.1 的响应中包含了 Connection: close。使用持久连接可以省去建立连接的开销，也可以减小 TCP 慢启动和其它拥塞控制机制带来的影响，总之是好处多多。</p><p>请求前面的红色圆圈表示这个连接是新建的，绿色表示是复用的。上面的圆圈表示的是浏览器到 Fiddler 的连接，下面的圆圈是 Fiddler 到服务端的连接。</p><p><strong>关于请求的时间分析，HttpWatch 的时间线显得更为详尽和直观，不过它是收费的，且最新版本 6.0 + 也只支持 IE 和 Firefox。</strong></p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>有些小伙伴或者童鞋们在使用Fiddler的时候出现抓包失灵的情况，可能就是你在Filters选项卡中勾选了什么东西才导致的! 所以使用过滤器要注意一下。</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(4)-会话面板和HTTP会话数据操作详解 -04</title>
      <link href="/2016/06/12/fiddler/"/>
      <url>/2016/06/12/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(4)-会话面板和HTTP会话数据操作详解</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p> 按照从上往下，从左往右的计划，今天就轮到介绍和分享Fiddler的会话面板了。</p><h4 id="2-会话列表-Session-list-概览"><a href="#2-会话列表-Session-list-概览" class="headerlink" title="2.会话列表 (Session list) 概览"></a>2.会话列表 (Session list) 概览</h4><p>Fiddler抓取到的每条http请求（每一条称为一个session），会话列表 主要是Fiddler所抓取到的每一条http请求都会显示到这里。主要包含了请求的ID编号、状态码、协议、主机名、URL、内容类型、body大小、进程信息、自定义备注等信息，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/wulAMLBjtOKe3cH.webp" alt></p><h4 id="3-会话列表各个列详解"><a href="#3-会话列表各个列详解" class="headerlink" title="3.会话列表各个列详解"></a>3.会话列表各个列详解</h4><h5 id="3-1每个字段的含义"><a href="#3-1每个字段的含义" class="headerlink" title="3.1每个字段的含义"></a>3.1每个字段的含义</h5><p>会话列表中又包含了很多字段,而每一个字段都有其自己的含义,用来描述当前每一条会话的详细信息!</p><p>各个字段的含义描述如下表所示:</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>#</code></td><td>显示抓取的<code>请求id顺序和类型图标</code>，id从1开始递增，HTTP Request 的顺序，从1开始，按照页面加载请求的顺序递增</td></tr><tr><td><code>Result</code></td><td>HTTP响应结果<code>状态码</code></td></tr><tr><td><code>Protocol</code></td><td>当前<code>请求会话</code>所使用的协议，如<code>HTTP/HTTPS/FTP</code>等等</td></tr><tr><td><code>Host</code></td><td>请求地址的主机名或域名（也会是主机名和端口号）</td></tr><tr><td><code>URL</code></td><td>从服务器请求资源的文件路径,有的时候也包含<code>GET</code>请求的具体参数</td></tr><tr><td><code>Body</code></td><td>响应内容的大小, 单位为<code>字节</code> 也就是<code>响应主体(Response Body)</code>中的字节数</td></tr><tr><td><code>Caching</code></td><td>请求的缓存过期时间或缓存控制header等值，即响应头中Expires 和 Cache-Control</td></tr><tr><td><code>Content-Type</code></td><td>响应内容的类型，以及编码类型</td></tr><tr><td><code>Process</code></td><td>发送此请求的<code>程序与进程id</code>：例如<code>chrome:1604。发出此请求的 Windows 进程和进程 ID</code></td></tr><tr><td><code>Comments</code></td><td>允许用户给<code>请求会话</code>添加备注文本信息。用户通过脚本或者右键菜单给此session 增加的备注</td></tr><tr><td><code>Custom</code></td><td>允许用户设置使用脚本设置自定义字段</td></tr><tr><td>………………………………….</td><td></td></tr></tbody></table><h5 id="3-2记录不同颜色的含义"><a href="#3-2记录不同颜色的含义" class="headerlink" title="3.2记录不同颜色的含义"></a>3.2记录不同颜色的含义</h5><p>每个记录不同图标和不同颜色的含义如下:</p><pre><code>1 红色：表示HTTP状态（错误）2 黄色：表示HTTP状态（认证）3 灰色：表示数据流类型 Connect 或表示响应类型为图像4 紫色：表示响应类型为 CSS5 蓝色：表示响应类型为 HTML6 绿色：表示响应类型为 Script7 在Fiddler Script session 的 ui-color 标志位中可以修改字体的颜色</code></pre><h5 id="3-3图标含义"><a href="#3-3图标含义" class="headerlink" title="3.3图标含义"></a>3.3图标含义</h5><table><thead><tr><th align="center">icon</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/QxtgA6Ba8usG2Zo.jpg" alt="图片"></td><td align="left">正在将请求发送到服务器</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/3JDSkRTH4nrVUaB.jpg" alt="图片"></td><td align="left">正在从服务器读取响应</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Lz1mvJonUV8u5Bp.jpg" alt="图片"></td><td align="left">请求在断点处暂停</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/HM8iJ61xE273LZd.jpg" alt="图片"></td><td align="left">响应在断点处暂停</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/cXsVh64qyflS3dA.jpg" alt="图片"></td><td align="left">请求使用HTTP HEAD方法</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/jv23OkGqdfVCQlH.png" alt="图片"></td><td align="left">请求使用的 HTTP POST 方法</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/uS4FTABLNiVp6Hg.jpg" alt="图片"></td><td align="left">请求使用HTTP连接方法;这将建立用于 HTTPS 流量的隧道</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/z7g2NpbIXxquseG.jpg" alt="微信图片_20220719131946"></td><td align="left">响应是 HTML</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Dy3hiaEcjYgkGuN.png" alt="图片"></td><td align="left">响应是图像</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/obUsR5MgfzaYwhO.png" alt="图片"></td><td align="left">响应是一个JS脚本</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/GWQvZTVpY3tOeK8.jpg" alt="微信图片_20220719132437"></td><td align="left">响应是级联样式表</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ErBNmi28OVHKtMA.jpg" alt="微信图片_20220719132716"></td><td align="left">响应为 XML</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/1qEJPN78FWyDHhr.png" alt="微信图片_20220719132540"></td><td align="left">响应为 JSON</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/5T6FdWBJEj3QHwr.png" alt="微信图片_20220719132902"></td><td align="left">响应是音频文件</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/YrdnDUcEwCghvqR.png" alt="图片"></td><td align="left">响应是视频文件</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/UmEXcJ9uWOtak4L.png" alt="图片"></td><td align="left">响应是一个 Silverlight 小程序</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/gWlD7H6PAfS9coz.png" alt="图片"></td><td align="left">响应是一个 Flash 小程序</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/pD6uovYJf9KCTkP.png" alt="微信图片_20220719133602"></td><td align="left">响应是字体</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/HWtaMCfXNEwAv6Q.jpg" alt="图片"></td><td align="left">通用成功响应</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/4joHF2vuCtA7RB3.jpg" alt></td><td align="left">响应是 HTTP/300，301，302，303 或 307 重定向</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/1KPmWqGiHaXJsgU.jpg" alt="微信图片_20220719133958"></td><td align="left">响应为 HTTP/304：使用缓存版本</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/3C5KozGrAjEmVLf.jpg" alt="微信图片_20220719133958"></td><td align="left">响应是对客户端凭据的请求</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Knr6Rz7efaFWGpB.jpg" alt="微信图片_20220719134155"></td><td align="left">响应是服务器错误</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="E:%5Ctemp%5CvQMaVLqOnIf2ijU.jpg" alt></td><td align="left">会话被客户端、Fiddler 或服务器中止。</td></tr><tr><td align="center"><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Cf2atvJ7lxQ8bGA.png" alt="图片"></td><td align="left">表示请求的格式为<code>html</code>格式</td></tr></tbody></table><h4 id="4-操作会话面板列"><a href="#4-操作会话面板列" class="headerlink" title="4.操作会话面板列"></a>4.操作会话面板列</h4><p>在每一个列上面当右键点击session框中的列时，可以发现有5个功能，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/UzLNq6OMbZGX9u8.gif" alt></p><h5 id="4-1Search-this-column-搜索此栏"><a href="#4-1Search-this-column-搜索此栏" class="headerlink" title="4.1Search this column (搜索此栏)"></a>4.1Search this column (搜索此栏)</h5><p>意思是它会根据每一个栏位的特性来进行条件搜索此栏位, 这样可以快速帮助用户精准找到想要的数据信息，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/uEsQ5FRP8XIBxWH.gif" alt></p><h5 id="4-2Flag-duplicates-重复会话标志"><a href="#4-2Flag-duplicates-重复会话标志" class="headerlink" title="4.2Flag duplicates (重复会话标志)"></a>4.2Flag duplicates (重复会话标志)</h5><p>标记列中的相同项并将相同项背景滤为绿色。这个功能可以给我们的会话打上标志背景, 并且这个背景颜色标记的是当前列中存在重复的数据</p><p>举个例子吧: 例如我们在URL这一栏上右键选择Flag duplicates 那么就会在当前列中存在重复URL的数据上打上一个绿色💚的背景，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/V2jlpXcqaQKD4k5.webp" alt></p><h5 id="4-3Hide-this-column-隐藏此列"><a href="#4-3Hide-this-column-隐藏此列" class="headerlink" title="4.3Hide this column (隐藏此列)"></a>4.3Hide this column (隐藏此列)</h5><p>这个没什么说的 就是把当前这一列栏位给隐藏了!</p><h5 id="4-4Ensure-all-columns-are-visible-确保所有列都可见"><a href="#4-4Ensure-all-columns-are-visible-确保所有列都可见" class="headerlink" title="4.4Ensure all columns are visible(确保所有列都可见)"></a>4.4Ensure all columns are visible(确保所有列都可见)</h5><p>这个功能就相当于一个复位按钮,如果你隐藏了某个栏位又不知道如何把它显示出来，那么就直接点选它就可以全部栏位都复位。</p><h5 id="4-5Costomize-columns-自定义栏位"><a href="#4-5Costomize-columns-自定义栏位" class="headerlink" title="4.5Costomize columns(自定义栏位)"></a>4.5Costomize columns(自定义栏位)</h5><p>定制列，可以增加其他的列名，并且还可以改变列名。自定义栏位，是对所有列进行自定义, 其实也相当于新增一个栏位，而不是选择的栏位。</p><h4 id="5-自定义列"><a href="#5-自定义列" class="headerlink" title="5.自定义列"></a>5.自定义列</h4><p>在Fiddler的会话面板中不会展示请求方式，虽然请求头中有展示，但是每次看接口，都得一个一个点开查看，也很麻烦，因此宏哥就以此为例子，添加请求方式列在会话面板。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/fo38Op1YlL6mkAU.png" alt></p><p>宏哥这里提供两种自定义列的方法，第一种方法：界面配置自定义列，第二种方法：通过脚本自定义列。具体步骤如下：</p><h5 id="5-1界面操作配置自定义列"><a href="#5-1界面操作配置自定义列" class="headerlink" title="5.1界面操作配置自定义列"></a>5.1界面操作配置自定义列</h5><p>1.在列名上，鼠标右键，即可弹出如下信息 ，，然后点击Customize Columns，则弹出如下图所示的弹框。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/yaowcs8YXp7WgqJ.gif" alt></p><p>2.Collection选择Miscellaneous，Field Name选择RequestMethod。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/zMylrnei6v7hObU.gif" alt></p><p>3.选择该字段后，你还可以定义列表的宽度以及列名。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/LtfAZg9xujHBaVv.gif" alt></p><p>4.点击Add后，你自定义添加的列则会展示在Fiddler会话面板中。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/TJcBVxI9mW5u8Zr.gif" alt></p><h5 id="5-2通过脚本自定义列"><a href="#5-2通过脚本自定义列" class="headerlink" title="5.2通过脚本自定义列"></a>5.2通过脚本自定义列</h5><p>Fiddler会话面板列有Result、Protocol、Host、URL、Content-Type等等，但有时候我们可能会遇到这样的场景：宏哥需要知道当前请求与应答服务器的ip，那么，如果给fiddler添加一列“ServerIP”，每一个session都会显示ip，那自然是再好不过了。以此为例宏哥讲解和分享一下如何通过脚本添加此自定义列。其实主要就是操作这个文件Fiddler2\Scripts\CustomRules.js。</p><p>1.在Fiddler点击Rules，然后再点击Customize Rules，打开添加脚本的文件，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/U9qMeHrEhAmXl23.gif" alt></p><p>2.Ctrl+F查找字符串static function Main()，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/EYNRvfBHKQOriWe.png" alt></p><p>3.在其方法体的最后添加如下一行脚本代码，如下图所示：</p><pre><code>FiddlerObject.UI.lvSessions.AddBoundColumn(&quot;栏位名称自定义&quot;, 120, &quot;X-HostIP&quot;);</code></pre><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ACYBoZkyNEfwvrX.gif" alt></p><p>4.保存脚本后，你自定义添加的列则会展示在Fiddler会话面板中。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/L2qElV7aev9Igmz.png" alt></p><h5 id="5-3隐藏字段"><a href="#5-3隐藏字段" class="headerlink" title="5.3隐藏字段"></a>5.3隐藏字段</h5><p>刚才讲的是添加字段，那可能会有疑惑，我添加后，以后不想要这个字段展示，那该如何处理？</p><p>在自定义列时，有个隐藏属性。如果想不展示哪个列字段，在对应字段上右键，选择隐藏即可。选择Hide this cloumn即可，隐藏后，则不会展示了。操作如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Jakz5OAP63hDBQf.gif" alt></p><h5 id="5-4展示隐藏的字段"><a href="#5-4展示隐藏的字段" class="headerlink" title="5.4展示隐藏的字段"></a>5.4展示隐藏的字段</h5><p>我们将字段隐藏后，还能支持再展示吗？答案是肯定的，操作同理，选择Ensure all cloumns are visible即可，隐藏的列就会展示出来了。操作如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/RosOFZLSdVDj7Ph.gif" alt></p><p>列的自定义，如上操作就可以轻松搞定了。我们在之前也看到，自定义时，可以定义很多字段的；也可以定义请求头、响应头；看各自需求，自定义即可。</p><h5 id="5-5请求会话的复制操作"><a href="#5-5请求会话的复制操作" class="headerlink" title="5.5请求会话的复制操作"></a>5.5请求会话的复制操作</h5><p>Fiddler中提供了很多对请求会话的复制操作,让你更好的去获取想要的数据。你可以在会话列表中选择你要操作的会话，然后右键选择copy。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/BLtx7k6icJnpP1r.gif" alt></p><p>其中子菜单含义如下表，你根据需求进行选择就可以了。如下表所示：</p><table><thead><tr><th>菜单名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Just URL</code></td><td>复制请求的<code>主机名+URL</code>资源的路径</td></tr><tr><td><code>Terse Summary</code></td><td>复制请求的<code>方法+URL+响应状态</code></td></tr><tr><td><code>this Column</code></td><td>复制当前请求中的<code>本列</code>信息</td></tr><tr><td><code>Headers Only</code></td><td>以格式化形式复制当前会话的<code>请求报文和响应报文</code></td></tr><tr><td><code>Session</code></td><td>复制当前原始会话 跟<code>Headers Only</code>差不多</td></tr><tr><td><code>Response DataURL</code></td><td>以及<code>base64编码</code>的形式复制响应数据的<code>URL</code></td></tr><tr><td><code>Full Summary</code></td><td>复制当前<code>会话信息</code>和<code>对应的列</code></td></tr></tbody></table><h5 id="5-6请求会话的保存操作"><a href="#5-6请求会话的保存操作" class="headerlink" title="5.6请求会话的保存操作"></a>5.6请求会话的保存操作</h5><p>Fiddler对会话的存储也制定了一些规则：你可以在会话列表中选择你要操作的会话，然后右键选择save。其中save菜单下有四个选项</p><pre><code>1 Selected Session(选定的会话)2 Request(请求)3 Response(响应)4 ...and Open as local File(作为本地文件打开)</code></pre><p>如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/sv24KnuMw1aqkdg.png" alt></p><p>######## 5.6.1Selected Session</p><p>Selected Session(选定的会话) 其下子菜单选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>in ArchiveZIP</code></td><td>把当前所选择的<code>请求会话</code>保存到<code>.saz</code>文件中</td></tr><tr><td><code>as Text</code></td><td>把当前所选择的<code>请求会话</code>保存到文本文件中 包含<code>请求报文+响应报文+响应体</code></td></tr><tr><td><code>as Text (Headers only)</code></td><td>把当前所选择的<code>请求会话</code>保存到文本文件中 包含<code>请求报文+响应报文</code></td></tr></tbody></table><p>######## 5.6.2Request</p><p>Request(请求)旗下子菜单选项如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Ibh4Cjyv8oMOfuX.png" alt></p><p>各个选项的含义如下表所示：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>Entire Request</code></td><td>把当前所选择的<code>请求会话</code>保存到<code>文本文件</code>中 只有<code>请求报文</code></td></tr><tr><td><code>Request Body</code></td><td>保存当前<code>请求会话</code>的<code>请求正文</code>为<code>文本文件</code></td></tr></tbody></table><p>######## 5.6.3Response</p><p>Response(响应)子菜单如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/OvTYjsE9R7m54DL.png" alt></p><p>各个选项的含义如下表所示：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>Entire Response</code></td><td>把当前所选择的<code>请求会话</code>保存到<code>文本文件</code>中 只有<code>响应报文+响应体</code></td></tr><tr><td><code>Response Body</code></td><td>保存当前<code>请求会话</code>的<code>响应体</code>为<code>文本文件</code></td></tr></tbody></table><p>######## 5.6.4…and Open as local File</p><pre><code>...and Open as local File(作为本地文件打开)</code></pre><p>这个选项的意思就是保存为本地的一个html文件 并且进行打开!</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><h5 id="6-1保存会话乱码问题"><a href="#6-1保存会话乱码问题" class="headerlink" title="6.1保存会话乱码问题"></a>6.1保存会话乱码问题</h5><p>我们有时候保存会话查看时，会发现返回的响应体是乱码，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/YpPMca7yVuD2gWn.png" alt></p><p>遇到这种问题，主要是需要<code>解码</code>就行了。宏哥这里提供两种方法：</p><p>（1）在<code>Inspectors 会话响应</code>中点击<code>Response body is encodee.click to decode</code>后，重新保存就没乱码了。</p><p>（2）选中上图会话框上的<code>decode</code>按钮，这样就<code>自动解码</code>了。</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/rCyacjNmW7nVHxY.gif" alt></p><p>解码后的，响应正文没有乱码，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/lMnUZjOhakKcWRH.png" alt></p><p>其实如果你已经了解了http的基础知识，那么会话列表中的列的信息也会很快的理解!而且你也不用每一个都去记住，要用的时候来查一查就行了!😉</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(3)-再识Fiddler让你感性认识一下 -03</title>
      <link href="/2016/06/11/fiddler/"/>
      <url>/2016/06/11/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(3)-再识Fiddler让你感性认识一下</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>上一篇通过宏哥的介绍想必各位小伙伴或者童鞋们对Fiddler已经有了一个理性地认识，今天宏哥在从Fiddler的外貌介绍和分享一下，让小伙伴们或者童鞋们再对Fiddler有一个感性的认识，今天主要是对Fiddler的界面进行一个详细的介绍。</p><h4 id="2-Fiddler主界面"><a href="#2-Fiddler主界面" class="headerlink" title="2.Fiddler主界面"></a>2.Fiddler主界面</h4><p>Fiddler的主界面分为：菜单栏（①）、工具面板（②）、会话面板（③）、监控面板（④）和状态面板（⑤）四部分组成，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/9qzSKF1iRWm3b4V.png" alt></p><h5 id="2-1Fiddler主界面概览"><a href="#2-1Fiddler主界面概览" class="headerlink" title="2.1Fiddler主界面概览"></a>2.1Fiddler主界面概览</h5><p>Fiddler的主界面概览，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/9pH7h2SQYFXigrG.png" alt></p><h4 id="3-Fiddler主界面详解"><a href="#3-Fiddler主界面详解" class="headerlink" title="3.Fiddler主界面详解"></a>3.Fiddler主界面详解</h4><p>Fiddler的主界面详解，说明注释、重新请求、删除会话、继续执行、流模式/缓冲模式、解码、保留会话、监控指定进程、寻找、保存会话、切图、计时、打开浏览器、清除IE缓存、编码/解码工具、弹出控制监控面板、MSDN、帮助。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/NxVWObzCmatq5jo.png" alt></p><h5 id="3-1菜单栏"><a href="#3-1菜单栏" class="headerlink" title="3.1菜单栏"></a>3.1菜单栏</h5><p>菜单栏的功能其实很简单主要包含：File(文件)、Edit(编辑)、Rules(规则)、 Tools(工具) 、View(视图) 和Help(帮助)六个板块。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/1I3k7zWSJweBuXZ.png" alt></p><h6 id="3-1-1-File"><a href="#3-1-1-File" class="headerlink" title="3.1.1 File"></a>3.1.1 File</h6><p>File菜单主要包含新建视图、加载一个保存好的抓包会话文件、保存所有会话列表数据到一个.saz文件中等等。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/gnONIC2ktLcyDpj.png" alt></p><p><strong>各个按钮功能说明：</strong></p><pre><code>Capture Traffic：默认勾选，勾选此项才可抓包，与点击左下角状态栏的 Capture 效果一样。New Viewer：开启一个新的 fiddler 的 viewer，注意这里不是再开一个新的 fiddler，而是开一个新的fiddler的viewer。Load Archive…：用于重新加载之前捕获到的 SAZ 文件格式保存的流量。Session Archive Zip 文件，用于保存 http 请求信息。Recent Archives：查看最近之前捕获到的 SAZ 文件格式保存的流量。Save：保存。Import Sessions…：从目标文件夹及其子文件夹加载所有 SAZ 文件。缓存和重用密码。支持导入从其他工具获得的流量。Export sessions：支持用fiddler把捕捉到的 sesison 用多种方式保存。CURL 脚本由 CURL 回放。Exit：退出 Fiddler。</code></pre><h6 id="3-1-2-Edit"><a href="#3-1-2-Edit" class="headerlink" title="3.1.2 Edit"></a>3.1.2 Edit</h6><p>Edit菜单主要包含一些编辑的功能,例如对会话的:复制 粘贴 拷贝等操作。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/6mTq9fibFwvRlhC.png" alt></p><p> <strong>各个按钮功能说明：</strong></p><pre><code>Copy：用来拷贝请求的相关信息。有用于复制在 web session 列表中选中的 session 信息，包括 just URL（选中的 session 的 URL 复制到剪切板中）、this column（拷贝菜单所在列的文本）、terse summary（选中 session 的简要说明复制到剪切板里）、header only （把 session 请求头复制到剪切板里）、session（把整个的 session 列表都复制到剪切板里）、full summary（把列表中显示的所有 session 信息复制到剪切板里）这些功能。Remove：主要是用来移除左侧边栏中的session。Select All：全选左侧边栏中 session。Undelete：恢复之前删除的 session。Paste as Sessions：把剪切板里的 sesisongs 复制到 web sessions 中，把以前的会话粘贴回来.Mark：自定义不同 session 的显示颜色.Unlock for Editing：把锁定的 session 进行解锁，可以进行编辑，默认情况下是不可进行编辑的，默认可以看到选定的 session 前是“锁”的图形 ，点击此按钮后变成可编辑按钮 。Find Sessions…：搜索 session.</code></pre><h6 id="3-1-3-Rules"><a href="#3-1-3-Rules" class="headerlink" title="3.1.3 Rules"></a>3.1.3 Rules</h6><p>Rules规则菜单所谓规则 指的也就是抓包的规则, 按照设置的一系列规则来显示抓取的数据会话。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/8aX43RxosMJ9Qtg.png" alt></p><p> <strong>各个按钮功能说明：</strong></p><pre><code>Hide Image Requests：可以隐藏图片请求，让图片类的 session 不在 session 框中显示出来。Hide CONNECTs：可以隐藏 CONNECT 方法的请求，让这类 session 不在 session 框中显示出来。Automatic Breakpoints：自动断点，控制是否自动在 Before Request 或 After Request 处断点，来修改请求或响应的内容。Customize Rules…：来打开 fiddler script 工具，调取脚本操作，多用于网络修改，其他自定义时使用。Require proxy authentication：若选中此项，则所有未提交 Require proxy authentication 的请求头的请求会返回 HTTP/407 响应，要求客户安装证书。Apply GZIP Encoding：请求 GZIP 编码，若选中此项，则只要请求包含了 gzip 标识的 Accept-Encoding 请求头就会对除了图片以外的所有相应使用 GZIP HTTP 进行压缩。Remove All Encoding：若选中此项，会删除所有请求相应的 http 内容编码和传输编码。Hide 304s：在session框中隐藏所有的 304 的 session。Request Japanese Content：把所有的 Accept-Encoding 请求头设置替换成 ja 标示，标示客户端希望以日语的形式发送。Automatically Authenticate：自动进行身份验证。User-Agents：选择相应的用户代理模式，默认是选择 disabled。那什么是 user-agent 呢？ua 是头域的组成部分，简单来说就是你向访问的网站提供你所用的浏览器的类型等信息，ua 字符串在每次浏览器 http 请求时发送到服务器端。Performance：此项提供影响 web 性能的简单选项。若选中了 simulate modem speeds，它会设置所有后续 session 的 flag，把 request-trickle-delay 标志设置为 300，所有上传数据延迟 300ms/kb，若把 response-trickle-delay 标志位设为 150，会使所有下载数据延迟 150ms/kb。若选中了 disable caching，将会删除所有 If-None-Match和If-Modified-Since 请求头，并添加 Pragma:no-cache 请求头，选中该项还会删除响应中的所有 Expires 头，并把 Cache-Control 响应头设置成 no-cache，该项无法阻止浏览器重用在所用该选项之前所缓存的响应，在选中该选项后，为了得到最佳结果，最好是清空浏览器中缓存。若选择 Catch Always Fresh 会自动响应所有包含 http/304 响应的有条件的 http 请求，表示客户端缓存是最新的，当访问的站点无法正确的设置缓存失效日期时，该选项可以极大的提高性能。</code></pre><h6 id="3-1-4-Tools"><a href="#3-1-4-Tools" class="headerlink" title="3.1.4 Tools"></a>3.1.4 Tools</h6><p>Tools(工具菜单) 这个菜单多数是针对fiddler这款工具本身的一些网络设置。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/dvegKUpPsjI2CWz.png" alt></p><p> <strong>各个按钮功能说明：</strong></p><pre><code>Options…：打开 Options 窗口，是 fiddler 抓包的一些设置项，包括对抓取接口是 http 还是 https 的设置，获取证书，设置代理端口号等功能。WinINET Options…：打开IE浏览器的 options 进行设置。Clear WinINET Catch：清空 IE 和其他应用中所使用的 WinINET 的缓存文件。Clear WinINET Cookies：清空 IE 和其他应用中所使用的 WinINET 的 Cookies 文件。TextWizard：文本向导工具，是一个非常好用的可以轻松将 text 文本 encode 和 decode 的小工具。Compare Sessions：比较 session，可以在 session 框中选中两个 session，然后点击此按钮，可以来比较两个 session，正常情况下需要安装插件。Reset Script：重置脚本。Sandbox：fiddler sanbox 官方文档。View IE Cache：打开本地文件系统，查看ie缓存。Win8 Loopback Exemptions：Win8 回环豁免工具，这个时候会弹出一个“AppContainer 回环豁免实用程序”的窗口，若要将所有的程序使用豁免，点击“全部免除”，然后点击“保存更改”New Session Clipboard…：打开一个新的 session 剪贴板，可以把侧边栏中的 session 拖到这个剪贴板中具体来查看。HOSTS…：主机重定向工具。若在其中勾选 Enable 框，然后在下面加入 host 配置，点击保存之后，这个配置并不会修改到本地 hosts 中，取消勾选就会失效，若点击 Import Windows Hosts File 将会导入本地的 host 文件内容。</code></pre><h6 id="3-1-5-View"><a href="#3-1-5-View" class="headerlink" title="3.1.5 View"></a>3.1.5 View</h6><p>View(视图菜单) 这个菜单是针对fiddler显示界面与视图的一些设置，如果有些工具栏和按钮没有显示，就可以在这里来查找。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/va6LNGKcj2tA83Y.png" alt></p><p>  <strong>各个按钮功能说明：</strong></p><pre><code>Show Toolbar：显示工具栏，默认是勾选的。Default Layout：默认 layout，session 在左，请求和响应在右边的上下处。Stacked Layout：session 在上，请求在下方。Wide layout：session 在上，请求和响应在下方的左右处。Tabs：打开标签页面，其中有三个标签可以打开，分别是 Preferences（fiddler 偏好属性），AutoSave（fiddler 自动保存的设置），APITest（api 的测试）。Statistics：查看一个请求的统计数据。Inspectors：嗅探，用来查看会话的内容，上面是请求，下面是响应Composer：设计构造，在 Composer 中进行请求的修改，可以把 session 框中的数据先清除，然后点击 Composer 中的 Excute 按钮来发送请求，请求出现在 session 框中Minimize To Tray：最小化托盘。Stay On Top：保持置顶。Squish Session List：挤压 session 框。AutoScroll Session List：自动滚动会话列表，默认是勾选此项的，勾选此项后，session 框中的每出现新的 session，session 框中就会不断向下滚动，若不勾选此项，就很方便具体某一个 session 的定位，即使出现了新的 session 也不会自动向下滚动。Refresh：刷新功能，按 F5 刷新。</code></pre><h6 id="3-1-6-Help"><a href="#3-1-6-Help" class="headerlink" title="3.1.6 Help"></a>3.1.6 Help</h6><p>Help(帮助菜单) 一些关于fiddler和网络的帮助信息文档,有兴趣的可以去查查看。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Meg8XyULT24JWrt.png" alt></p><p>  <strong>各个按钮功能说明：</strong></p><pre><code>Help：进入 fiddler 的帮助的网页中。Get Fiddler Book…：fiddler book 的网页。Discussions：fiddler 的讨论网页，这个需要魔法上网。Http Preferences：进入 http preferences 相关网站。Troubleshoot…：会捕获所有请求，对于哪些被过滤的请求用删除线表示出来并给出原因，使用时候会打开一个网页。Get Priority Support…：打开网页购买 fiddler 的优先级服务。Check for Updates…：检查软件更新情况。Send Feedback…：意见反馈。About：当前 fiddler 的相关信息。</code></pre><h5 id="3-2工具栏"><a href="#3-2工具栏" class="headerlink" title="3.2工具栏"></a>3.2工具栏</h5><p>工具栏上的快捷按钮，也是平常我们在抓包过程当中经常会使用到的。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/bQejOdmT8h7Bzty.png" alt></p><h6 id="3-2-1-WinConfig"><a href="#3-2-1-WinConfig" class="headerlink" title="3.2.1 WinConfig"></a>3.2.1 WinConfig</h6><p>给win电脑上的应用程序 配置fiddler权限。windows 使用了一种叫做“AppContainer”的隔离技术，使得一些流量无法正常捕获，在 fiddler 中点击 WinConfig 按钮可以解除这个诅咒，这个与菜单栏 Tools→Win8 Loopback Exemptions 功能是一致的。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/xL8VJoO3Y2EkXWB.gif" alt></p><h6 id="3-2-2气泡图标"><a href="#3-2-2气泡图标" class="headerlink" title="3.2.2气泡图标"></a>3.2.2气泡图标</h6><p>此按钮来给选定的 session 添加注释或者給会话添加备注。使用这个工具按钮你可以给某个会话添加一些描述或者备注信息。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/NJWPtvscxSTp7mM.gif" alt></p><h6 id="3-2-3-Replay"><a href="#3-2-3-Replay" class="headerlink" title="3.2.3 Replay"></a>3.2.3 Replay</h6><p>重发按钮，选定请求重发按钮。</p><p>（1）这个按钮的作用其实就是,重新发一次当前你所选择的会话请求, 也就是说你点击一下Replay就会通过Fiddler来帮你发一次请求到服务器去，也可以通过选择一个会话之后点击键盘上的R键进行快速重放操作，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/mSCML9Ddl4HRAPe.webp" alt></p><p> （2）如果你想一次性向某个会话发送n次请求, 那么可以先选择一个会话，然后按住shift+R 或者 按住shift+Replay按钮或者shift + u来输入一个请求的次数。这种操作可以对一些普通的基础服务器做一个压力测试, 也就相当于一个简单并发测试。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/xJNwGFVZWLRIbYu.webp" alt></p><h6 id="3-2-3-Remove"><a href="#3-2-3-Remove" class="headerlink" title="3.2.3 Remove"></a>3.2.3 Remove</h6><p>删除会话按钮顾名思义就是用来删除列表中的会话, 它这个按钮内部包含了删除会话的一些过滤方法。移除按钮，其中有 Remove all 移除所有，Images，CONNECTs，Non-200s，Non-Browser，Complete &amp; Unmarked，Duplicate response bodies，这些都是移除 session 中的这些状态的选项。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/SZ8193sIHnupPTA.gif" alt></p><p>选项的含义如下表:</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>Remove All</code></td><td>删除全部会话 快捷键为ctrl+x</td></tr><tr><td><code>Images</code></td><td>删除图片相关的请求会话</td></tr><tr><td><code>CONNECTs</code></td><td>删除连接相关的请求会话</td></tr><tr><td><code>Non-200s</code></td><td>删除非200状态的请求会话</td></tr><tr><td><code>Non-Browser</code></td><td>删除非浏览器的请求会话</td></tr><tr><td><code>Complete &amp; Unmarked</code></td><td>删除已完成且未添加备注的请求</td></tr><tr><td><code>Duplicate response bodies</code></td><td>删除没有响应bodies或者重复响应bodies的请求</td></tr></tbody></table><h6 id="3-2-4-Go"><a href="#3-2-4-Go" class="headerlink" title="3.2.4 Go"></a>3.2.4 Go</h6><p>重跑 sessions，依据断点暂停。打断点时使用。</p><h6 id="3-2-5-Stream"><a href="#3-2-5-Stream" class="headerlink" title="3.2.5 Stream"></a>3.2.5 Stream</h6><p>流模式是一种实时通信模式，请求之后实时的返回，更接近浏览器真实行为，但 fiddler 默认是缓冲模式而不是流模式。</p><p><strong>Fiddler两种抓包模式</strong></p><p>缓冲模式（Buffering Mode）Fiddler直到HTTP响应完成时才将数据返回给应用程序。可以控制响应，修改响应数据。但是时序图有时候会出现异常。</p><p>流模式（Streaming Mode）Fiddler会即时将HTTP响应的数据返回给应用程序。更接近真实浏览器的性能。时序图更准确,但是不能控制响应。</p><p>缓冲模式： 服务器把所有内容全部返回到Fiddler之后，Fiddler在一次性发送到客户端。可以控制响应，修改响应数据，但是时序图有时候会出现异常。（这样就支持断点功能，伪造请求，伪造响应等）。</p><p>Fiddler默认的模式为缓冲模式。</p><p>在缓冲模式下，可以进行Fiddler的其他功能，比如支持断点功能，伪造请求，伪造响应等。</p><p>流模式： Fiddler会把收到内容立即发送给客户端。更接近真实浏览器的性能，速度快，时序图更准确（比如瀑布图），但是不能控制响应。换句话说，与浏览器实际请求的模式一致，服务器响应什么数据，立即返回前端。</p><p>如果不需要AutoResponse和Fileters功能的话，一般使用缓冲模式。</p><h6 id="3-2-6Decode"><a href="#3-2-6Decode" class="headerlink" title="3.2.6Decode"></a>3.2.6Decode</h6><p>解码，这里可以将 session 中乱码进行解码方便查看。当把这个按钮点击上了之后，会对所有返回的请求会话进行解码。</p><p>第一种方法：要知道http有的时候返回的正文内容是被编码之后的，若要解码全部会话中的响应报文可以先把这个按钮点选上, 再抓包的时候响应报文就会自动解码其中的正文内容。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/sdBm7HCKyNJjGUo.gif" alt></p><p>第二种方法：你也可以不用点选这个按钮，要解码那个会话,再选择会话的时候点击右边响应报文中的黄色部分提醒你解码：Response body is encoded click to decode(解码响应报文) 就可以了，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/DxBkSoPOAe37wHt.gif" alt></p><h6 id="3-2-7Keep-All-sessions"><a href="#3-2-7Keep-All-sessions" class="headerlink" title="3.2.7Keep All sessions"></a>3.2.7Keep All sessions</h6><p>All sessions：这里可以保持 session 框中存在多少个 sessions。</p><h6 id="3-2-8Any-Process"><a href="#3-2-8Any-Process" class="headerlink" title="3.2.8Any Process"></a>3.2.8Any Process</h6><p>点击此按钮并且拖动到你想要捕获的浏览器从而实现只捕获某个浏览器的请求。这个功能有点意思, 可以瞄准你想要抓取的对象。比如说: 我们现在要抓取一个<code>ie浏览器</code>的请求数据包, 那么可以以下操作，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/zZOptJsUPHAW8lo.gif" alt></p><h6 id="3-2-9Find"><a href="#3-2-9Find" class="headerlink" title="3.2.9Find"></a>3.2.9Find</h6><p>这个望远镜的图标是用来查询的，其他软件有类似的图标，调用这个查询功能的快捷键（Ctrl + F）。可以查找包含指定内容的请求（可单独指定请求过程或者响应过程，检测header或body），默认以黄色高亮显示。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/WCRgE2QwrzD8ktc.gif" alt></p><p>一些其他选项的含义如下表:</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>Match case</code></td><td>表示区分大小写</td></tr><tr><td><code>Regular Expression</code></td><td>正则表达式</td></tr><tr><td><code>Search binaries</code></td><td>搜索二进制文件</td></tr><tr><td><code>Decode compressed content</code></td><td>解码压缩内容</td></tr><tr><td><code>Search only selected sessions</code></td><td>只搜索选择的请求</td></tr><tr><td><code>Result Highlight</code></td><td>搜索结果的强调颜色</td></tr></tbody></table><h6 id="3-2-10Save"><a href="#3-2-10Save" class="headerlink" title="3.2.10Save"></a>3.2.10Save</h6><p>保存按钮，保存所有的 session 成 SAZ 文件。</p><h6 id="3-2-11相机"><a href="#3-2-11相机" class="headerlink" title="3.2.11相机"></a>3.2.11相机</h6><p>这里可不是用来拍照的而是用来截图的。把当前的屏幕截图以jpg的格式，添加到web sessions列表中如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/UC4nrdvY7G6lcgw.gif" alt></p><h6 id="3-2-12钟表图标"><a href="#3-2-12钟表图标" class="headerlink" title="3.2.12钟表图标"></a>3.2.12钟表图标</h6><p>简单的计时功能。点击一下开始计时，再点击一下停止计时。</p><h6 id="3-2-13Browser"><a href="#3-2-13Browser" class="headerlink" title="3.2.13Browser"></a>3.2.13Browser</h6><p>快捷的打开一个浏览器，打开浏览器来查看响应数据。如果选中了一个会话，会在浏览器中打开目标URL。如果没有选中任何会话或者选中了多个会话，在浏览器中打开about:blank。</p><h6 id="3-2-14Clear-Cache"><a href="#3-2-14Clear-Cache" class="headerlink" title="3.2.14Clear Cache"></a>3.2.14Clear Cache</h6><p>清除 WinINET 的缓存，按住 CTRL 键并点击该按钮可以清除WinINET中保存永久的 cookies。</p><h6 id="3-2-15TextWizard"><a href="#3-2-15TextWizard" class="headerlink" title="3.2.15TextWizard"></a>3.2.15TextWizard</h6><p>打开文本编码/解码小工具，以使文本在多种编码间转换。此工具可以将某一编码过的或者未编码过的字串拿到此处解码和编码，在菜单栏中的 Tools 中也有此项可以打开。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ugrclRQ4FeoD7P6.webp" alt></p><h6 id="3-2-16Tearoff"><a href="#3-2-16Tearoff" class="headerlink" title="3.2.16Tearoff"></a>3.2.16Tearoff</h6><p>此功能用来将右边栏里的请求和响应部分给单独拆成一个新窗口，方便视察。点击分离出的窗口X关闭按钮，即可复原窗口。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/xEylcLw8qTJkdUO.gif" alt></p><h6 id="3-2-17MSDN-Search…"><a href="#3-2-17MSDN-Search…" class="headerlink" title="3.2.17MSDN Search…"></a>3.2.17MSDN Search…</h6><p>在网页版的微软开发中去搜索。在MSDN的web sessions区域进行搜索，在微软开发者社区的搜索，一般都不会用。</p><h6 id="3-2-18问号图标"><a href="#3-2-18问号图标" class="headerlink" title="3.2.18问号图标"></a>3.2.18问号图标</h6><p>fiddler 的在线帮助网站。</p><h6 id="3-2-19Online"><a href="#3-2-19Online" class="headerlink" title="3.2.19Online"></a>3.2.19Online</h6><p>鼠标放在上面，会显示一些本机的在线信息。如IP信息。用来指示当前是在线的还是离线的。如果在线，把光标停留在该按钮上方会显示包含本地计算机的主机名和IP的提示。双击该按钮会打开系统的Network Connections控制面板。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/eInYQPHSLopR7Jk.gif" alt></p><h6 id="3-2-19叉号（删除工具栏）"><a href="#3-2-19叉号（删除工具栏）" class="headerlink" title="3.2.19叉号（删除工具栏）"></a>3.2.19叉号（删除工具栏）</h6><p>用来关闭工具栏的按钮，在 View 中可以打开工具栏。如果要恢复工具栏，可以点击菜单栏<strong>View —&gt; Show Toolbar</strong>，进行恢复。</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>好了，到此宏哥就将Fiddler的工具栏常用的基本上全都讲解和分享完了，今天时间也不早了，就到这里！感谢您耐心的阅读~~</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(2)-初识Fiddler让你理性认识一下 -02</title>
      <link href="/2016/06/10/fiddler/"/>
      <url>/2016/06/10/fiddler/</url>
      
        <content type="html"><![CDATA[<p>**🔥 《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(2)-初识Fiddler让你理性认识一下 </p><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>　　今天的理性认识主要就是讲解和分享Fiddler的一些理论基础知识。其实这部分也没有什么，主要是给小伙伴或者童鞋们讲一些实际工作中的场景，然后隆重推出我们的猪脚（主角）-Fiddler。</p><h5 id="1-1工作场景"><a href="#1-1工作场景" class="headerlink" title="1.1工作场景"></a>1.1工作场景</h5><p><strong>做app测试，你是否有过这样的经历？</strong></p><p>1.后端开发同事在调试解决bug时 ，总找你拿着手机点点点，然后他在后台看数据是否异常。（一个上午，一不小心过去了）</p><p>2.前端开发同事在调试解决bug时，也找你过来帮忙造几个数据，于是你辛辛苦苦造了个数据，他点一下，数据用完了，bug没解决。于是乎又找你造数据。（一个下午，又一不小心过去了）</p><p>3.你曾经是否遇到过这种情况，当你发现一个bug提交给前端开发时，他说是后端返回数据的问题。于是你找到后端开发，他说是前端数据提交的问题，让你找前端开发。（一个晚上过去了，bug没解决。。。）</p><p>这个时候就有请我们的主角-Fiddler开始闪亮登场。前边这些他可以通通解决。</p><p><strong><code>温馨提示:全程干货、内容比较多，建议新手朋友可以先点赞+收藏再慢慢观看!</code> 😇</strong></p><h4 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h4><p>　　在这个网络信息时代里，计算机安全始终是一个让人揪心的问题，网络安全则有过之而无不及。许多电脑高手 经常利用 Fiddler 可以作为代理的这个功能去抓取会话并进行修改达到自己想要的目的。Fiddler是一个强大并且跨平台的HTTP(S)抓包神器，你可别拿去做坏事。它的英文名叫：Fiddler，中文名叫：小提琴。Fiddler 是一个 HTTP 协议调试代理工具。它能够记录并检查所有你的电脑和互联网之间的 HTTP、FTP、HTTPS 的数据包。通过设置断点，用户还可以修改 “进出”Fiddler 的数据。由于 Fiddler 具备强大的数据抓包和修改功能，所以 Fiddler 广泛应用 Web 渗透测试领域。</p><p>Fiddler是最强大最好用的Web调试工具之一， 它能记录所有客户端和服务器的http和https请求。允许你监视、设置断点、甚至修改输入输出数据。Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展。换言之，你对HTTP 协议越了解，你就能越掌握Fiddler的使用方法。你越使用Fiddler，就越能帮助你了解HTTP协议。Fiddler无论对开发人员或者测试人员来说，都是非常有用的工具。</p><p>Fiddler是以web proxy代理服务器的形式工作的 , 它也是一个http协议数据抓包与调试代理工具，它能够记录和检查当前你的电脑和互联网之间的http消息, 也就是说可以将网络传输发送与接受的数据包进行截获、重发、编辑、转存等操作 还可以用来检测网络安全。</p><h4 id="3-抓包"><a href="#3-抓包" class="headerlink" title="3.抓包"></a>3.抓包</h4><p>　　抓包（packet capture）：用特定的工具获取客户端与服务端发送和返回的数据包。目的是分析数据包的内容与协议，从而来判断是否符合设计要求。其实就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查<strong>网络安全</strong>。</p><h4 id="4-什么情况下需要抓包"><a href="#4-什么情况下需要抓包" class="headerlink" title="4.什么情况下需要抓包?"></a>4.什么情况下需要抓包?</h4><p>1.开发要你重现bug，截取数据，定位问题的时候</p><p>2.判断一个问题是前端bug还是后端bug的时候</p><p>3.开发要你做接口测试，但又不没给你接口文档的情况–》方法，接口地址，传递参数，头部，返回内容</p><p>4.在不修改任何环境的情况下，修改返回的结果，即通常说的mock–》模拟接口</p><h4 id="5-为什么要学习Fiddler"><a href="#5-为什么要学习Fiddler" class="headerlink" title="5.为什么要学习Fiddler?"></a>5.为什么要学习Fiddler?</h4><p>宏哥从三个角度给小伙伴们或者童鞋们来解剖一下：</p><h5 id="5-1Fiddler本身优势"><a href="#5-1Fiddler本身优势" class="headerlink" title="5.1Fiddler本身优势"></a>5.1Fiddler本身优势</h5><p>1、功能强大，其他工具有的功能它也有，其他工具没有的功能它也有，支持http，https，ftp等协议；</p><p>2、完全免费，长期免费。</p><p>3、所有的浏览器可以使用，所有的平台都可以使用。就冲着这三点，就值得拥有。</p><h5 id="5-2同类产品对比"><a href="#5-2同类产品对比" class="headerlink" title="5.2同类产品对比"></a>5.2同类产品对比</h5><p>除了Fiddler还有哪些能抓包？</p><p>抓包工具：wireshark、fiddler、httpwatch、charles、chrome开发者工具(F12)，各工具的对比，</p><p>说到抓包工具，有Fiddler、Charles、HttpWatch、WIRESHARK等知名、不知名的……当然工具没有强弱好坏之分，只是看在什么场景下使用更为适合！Fiddler和同种类型的抓包工具对比，如下图所示：<img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/4XJBCEWD7hVUuHY.png" alt></p><p>从上图我们可以看出：我们为什么选择Fiddler进行抓包，可以看一下它的比较。</p><p>　　首先第一个Fiddler它的优势，独立运行，第二个支持移动设备（是否能抓移动APP的包，）在这一块的话wireshark、httpwatch就不支持，因此在这一块就可以排除掉前连个，因为我们有时候去进行测试的时候，除了测web端，也会要去测app端，在企业里经常去要做的事情。</p><p>　　然后Fiddler是免费的，charles是收费的。当然我知道大家都能够各显神通，做坏事的时候，记得带上你的负罪感。</p><p>　　当然你选择这个免费工具的前提是，它满足你的需求，能够解决你的问题，并不是说我随便找一个不能解决我问题的工具，这个肯定是不行的，至于说在这一块想去用一下wireshark、httpwatch可以自行去下载使用，我们今天主要分享Fiddler。（需要软件测试相关安装包，可以微信公众号主页点击领取资料，安装包，教程都给你准备好了，免费）</p><h5 id="5-3用户"><a href="#5-3用户" class="headerlink" title="5.3用户"></a>5.3用户</h5><p>　　在测试中，不管是做手工测试，还是接口测试，我们都需要查看后端返回的数据。有的时候，我们也需要调试，或者mock一下后端的返回，来验证前端是否达到预期。为了捕获这些请求，抓包工具不可少。熟练掌握一些抓包工具，可以方便我们测试，调试，分析问题。</p><p>　　不管是在开发、还是在测试阶段中，“抓包”都是定位bug的主要方法之一。特别是当你提交bug给对应的开发同学，如果没有“铁证”，他们通常都拒绝修改。甚至还会高傲的对你说“你抓个包看看，是不是后台或者接口的问题啊，憋有事没事给我提bug<del>”。这个时候，Fiddler就可以帮助你快速打脸回去了</del>当然，打脸不是目的，帮助开发同学快速精准的定位bug原因，才是王道！</p><h4 id="6-Fiddler是什么？"><a href="#6-Fiddler是什么？" class="headerlink" title="6.Fiddler是什么？"></a>6.Fiddler是什么？</h4><p>那么Fiddler究竟是什么？能干什么呢？</p><p>《度娘宝典》如是说：<br>　　Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。</p><h5 id="6-1宏哥推荐的原因"><a href="#6-1宏哥推荐的原因" class="headerlink" title="6.1宏哥推荐的原因　　"></a>6.1宏哥推荐的原因　　</h5><p>1.安装配置简单，快速上手（别说咸鱼，菜鸟都会<del>）；基本功能强大，新手必备（简直不要太好用</del>）；</p><p>2.能记录所有客户端（PC端和手机客户端）和服务器间的Http和Https请求，可监视、设置断点、修改response和request，模拟低速网速环境，还能够使用.net框架语言扩展）</p><h4 id="7-Fiddler支持和不支持的功能"><a href="#7-Fiddler支持和不支持的功能" class="headerlink" title="7.Fiddler支持和不支持的功能"></a>7.Fiddler支持和不支持的功能</h4><p>　　宏哥经常会遇到的一些小伙伴或者童鞋们的私信或者留言的问题类似于：“宏哥，我可以使用Fiddler来完成XXX吗？Fiddler适用于很多场景中。但是，对于一些场景，Fiddler是不合适的。绝大多数情况下，人们所使用的是Fiddler的少数几个功能。一下将简单说明Fiddler所适用的场景。</p><h5 id="7-1Fiddler支持功能的不完整列表"><a href="#7-1Fiddler支持功能的不完整列表" class="headerlink" title="7.1Fiddler支持功能的不完整列表"></a>7.1Fiddler支持功能的不完整列表</h5><p>1.查看几乎所有的浏览器、客户端应用或者服务之间的web数据流。监控我们浏览器所有的http/https的信息和流量，也就是所有的请求或者响应，所有的流量都可以监听。</p><p>2.手动或者自动修改任意的请求或者响应。当监听截取到http请求之后，就可以做一些查看 分析浏览器请求的内容细节,就可以伪造一些请求 伪造一个服务器的响应都是可以的!</p><p>3.解密HTTPS数据流以便查看和修改</p><p>4.归档捕获到的数据流，支持不同计算机上加载这些数据</p><p>5.给客户端应用“回放（play back）”先前捕获到的响应，即使当前服务器处于脱机状态。</p><p>6.绝大多数PC和各种设备之间的Web数据流的调试，包括Mac/Linux系统、智能手机和平板电脑。</p><p>7.挂接到（chain to）上游代理服务器，包括TOR网络（TOR是专门防范对流量探嗅分析的软件项目。它通过由遍及全球的中继所组成的分布式网络转发通信，可以实现匿名访问网络。）</p><p>8.还可以测试网站的性能</p><p>9.作为反向代理运行，在不需要配置客户端计算机或者设备的情况下，在服务端捕获的数据流。</p><p>10.全局、局部断点功能。</p><p>11.第三方插件</p><h5 id="7-2Fiddler不支持功能的不完整列表"><a href="#7-2Fiddler不支持功能的不完整列表" class="headerlink" title="7.2Fiddler不支持功能的不完整列表"></a>7.2Fiddler不支持功能的不完整列表</h5><p>Fiddler是一个非常灵活强大的工具，但某些功能目前还不支持。</p><p>1.调试非网络协议数据流</p><p>（1）Fiddler支持HTTP、HTTPS和FTP数据流以及相关协议，如HTML5 WebSockets和ICY流。</p><p>（2）Fiddler无法监测或修改基于其他协议的数据，如SMTP、POP3、Telnet、IRC等。</p><p>2.处理超大请求和响应</p><p>（1）超过2GB的请求，Fiddler无法处理</p><p>（2）超过2GB的响应，Fiddler的处理能力有限</p><p>（3）Fiddler使用系统内存和页面文件（pagefile）来保存会话数据。保存大量的会话或者超大的请求和响应会导致性能急剧下降。</p><p>3.“神奇”地修复网站的错误（bug）</p><p>（1）Fiddler可以用来协助识别网络问题，但通常不能独立修复这些bug。</p><h4 id="8-Fiddler应用场景"><a href="#8-Fiddler应用场景" class="headerlink" title="8.Fiddler应用场景"></a>8.Fiddler应用场景</h4><p>Fiddler的应用场景也很广泛，具体应用场景如下：</p><p>1.接口调试</p><p>2.接口测试</p><p>3.线上环境调试</p><p>4.web性能分析</p><p>5.判断前后端bug</p><p>6.开发环境hosts配置</p><p>7.mock模拟测试</p><p>8.弱网断网测试</p><p>要知道Fiddler作为系统代理，所有的来自互联网服务的http（Https）请求在到达目标Web服务器之前都会经过Fiddler，同样的，所有的Http（Https）响应都会在返回客户端之前也会经过Fiddler。</p><h4 id="9-Fiddler部署"><a href="#9-Fiddler部署" class="headerlink" title="9.Fiddler部署"></a>9.Fiddler部署</h4><h5 id="9-1Fiddler环境部署"><a href="#9-1Fiddler环境部署" class="headerlink" title="9.1Fiddler环境部署"></a>9.1Fiddler环境部署</h5><p>1.下载Fiddler，官方下载地址：<a href="https://www.telerik.com/download/fiddler填写好电子邮箱和国家地区" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler填写好电子邮箱和国家地区</a> 点击Download for windows就可以下载了。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Ln1kARpit3GSfOd.png" alt></p><p>2.安装：傻瓜式安装，一直点下一步，直达完成为止。安装成功会显示如下界面，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/wN65xFyjDKX8mRY.png" alt></p><h5 id="9-2Fiddler更新"><a href="#9-2Fiddler更新" class="headerlink" title="9.2Fiddler更新"></a>9.2Fiddler更新</h5><p>1.Fiddler在启动时，会自动查询是否有新版本。当发现有新版本时，会有更新提示。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Tm5hKG8j1k7HSNB.png" alt></p><p>2.点击“Yes”按钮，Fiddler会启动浏览器，下载最新的安装程序。下载完成后，关闭正在运行的Fiddler，手动安装新下载的程序。如果点击的是“Next Time”下一次安装这个按钮，下一次启动Fiddler时，它会自动下载安装最新版本。如果点击“No”，弹出的对话框就会关闭，不会安装新的版本，下一次启动Fiddler时，还会弹出这个提示。</p><p>3.Fiddler提示更新，傻瓜式更新，一直点下一步，直达完成为止。更新成功会显示如下界面，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ecfqXypS28hvYRQ.png" alt></p><h5 id="9-3Fiddler退出"><a href="#9-3Fiddler退出" class="headerlink" title="9.3Fiddler退出"></a>9.3Fiddler退出</h5><p>可能有的小伙伴觉得没有必要介绍Fiddler退出，这么简单我直接关闭不就直接退出了，但是有时候你的退出操作却是不正常的退出操作，这个就会产生一系列的问题。当Fiddler是以代理服务器形式工作的，默认ip地址是127.0.0.1:8888,如果Fiddler是非正常退出，那么仍会占用端口，导致其他网页访问失败，因此大家退出Fiddler的时候，要点击File，点击Exit，正常退出Fiddler，而不是直接点击右上角的叉号关闭。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/AtGJEpSz6bfcLRj.gif" alt></p><h5 id="9-4Fiddler卸载"><a href="#9-4Fiddler卸载" class="headerlink" title="9.4Fiddler卸载"></a>9.4Fiddler卸载</h5><p>可以使用控制面板中的“添加/删除”来卸载Fiddler。卸载后，系统并不会被清理干净，因此卸载无法解决配置问题。</p><h4 id="10-Fiddler工作原理"><a href="#10-Fiddler工作原理" class="headerlink" title="10.Fiddler工作原理"></a>10.Fiddler工作原理</h4><p>　　在介绍fiddler使用方法之前，我想先介绍一下fiddler原理，明白原理后，使用起来会更得心应手。</p><p>　　Fiddler是位于客户端和服务器端之间的HTTP代理， 它能够记录客户端和服务器之间的所有 HTTP(S)请求，可以针对特定的HTTP(S)请求，分析网络传输的数据，还可以设置断点、修改请求的数据和服务器返回的数据。<br>　　Fiddler在客户端与服务器之间建立一个代理服务器，Fiddler工作于七层中的应用层，能够捕获通过的HTTP(S)请求。Fiddler启动后会自动将代理服务器设置成本机，默认端口为8888。Fiddler不仅能记录PC上浏览器的网络请求数据，还可以记录同一网络中的其他设备的HTTP(S)请求数据。数据传递流程大致如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/bazTcI21NtCnuiG.png" alt></p><p>　　由上图可以看出，Fiddler使用代理方式，让客户端所有数据流都发给它，然后由fiddler转发给目标server，目标server的回包发给fiddler，再由fiddler转发给客户端。所以不管是Request还是Respone数据包都经过了fiddler，fiddler能进行截获和分析。正是他这样架构优势，才有其其他工具无法做到的强大功能，其不光是支持这些<a href="http://fiddler2.com/documentation/Configure-Fiddler/Tasks/ConfigureBrowsers#ie,-chrome,-safari,-and-opera" target="_blank" rel="noopener">IE, Chrome, Safari, and Opera</a>浏览器的抓包，还支持一些客户端的http(s)抓包，前提是这些client支持http代理配置。</p><p> <img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Q4IbYRjN1nXxGc9.png" alt></p><h5 id="10-1图解"><a href="#10-1图解" class="headerlink" title="10.1图解"></a>10.1图解</h5><p>1) 客户端向服务器发送HTTP(S)请求时，请求会先经过代理Fiddler代理服务器。<br>2) Fiddler代理服务器截取客户端的请求报文，再转发到服务器，转发之前可以做一些请求报文参数修改的操作。<br>3) 服务器处理完请求以后返回响应报文，Fiddler代理服务器会截取服务器的响应报文。<br>4) Fiddler处理完响应报文后再返回给客户端。</p><p>Fiddler的原理简单点说就是通过改写HTTP代理然后让网络数据从Fiddler这边通过 这样子来监控并且截取到网络信息数据。当你打开Fiddler的时候, 就已经设置好了浏览器的代理了。当你关闭的时候，它会自动的帮你把代理还原。这里还要清楚一点的就是 浏览器默认走的是我们的系统代理，其实这里的代理监听 就是在 请求和响应之间插了一脚, 让fiddler成为系统代理。</p><p>1.在你安装好Fiddler之后启动，并可以打开菜单栏中的<strong>Tools—&gt;options—&gt;Connections</strong> ，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/hNflD3G45x8Jaib.gif" alt></p><p>2.从上图可以看到：有一句<strong>Act as system proxy on startup</strong>意思就是(在启动时充当系统代理),并且默认监听端口设置为了8888。Fiddler就是一个中间的proxy(代理服务器)，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/1OUsIR7NcqKtWez.png" alt></p><p>3.查看自己电脑系统是否在启动Fiddler后，开启了代理，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/dyiZ8Ownx2cfuXt.png" alt></p><p>4.当正常退出fiddler的时候，再次查看系统手动设置代理选项就会被清空并关闭，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/ivBX9K5wyoQWquY.png" alt></p><h4 id="11-小结"><a href="#11-小结" class="headerlink" title="11.小结"></a>11.小结</h4><p>注意：这个Fiddler工具是基于.NET Framework的 ,因为Fiddler是c#开发的，如果是比较老的windows系统要保证运行环境!☺️Fiddler的安装方法也很简单 获取到安装包之后,直接选择安装路径 或 无脑下一步就可以了!☺️</p><p>Fiddler是以代理WEB服务器的形式工作的,浏览器与服务器之间通过建立TCP连接以HTTP协议进行通信，浏览器默认通过自己发送HTTP请求到服务器，本地使用代理地址:127.0.0.1, 端口:8888.而当Fiddler开启会自动设置系统代理， 正常退出的时候它会自动注销代理，这样就不会影响别的程序。但是如果Fiddler非正常退出，这时可能会因为Fiddler没有自动注销，而会造成网页无法访问。</p><p>解决的办法是重新启动下Fiddler，然后正常退出就可以了, 这也是有很多新手安装了Fiddler之后导致一些网络无法访问的原因之一。</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(1)-HTTP和HTTPS基础知识 -01</title>
      <link href="/2016/06/09/fiddler/"/>
      <url>/2016/06/09/fiddler/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 《吐血整理》保姆级系列教程-玩转Fiddler抓包教程(1)-HTTP和HTTPS基础知识 ）</strong></p><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><p>有的小伙伴或者童鞋们可能会好奇地问宏哥，不是讲解和分享抓包工具了怎么这里开始讲解HTTP和HTTPS协议了。这是因为你对HTTP协议越了解，你就能越掌握Fiddler的使用方法，反过来你越使用Fiddler，就越能帮助你了解HTTP协议。</p><p>Fiddler无论对开发人员或者测试人员来说，都是非常有用的工具。</p><h4 id="2-前言"><a href="#2-前言" class="headerlink" title="2.前言"></a>2.前言</h4><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h4 id="3-HTTP和HTTPS基本概念"><a href="#3-HTTP和HTTPS基本概念" class="headerlink" title="3.HTTP和HTTPS基本概念"></a>3.HTTP和HTTPS基本概念</h4><p><strong>HTTP</strong>（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</p><p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/IXbTaPRAuCDg3k8.png" alt></p><p><strong>HTTPS协议的主要作用可以分为两种：</strong></p><p>一种是建立一个信息安全通道，来保证数据传输的安全；</p><p>另一种就是确认网站的真实性。</p><h4 id="4-什么是http请求和响应"><a href="#4-什么是http请求和响应" class="headerlink" title="4.什么是http请求和响应?"></a>4.什么是http请求和响应?</h4><p>http的工作方式为一个简单的客户端请求与服务端响应的应答过程。它指定了客户端发送给服务器什么样的消息形式以及得到什么样的消息响应，所有的www文件都必须遵循这个标准协议, 目的是提供一种发布和接收html页面的方法。举个例子比如说 客户端（浏览器）向服务器提交一个http请求, 那么服务器又会向客户端这边返回响应信息。而这些响应信息包含关于客户端请求的状态信息以及客户端所需要的内容信息。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/3t9qHn4GRWcUXEK.png" alt></p><h4 id="5-http协议和web之间的本质"><a href="#5-http协议和web之间的本质" class="headerlink" title="5.http协议和web之间的本质"></a>5.http协议和web之间的本质</h4><p>http协议和web之间的本质说白了就是就是浏览器和服务器打交道的。客户端向服务器端发送Http请求,然后服务器端向客户端返回http响应!</p><p>http协议：所谓协议，就是指双方遵循的规范。http协议，就是浏览器和服务器之间进行“沟通”的一种规范。, 也就是以这个规范来向服务器发起请求, 服务器才会给客户端进行正确的响应, 所以http有的时候也可以理解为是一种 规范、规则、标准。http协议是属于“应用层的协议”,而且是基于TCP/IP协议的, 也就是说http通信发生在TCP/IP链接之上。</p><p>通俗一点说http协议就是基于TCP的一种应用层协议 它不会关系数据传输的细节问题,也就是说你不用去关心它下层TCP的运行逻辑, 它的核心只在于用来规定客户端和服务端的数据传输格式。最早http是用来向客户端传输html文件内容,默认的端口80</p><h5 id="5-1扩展"><a href="#5-1扩展" class="headerlink" title="5.1扩展"></a>5.1扩展</h5><p>有兴趣的朋友可以自行了解一下iso网络七层模型。</p><p>如果你接触过socket网络编程，就应该明白TCP和UDP这两种使用广泛的通信协议（建立连接、三次握 手等等，当然，这不是本文讨论的重点）。</p><p>既然TCP/UDP是广泛使用的网络通信协议，那为啥有多出个http协议来呢？</p><p>笔者曾自己动手写过一个简单的web服务器处理软件，根据我的推断（不一定准确）。UDP协议具有不可靠性和不安全性，显然这很难满足web应用的需要。</p><p>而TCP协议是基于连接和三次握手的，虽然具有可靠性，但人具有一定的缺陷。但试想一下，普通的C/S架构软件，顶多上千个Client同时连接，而B/S架构的网站，十万人同时在线也是很平常的事儿。如果十万个客户端和服务器一直保持连接状态，那服务器如何满足承载呢？</p><p>这就衍生出了http协议。基于TCP的可靠性连接。通俗点说，就是在请求之后，服务器端立即关闭连接、释放资源。这样既保证了资源可用，也吸取了TCP的可靠性的优点。</p><p>正因为这点，所以大家通常说http协议是“无状态”的，也就是“服务器不知道你客户端干了啥”，其实很大程度上是基于性能考虑的。以至于后来有了session之类的玩意。</p><p>通俗点说http，就是在请求和响应之后，服务器端立即关闭连接，并释放资源，这样既保证了资源可显示与可用性，也吸取了TCP协议的可靠性优点,但是缺点就无法跟踪用户的操作了,所以我们在后端开发的学习中才会接触一个东西叫session和cookie技术</p><p>所以你也可以理解为http是基于请求与响应的模式, 并且是无状态的应用层协议。</p><h4 id="6-http请求和响应的基本原理"><a href="#6-http请求和响应的基本原理" class="headerlink" title="6.http请求和响应的基本原理"></a>6.http请求和响应的基本原理</h4><p>HTTP 消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ 请求（requests）– 由客户端发送用来触发一个服务器上的动作；响应（responses）– 来自服务器的应答。</p><p>任何一个http请求都只会分为两个部分: 一个请求报文另外一个是响应报文。</p><p>请求报文是客户端按照一定的格式生成一段文本,然后发给我们的服务端, 而服务器接收到了这样一个请求报文就会解析里面的内容进行处理,然后做出反馈，也就是响应。</p><p>响应报文也就是服务器端根据请求报文反馈给客户端的文本信息。</p><h5 id="6-1http请求-request-报文基本结构"><a href="#6-1http请求-request-报文基本结构" class="headerlink" title="6.1http请求(request)报文基本结构"></a>6.1http请求(request)报文基本结构</h5><p>http请求(request)也叫请求报文，一个基本的HTTP请求报文由请求行（request line）、请求头部（request header）、空行和请求数据4个部分构成。</p><pre><code>1.请求行（request line）:就是请求方式和协议,也就是说用于描述客户端的请求方式,例如post/get方式, 以及请求的资源名称和HTTP协议的版本号!2.若干个请求头（request header）: 这些也叫消息头告诉服务器发送的是什么数据类型，编码类型、请求的是哪台主机、以及客户端浏览器的一些系统环境 等等， 这些消息头中有很多头部字段名 和 对应的值它的格式为 name:value3.空白行4.请求正文内容</code></pre><p>说了这么多是不是有点懵有点晕，那宏哥就使用抓包工具抓取实际例子，我们具体看一下：</p><p>那么我们在学习http知识的时候 就可以先直接使用Fiddler来抓取一个http请求和http响应来先看看到底是什么东西!这样也有助于我们来更好地理解http。我们可以通过Fiddler抓取网络数据包的手段，就可以看到一个基本的http请求结构都包含哪些信息!例如一个GET方式的请求(Request)信息，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/4w7Jel1pfxz8AMn.png" alt></p><h5 id="6-2http响应-response-报文基本结构"><a href="#6-2http响应-response-报文基本结构" class="headerlink" title="6.2http响应(response)报文基本结构"></a>6.2http响应(response)报文基本结构</h5><p>http响应(response)也叫响应报文，一个基本的HTTP响应报文由响应行、响应头、空行和响应体4个部分构成。</p><pre><code>1.响应行：响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK2.响应头：响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。3.空白行：4.响应体：响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。</code></pre><p>其实响应报文比请求报文更加简单, 你只要能够搞懂请求报文 那么响应报文就很容易搞懂，同样的道理，我们可以通过Fiddler抓取网络数据包的手段，就可以看到一个基本的http响应结构都包含哪些信息。</p><p>例如一个POST方式的请求(Request)信息 如下:例如一个POST方式的请求(Request)信息，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/l53LnySJPIerWaf.png" alt></p><p>怎么样是不是看这一大堆脑壳都大了一直稳稳地响个不停呢 ？感觉无从下手，更不用说学习里， 哈哈哈不要着急，跟着宏哥慢慢来学!😁😁😁</p><h4 id="7-Http请求-Request-报文结构图解"><a href="#7-Http请求-Request-报文结构图解" class="headerlink" title="7.Http请求(Request)报文结构图解"></a>7.Http请求(Request)报文结构图解</h4><p>我们先来看一张请求(Request)图解，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/AnI4P37Cwv1plZs.jpg" alt></p><p><strong>然后宏哥来逐一解剖上图中的各个部分，解剖结果如下：</strong></p><h5 id="7-1请求方法-Request-method"><a href="#7-1请求方法-Request-method" class="headerlink" title="7.1请求方法 (Request method)"></a>7.1请求方法 (Request method)</h5><p>我们常见的一些请求方式也就是POST/GET,当然还有其他的一些请求方式, 如下表所示：</p><table><thead><tr><th>请求方法</th><th>描述</th></tr></thead><tbody><tr><td><code>GET</code></td><td><code>请求资源</code> 比如常见的就是输入一个<code>URL</code>去请求一个资源下来, 它也可以带上一定的参数一起请求</td></tr><tr><td><code>POST</code></td><td><code>提交资源</code> 比如说我们想把用户名和密码 提交到服务器去,这个时候用<code>POST</code>比较好</td></tr><tr><td><code>HEAD</code></td><td><code>获取响应头，检查一个对象是否存在</code></td></tr><tr><td><code>PUT</code></td><td>替换资源，向服务器发送数据，并存储服务器内部</td></tr><tr><td><code>DELETE</code></td><td>删除资源</td></tr><tr><td><code>OPTIONS</code></td><td>允许客户端查看服务器的性能</td></tr><tr><td><code>TRACE</code></td><td>显示服务器收到的请求 常见于测试和调试诊断!</td></tr><tr><td><code>CONNECT</code></td><td>对通道提供支持</td></tr></tbody></table><h5 id="7-2URL-Uniform-Resource-Locator）"><a href="#7-2URL-Uniform-Resource-Locator）" class="headerlink" title="7.2URL (Uniform Resource Locator）"></a>7.2URL (Uniform Resource Locator）</h5><p>URL中文名为统一资源定位符 英文全称Uniform Resource Locator ,可以使用一个URL地址来描述一个网络上的资源，而HTTP的<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>对应着对这个资源的查、改、增、删四个操作。我们网络中的每一信息资源都有统一的且在网上唯一的地址!</p><p>URL具体由4部分组成：协议、主机、域名、端口、路径文件、[附加资源]</p><p>URL的一般语法格式为：</p><pre><code>protocol :// hostname[:port] / path / [?query-parameters][#anchor]</code></pre><p>1.协议 (protocol)：指底层使用的协议类型，如：http、ftp、https、等…</p><p>2.主机名 (hostname) + 域名：HTTP服务器的IP或者域名。主机名+域名 例如: <a href="http://www.xsphp.com" target="_blank" rel="noopener">www.xsphp.com</a></p><p>3.端口 (port)：HTTP服务器端口，端口是一个数字, 端口是可选的 省略时使用方案是服务器默认配置的端口。例如 80、8080、..各种传输协议都有默认的端口号，如http协议的默认端口为80，如果URL地址省略端口，则使用默认端口号。</p><p>注意：有时候出于安全或其他考虑，可以在服务器配置上对端口进行重新定义，也就是采用非标准端口号，那么此时，URL地址中就不能省略端口号这一项。</p><p>4.路径文件 (path)：访问资源的路径。由零或多个/符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。例如: /tpl/index.php</p><p>5.查询参数 附加资源 (query-parameters)：发送给HTTP服务器的数据。</p><p>这一项在URL中也是可选的 用于给动态网页如 PHP/JSP/ASP/ASP.NET等后端页面 传递参数的一种方式，并且如果是GET请求方法, 那么可有多个参数, 它们彼此用&amp;符号隔开，每个参数的名和值用=符号隔开</p><p>语法格式: ?参数=值&amp;参数2=值 以此类推。例如: ?id=33&amp;age=25&amp;name=zhangsan。举个例子：一个比较常见的url地址， 如：<a href="https://www.xxxx.net/xxxx/xxxx/xxxx/100?num=1001.2014.3001.5501" target="_blank" rel="noopener">https://www.xxxx.net/xxxx/xxxx/xxxx/100?num=1001.2014.3001.5501</a></p><p>6.anchor：锚点</p><h5 id="7-3请消息求头-Request-Header"><a href="#7-3请消息求头-Request-Header" class="headerlink" title="7.3请消息求头 (Request Header)"></a>7.3请消息求头 (Request Header)</h5><p>1.请求消息头也叫消息头告诉服务器发送的是什么数据类型，编码类型、请求的是哪台主机、以及客户端浏览器的一些系统环境 等等前面已经说过了, 并且请求头是可以由开发人员根据需求去进行自定义的。</p><p>这些消息头中有很多头部字段名 和 对应的值它的格式为 name:value。我们常见的一些请求头如下表所示：</p><table><thead><tr><th>请求头</th><th>描述</th><th></th></tr></thead><tbody><tr><td><code>Host</code></td><td>主机IP地址或域名</td><td></td></tr><tr><td><code>User-Agent</code></td><td>提交一些<code>客户端</code>相关信息，例如: <code>操作系统、浏览器</code>等一些版本信息给<code>服务器</code>, 而这些信息可能会让<code>服务器</code>按照一定的规则给<code>客户端</code>返回兼容性比较好的信息!</td><td></td></tr><tr><td><code>Accept</code></td><td>指定<code>客户端</code>接收的信息类型，<br>例如:<code>image/jpg,text/html,application/json</code><br>也就是可以让<code>客户端</code>告诉<code>服务器</code> 之后客户端这一边想接收到什么样的数据格式</td><td></td></tr><tr><td><code>Accept-Charset</code></td><td>告诉<code>服务器</code>等一会这边<code>客户端</code>需要接收的<code>字符集编码格式</code>，</td><td><br>例如:<code>gb2312、iso-8859-1、utf-8</code></td></tr><tr><td><code>Accept-Encoding</code></td><td>告诉<code>服务器</code>， 客户端这边可接受的<code>内容压缩编码</code>，例如<code>gzip</code> 可以在一定程度上节省流量!</td><td></td></tr><tr><td><code>Accept-Language</code></td><td>告诉服务器, <code>客户端</code>可接受的语言，例如<code>Accept-Language：zh-cn</code></td><td></td></tr><tr><td><code>Authorization</code></td><td>客户端提供给服务端进行权限认证的信息, 也就是要告诉服务器端一些认证的信息，服务器才能返回响应的数据!</td><td></td></tr><tr><td><code>Cookie</code></td><td>携带的COOKIE信息, 普通情况下，当一个用户登录成功，就会在本地保存一份<code>cookie</code>,下次请求就会直接带上这个<code>cookie</code>信息，也就是这个用户的相关信息</td><td></td></tr><tr><td><code>Referer</code></td><td>当前文档的<code>URL</code> 也就是纪录下从哪个<code>链接地址</code>提交到<code>服务器</code>的</td><td></td></tr><tr><td><code>Content-Type</code></td><td>向<code>服务器</code>提交内容的格式<br>例如：<code>Content-Type：application/x-www-form-urlencoded</code><br>总而言之,就是告诉<code>服务器</code>,<code>客户端</code>传递的内容属于什么格式 或 其他编码格式!</td><td></td></tr><tr><td><code>Content-Length</code></td><td>数据长度, 也就是<code>客户端</code>向<code>服务器端</code>提交内容的数据长度有多少字节!</td><td></td></tr><tr><td><code>Cache-Control</code></td><td>缓存机制，例如：<code>Cache-Control:no-cache</code></td><td></td></tr><tr><td><code>pragma</code></td><td>防止页面被缓存，与<code>Cache-Control:no-cache</code>作用一样</td><td></td></tr><tr><td>……………………………………….</td><td></td><td></td></tr></tbody></table><p>2.我们可以用Fiddler截取一个请求头看看，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/M9ezPEO3BHycWo5.png" alt></p><h5 id="7-4空行"><a href="#7-4空行" class="headerlink" title="7.4空行"></a>7.4空行</h5><p>空白行：也就是在消息头结束的下方，会存在一个空白行, 这是必须存在的, 是由HTTP标准规定的!</p><h5 id="7-5请求体"><a href="#7-5请求体" class="headerlink" title="7.5请求体"></a>7.5请求体</h5><p>请求体它的出现是要根据请求的方式不同而不同, 也就是如果是POST那么就会以键与值的形式进行发送, 如果是GET请求那么这里就不会包含请求正文内容。</p><p>从7.3宏哥抓包可以看出这里是一个json数据：</p><pre><code>{&quot;email&quot;:&quot;xxxxxxx@qq.com&quot;,&quot;password&quot;:&quot;xxxxxxx&quot;,&quot;remember&quot;:&quot;0&quot;,&quot;code&quot;:&quot;&quot;,&quot;mobile&quot;:&quot;&quot;,&quot;type&quot;:&quot;login&quot;,&quot;reqtimestamp&quot;:1647506402551}</code></pre><h4 id="8-http响应-Response-报文结构图解"><a href="#8-http响应-Response-报文结构图解" class="headerlink" title="8.http响应(Response)报文结构图解"></a>8.http响应(Response)报文结构图解</h4><p>同样我们先来看一张http响应(response)图解，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/Qt2IVyjv6GZ3Tg1.jpg" alt></p><p><strong>然后宏哥来逐一解剖上图中的各个部分，解剖结果如下：</strong></p><h5 id="8-1响应行"><a href="#8-1响应行" class="headerlink" title="8.1响应行"></a>8.1响应行</h5><p>响应行也叫状态行， 上图中响应行内部其实包含了3个重要的信息部分:</p><p>HTTP协议的版本、HTTP状态码、HTTP的状态描述</p><p>1.HTTP协议的版本现目前都是HTTP/1.1 版本 这个没什么好说的!</p><p>2.HTTP状态码 可以用来表示网页服务器端给客户端返回的HTTP响应状态, 通常都是3位数字的代码, 而这些常见的状态码又可以分为几种提示类型: 🙂 如下表所示：</p><table><thead><tr><th>类别状态码</th><th>描述</th></tr></thead><tbody><tr><td><code>1xx</code></td><td>这种类别的<code>状态码</code> 为<code>提示消息类型</code> 通常表示<code>请求被服务器端成功接收</code></td></tr><tr><td><code>2xx</code></td><td>这种类别的<code>状态码</code> 为<code>成功消息类型</code>通常表示<code>请求被服务器端成功处理</code></td></tr><tr><td><code>3xx</code></td><td>这种类别的<code>状态码</code> 为<code>重定向类型</code>通常表示<code>被服务器端重新定义了请求方向,需要进一步的操作以完成请求</code></td></tr><tr><td><code>4xx</code></td><td>这种类别的<code>状态码</code> 为<code>客户端错误信息</code>通常表示<code>服务器告诉客户端的一些错误消息</code></td></tr><tr><td><code>5xx</code></td><td>这种类别的<code>状态码</code> 为<code>服务端错误信息</code>通常表示<code>告诉客户端 服务器这边出现的一些错误信息</code></td></tr></tbody></table><p>3.HTTP的状态描述是紧跟在状态码后面的英文单词</p><p>每一种具体类别状态码+状态描述可以参考下表:</p><p><code>1xx: 提示消息类型</code></p><table><thead><tr><th>消息:</th><th>状态描述</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td></tr></tbody></table><p><code>2xx: 成功消息类型</code></p><table><thead><tr><th>消息:</th><th>状态描述</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功（其后是对GET和POST请求的应答文档。）</td></tr><tr><td>201</td><td>Created</td><td>请求被创建完成，同时新的资源被创建。</td></tr><tr><td>202</td><td>Accepted</td><td>供处理的请求已被接受，但是处理未完成。</td></tr><tr><td>203</td><td>Non-authoritative Information</td><td>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td></tr><tr><td>204</td><td>No Content</td><td>没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td></tr><tr><td>205</td><td>Reset Content</td><td>没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td></tr><tr><td>206</td><td>Partial Content</td><td>客户发送了一个带有Range头的GET请求，服务器完成了它。</td></tr></tbody></table><p><code>3xx: 重定向类型</code></p><table><thead><tr><th>消息:</th><th>状态描述</th><th>含义</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>所请求的页面已经转移至新的url, 说通俗一点表示请求的资源分配了url，以后就应该使用这个url</td></tr><tr><td>302</td><td>Found</td><td>所请求的页面已经临时转移至新的url, 也就是说请求的资源临时分配了url，本次请求暂且使用这个url， 这里<code>302与301</code>的区别是，302表示临时性重定向，重定向的url还有可能还会改变。</td></tr><tr><td>303</td><td>See Other</td><td>表示请求的资源路径发生改变，请使用<code>GET</code>方法请求url。其实与302一样，但是明确指出让我们使用<code>GET</code>方法请求url</td></tr><tr><td>304</td><td>Not Modified</td><td>未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td></tr><tr><td>305</td><td>Use Proxy</td><td>客户请求的文档应该通过Location头所指明的代理服务器提取。</td></tr><tr><td>306</td><td>Unused</td><td>此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>被请求的页面已经临时移至新的url。</td></tr></tbody></table><p><code>4xx: 客户端错误信息</code></p><table><thead><tr><th>消息:</th><th>状态描述</th><th>含义</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>服务器未能理解请求，通常为表示请求的报文中存在<code>语法错误</code> ，比如: 提交<code>json</code>数据的时候，如果<code>json</code>格式有问题，接收端接收<code>json</code>，也会出现<code>400 bad request</code></td></tr><tr><td>401</td><td>Unauthorized</td><td>被请求的页面需要用户名和密码。</td></tr><tr><td>402</td><td>Payment Required</td><td>此代码尚无法使用。</td></tr><tr><td>403</td><td>Forbidden</td><td>对被请求页面的访问被禁止。</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法找到被请求的页面。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求中指定的方法不被允许, 请求的方式<code>get、post、delete</code>方法与后台规定的方式不符合 例如: 比如： 后台方法规定的请求方式只接受<code>get</code>，如果用<code>post</code>请求，就会出现 <code>405 method not allowed</code>的提示</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器生成的响应无法被客户端所接受。</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超出了服务器的等待时间。</td></tr><tr><td>409</td><td>Conflict</td><td>由于冲突，请求无法被完成。</td></tr><tr><td>410</td><td>Gone</td><td>被请求的页面不可用。</td></tr><tr><td>411</td><td>Length Required</td><td>“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</td></tr><tr><td>412</td><td>Precondition Failed</td><td>请求中的前提条件被服务器评估为失败。</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于所请求的实体的太大，服务器不会接受请求。</td></tr><tr><td>414</td><td>Request-url Too Long</td><td>由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>由于媒介类型不被支持，服务器不会接受请求, 例如: 后台程序不支持提交的<code>content-type</code>类型，就会返回<code>415</code></td></tr><tr><td>416</td><td></td><td>服务器不能满足客户在请求中指定的Range头。</td></tr><tr><td>417</td><td>Expectation Failed</td><td></td></tr></tbody></table><p><code>5xx: 服务器错误信息</code></p><table><thead><tr><th>消息:</th><th>状态描述</th><th>含义</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>请求未完成。服务器遇到不可预知的情况。</td></tr><tr><td>501</td><td>Not Implemented</td><td>请求未完成。服务器不支持所请求的功能。</td></tr><tr><td>502</td><td>Bad Gateway</td><td>请求未完成。服务器从上游服务器收到一个无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>请求未完成。服务器临时过载或当机。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>网关超时。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持请求中指明的HTTP协议版本。</td></tr></tbody></table><h5 id="8-2响应头-Response-Header"><a href="#8-2响应头-Response-Header" class="headerlink" title="8.2响应头 (Response Header)"></a>8.2响应头 (Response Header)</h5><p>1.响应头也叫消息报头 也就是服务器端要告诉客户端的一些附加信息, 但是也有可能这些响应头是由后端开发人员进行自定义的!</p><p>而且这里的响应头跟请消头 很类似, 格式也基本一样, 它的格式为 name:value。具体宏哥这里也列举了一些常见的响应头 如下表所示：</p><table><thead><tr><th>响应头</th><th>含义</th></tr></thead><tbody><tr><td><code>Server</code></td><td>HTTP服务器的软件信息</td></tr><tr><td><code>Date</code></td><td>响应报文的时间, 要注意返回时间的时区</td></tr><tr><td><code>Expiros</code></td><td>服务器指定的一个缓存过期时间</td></tr><tr><td><code>Set-Cookie</code></td><td>设置Cookie, 也就是<code>服务器</code>返回的一段文本给<code>客户端</code>,让<code>客户端</code>保存好,下次请求就把这个<code>cookie</code>文本带上!</td></tr><tr><td><code>Last-Modified</code></td><td>资源最后修改时间 ，也就是客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户，原来缓冲的文档还可以继续使用, 也就是说不用在从服务器中进行返回</td></tr><tr><td><code>Content-Type</code></td><td><code>服务器</code>返回给<code>客户端</code>的响应类型和编码字符集<br>例如：<code>Content-Type:text/html;charset=utf-8</code></td></tr><tr><td><code>Content-Length</code></td><td>内容长度, 也就是<code>服务器</code>返回给<code>客户端</code>返回的内容是多少字节</td></tr><tr><td><code>Connection</code></td><td>例如<code>Keep-Alive</code>，表示保持<code>tcp链接不会关闭</code>，当然它不会永久保持链接，我们在服务器端中是可以设置的</td></tr><tr><td><code>Location</code></td><td>指明<code>服务器</code>给<code>客户端</code>重定向的位置，也就是新的URL地址 如:304的情况</td></tr><tr><td>………………………………..</td><td></td></tr></tbody></table><p>宏哥这里只例举一下常见和常用的，其实还有更多的<code>响应头</code>这里就不一一列举了!有兴趣的自己可以百度一下！</p><p>2.我们可以用Fiddler截取一个响应头看看，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/CKfxtheDIMjumFZ.png" alt></p><h5 id="8-3空白行"><a href="#8-3空白行" class="headerlink" title="8.3空白行"></a>8.3空白行</h5><p>空白行也就是http规范制定的必须存在的一个空行, 空行的目的就是一种格式，也就是要告诉用户接下来的内容就是正文内容了!</p><h5 id="8-4响应体"><a href="#8-4响应体" class="headerlink" title="8.4响应体"></a>8.4响应体</h5><p>响应体也就是实际从服务器返回给客户端的正文内容,也可能是一些字符串， 也可以是任意的格式:</p><p>响应体大多数情况下都是html、json、文本、xml 这些格式!</p><p>从8.2宏哥抓包可以看出这里是一个json数据：</p><pre><code>{&quot;status&quot;:1,&quot;code&quot;:10000,&quot;message&quot;:&quot;\u8bbf\u95ee\u6210\u529f&quot;,&quot;data&quot;:{&quot;url&quot;:&quot;&quot;,&quot;token&quot;:&quot; xxxxxxxx&quot;,&quot;isenterprise&quot;:0,&quot;uid&quot;:&quot; xxxxxxxxx&quot;}}</code></pre><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>1.HTTP 请求和响应具有相似的结构，由以下部分组成︰</p><p>（1）一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。</p><p>（2）一个可选的 HTTP 头集合指明请求或描述消息正文。</p><p>（3）一个空行指示所有关于请求的元数据已经发送完毕。</p><p>（4）一个可选的包含请求相关数据的正文 (比如 HTML 表单内容), 或者响应相关的文档。 正文的大小有起始行的 HTTP 头来指定。</p><p>起始行和 HTTP 消息中的 HTTP 头统称为请求头，而其有效负载被称为消息正文。</p><p><img src="/images/loading.gif" data-original="https://s2.loli.net/2022/07/19/3U6pIOgwt2yNQT7.png" alt></p><p>好了，对于Http和Https相关的的知识点宏哥就说这么多了,对于学习fiddler足够了！</p><p>接下来你就可以愉快的学习Fiddler了🤗</p>]]></content>
      
      
      <categories>
          
          <category> Fiddler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python相关知识-04</title>
      <link href="/2016/06/08/python/"/>
      <url>/2016/06/08/python/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python学习 -女神或者男神把微信消息撤回后好慌，有了这个妈妈再也不担心你看不到女神或者男神撤回的消息了（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>有时候在忙工作，女朋友发了一个消息，就撤回了，但是人天生的都有一颗好奇心，而且在当今这个时代找个女朋友不容易，一个程序猿找一个女朋友更是不容易的。人家好不容易跟你，你还不得把人家当老佛爷侍候着，侍候着也不行，还得小心翼翼地侍候着，但是声明：宏哥可能过分宠她，但绝对不是妻管严哈！因此当她撤回消息后，慌得一逼，是不是不高兴了？是不是生气了？还是发生什么事了？是不是生病了？还是我哪里惹到她了？俗话说：不干亏心事，不怕鬼叫门，虽然自己确实没有干亏心事，但是心里仍然打着小鼓，脑海里一遍一遍的过滤着，我好像没有惹到她呀！到底是怎么了呢？更严重的话，可能有时候自己会胡思乱想，因为这个可能会影响正常工作，当然了，宏哥目前还没出现这种情况哈！偶尔有时候我会问一次，女朋友告诉我撤回啥了，但是有时候人家撤回好几条，我要一一追问；人家就会说：烦你，烦死了，一些之类的话。吓得宏哥以后都不敢问了，所以为了不问，就有了这篇文章。</p><p>当我们与朋友，亲人，爱人聊天的时候，我估计每个人都经理过，那就是微信撤回功能中所提到的，对方撤回一条消息。</p><p>俗话说，说出口的话，如泼出去的水，是收不回的。但今天可以了，在微信和QQ上，你可以撤回你刚刚说的话。当你的手机发出“嘀”的提示音，表示你收到了一条消息。忙打开，迫不及待地看看，是谁又在与自己说话。还没来得及看，或还没有看完，那句话却忽然没了，屏幕上显示“对方撤回了一条消息”。这个时候，我们都会有所感受</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/JPVnfILe5adgCA6.png" alt="1232840-20190710130126354-1972084673.png"></p><p>每天，我们的手机都会收到大量的信息，包括别人与你说的话，其中的绝大多数，都属于可有可无的话，即垃圾信息。你也许为此不胜其烦，但有一条消息，一定能够引起你的关注，那就是“对方撤回了一条消息”。</p><p>一条撤回的消息，就像一个秘密，让你迫切地想去一探究竟；或如一个诱饵，瞬间勾起你强烈的兴趣。你想知道，那是怎样的一句话？是对方不慎讲出的真话，还是一句发错了对象的话？</p><p>总之，这个撤回的消息，让人顿生×××。这个时候，就是技术人员出马的时候了，哪门子技术人员？如：Python程序员！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/KUqmZr2aT5o79sJ.png" alt="1232840-20190710130354979-1124712765.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/e8xvE69uaGLtizo.jpg" alt="1474961669_736163.jpg"></p><p>看了上边这种那个图片想必大家都不是很陌生吧。<br>你是不是遇到过这样的情况，一个微信群，某个臭小子或者女神、男神发了条消息，等到自己有时间去看的时候却被撤回了……总感觉自己突然成为了唯一的吃瓜群众……<br>又或者你的女神、男神发了个消息，结果没来急看就这样了……<br>比如……下面这个</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/7c9gbpNfY6QBshP.jpg" alt="1474961717_675662.jpg"></p><p>内心独白：好想知道对面跟我说了什么了?<br>内心独白：我要不要直接打电话过去?<br>内心独白：还是直接问问刚才你发的什么（屁话，人家想让你知道还撤回啊？）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/WCInaiSKMkmTtRL.jpg" alt="1474961788_981255.jpg"></p><p>想要知道那条消息是啥，想的心里痒痒？今天宏哥就给大家透露一个方法，嘿嘿嘿，接着看吧：<br>哈哈哈！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/fC6qKHZxrE9wp7I.jpg" alt="1474961810_319769.jpg"></p><h4 id="2-普通人"><a href="#2-普通人" class="headerlink" title="2.普通人"></a>2.普通人</h4><p>此方法只针对iPhone用户，且只能查看文字消息（Android 用户可以试一下，成不成功吗，这里还是个问号，因为宏哥没有实践，没有实践，就没有发言权）。</p><p>此方法对图片、视频神马的没办法的呦！具体操作：</p><p>1.首先,进入iPhone的设置页面，设置通知栏。</p><p>2.在微信的设置页面，允许微信通知，并且其中的所有选项都修改为允许。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/i6ve7qslSbawH19.jpg" alt="1474961831_587389.jpg"></p><p>3.这么设置以后有啥效果呢？嘿嘿嘿，小伙伴们想想看，你那丰富的通知栏……懂了吧，啥消息都会给你留在那儿了。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/sYSzEQKJa26MfbR.jpg" alt="1474961924_810360.jpg"></p><p>PS：如果你按照宏哥的说法做了，但是仍然没有看到消息，可能是微信APP内的设置选项没有打开，可以打开微信设置——新消息通知——打开通知显示消息详情，然后再试试罗！<br>小伙伴们拿走不谢！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/DfHobGFr7gL12vz.jpg" alt="1474961945_543613.jpg"></p><p>最后有些人说这么简单，哪里用你教，拜托宏哥也是搜集的一些小技巧，没有提醒，咋么想到这个方法呢？</p><p> 以上方法撑死了只能看到文字信息，图片语音等等就看不到了，下边宏哥介绍代码实现得方法：</p><p>ps:安卓手机我试过了很好使的，有兴趣的iPhone手机用户也可以试一下哈！！！</p><h4 id="3-python技术人员"><a href="#3-python技术人员" class="headerlink" title="3.python技术人员"></a>3.python技术人员</h4><h5 id="1、准备环境"><a href="#1、准备环境" class="headerlink" title="1、准备环境"></a>1、准备环境</h5><p>python语言环境</p><p>python解释器-pycharm</p><h5 id="2、itchat介绍"><a href="#2、itchat介绍" class="headerlink" title="2、itchat介绍"></a>2、itchat介绍</h5><p>itchat是一个开源的微信个人号接口，通过itchat可以实现微信（好友或微信群）的信息处理，包括文本、图片、小视频、地理位置消息、名片消息、语音消息、动画表情、普通链接、音乐链接、群消息、红包消息、系统消息等，可以对微信的消息进行获取和回复。</p><h5 id="3、itchat使用"><a href="#3、itchat使用" class="headerlink" title="3、itchat使用"></a>3、itchat使用</h5><blockquote><p>itchat库的安装</p></blockquote><pre><code>pip install itchat</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/pu3m9DgFSPzq7dB.png" alt="1232840-20190710104949085-164366023.png"></p><blockquote><p>API</p></blockquote><p><a href="https://itchat.readthedocs.io/zh/latest/api/" target="_blank" rel="noopener">查看地址</a></p><h5 id="4、pycharm解释器写入代码"><a href="#4、pycharm解释器写入代码" class="headerlink" title="4、pycharm解释器写入代码"></a>4、pycharm解释器写入代码</h5><pre><code>#!/usr/bin/env python3# -*- coding: utf-8 -*-# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-7-10@author: 北京-宏哥   QQ交流群：707699217Project:学习和使用python&#39;&#39;&#39;# 3.导入模块import itchatfrom itchat.content import *import timeimport reimport osmsg_information = {}# 针对表情包的内容face_bug = None@itchat.msg_register([TEXT, PICTURE, FRIENDS, CARD, MAP, SHARING, RECORDING, ATTACHMENT, VIDEO], isFriendChat=True, isMpChat=True)def handle_receive_msg(msg):    global face_bug    # 接收消息的时间    msg_time_rec = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())    # 在好友列表列表中查询发送信息的好友昵称    msg_from = itchat.search_friends(userName=msg[&#39;FromUserName&#39;])[&#39;NickName&#39;]    # 信息发送的时间    msg_time = msg[&#39;CreateTime&#39;]    # 每条信息的ID    msg_id = msg[&#39;MsgId&#39;]    # 储存信息的内容    msg_content = None    # 储存分享的连接，比如分享的文章和音乐    msg_share_url = None    # 如果发送的消息是文本或者好友推荐    if msg[&#39;Type&#39;] == &#39;Text&#39; or msg[&#39;Type&#39;] == &#39;Friends&#39;:        msg_content = msg[&#39;Text&#39;]        print(msg_content)    # 如果发送的消息是附件，视频，图片，语音    elif msg[&#39;Type&#39;] == &#39;Attachment&#39; or msg[&#39;Type&#39;] == &#39;Video&#39; \        or msg[&#39;Type&#39;] == &#39;Picture&#39;\            or msg[&#39;Type&#39;] == &#39;Recording&#39;:        # 内容为下载文件名        msg_content = msg[&#39;FileName&#39;]        msg[&#39;Text&#39;](str(msg_content))    # 如果消息是推荐的名片    elif msg[&#39;Type&#39;] == &#39;Card&#39;:        # 内容是推荐人的昵称和性别        msg_content = msg[&#39;RecommendInfo&#39;][&#39;NickName&#39;] + &#39;的名片&#39;        if msg[&#39;RecommendInfo&#39;][&#39;Sex&#39;] == 1:            msg_content += &#39;性别为男&#39;        else:            msg_content += &#39;性别为女&#39;        print(msg_content)    # 如果消息为分享的位置信息    elif msg[&#39;Type&#39;] == &#39;Map&#39;:        x, y, location = re.search(            &quot;&lt;location x=\&quot;(.*?)\&quot; y=\&quot;(.*?)\&quot;.*label=\&quot;(.*?)\&quot;.*&quot;, msg[&#39;OriContent&#39;]).group(1, 2, 3)        if location is None:            # 内容为详细地址            msg_content = r&#39;纬度-&gt;&#39; + x.__str__() + &quot;经度-&gt;&quot; + y.__str__()        else:            msg_content = r&quot;&quot; + location    # 如果消息是分享的音乐或者文章，详细的内容为文章的标题或者分享的名字    elif msg[&#39;Type&#39;] == &#39;Sharing&#39;:        msg_content = msg[&#39;Text&#39;]        msg_share_url = msg[&#39;Url&#39;]        print(msg_share_url)    face_bug = msg_content    # 将信息存储在字典中，每一个msg_id对应一条消息    msg_information.update(        {            msg_id: {                &quot;msg_from&quot;: msg_from, &quot;msg_time&quot;: msg_time, &quot;msg_time_rec&quot;: msg_time_rec,                &quot;msg_type&quot;: msg[&#39;Type&#39;],                &quot;msg_content&quot;: msg_content, &quot;msg_share_url&quot;: msg_share_url            }        })#这个是用于监听是否有friend消息撤回@itchat.msg_register(NOTE, isFriendChat=True, isGroupChat=True, isMpChat=True)def information(msg):    # 这里如果这里的msg[&#39;Content&#39;]中包含消息撤回和id，就执行下面的语句    if &#39;撤回了一条消息&#39; in msg[&#39;Content&#39;]:        old_msg_id = re.search(&quot;\&lt;msgid\&gt;(.*?)\&lt;\/msgid\&gt;&quot;, msg[&#39;Content&#39;]).group(1)        # 得到消息        old_msg = msg_information.get(old_msg_id)        print(old_msg)        # 如果发送的是表情        if len(old_msg_id)&lt;11:            itchat.send_file(face_bug, toUserName=&#39;filehelper&#39;)        # 发送撤回的提示给文件助手        else:            msg_body = &quot;【&quot;\                       + old_msg.get(&#39;msg_from&#39;) + &quot;撤回了】\n&quot;\                       + old_msg.get(&quot;msg_type&quot;) + &quot;消息:&quot; + &quot;\n&quot;\                       + old_msg.get(&quot;msg_time_rec&quot;) + &quot;\n&quot;\                       + r&quot;&quot; + old_msg.get(&quot;msg_content&quot;)        # 如果分享的文件被撤回了，那么就将分享的url加在msg_body中发送给文件助手        if old_msg[&#39;msg_type&#39;] == &quot;Sharing&quot;:            msg_body += &quot;\n就是这个链接&gt;&quot; + old_msg.get(&#39;msg_share_url&#39;)        # 将撤回消息发送到文件助手        itchat.send_msg(msg_body, toUserName=&quot;filehelper&quot;)        # 有文件的话也要将文件发送回去        if old_msg[&quot;msg_type&quot;] == &quot;Picture&quot;\                or old_msg[&quot;msg_type&quot;] == &quot;Recording&quot;\                or old_msg[&quot;msg_type&quot;] == &quot;Video&quot;\                or old_msg[&quot;msg_type&quot;] == &quot;Attachment&quot;:            file = &quot;@fil@%s&quot; % (old_msg[&#39;msg_content&#39;])            itchat.send(msg=file, toUserName=&#39;filehelper&#39;)            os.remove(old_msg[&#39;msg_content&#39;])        # 删除字典旧信息        msg_information.pop(old_msg_id)itchat.auto_login(hotReload=True)itchat.run()</code></pre><p>运行之后需要扫描二维码登录，登录后微信手机助手就能监测到对方撤回的消息</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/9ogHFQ2u8WndxyB.png" alt="786645-20190430144939424-363898350.png"></p><p>扫码登录日志撤回测试：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/YiLq2IeQHscfKtp.png" alt="1232840-20190710115019243-1843266056.png"></p><p>文件传输助手接收到的撤回信息：（你可以在这里查看女神或者男神撤回的信息）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/GUOjASQmvPFw45E.png" alt="1232840-20190710115448892-334454506.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/3PfspFzE7Q2xOIZ.png" alt="1232840-20190710130430968-976090296.png"></p><p>下面介绍.py文件如何生成.exe文件，方便做成exe发送给其他人使用</p><p>pycharm编辑器Terminal窗口使用</p><pre><code>pyinstaller -F .py文件所在绝对路径</code></pre><p>成功之后会在python安装路径下的dist文件看到生成的exe文件</p><p>PS：python3.6版本下的才能转换成功</p><p>欢迎留言讨论你的男神和女神对于你撤回消息的反应哈！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python相关知识-03</title>
      <link href="/2016/06/07/python/"/>
      <url>/2016/06/07/python/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 安装需要的第三方库时，命令行输入pip提示不是内部或外部命令</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>在做Python开发时，安装需要的第三方库时，大多数人喜欢选择在命令行用pip进行安装。</p><p>然而有时敲入pip命令会提示‘pip’不是内部或外部命令。。如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/SLlHMdvDCr7Axm9.png" alt="1232840-20190111103734604-1038184035.png"></p><h4 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h4><p>1、在python安装目录中找得到script文件夹，查看文件夹内部是否存在pip3.exe这个文件。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/1ywdlmc2ehFKJPv.png" alt="1232840-20190111104202531-1755210513.png"></p><p>2、如果没有，在命令行输入：python -m ensurepip 将pip.exe文件下载下来</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/mEZ2BnbDfzpkJr6.png" alt="1232840-20190111104339720-994539650.png"></p><p>3、在python安装目录中找得到script文件夹，查看文件夹内部，可以看到存在pip3.exe这个文件了。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/m1Nx5jDrJ4nhPwK.png" alt="1232840-20190111104308507-1203287731.png"></p><p>4、验证pip是否安装成功，出现如图界面，就是成功的安装了pip。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/fqXDgktuy7C9Apw.png" alt="1232840-20190111110446180-1159387478.png"></p><h4 id="3-附录"><a href="#3-附录" class="headerlink" title="3.附录"></a>3.附录</h4><p>如果script文件夹内存在pip.exe，那么就是cmd的环境路径有问题</p><p>在命令行输入path c:\windows\system32\</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/yioPqXTZCUFIlxh.png" alt="1232840-20190111110816837-1166434226.png"></p><p>或者在环境变量中添加%SystemRoot%System32</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/vPuSLDV95IlB63O.png" alt="1232840-20190111110756814-467727971.png"></p><p>有些python库是windows环境下无法支持使用的，为了不影响学习和使用，在此添加一个whl包的下载方法</p><p>Python open-source extension packages </p><p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy</a></p><p>这个网站里面有很多.whl格式的packages，是一个非常好的资源站。 </p><p>以一个实例演示whl文件的安装</p><p>1.首先在网站下载需要的库包</p><p>2.win+R打开终端</p><p>3.在终端执行 pip install D:\curses-2.2+utf8-cp37-cp37m-win_amd64.whl(我下载安装的是curses)</p><p>此外，安装的话<br>同时，在windows下确实很多package不好装。可以下载python包到本地，命令行进入文件夹（有setup.py路径下），输入：</p><pre><code> $ python setup.py install</code></pre><p>则可以将第三方库安装到python中。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python相关知识-02</title>
      <link href="/2016/06/06/python/"/>
      <url>/2016/06/06/python/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 api-ms-win-crt-process-l1-1-0.dll 丢失的处理，遇到问题和完美解决</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>在换了新电脑后，一些环境需要重新搭建，本以为是个小case，没想到竟然遇到了各种拦路虎。</p><p>在成功安装Python3.7后，需要检验是否成功安装，在命令行输入python后，回车；发现提示api-ms-win-crt-process-l1-1-0.dll丢失，网上搜索后发现很多人都出现了 api-ms-win-crt**.dll缺失的问题，导致一些软件或游戏无法正常运行。总结如下：</p><p>Windows 通用 C 运行库（Universal C Runtime）是通过Windows Update更新安装到系统的，更新的编号为KB2999226（10.0.10240.16390）或KB3118401（10.0.10586.9），组件如下：</p><p>　　api-ms-win-core-file-l1-2-0.dll</p><p>　　api-ms-win-core-file-l2-1-0.dll</p><p>　　api-ms-win-core-localization-l1-2-0.dll</p><p>　　api-ms-win-core-processthreads-l1-1-1.dll</p><p>　　api-ms-win-core-synch-l1-2-0.dll</p><p>　　api-ms-win-core-timezone-l1-1-0.dll</p><p>　　api-ms-win-core-xstate-l2-1-0.dll</p><p>　　api-ms-win-crt-conio-l1-1-0.dll</p><p>　　api-ms-win-crt-convert-l1-1-0.dll</p><p>　　api-ms-win-crt-environment-l1-1-0.dll</p><p>　　api-ms-win-crt-filesystem-l1-1-0.dll</p><p>　　api-ms-win-crt-heap-l1-1-0.dll</p><p>　　api-ms-win-crt-locale-l1-1-0.dll</p><p>　　api-ms-win-crt-math-l1-1-0.dll</p><p>　　api-ms-win-crt-multibyte-l1-1-0.dll</p><p>　　api-ms-win-crt-private-l1-1-0.dll</p><p>　　api-ms-win-crt-process-l1-1-0.dll</p><p>　　api-ms-win-crt-runtime-l1-1-0.dll</p><p>　　api-ms-win-crt-stdio-l1-1-0.dll</p><p>　　api-ms-win-crt-string-l1-1-0.dll</p><p>　　api-ms-win-crt-time-l1-1-0.dll</p><p>　　api-ms-win-crt-utility-l1-1-0.dll</p><p>　　api-ms-win-eventing-provider-l1-1-0.dll（KB3118401不含此文件）</p><p>　　ucrtbase.dll</p><p>在C:\window\system\   或者C:\window\SysWOW64\ 里找不到相应的.dll文件。网上有一些 单个.dll文件的下载，但是尝试后均无效。正确的做法是micorsoft 官网下载相应更新，再安装。重启后OK：</p><p>micorsoft 官网也告诉我们两个解决方法如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/Q2HTcxPulepqfU5.png" alt="1232840-20190110090158227-376225806.png"></p><h4 id="2-方法一："><a href="#2-方法一：" class="headerlink" title="2.方法一："></a>2.方法一：</h4><p>1、点击左下角的Windows图标，点击控制面板</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/NAb7O9uFxE5qJRp.png" alt="1232840-20190110090358016-1555634697.png"></p><p>2、点击“系统和安全”，点击“Windows Update”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/hLvR9OeMANuywEd.png" alt="1232840-20190110090741616-332028880.png"></p><p>3、点击“检查更新”，下载安装包，安装即可。（这个我这边亲自实验一边，问题没有解决），有兴趣的自己可以试一下。</p><h4 id="3-方法二："><a href="#3-方法二：" class="headerlink" title="3.方法二："></a>3.方法二：</h4><p>下载更新的独立程序（缺少哪个就安装那个），运行如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/ihuAdCQLywTIvN8.png" alt="1232840-20190110084818397-1276668829.png"></p><p>api-ms-win-crt-process-l1-1-0.dll 丢失是因为缺少下边两个安装包</p><p>KB2999226、KB3118401更新下载：</p><p>KB2999226 微软下载链接 <a href="https://support.microsoft.com/en-us/help/2999226/update-for-universal-c-runtime-in-windows" target="_blank" rel="noopener">https://support.microsoft.com/en-us/help/2999226/update-for-universal-c-runtime-in-windows</a></p><p>KB3118401 微软下载链接 <a href="https://support.microsoft.com/en-us/help/3118401/update-for-universal-c-runtime-in-windows" target="_blank" rel="noopener">https://support.microsoft.com/en-us/help/3118401/update-for-universal-c-runtime-in-windows</a></p><p> 本人亲测第一个下载安装后，问题就解决了，所以第二个没有安装。</p><p>注意：下载的时候下载对应操作系统和64、32的安装包。笔者第一次下载32位的，运行时报错，当时没找到原因，第二天才发现下载的是32位的安装包</p><p>然后下载64位，运行成功，安装成功，问题解决。</p><h4 id="4-安装包"><a href="#4-安装包" class="headerlink" title="4.安装包"></a>4.安装包</h4><p>说是下载失效了特意找了几个，没有试过，自己下载试一下。附上网盘链接: <a href="https://pan.baidu.com/s/13lV8hDX4b5TiOL8og7dHSg" target="_blank" rel="noopener">https://pan.baidu.com/s/13lV8hDX4b5TiOL8og7dHSg</a> 提取码: 8sks</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python相关知识-01</title>
      <link href="/2016/06/05/python/"/>
      <url>/2016/06/05/python/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Python冒号的解释</strong></p><h4 id="1-Python冒号的解释"><a href="#1-Python冒号的解释" class="headerlink" title="1.Python冒号的解释"></a>1.Python冒号的解释</h4><ol><li>“没什么首次没有为第二个，跳了三个”。它得到的切片序列的每一个第三个项目。 扩展片是你想要的。新在Python 2.3 </li><li>Python的序列切片地址可以写成[开始：结束：一步]和任何启动，停止或结束可以被丢弃。a[::3]是每第三个序列。 </li><li>seq[::n]是每一个序列n个项的整个序列中。 例如：</li></ol><pre><code>&gt;&gt;&gt; range(10)[::2][0, 2, 4, 6, 8]</code></pre><p>语法是：</p><p>seq[start:end:step]<br>所以，你可以这样做：</p><pre><code>&gt;&gt;&gt; range(100)[5:18:2][5, 7, 9, 11, 13, 15, 17]</code></pre><ol start="4"><li>解释s[i:j:k]是，根据该“片第从i到j与第k步”。何时i和j缺席，整个序列是和s[::k]意思是“每k个项目”。 示例 首先，让我们来初始化一个列表：</li></ol><pre><code>&gt;&gt;&gt; s = range(20)&gt;&gt;&gt; s[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</code></pre><p>让我们从每一个第3项s：</p><pre><code>&gt;&gt;&gt; s[::3][0, 3, 6, 9, 12, 15, 18]</code></pre><p>让我们从每一个第3项s[2:]：</p><pre><code>&gt;&gt;&gt; s[2:][2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&gt;&gt;&gt; s[2::3][2, 5, 8, 11, 14, 17]</code></pre><p>让我们从每一个第3项s[5:12]：</p><pre><code>&gt;&gt;&gt; s[5:12][5, 6, 7, 8, 9, 10, 11]&gt;&gt;&gt; s[5:12:3][5, 8, 11]</code></pre><p>让我们从每一个第3项s[:10]：</p><pre><code>&gt;&gt;&gt; s[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; s[:10:3][0, 3, 6, 9]</code></pre><ol start="5"><li>当在Python切片第三是一步。至于看片扩展为一个很好的概述。 有了这些知识 CodeGo.net，[::3]您还没有指定任何开始或结束指数的切片。既然你已经指定了一步，3，这将需要的每第三个条目something开始优先个索引。例如：</li></ol><pre><code>&gt;&gt;&gt; &#39;123123123&#39;[::3]&#39;111&#39;</code></pre><ol start="6"><li><p>第三是优先步。因此，[:: 3]将返回列表/字符串的每个第3位。 </p></li><li><p>该::分开结束，开始，步长值。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你安装Eclipse最新版本的详细教程</title>
      <link href="/2016/06/04/eclipse/"/>
      <url>/2016/06/04/eclipse/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 手把手教你安装Eclipse最新版本的详细教程 （非常详细，非常实用）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>首先声明此篇文章主要是针对测试菜鸟或者刚刚入门的小伙们或者童鞋们，大佬就没有必要往下看了。</p><p>写这篇文章的由来是因为后边要用这个工具，但是由于某些原因有部分小伙伴和童鞋们可能不会安装此工具，为了方便小伙伴们和童鞋们的后续学习和不打击他们的积极性，因为80%的人都是死在工具的安装这第一道门槛上，这门槛说高也不高说低也不是太低。所以宏哥就抽时间水了这一篇文章。</p><h4 id="2-第一步：下载eclipse，并安装。"><a href="#2-第一步：下载eclipse，并安装。" class="headerlink" title="2.第一步：下载eclipse，并安装。"></a>2.第一步：下载eclipse，并安装。</h4><p>1、首先打开官方地址（见下面）</p><p>Eclipse官方下载地址：点击打开官方链接</p><p>下载链接：<a href="http://www.eclipse.org/downloads/" target="_blank" rel="noopener">http://www.eclipse.org/downloads/</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/VFh7zjDdGMKkyH4.png" alt="1232840-20191014111219368-1569509436.png"></p><p>2、点击 Download Packages;</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/p72WXNatJOhwHMz.png" alt="1232840-20191014113422987-250379218.png"></p><p>3、下载安装包<br>如图：根据自己的系统选择64位的，点击相应链接下载（可能会弹出一个需要你付费的页面，并不是eclipse需要付费，这只是请求你捐钱的，无需理会）</p><p>下载完成后，解压安装包，解压路径随意。</p><p>打开之后，选中图中的文件，在桌面创建快捷方式，安装告一段落，可以尝试双击打开运行一下，应该会有bug。(这是因为没有安装JDK)</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/n5LhuMmab2ceCT1.png" alt="1232840-20191014113539558-1601346403.png"></p><h4 id="3-第二步：下载JDK。"><a href="#3-第二步：下载JDK。" class="headerlink" title="3.第二步：下载JDK。"></a>3.第二步：下载JDK。</h4><p>1、下载JDK安装包<br>先给上下载链接：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/D7rmwZYGbicOgW8.png" alt="1232840-20191014115457232-1232844090.png"></p><p>2、点击java之后，在第一个框中，点选Accept License Agreement</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/bR6kiPIGAZHh2YU.png" alt="1232840-20191014115705700-845721958.png"></p><p>3、下载完成后，打开一路确定安装即可。</p><h4 id="4-第三步：java环境变量配置。"><a href="#4-第三步：java环境变量配置。" class="headerlink" title="4.第三步：java环境变量配置。"></a>4.第三步：java环境变量配置。</h4><p>1、我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量设置</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/slq3tvrzni5xJko.png" alt="1232840-20191014132921799-1220247949.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/XsJhAoHCIfR8gBe.png" alt="1322366-20190509103700175-611435434.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/8FQHZv3nAVPoYWa.png" alt="1322366-20190509103708400-407578846.png"></p><p>2、变量配置<br>要让系统变量中（第二个框是系统变量）有path和classpath这两个变量，方法是：</p><p>点击新建，变量名：path，变量值：刚刚JDK的安装路径，例如我的：C:\Program Files\Java\jdk1.8.0_121\bin。</p><p>同样新建，变量名：classpath，变量值:C:\Program Files\Java\jdk1.8.0_121\jre\lib\rt.jar</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/ezt9yafiUPHGTcO.png" alt="1322366-20190509103639640-1801091649.png"></p><p>到这里，就已经配置完成了，接下来可以打开DOS命令（开始菜单右键，运行：CMD）输入javac，显示如下图一样就可以了。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/s3m8pCf6awV9BKD.png" alt="1232840-20191014133147629-1250026089.png"></p><p>3、第二种配置方法：</p><p>“变量名”：JAVA_HOME</p><p>“变量值”：C:\Program Files\Java\jdk1.7.0_07//你安装的jdk的磁盘路径</p><p>“变量名”：Path</p><p>“变量值”：%Java_Home%\bin;%Java_Home%\jre\bin;</p><p>“变量名”：ClassPath</p><p>“变量值”：.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar</p><p>注：上面的代码最好也是一个字符不变的贴上去，“变量值”最前面的 .; 不要漏掉。</p><p>做完上面的三个步骤之后，环境变量的配置已经完成了。</p><p>检查环境变量搭好了：调出“cmd”检查</p><p>1、输入：“java”，你应该看到下面的东西：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/6iIlY5mvdFqCJHK.png" alt="1322366-20190509103621678-260783540.png"></p><p>2、输入“javac”，你应该看到下面的东西：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/s3m8pCf6awV9BKD.png" alt="1232840-20191014133147629-1250026089.png"></p><p>3、输入“java -version”，你应该看到下面的东西：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/13/yJqOVscAe1haERr.png" alt="1232840-20191014133330429-452343785.png"></p><p>安装和配置完环境变量，再次双击桌面上的Eclipse图标，Eclipse启动成功。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><pre><code>    好了，菜鸟们到此Eclipse的安装就已经全部结束和完成。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Eclipse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Firefox相关知识-01</title>
      <link href="/2016/06/03/firefox/"/>
      <url>/2016/06/03/firefox/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 火狐浏览器所有版本</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>最近在群里看到好多人需要火狐浏览器的低版本，而且都是跪求，更有甚者是高额悬赏，因此给大家一个链接，免费的，免费的，免费的！！！重要的事说三遍，拿走不谢~~</p><h4 id="2-下载地址"><a href="#2-下载地址" class="headerlink" title="2.下载地址"></a>2.下载地址</h4><p>火狐所有版本，了解一下，有需要的自行下载。</p><p><a href="http://ftp.mozilla.org/pub/firefox/releases/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/firefox/releases/</a></p>]]></content>
      
      
      <categories>
          
          <category> Firefox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Firefox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome相关知识-04</title>
      <link href="/2016/06/02/chrome/"/>
      <url>/2016/06/02/chrome/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 《废柴》系列 - What？废柴，你不会下载Google浏览器插件，Are you kidding？？？</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>乍眼一看这文章标题我就笑了，相信大家这时候也笑了，哈哈😝😄，而且是笑得肚子疼。别笑，再笑宏哥就没有那个状态了！！！虽然宏哥打算这么简单没必要再写一篇文章说明了，但是在博客园看了很多关于推荐Google浏览器插件的文章，各式各样的，简直是琳良满目，泛滥成灾。写这篇文章的起因是：我有一次碰到有人问我Google的插件如何下载，我当时就呵呵了。还好那天心情不错，自己也不太忙。于是就给他耐心地解答了。是的，对于国外或者国内可以翻墙可以 Google 的人来说，下载安装谷歌插件当然很简单，直接进入 Chrome网上应用商店 ，找到自己想要安装的插件，点击安装就行了。但是对于国内不会翻墙，或者翻墙没翻过去不可以Google的人来说，下载插件就是件会让人头疼的事。即使你推荐的插件再好，他也只能是看看或者是望而却步。推荐插件是：授人以鱼，而宏哥教你下载插件是：授人以渔，授人以鱼不如授人以渔。后来还有很多人问到类似问题。所以想到这里宏哥决定还是写一下关于下载下载的文章。</p><p>首先说明这里主要针对的是不能Google的童鞋或者小伙伴，如果能Google，你可以略过，或者有兴趣的也可以继续往下看看，说不定会有意外的收获了。说不定宏哥的方法会比你的好一点点了。</p><h4 id="2-能Google"><a href="#2-能Google" class="headerlink" title="2.能Google"></a>2.能Google</h4><p>　　能Google的来说下载安装谷歌插件很简单，直接进入Chrome网上应用商店，找到自己想要的安装的或者别人推荐的插件，点击安装就可以了。</p><p>Chrome网上应用商店地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/category/extensions?hl=zh-CN</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/4YawUsjdl5BG3mN.png" alt="1232840-20200323125847354-134724162.png"></p><h4 id="3-不能Google"><a href="#3-不能Google" class="headerlink" title="3.不能Google"></a>3.不能Google</h4><p>这里主要是为不能访问 Chrome应用商店，那可能需要采用其他方法下载插件。宏哥这里暂时提供四种方法，保证让你能够下载到想要的插件。</p><h5 id="3-1中文镜像网站"><a href="#3-1中文镜像网站" class="headerlink" title="3.1中文镜像网站"></a>3.1中文镜像网站</h5><p>　　这种镜像网站好多的，例如我们下载Android的SDK的时候访问不到国外的Google地址的下载SDK网站，我们就需要在网上找一个镜像网站进行下载；在例如：我们在安装Python的某些模块时候访问不到国外的网站地址，也需要找个镜像地址，进行下载安装。</p><p>　　在这里，宏哥首先介绍的也是一个在线的中文镜像网站，这种网站网上挺多，但这个算是中文里做的最好的。界面 UI 也正版的网站神似。下载也没有那么多烦人、恶心的限制，比如必须要关注公众号才能下载等等。</p><p>中文镜像网站地址：<a href="https://www.gugeapps.net" target="_blank" rel="noopener">https://www.gugeapps.net</a> ，打开如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/FMWiROmLSvVbfkY.png" alt="1232840-20200323125940984-1203144533.png"></p><p>选到自己想要的插件，然后点击下载，下载完解压就行，</p><p>这里解压出来是个插件的文件夹，现在文件夹已经有了，如果要使用，还得安装。我前面视频提到了怎样安装插件，并且如果安装失败，怎样解决我也做了演示，不知道的朋友记得去先看那个视频，等会链接我放在视频描述中。</p><p>####3 3.2英文镜像</p><p>　　上边是中文的镜像网站，那么洋鬼子人家在国内也不能访问Google，也看不懂中文，那该怎么办了？？？</p><p>别急啊！现在宏哥就给你推荐一个英文的，相比来说，它的优点更多。它更知名，全世界想离线下载谷歌插件，基本都是来这下，最主要的是它提供了插件的历史版本。像这些插件的历史版本文件，连 Chrome网上商店都下载不到，这里是最好的下载地址。</p><p> 这个网站国内也可以访问和下载。和刚才的区别是，这里下载下来的文件是 .crx 格式文件。这是插件的压缩格式，这是正宗的Chrome插件的文件格式。刚才前面下载下来的是已经被解压缩的文件夹。但是区别不大，没啥影响。</p><p>英文镜像网站地址：<a href="https://www.crx4chrome.com/" target="_blank" rel="noopener">https://www.crx4chrome.com/</a>   打开后如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/jNOYAGeCBFQk5X3.png" alt="1232840-20200323130034202-1120456365.png"> </p><p>基本这以上两个网站就可以解决下载谷歌插件的需求。</p><h5 id="3-3鸡肋网站"><a href="#3-3鸡肋网站" class="headerlink" title="3.3鸡肋网站"></a>3.3鸡肋网站</h5><p>接下来是以防万一，这个网站也是用来下载插件的，但是有点区别，需要提供谷歌官网网站插件的 ID 或者 URL。</p><p>鸡肋网站地址：<a href="https://chrome-extension-downloader.com/" target="_blank" rel="noopener">https://chrome-extension-downloader.com/</a> 打开如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/6gL8aJdpOSknBT2.png" alt="1232840-20200323133708234-667272431.png"></p><p>反正我觉得这网站很鸡肋，我们那个人可以记得那么一长串字母的插件的ID和URL,除非是被人或者同时发给你的，那你可以用这个在这个网站试一下，其他的我觉没什么使用场景、没有什么用武之地。</p><h5 id="3-4绝招"><a href="#3-4绝招" class="headerlink" title="3.4绝招"></a>3.4绝招</h5><p>　最后是最重要的绝招，不到万不得已的时候，千万不能轻易显露，否则可能引来杀身之祸。这句词怎么这么熟悉了，呀！跑题了。回归正题：绝招就是将插件离线打包下来，比如我现在有个插件，我要打包导出来给别人使用。或者是</p><p>如果我们自己电脑上已经通过某种方式添加了扩展程序, 想把它移植到其他没有翻墙或者压根没有网的电脑上去怎么办呢?</p><p>这时候就需要利用chrome浏览器的扩展程序打包功能了。</p><p>1.在谷歌浏览器的URL地址输入：chrome://version/  查看安装插件所在的目录如下图：个人资料路径</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/s6oVS4F2fRdtwZA.png" alt="1232840-20200323130423131-1575791462.png"></p><p>2.找到Extensions文件夹，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/xhbGwyIsFDnBdYc.png" alt="1232840-20200323130549421-989512099.png"></p><p>3.找到Extensions文件夹，点击打开，可以看到一串字母是插件的ID。如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/jCca5Kw4F7Rio8P.png" alt="1232840-20200323130707480-939192332.png"></p><p>4.然后打开扩展程序的开发者模式</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/VaLrNHh3xyltWB7.png" alt="1232840-20200323132511485-327114122.png"></p><p>5.点击打包扩展程序, 把扩展程序的本地路径复制粘贴上去即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/TWyoQpLhJPxbVkR.png" alt="1232840-20200323132840015-753782218.png"></p><p>6.点击点击打包扩展程序后，点击“确定”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/ldqkrYDS5mVvcEO.png" alt="1232840-20200323132907101-302567763.png"></p><p>7.点击确定后, 就会在…..Default\Extensions\插件ID 的文件夹生成我们需要的crx文件了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/sUm7jdGuKIN5HTb.png" alt="1232840-20200323133005876-338940262.png"></p><p>这时候只要将这个文件拖到chrome浏览器上就可以安装了</p><p>这是一个兜底的方案，万一前面的都不行了，知道了这种方法也能成功让别人安装上插件。当然前提是你自己已经安装上这个插件。</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>　　 好了，今天就分享到这里吧，你可以在评论里留下，你觉得比较好的下载Chrome插件的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome相关知识-03</title>
      <link href="/2016/06/01/chrome/"/>
      <url>/2016/06/01/chrome/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 谷歌浏览器的各个版本对应的webdriver（chromedrive）-超级详细</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>近来看到各个测试群里的小伙伴由于安装的谷歌浏览器版本各不相同，有高有低，这可是难住愁坏了一大批人，所以都在要各种版本的谷歌浏览器相对应的chromedrive，为此找了一个淘宝镜像网址供大家下载。</p><h4 id="2-各种版本的谷歌浏览器相对应的chromedrive"><a href="#2-各种版本的谷歌浏览器相对应的chromedrive" class="headerlink" title="2.各种版本的谷歌浏览器相对应的chromedrive"></a>2.各种版本的谷歌浏览器相对应的chromedrive</h4><p>直接到网址下载对应的即可：<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome相关知识-02</title>
      <link href="/2016/05/31/chrome/"/>
      <url>/2016/05/31/chrome/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 谷歌访问助手安装教程网址-超级详细</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>俗话说：“外事问谷歌，内事问百度”，但是对于一个开发人员和测开人员，绝大多数新的技术和解决方案都得翻墙去谷歌查找，这里给大家一个可以简单操作，就可以达到目的浏览器插件。自己按照步骤下载、安装、访问即可。</p><h4 id="2-网址"><a href="#2-网址" class="headerlink" title="2.网址"></a>2.网址</h4><p>　　<a href="http://www.ggfwzs.com/" target="_blank" rel="noopener">http://www.ggfwzs.com/</a></p><h4 id="3-问题及解决方案"><a href="#3-问题及解决方案" class="headerlink" title="3.问题及解决方案"></a>3.问题及解决方案</h4><p>　　正确安装以后，还是不能访问，注意查看一下，防火墙和杀毒软件是不是禁止了，改成允许通过，即可。</p>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome相关知识-01</title>
      <link href="/2016/05/30/chrome/"/>
      <url>/2016/05/30/chrome/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 谷歌浏览器的各种插件网址Chrome插件（谷歌浏览器）-超级详细</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><blockquote><p>各种各样的插件，可以查找对自己有用的，自行下载安装</p></blockquote><p><a href="http://chromecj.com/" target="_blank" rel="noopener">http://chromecj.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm使用教程-06</title>
      <link href="/2016/05/29/pycharm/"/>
      <url>/2016/05/29/pycharm/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 关于pycharm安装出现的interpreter field is empty，无法创建项目存储位置</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><blockquote><p>关于pycharm安装出现的interpreter field is empty（解释器为空）</p></blockquote><p>关于pycharm安装出现的interpreter field is empty，无法创建项目存储的位置。如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/WEINkoes352KXl6.png" alt="1232840-20190109151824690-266242034.png"></p><p>我之前安装的时候一直老是有这个提示，后来才发现是因为没安装这个python的原因，</p><blockquote><p>解决办法：</p></blockquote><p>需要下载安装python解释器</p><p>第一步：打开python官网地址：<a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">https://www.python.org/downloads/windows/</a>   ，选择自己需要的版本，我下载的是最新版本：Latest Python 3 Release - Python 3.6.4</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/kSaiQIvbhYe8LwJ.png" alt="1131060-20171221160703631-1708123626.png"></p><p>第二步：安装python，请参照<a href="https://www.cnblogs.com/du-hong/p/8330595.html" target="_blank" rel="noopener">https://www.cnblogs.com/du-hong/p/8330595.html</a></p><p>第三步：关闭pycharm然后重新启动pycharm，然后就可以正常使用pycharm。</p>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm使用教程-05</title>
      <link href="/2016/05/28/pycharm/"/>
      <url>/2016/05/28/pycharm/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Pycharm使用教程（五）-PyCharm证书过期：Your license has expired（非常详细，非常实用）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><blockquote><p><font color="red"> <strong>pycharm激活码，由于那台服务器不维护了，不好使了，你可以关注宏哥的公众号发送：激活码，Ctrl+A，Ctrl+C，然后Ctrl+V，就可以了。</strong></font></p></blockquote><p>报错“your evaluation license has expired, pycharm will now exit”<br>1、解决步骤，点击‘Activation code’，授权激活pycharm</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/YnxCAJEMlrGuejU.png" alt="1232840-20181109101404127-1732126830.png"></p><p>2、修改C:\Windows\System32\drivers\etc 目录下的hosts文件<br>将hosts文件复制到其他文件夹下，打开hosts文件</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/uFCk4plVfLG6tvn.png" alt="1232840-20181109102929383-676315913.png"></p><p>在文件的末尾添加“0.0.0.0 account.jetbrains.com”，如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/keQJoURbBgvFVlh.png" alt="1232840-20181109103010320-1251507250.png"></p><p>随后将修改后的hosts文件，重新复制到C:\Windows\System32\drivers\etc 目录下，并将原来的hosts文件覆盖</p><p>3、 打开网址：<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/47DlqBmnoCP6jMi.png" alt="1232840-20181109103340565-1130202462.png"></p><p>4、点击获取注册码，并复制</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/V7zBpbMPweTvrsd.png" alt="1232840-20181109103410438-520848837.png"></p><p>5、将注册码复制到Activation code的文本框中，点击ok！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/axodLfDT2yvYMpk.png" alt="1232840-20181109103129073-1949895271.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm使用教程-04</title>
      <link href="/2016/05/27/pycharm/"/>
      <url>/2016/05/27/pycharm/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Pycharm使用教程（四）-安装python依赖包（非常详细，非常实用）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>在做python开发时，需要很多依赖包，如果已经安装pip，安装依赖包，可以通过命令行；没有安装的，也可以通过PyCharm安装。</p><h4 id="2-具体安装步骤"><a href="#2-具体安装步骤" class="headerlink" title="2.具体安装步骤"></a>2.具体安装步骤</h4><p>1、在File-&gt;Setting，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/mvwCrH4895V13st.png" alt="1232840-20190115135230464-561724634.png"></p><p>2、点击Project:untilted-&gt;Project Interpreter，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/8BNfFixCZ5OLnE2.png" alt="1232840-20190115135312815-986220616.png"></p><p>3、点击“+”，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/rSnfcAIB4bwgJ6O.png" alt="1232840-20190115135342587-932041854.png"></p><p>4、在弹出的“Available Packages”的搜索框输入要安装的依赖包，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/f1KBU8HynxMWphQ.png" alt="1232840-20190115135459110-1011518511.png"> </p><p>5、点击左下角的“Install Package”，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/wJMumEiyYoKZTGx.png" alt="1232840-20190115135519883-1621537554.png"></p><p>6、等待一会，出现如下界面，依赖包安装成功，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/uS7AXPzmtHJBNY6.png" alt="1232840-20190115135618310-354619733.png"></p><p>7、可以通过在命令行输入 pip list查看，也可以在代码编辑区域输入 import 依赖包，不报错，还可以在命令行输入python，然<br>后再输入import+依赖包，回车验证等等，只要验证成功即可。</p><p>（1）命令行输入 pip list查看</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/R2zci1AMIGnPFmD.png" alt="1232840-20190115141200417-120869830.png"></p><p>（2）代码编辑区域输入 import 依赖包</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/wJLO9BUpDasKNkG.png" alt="1232840-20190115140110969-1752336077.png"></p><p>（3）命令行输入python，然后再输入import+依赖包，回车验证</p><h4 id="3-安装前："><a href="#3-安装前：" class="headerlink" title="3.安装前："></a>3.安装前：</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/AO6EnCsRuGkexrF.png" alt="1232840-20190115141116225-1122399938.png"></p><h4 id="4-安装后："><a href="#4-安装后：" class="headerlink" title="4.安装后："></a>4.安装后：</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/pDumTgqdi91tcJk.png" alt="1232840-20190115141025002-633927271.png"></p><p>此外此处也可以查看</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/3bzpoEnwMUkGfNX.png" alt="1232840-20190115140038739-1281303998.png"></p><h4 id="5-附录"><a href="#5-附录" class="headerlink" title="5.附录"></a>5.附录</h4><p>命令行安装。输入pip3 install requests ，出现successfully，安装成功！如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/4INC2szfXjJlF13.png" alt="1232840-20190115140733985-518018823.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm使用教程-03</title>
      <link href="/2016/05/26/pycharm/"/>
      <url>/2016/05/26/pycharm/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Pycharm使用教程（三）（非常详细，非常实用）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>工具汉化，宏哥一般都是不推荐的，就那么记得常用的单词，用用就熟悉了，没有必要兴师动众的汉化一下，汉化可能出现一些你意想不到的错误bug，还是使用原汁原味的英文版比较香吧。当然了你非要汉化的话，就接着看宏哥啰嗦吧。</p><h4 id="2-汉化"><a href="#2-汉化" class="headerlink" title="2.汉化"></a>2.汉化</h4><p>1、 汉化：把resources_zh.jar拷贝到PyCharm的安装目录下的lib目录，重启Pycharm即可。</p><p>（resources_zh.jar汉化包关注本账号获取：链接: <a href="https://pan.baidu.com/s/1JCpTloWnQdQ8ShsUt-Qabg" target="_blank" rel="noopener">https://pan.baidu.com/s/1JCpTloWnQdQ8ShsUt-Qabg</a> 提取码: i7pu ）</p><p>如果打开后显示乱码，请先删除resources_cn.jar，然后打开pycharm2017，在菜单上依次选择 File -&gt; Settings -&gt; Appearance&amp;Behavior -&gt; Appearance -&gt; 选中Override default fonts by(not recommended) Name: Microsoft YaHei (选择任意中文字体) 然后将resources_cn.jar 复制到 .\lib 目录，重新打开pycharm2017就能正常显示中文了哦！</p><h4 id="2-整体结构："><a href="#2-整体结构：" class="headerlink" title="2.整体结构："></a>2.整体结构：</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/y9BCAisY43hcnJe.jpg" alt="u_2334796874,1890949722_fm_173_s_6F42E512090F7D4B4EE1C5DE020080B3_w_640_h_442_img.jpg"></p><h4 id="3-常用功能介绍："><a href="#3-常用功能介绍：" class="headerlink" title="3.常用功能介绍："></a>3.常用功能介绍：</h4><p>（1） 如何更换Python解释器：</p><p>在文件-&gt;设置-&gt;项目:xxx下找到Project Interpreter。然后修改为你需要的Python解释器。注意这个地方一定要注意的是：在选择Python解释器的时候，一定要选择到python.exe这个文件，而不是python的安装文件夹。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/Acj5BYi4GMk3sPe.jpg" alt="u_92383329,3330612653_fm_173_s_8052CD300B4F614B5AC941DD010010B2_w_640_h_379_img.jpg"></p><p>（2） 如何创建一个Python包：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/r1gEU2cYp63sWyJ.jpg" alt="u_709165834,4092466336_fm_173_s_E900CC13191EC4CE1E7538CE0100C0B1_w_569_h_481_img.jpg"></p><p>如何创建一个Python包</p><p>一定要选择Python Package，不然就不会创建一个<strong>init</strong>.py文件。</p><p>（3） 如何创建不同类型的文件：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/otKIypSxPA4UfTM.jpg" alt="u_4170034771,2674907726_fm_173_s_A952CC13111E47CE0E7931CE030050B2_w_560_h_483_img.jpg"></p><p>如何创建不同类型的文件</p><p>（4） 如何新建一个项目：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/d85Ywm12hlUvsFI.jpg" alt="u_4063825697,3355993681_fm_173_s_0012EC32030A656C185DE0CA000050B2_w_640_h_372_img.jpg"></p><p>（5） 如何调整编辑器字体及其大小：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/Mm5XhrvisqUoA2x.jpg" alt="u_3865795732,2667976827_fm_173_s_0053CD3041CF514D4C6504DA010050B2_w_640_h_429_img.jpg"></p><p>（6） 如何调整控制台的字体及其大小：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/TEdscMrShGx5gtZ.jpg" alt="u_3746912621,3652501741_fm_173_s_8052C730498F504B4C6400DA010050B2_w_640_h_426_img.jpg"></p><p>（7） 如何设置文件编码：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/hJFVtYsUGkXHlN9.jpg" alt="u_2603804655,1925548751_fm_173_s_0352CD320F3F640F08F521DB000050B0_w_640_h_424_img.jpg"></p><p>（8） 如何修改文件背景颜色：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/y8bWzjuXxt9pZDI.jpg" alt="u_1809988302,1416909072_fm_173_s_8A52C510055E55CA406118590300C030_w_640_h_429_img.jpg"></p><p>（9） 如何让一个tab键代替4个空格键：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/aPGrQzJtLws4yI2.jpg" alt="u_3807832282,2626033699_fm_173_s_0052CD32090B704F5EF185DA0000C0B2_w_640_h_425_img.jpg"></p><p>（10） 如何自定义Python模版文件：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/8Imhq1aO9rL4PTf.jpg" alt="u_89741738,3612108539_fm_173_s_C942C518415F51CE004D08DA0100C0B2_w_640_h_428_img.jpg"></p><p>（11） 显示行号：</p><p>在显示行号的地方右键，勾选上显示行号。</p><p>（12） 如何安装插件：</p><p>设置-&gt;Plugins-&gt;Browse repositories，然后输入你要安装的插件。</p><p>（13） 复制文件路径：右键-&gt;copy path。</p><p>（14） 在文件管理器中打开：右键-&gt;Show In Explorer。</p><p>（15） 进入到某文件中：把光标放在单词中间，然后按ctrl+b或者按ctrl键+鼠标左键。</p><p>（16） 查看项目结构：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/OJunwqEiQxh9jBk.jpg" alt="u_3619954959,3307486876_fm_173_s_6C60A51B1D5E44CE5ED5E4DB010050B1_w_272_h_346_img.jpg"></p><p>（17） DEBUG：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/orSJ7Ud5wjfyKNF.jpg" alt="u_371002929,4079515813_fm_173_w_28_h_23_img.jpg"></p><blockquote><p>跳过函数执行。</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/nfroaYBb8V6ImAH.jpg" alt="u_4044579004,3202942114_fm_173_w_22_h_21_img.jpg"></p><blockquote><p>进入自己的函数，进入系统的函数</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/uJxD7gCLoO8VbQl.jpg" alt="u_817344506,3957539072_fm_173_w_32_h_21_img.jpg"></p><blockquote><p>进入自己的函数，但不进入系统的函数。</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/HyBvk1rdn2eAqlL.jpg" alt="u_1224241286,155747354_fm_173_w_29_h_26_img.jpg"></p><blockquote><p>跳出当前执行的函数。</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/Vvs2IdZofQLRWHx.jpg" alt="u_344074822,3914074313_fm_173_w_27_h_22_img.jpg"></p><blockquote><p>跳到光标所在的地方。</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/Zimskzf73Vo9ScC.jpg" alt="u_94481096,2953183334_fm_173_w_30_h_26_img.jpg"></p><blockquote><p>跳到下一个断点。</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/OfEMCZlXkQrP4S5.jpg" alt="u_169984750,3515446342_fm_173_w_28_h_24_img.jpg"></p><blockquote><p>结束本次执行。</p></blockquote><p>（18） 设置一次性只能运行一个实例：</p><p>（19） 常用快捷键：</p><ul><li><p>ctrl+d：复制当前行到下一行。</p></li><li><p>ctrl+y：删除当前这一行。</p></li><li><p>shift+enter：跳到下一行。</p></li><li><p>ctrl+/：添加注释。</p></li><li><p>tab：缩进。</p></li><li><p>shift+tab：取消缩进。</p></li><li><p>ctrl+f：查找。</p></li><li><p>ctrl+shift+f：在当前项目中查找。</p></li><li><p>ctrl+减号：折叠当前代码块。</p></li><li><p>ctrl+加号：展开当前代码块。</p></li><li><p>ctrl+shift+减号：折叠当前文件所有代码块。</p></li><li><p>ctrl+shift+加号：展开当前文件所有代码库。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm使用教程-02</title>
      <link href="/2016/05/25/pycharm/"/>
      <url>/2016/05/25/pycharm/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 手把手的教你激活PyCharm –Pycharm激活详细教程（二）（非常详细，非常实用）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>Pycharm安装以后必须激活后，才能正常的使用。否则就不能使用。</p><blockquote><p><font color="red"> <strong>pycharm激活码，由于那台服务器不维护了，不好使了，你可以关注宏哥的公众号发送：激活码，Ctrl+A，Ctrl+C，然后Ctrl+V，就可以了。</strong></font></p></blockquote><h4 id="2-激活PyCharm"><a href="#2-激活PyCharm" class="headerlink" title="2.激活PyCharm"></a>2.激活PyCharm</h4><h5 id="1、Activation-code激活"><a href="#1、Activation-code激活" class="headerlink" title="1、Activation code激活"></a>1、Activation code激活</h5><p>优点：Window、Mac、Ubantu都稳定有效，关键是这种激活方式不会产生其他影响</p><p>缺点：需要修改hosts文件</p><p>第一步：点击‘Activation code’，授权激活pycharm，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/VgmsbyIdh6atlE1.png" alt="1232840-20190109150211381-1273247550.png"></p><p>第二步：修改C:\Windows\System32\drivers\etc 目录下的hosts文件；将hosts文件复制到其他文件夹下，打开hosts文件，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/N9lnGEezFWikvcI.png" alt="1232840-20190109150359410-161100911.png"></p><p>在文件的末尾添加“0.0.0.0 account.jetbrains.com”，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/7bJxekWtNzMPrO3.png" alt="1232840-20190109150432105-2027005139.png"></p><p>随后将修改后的hosts文件，重新复制到C:\Windows\System32\drivers\etc 目录下，并将原来的hosts文件覆盖</p><p>第三步： 打开网址：<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/mpwzOrgKPyek42L.png" alt="1232840-20190109150522768-294476463.png"></p><p>第四步：点击获取注册码，并复制</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/iVPuCYbwMZaAmed.png" alt="1232840-20190109150602656-1396293699.png"></p><p>第五步：将注册码复制到Activation code的文本框中，点击ok！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/6G5zU9SynW7OpNR.png" alt="1232840-20190109150904913-1654474696.png"></p><p>如果出现此种情况：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/ebpLmIUki4fyBjS.png" alt="1232840-20190110095238090-747005073.png"></p><p>说明此文件权限不够，不能对此文件进行修改，解决方法如下：</p><ol><li><p>在桌面新建一个hosts文件，然后把 0.0.0.0 account.jetbrains.com  加到最后，保存，在直接复制到此文件夹，替换一下即可。</p></li><li><p>修改权限方法如下：</p></li></ol><p>右键，属性，安全，点击编辑，修改的权限（不同电脑计算机名字是不一样的，根据自己的计算机名来改）如下图，分别给修改和写入后边打上对勾</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/lT6rq85Pdm3fH2E.png" alt="1232840-20190110095256391-298540788.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/EIbujmZQweLk2Kf.png" alt="1232840-20190110095317731-807686940.png"></p><p>点击应用，确定，然后重复上边操作即可。</p><p>第六步：PyCharm激活后，如下界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/wI7Az8WRGuxfVhF.png" alt="1232840-20190109150958137-1791073148.png"></p><p>第七步：激活之后会自动跳转到下图界面，创建项目路径：Create New Project</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/heuq7lOaGL9njzN.png" alt="1232840-20190109151127837-912089017.png"></p><p>第八步：项目设置，在电脑的D盘、E盘等等创建一个空的文件夹（磁盘空间充足的位置），找到你的项目文件夹，直接点击右下角Create</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/K6oVzh4MtT3R5ms.png" alt="1232840-20190109151337755-1554528427.png"></p><p>第九步：IDE提供的提示，直接close即可，不用理会。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/mEbgvoA2fKH8yqV.png" alt="1232840-20190110093250778-715773510.png"></p><p>第十步：进入的界面如下图所示，鼠标右击图中箭头指向的地方，然后选择New，最后选择python file，在弹出的框中填写文件名（任意填写），本例填写：helloworld。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/I3CcxrmpsGUfbd5.jpg" alt="5b5b00014f03cd95e86d.jpg"></p><p>第十一步：之后得到下图，然后点击OK即可：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/5QGZYWThHRPScEL.jpg" alt="5b570004e64fb14fc584.jpg"></p><p>第十二步：文件创建成功后便进入如下的界面，便可以编写自己的程序了。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/RyI8OYfGkjd7uML.jpg" alt="5b5900019196067eda92.jpg"></p><p>第十三步：这个界面是Pycharm默认的界面，大家完全可以自己去setting中设置自己喜欢的背景和字体大小、格式等等。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/LHMRkjpPAt3SdEi.jpg" alt="5b5a00018131817c3500.jpg"></p><p>第十四步：在这里我就不一一赘述了，起码到这里我相信大家已经实现了Pycharm的安装和激活。</p><p>第十五步：查看激活，点击“Help”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/6ca3EidPruo4NsW.png" alt="1232840-20190110094557543-1270265519.png"></p><p>第十六步：点击“Register”，看到激活到2019年5月5日，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/TKkWopcgYIryu25.png" alt="1232840-20190110094732145-1166596981.png"></p><p>附录：Pycharm中的部分快捷键</p><p>1、Ctrl + Enter：在下方新建行但不移动光标；</p><p>2、Shift + Enter：在下方新建行并移到新行行首；</p><p>3、Ctrl + /：注释(取消注释)选择的行；</p><p>4、Ctrl+d：对光标所在行的代码进行复制。</p><p>最后小编祝大家能够顺利的完成Python和Pycharm的安装，提前^<em>^祝大家周末愉快^</em>^</p><h5 id="2、License-server激活"><a href="#2、License-server激活" class="headerlink" title="2、License server激活"></a>2、License server激活</h5><p>优点：方便快捷</p><p>缺点：激活的人数多了就容易被封杀，所以可能经常需要去激活</p><p>选择License server激活，然后填入： idea.qmanga.com或<a href="http://xidea.online，然后点Activate激活即可，如果这几个服务器都无法激活，建议使用第一种激活码方式激活。" target="_blank" rel="noopener">http://xidea.online，然后点Activate激活即可，如果这几个服务器都无法激活，建议使用第一种激活码方式激活。</a></p><h5 id="3、破解补丁激活"><a href="#3、破解补丁激活" class="headerlink" title="3、破解补丁激活"></a>3、破解补丁激活</h5><p>优点：到期时间为2099年，基本为永久啦</p><p>缺点：相对服务器激活麻烦些，但是一共只需要3个步骤，其实并不麻烦</p><p>1.下载链接: <a href="https://pan.baidu.com/s/1DJffBulrABZDa8nV1ntxug" target="_blank" rel="noopener">https://pan.baidu.com/s/1DJffBulrABZDa8nV1ntxug</a> 提取码: 6789 </p><p>2.将JetbrainsCrack-2.6.10-release-enc.jar放置到 pycharm安装目录的\bin目录下（位置可随意，只要配置文件填写相对应的路径）。</p><p>3.在 Pycharm安装目录的\bin目录下找到 pycharm.exe.vmoptions 和 pycharm64.exe.vmoptions (如果你是idea激活则是：idea.exe.vmoptions和idea64.exe.vmoptions)，以文本格式打开并同时在两个文件最后追加  -javaagent:E:\software\PyCharm 2018.3.2\bin\JetbrainsCrack-2.6.10-release-enc.jar，注意路径修改成你的pycharm安装路径（ 注意：标红处是你自己的安装目录），然后保存。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/E3dWjGovrZmScib.png" alt="1232840-20190110140030380-1271697762.png"></p><p>4.重启PyCharm </p><p>注意！如果之前已经存在注册码，可以直接跳到第5步，如果没有注册码，则填写下面的注册码！</p><pre><code>BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK/3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL/oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw/sCltpoPWlJtDOcw/iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9</code></pre><p>5.验证是否是有效期是否截止到2099年    点击 pycharm的help-&gt;about查看:</p><p>没有永久激活时如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/F2XblutVrAanZji.png" alt="1232840-20190110142008443-1455818116.png"></p><p>永久激活以后，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/ehk8UysDaVTE7ji.png" alt="1232840-20190110152720900-1259027352.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm使用教程-01</title>
      <link href="/2016/05/24/pycharm/"/>
      <url>/2016/05/24/pycharm/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 手把手的教你安装PyCharm –Pycharm安装详细教程（一）（非常详细，非常实用）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>Jetbrains家族和Pycharm版本划分：</p><p>pycharm是Jetbrains家族中的一个明星产品，Jetbrains开发了许多好用的编辑器，包括Java编辑器（IntelliJ IDEA）、JavaScript编辑器（WebStorm）、PHP编辑器（PHPStorm）、Ruby编辑器（RubyMine）、C和C++编辑器（CLion）、.Net编辑器（Rider）、iOS/macOS编辑器（AppCode）等。pycharm现在在官网 <a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/#section=windows</a> 是分为两个版本，第一个版本是Professional(专业版本)，这个版本功能更加强大，主要是为Python和web开发者而准备，是需要付费的。第二个版本是社区版，一个专业版的阉割版，比较轻量级，主要是为Python和数据专家而准备的。一般我们做开发，下载专业版本比较合适。</p><p>PyCharm 是我用过的python编辑器中，比较顺手的一个。而且可以跨平台，在macos和windows下面都可以用，这点比较好。是python现在最好用的编辑器，没有之一。</p><h4 id="2-安装包"><a href="#2-安装包" class="headerlink" title="2.安装包"></a>2.安装包</h4><h5 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h5><p>笔者使用PyCharm2018.3.2，请根据机器是64位还是32位来选择对应的PyCharm版本。（相信绝大部分人都可以很从容的来查看自己机器的位数，在这里就不赘述了，如果不清楚自己可以百度一下就可以）</p><p>可以去PyCharm官网：<a href="https://www.jetbrains.com下载对应机器的安装包。" target="_blank" rel="noopener">https://www.jetbrains.com下载对应机器的安装包。</a></p><blockquote><p>安装包下载</p></blockquote><p>第一步：进入PyCharm官网，点击Tools，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/7vYhjBGtAFoH13x.png" alt="1232840-20190109115133527-1404798186.png"></p><p>第二步：点击“PyCharm”，进入安装包现在页面，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/aZ4WfyqOwtzp8TL.png" alt="1232840-20190109115453100-2096076603.png"></p><p>第三步：点击“DOWNLOAD NOW”，根据自己需要下载匹配的操作系统的安装包，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/oYJFWwat6RdAHnQ.png" alt="1232840-20190109140524528-168462390.png"></p><p>第四步：等待安装包下载完，运行即可。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/Z4Od6KHaB3bwEPp.png" alt="1232840-20190109131658427-583021692.png"></p><blockquote><p>python安装过程</p></blockquote><p>第一步：找到下载好的PyCharm安装包，如下图所示“</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/HSbv8uKJX5dtFey.png" alt="1232840-20190109132056088-472244638.png"></p><p>第二步：双击已下载的PyCharm安装包，出现如下图所示的界面，点击“next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/NHBKg2I69qU8uws.png" alt="1232840-20190109132212294-2099423257.png"></p><p>第三步：选择安装目录，Pycharm需要的内存较多，建议将其安装在D盘或者E盘，不建议放在系统盘C盘：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/OAtNKhRMk4QlCJx.png" alt="1232840-20190109132908333-1851417168.png"></p><p>第四步：点击Next，进入下图的界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/xC8dp7gcJtYInUA.png" alt="1232840-20190109140710705-1188603016.png"></p><p>数字1：create desktop shortcut（创建桌面快捷方式），系统32位就选32-bit,系统64位就选64-bit。现在大多数都是64位了，不清楚系统类型：我的电脑=》右键=》属性</p><p>笔者的电脑是64位系统，所以选择64位。</p><p>数字2：update path variable(restart needed)更新路径变量(需要重新启动)，add launchers dir to the path（将启动器目录添加到路径中）。上一个PyCharm版本没有的，所以没有选择。</p><p>数字3：update context menu（更新上下文菜单），add open folder as project（添加打开文件夹作为项目）。上一个PyCharm版本没有的，所以没有选择。</p><p>数字4：create associations 创建关联，关联.py文件，双击都是以pycharm打开。</p><p>数字5：不要选，我第一次安装的时候就是勾选了，差点放弃。pycharn是国外的软件，网站就是国外，下载速度很慢。有人选上等一两个小时，我等半小时，直接强制关掉。没勾选安装很快完成。把数字1和数字4勾选就好，数字2和数字3看你自己需求。（数字5如果有需求，自己可以单独去官网下载安装JRE）</p><p>第五步：点击Next，进入下图界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/btiyOJLqDhslGWB.png" alt="1232840-20190109141502543-596948624.png"></p><p>默认安装即可，直接点击Install。</p><p>第六步：耐心的等待两分钟左右，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/KgeOnB4M7awXLxV.png" alt="1232840-20190109142045469-820508723.png"></p><p>第七步：之后就会得到下面的安装完成的界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/JPon3dB7pYiGjxh.png" alt="1232840-20190109142148404-202786759.png"></p><p>第八步：点击Finish，Pycharm安装完成。接下来对Pycharm进行配置，双击运行桌面上的Pycharm图标，进入下图界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/m3ypHnMObh4sdt1.png" alt="1232840-20190109142252161-812073381.png"></p><p>从哪里导入pycharm设置，直接第三个（Do not import settings），以后还可以导入。选择Do not import settings，之后选择OK，进入下一步。</p><p>第九步：勾选I confirm that……. ，界面如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/n12r9yOxpYqGzhL.png" alt="1232840-20190109142659510-1653975310.png"></p><p>第十步：点击“continue”，界面如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/nUaYy5QdXWKieCL.png" alt="1232840-20190109142743855-215747222.png"></p><p>第十一步：数据分享，界面如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/d2sC4hgRl3GZrjD.png" alt="1232840-20190109143038885-1684670697.png"></p><p>这个相当于一个问卷调查吧，看自己愿不愿将信息发送JetBrains来提升他们产品的质量</p><p>第十一步：点击“send”或者“Don’t send”。进入如下界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/cIuLCNU75TVREyz.png" alt="1232840-20190109143306858-34525242.png"></p><p>皮肤选择，建议选择Darcula主题，该主题更有利于保护眼睛，而且看上去也非常不错~~</p><p>第十二步：可以右上角关掉，也可以左下角：skip remaining and set defaults（跳过其余和设置默认值）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/fmdoLOaDJBq9RS1.png" alt="1232840-20190109143617068-26321567.png"></p><p>第十三步：点击左下角：skip remaining and set defaults（跳过其余和设置默认值）进入激活界面，选择第二个License server，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/gBTidRI13lDQpMv.png" alt="1232840-20190109143944819-1495627784.png"></p><p>Active 激活分为三种：1、JetBrains Account 账户激活；2、Activation code激活码（推荐亲测）；3、License server授权服务器激活（推荐）</p><p>Evaluate试用 一般是30天，不推荐</p><p>国内一般都是破解激活，到此安装已完成，具体激活请看激活的随笔。</p>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-12</title>
      <link href="/2016/05/23/testng/"/>
      <url>/2016/05/23/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-12 - TestNG之xml文件详解篇 （详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>现在这篇，我们来学习TestNG.xml文件，前面我们已经知道，TestNG就是运行这个文件来执行测试用例的。通过本篇，你可以进一步了解到：这个文件是配置测试用例，测试套件。简单来说，利用这个文件，我们可以跑同一个类或者多个不同类里面的测试用例。</p><p>TestNG通过设置testng.xml文件能做以下事情</p><p>1）创建来源不同包、类、方法的测试套件</p><p>2）包括一些选项，例如失败的用例可以重跑。</p><p>3）支持使用正则表达式</p><p>4）运行把外部参数传入测试方法</p><p>5）支持配置多线程的执行环境</p><p>testNG启发自JUnit和NUnit的一种测试框架，通过使用testNG使的测试更简单。，比如如下的一些特点：</p><p>1.通过注释来管理测试</p><p>2.多线程并发执行测试，且是安全的</p><p>3.支持数据驱动测试</p><p>4.支持在多样化的平台上使用（Eclipse、IDEA、Maven等）</p><p>5.嵌入了BeanShell，使的更具灵活性</p><p>6.支持依赖</p><h4 id="2-testNG的xml文件的结构"><a href="#2-testNG的xml文件的结构" class="headerlink" title="2.testNG的xml文件的结构"></a>2.testNG的xml文件的结构</h4><h5 id="2-1简单的大概结构如下："><a href="#2-1简单的大概结构如下：" class="headerlink" title="2.1简单的大概结构如下："></a>2.1简单的大概结构如下：</h5><pre><code>&lt;suite&gt; --&lt;test&gt; -- --&lt;parameter&gt; -- --&lt;test&gt; -- -- -- &lt;parameter&gt; -- -- -- &lt;groups&gt; -- -- -- &lt;classes&gt;</code></pre><h5 id="2-2比较详细的结构如下："><a href="#2-2比较详细的结构如下：" class="headerlink" title="2.2比较详细的结构如下："></a>2.2比较详细的结构如下：</h5><pre><code>&lt;suite&gt;     &lt;suite-files&gt;          &lt;suite-file path=&quot;&quot;&gt;&lt;/suite-file&gt;     &lt;/suite-files&gt;     &lt;parameter name=&quot;&quot; value=&quot;&quot;&gt;&lt;/parameter&gt;     &lt;method-selectors&gt;          &lt;method-selector&gt;               &lt;selector-calss name=&quot;&quot;&gt;&lt;/selector-calss&gt;          &lt;/mehod-selector&gt;     &lt;/method-selectors&gt;     &lt;test name=&quot;&quot;&gt;          &lt;parameter name=&quot;&quot; value=&quot;&quot;&gt;&lt;parameter&gt;          &lt;groups&gt;               &lt;define name=&quot;&quot;&gt;                    &lt;include name=&quot;&quot;/&gt;                    &lt;exclude name=&quot;&quot;/&gt;               &lt;/define&gt;               &lt;run&gt;                    &lt;include name=&quot;&quot;/&gt;                    &lt;exclude name=&quot;&quot;/&gt;               &lt;/run&gt;          &lt;/groups&gt;          &lt;classes&gt;               &lt;class name=&quot;&quot;&gt;                    &lt;mehods&gt;                         &lt;parameter name=&quot;&quot; value=&quot;&quot;&gt;&lt;/parameter&gt;                         &lt;include name=&quot;&quot;&gt;&lt;/include&gt;                         &lt;exclude name=&quot;&quot;&gt;&lt;/exclude&gt;                    &lt;/methods&gt;               &lt;/class&gt;               &lt;class&gt;&lt;/class&gt;          &lt;/classes&gt;          &lt;packages&gt;               &lt;package name=&quot;&quot;&gt;                    &lt;include name=&quot;&quot;&gt;&lt;/include&gt;                    &lt;exclude name=&quot;&quot;&gt;&lt;/exclude&gt;               &lt;/package&gt;          &lt;/packages&gt;          &lt;listeners&gt;               &lt;listener class-name=&quot;&quot;/&gt;          &lt;/listenters&gt;     &lt;/test&gt;     &lt;test&gt;&lt;/test&gt;&lt;/suite&gt;</code></pre><h4 id="3-文档具体的元素说明"><a href="#3-文档具体的元素说明" class="headerlink" title="3.文档具体的元素说明"></a>3.文档具体的元素说明</h4><h5 id="3-1-lt-suite-gt"><a href="#3-1-lt-suite-gt" class="headerlink" title="3.1&lt;suite&gt;"></a>3.1&lt;suite&gt;</h5><p>testNG.xml文件的最外层标签即suite，即测试套件，其下可以有多个&lt;test&gt;和&lt;groups&gt;，其有几个可以添加的属性</p><p>说明：一个xml文件只能有一个&lt;suites&gt;,，是一个xml文件的根级</p><p>&lt;suite&gt;由&lt;test&gt;和&lt;parameters&gt;组成</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th><th>使用方法</th><th>参数值</th></tr></thead><tbody><tr><td>name</td><td>必选项，<suite>的名字，将出现在reports里</suite></td><td>name=”XXX”</td><td>suite名字</td></tr><tr><td>junit</td><td>是否执行Junit模式(识别setup()等)</td><td>junit=”true”</td><td>true和false，默认false</td></tr><tr><td>verbose</td><td>控制台输出的详细内容等级,0-10级（0无，10最详细）</td><td>verbose=”5”</td><td>0到10</td></tr><tr><td>parallel</td><td>是否在不同的线程并行进行测试，要与thread-count配套使用</td><td>parallel=”mehods”</td><td>详见表格下内容，默认false</td></tr><tr><td>parent-module</td><td>和Guice框架有关，只运行一次，创建一个parent injector给所有guice</td><td>injectors</td><td></td></tr><tr><td>guice-stage</td><td>和Guice框架有关</td><td>guice-stage=”DEVELOPMENT”</td><td>DEVELOPMENT，PRODUCTION，TOOL，默认”DEVELOPMENT”</td></tr><tr><td>configfailurepolicy</td><td>测试失败后是再次执行还是跳过，值skip和continue</td><td>configfailurepolicy=”skip”</td><td>skip、continue，默认skip</td></tr><tr><td>thread-count</td><td>与parallel配套使用，线程池的大小，决定并行线程数量</td><td>thread-count=”10”</td><td>整数，默认5</td></tr><tr><td>annotations</td><td>获取注解，值为javadoc时，使用JavaDoc的注释；否则用JDK5注释</td><td>annotations=”javadoc”</td><td>javadoc</td></tr><tr><td>time-out</td><td>设置parallel时，终止执行单元之前的等待时间（毫秒）</td><td>time-out=”10000”</td><td>整数，单位毫秒</td></tr><tr><td>skipfailedinvocationcounts</td><td>是否跳过失败的调用</td><td>skipfailedinvocationcounts=”true”</td><td>true和false，默认false</td></tr><tr><td>data-provider-thread-count</td><td>并发时data-provider的线程池数量</td><td>data-provider-thread-count=”5”</td><td>整数</td></tr><tr><td>object-factory</td><td>一个实现IObjectFactory接口的类，实例化测试对象</td><td>object-factory=”classname”</td><td>类名</td></tr><tr><td>allow-return-values</td><td>是否允许返回函数值</td><td>all-return-values=”true”</td><td>true和false</td></tr><tr><td>preserve-order</td><td>是否按照排序执行</td><td>preserve-order=”true”</td><td>true和false，默认true</td></tr><tr><td>group-by-instances</td><td>按照实例分组</td><td>group-by-instances=”true”</td><td>true和false，默认false</td></tr></tbody></table><p>parallel<br>该参数的值false，methods，tests，classes，instances。默认false</p><p>parallel必须和thread-count配套使用，否则相当于无效参数，thread-count决定了并行测试时开启的线程数量</p><p>parallel=”mehods”  TestNG将并行执行所有的测试方法在不同的线程里</p><p>parallel=”tests”  TestNG将并行执行在同一个<test>下的所有方法在不同线程里</test></p><p>parallel=”classes”  TestNG将并行执行在相同<class>下的方法在不同线程里</class></p><p>parallel=”instances”  TestNG将并行执行相同实例下的所有方法在不同的县城里</p><p>parent-module和guice-stage和Guice框架有关，testNG 6对Guice框架提供了支持，我没用过这个框架，所以这两个参数没看懂╮(╯▽╰)╭</p><h5 id="3-2-lt-suite-file-gt"><a href="#3-2-lt-suite-file-gt" class="headerlink" title="3.2&lt;suite-file&gt;"></a>3.2&lt;suite-file&gt;</h5><p>说明：引入外部的xml文件（地址由path参数决定，path必填项），将引入的xml与当前的xml文件一起使用</p><p>声明方法：</p><pre><code>&lt;suite-files&gt;     &lt;suite-file path=&quot;/path/suitefile1&quot;&gt;&lt;/suite-file&gt;&lt;/suite-files&gt;</code></pre><h5 id="3-3-lt-test-gt"><a href="#3-3-lt-test-gt" class="headerlink" title="3.3&lt;test&gt;"></a>3.3&lt;test&gt;</h5><p>此标签无特别意义，其下可以包括多个标签，如groups、classes等</p><p>说明：一个&lt;suite&gt;下可以有多个&lt;test&gt;，可以通过&lt;suite&gt;的parallel=”tests”来进行并行测试，必须和thread-count配套使用，否则是无效参数</p><p>&lt;test&gt;由&lt;parameters&gt;、&lt;groups&gt;、&lt;classes&gt;三部分组成</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th><th>使用方法</th><th>参数值</th></tr></thead><tbody><tr><td>name</td><td>test的名字，将出现在报告里</td><td>name=”testname”</td><td>test的名字</td></tr><tr><td>junit</td><td>是否按照Junit模式运行</td><td>junit=”true”</td><td>true和false，默认false</td></tr><tr><td>verbose</td><td>控制台输出的详细内容等级,0-10级（0无，10最详细），不在报告显示</td><td>verbose=”5”</td><td>0到10</td></tr><tr><td>parallel</td><td>是否在不同的线程并行进行测试，要与thread-count配套使用</td><td>parallel=”mehods”</td><td>与suite的parallel一致，默认false</td></tr><tr><td>thread-count</td><td>与parallel配套使用，线程池的大小，决定并行线程数量</td><td>thread-count=”10”</td><td>整数，默认5</td></tr><tr><td>annotations</td><td>获取注解，值为javadoc时，使用JavaDoc的注释；否则用JDK5注释</td><td>annotations=”javadoc”</td><td>javadoc</td></tr><tr><td>time-out</td><td>设置parallel时，终止执行单元之前的等待时间（毫秒）</td><td>time-out=”10000”</td><td>整数，单位毫秒</td></tr><tr><td>enabled</td><td>标记是否执行这个test</td><td>enabled=”true”</td><td>true和false，默认true</td></tr><tr><td>skipfailedinvocationcounts</td><td>是否跳过失败的调用</td><td>skipfailedinvocationcounts=”true”</td><td>true和false，默认false</td></tr><tr><td>preserve-order</td><td>是否按照排序执行，如果是true，将按照xml文件中的顺序去执行</td><td>preserve-order=”true”</td><td>true和false，默认true</td></tr><tr><td>allow-return-values</td><td>是否允许返回函数值</td><td>all-return-values=”true”</td><td>true和false，默认false</td></tr></tbody></table><h5 id="3-4-lt-parameter-gt"><a href="#3-4-lt-parameter-gt" class="headerlink" title="3.4&lt;parameter&gt;"></a>3.4&lt;parameter&gt;</h5><p>说明：提供测试数据，有name和value两个参数</p><p>声明方法：&lt;parameter name = “parameter_name” value = “parameter_value “/&gt;</p><p>testng.xml文件中的&lt;parameter&gt;可以声明在<suite>或者<test>级别，在<test>下的<parameter>会覆盖在<suite>下声明的同名变量</suite></parameter></test></test></suite></p><h5 id="3-5-lt-method-selectors-gt"><a href="#3-5-lt-method-selectors-gt" class="headerlink" title="3.5&lt;method-selectors&gt;"></a>3.5&lt;method-selectors&gt;</h5><p>说明：方法选择器定义了哪些类的方法需要去执行，类必须继承自org.testng.IMethodSelector</p><p>声明方法：</p><pre><code>&lt;method-selectors&gt;     &lt;method-selector&gt;          &lt;selector-class name=&quot;classname&quot; priority=&quot;1&quot;&gt;&lt;/selector-class&gt;          &lt;script language=&quot;java&quot;&gt;&lt;/script&gt;    （language还可以用beanshell等）     &lt;/method-selector&gt;&lt;/method-selectors&gt;</code></pre><p>备注：&lt;method-selectors&gt;这个我没用过，所以了解，如果有错的欢迎指出来~</p><h5 id="3-6-lt-groups-gt"><a href="#3-6-lt-groups-gt" class="headerlink" title="3.6&lt;groups&gt;"></a>3.6&lt;groups&gt;</h5><p>此标签必然是在&lt;test&gt;标签下的，用于标识那些组会被用于测试或者被排除在测试之外，其同级必然要包含一个&lt;classes&gt;标签或者&lt;pakages&gt;标签，用于指定groups来自于哪些包或者类</p><p>说明：要运行的组，可以自定义一个组，可以包括要执行的，还排除要执行的方法。必须和<classes>配套使用，从下面的类中找到对应名字的方法</classes></p><p>&lt;groups&gt;由<difine>和<run>、<dependencies>三部分组成。<diffine>可以将group组成一个新组，包括要执行和不执行的大组；<run>要执行的方法；<dependencies>指定了某group需要依赖的group（比如下面的例子，group1需要依赖group2和group3先执行）。</dependencies></run></diffine></dependencies></run></difine></p><p>声明方法：</p><pre><code>&lt;groups&gt;     &lt;define name =&quot;all&quot;&gt;          &lt;include name =&quot;testgroup1&quot;/&gt;          &lt;exclude name =&quot;testgroup2&#39;/&gt;     &lt;/define&gt;     &lt;run&gt;          &lt;include name =&quot;all&quot;/&gt;          &lt;include name =&quot;testmethod1&quot;/&gt;          &lt;exclude name=&quot;testmethod2&quot;/&gt;     &lt;/run&gt;     &lt;dependencies&gt;          &lt;group name =&quot;group1&quot; depends-on=&quot;goup2 group3&quot;/&gt;     &lt;/dependencies&gt;&lt;/groups&gt;</code></pre><h5 id="3-7-lt-classes-gt"><a href="#3-7-lt-classes-gt" class="headerlink" title="3.7&lt;classes&gt;"></a>3.7&lt;classes&gt;</h5><p>说明：方法选择器，要执行的方法写在这里，参数有name和priority。</p><p>注释：</p><p>1.&lt;classes&gt;下必须写要执行的<class>，否则不会执行任何内容，如果填写了class没有写methods，会按照填写的class的下的注释@Test去执行所有的方法</class></p><p>2.&lt;classes&gt;下的<methods>如果填写了<include>，那只会执行所填写的方法，没有填写的方法不会去执行</include></methods></p><p>声明方法：</p><pre><code>&lt;classes&gt;     &lt;class name=&quot;要执行的class名&quot;&gt;          &lt;methods&gt;               &lt;include name =&quot;要执行的方法名&quot;&gt;&lt;/include&gt;          &lt;/methods&gt;     &lt;/class&gt; &lt;/classes&gt;</code></pre><h5 id="3-8-lt-packages-gt"><a href="#3-8-lt-packages-gt" class="headerlink" title="3.8&lt;packages&gt;"></a>3.8&lt;packages&gt;</h5><p>说明：&lt;packages&gt;指定包名代替类名。查找包下的所有包含testNG annotation的类进行测试</p><p>声明方法：</p><pre><code>&lt;packages&gt;     &lt;package name=&quot;packagename&quot;/&gt;     &lt;package name=&quot;packagename&quot;&gt;          &lt;include name=&quot;methodname&quot;/&gt;          &lt;exclude name=&quot;methodname&quot;/&gt;     &lt;/package&gt;&lt;/packages&gt;</code></pre><h5 id="3-9-lt-listener-gt"><a href="#3-9-lt-listener-gt" class="headerlink" title="3.9&lt;listener&gt;"></a>3.9&lt;listener&gt;</h5><p>说明：指定listeners，这个class必须继承自org.testng.ITestNGListener。在java中使用@Listeners({com.example.MyListener.class,com.example.MyMethodInterceptor.class})的注释也可以有同样效果</p><p>声明方法：</p><pre><code>&lt;listeners&gt;     &lt;listener class-name=&quot;com.example.MyListener&quot;/&gt;     &lt;listener class-name=&quot;com.example.MyMehodIntercepor&quot;/&gt;&lt;/listeners&gt;</code></pre><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>  好了，今天关于TestNG之xml文件详解篇 ，就分享到这里。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-11</title>
      <link href="/2016/05/22/testng/"/>
      <url>/2016/05/22/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-11 - TestNG之annotation与并发测试篇 （详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>TestNG中用到的annotation的快速预览及其属性。</p><h4 id="2-TestNG基本注解-注释"><a href="#2-TestNG基本注解-注释" class="headerlink" title="2.TestNG基本注解(注释)"></a>2.TestNG基本注解(注释)</h4><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@BeforeSuite</td><td>注解的方法只运行一次，在当前suite所有测试执行之前执行</td></tr><tr><td>@AfterSuite</td><td>注解的方法只运行一次，在当前suite所有测试执行之后执行</td></tr><tr><td>@BeforeClass</td><td>注解的方法只运行一次，在当前类中所有方法调用之前执行</td></tr><tr><td>@AfterClass</td><td>注解的方法只运行一次，在当前类中所有方法调用之后执行</td></tr><tr><td>@BeforeTest</td><td>只运行一次，所有的测试方法运行之前运行</td></tr><tr><td>@AfterTest</td><td>只运行一次，所有的测试方法运行之后运行</td></tr><tr><td>@BeforeGroups</td><td>组的列表，这种配置方法将之前运行。此方法是保证在运行属于任何这些组第一个测试方法，该方法被调用。</td></tr><tr><td>@AfterGroups</td><td>组的名单，这种配置方法后运行。此方法是保证运行后不久，最后的测试方法，该方法属于任何这些组被调用。</td></tr><tr><td>@BeforeMethod</td><td>在每一个测试方法（@test）运行之前运行，例：执行完测试用例后要重置数据才能执行第二条用例时，可用之种方式。</td></tr><tr><td>@AfterMethod</td><td>在每一个测试方法（@test）运行之后运行</td></tr><tr><td>@DataProvider</td><td>标志着一个方法，提供数据的一个测试方法。注解的方法必须返回一个Object[] []，其中每个对象[]的测试方法的参数列表中可以分配。<br>该@Test 方法，希望从这个DataProvider的接收数据，需要使用一个dataProvider名称等于这个注解的名字。</td></tr><tr><td>@Factory</td><td>作为一个工厂，返回TestNG的测试类的对象将被用于标记的方法。该方法必须返回Object[]。</td></tr><tr><td>@Listeners</td><td>定义一个测试类的监听器</td></tr><tr><td>@Parameters</td><td>介绍如何将参数传递给@Test方法。</td></tr><tr><td>@Test</td><td>标记一个类或方法作为测试的一部分。</td></tr></tbody></table><p> 如上列表中的@Factory、@Linsteners这两个是不常用的；<br>前十个注解看起来不太容易区分，顺序不太容易看明白，以如下范例做简单说明，代码：</p><pre><code>package com.course.testng.multiThread;/** * @author 北京-宏哥 *  * Java自动化测试框架-11 - TestNG之annotation与并发测试篇  * * 2016年05月22日 */import org.testng.Assert;import org.testng.annotations.AfterClass;import org.testng.annotations.AfterGroups;import org.testng.annotations.AfterMethod;import org.testng.annotations.AfterSuite;import org.testng.annotations.AfterTest;import org.testng.annotations.BeforeClass;import org.testng.annotations.BeforeGroups;import org.testng.annotations.BeforeMethod;import org.testng.annotations.BeforeSuite;import org.testng.annotations.BeforeTest;import org.testng.annotations.Test;public class NewTest {  @Test(groups=&quot;group1&quot;)  public void test1() {      System.out.println(&quot;test1 from group1&quot;);      Assert.assertTrue(true);  }  @Test(groups=&quot;group1&quot;)  public void test11() {      System.out.println(&quot;test11 from group1&quot;);      Assert.assertTrue(true);  }  @Test(groups=&quot;group2&quot;)  public void test2()   {      System.out.println(&quot;test2 from group2&quot;);      Assert.assertTrue(true);  }  @BeforeTest  public void beforeTest()   {      System.out.println(&quot;beforeTest&quot;);  }  @AfterTest  public void afterTest()   {      System.out.println(&quot;afterTest&quot;);  }  @BeforeClass  public void beforeClass()   {      System.out.println(&quot;beforeClass&quot;);  }  @AfterClass  public void afterClass()   {      System.out.println(&quot;afterClass&quot;);  }  @BeforeSuite  public void beforeSuite()   {      System.out.println(&quot;beforeSuite&quot;);  }  @AfterSuite  public void afterSuite()   {      System.out.println(&quot;afterSuite&quot;);  }  //只对group1有效，即test1和test11  @BeforeGroups(groups=&quot;group1&quot;)  public void beforeGroups()   {      System.out.println(&quot;beforeGroups&quot;);  }  //只对group1有效，即test1和test11  @AfterGroups(groups=&quot;group1&quot;)  public void afterGroups()   {      System.out.println(&quot;afterGroups&quot;);  }  @BeforeMethod  public void beforeMethod()   {      System.out.println(&quot;beforeMethod&quot;);  }  @AfterMethod  public void afterMethod()   {      System.out.println(&quot;afterMethod&quot;);  }}</code></pre><p>控制台输出如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/6BGdjEbzgrSyu2I.png" alt="1232840-20191113100820775-1204938300.png"></p><h4 id="3-使用注释-注解的好处"><a href="#3-使用注释-注解的好处" class="headerlink" title="3.使用注释/注解的好处"></a>3.使用注释/注解的好处</h4><p>以下是使用注释/注解的一些好处：</p><p>TestNG通过查找注释/注解来识别它感兴趣的方法。 因此，方法名称不限于任何模式或格式。</p><p>可以将其他参数传递给注释。</p><p>注释是强类型的，所以编译器会马上标记任何错误。</p><p>测试类不再需要扩展任何东西(如TestCase，对于JUnit3)。</p><h4 id="4-Concurrenttesting（注解方式）"><a href="#4-Concurrenttesting（注解方式）" class="headerlink" title="4.Concurrenttesting（注解方式）:"></a>4.Concurrenttesting（注解方式）:</h4><p>@Test注解上可通过配置threadPoolSize来实现并发，threadPoolSize和invocationCount是结合使用的，当invocationCount=1的时候，threadPoolSize没有意义。invocationCount表示方法被调用的次数，如果不配置threadPoolSize，该方法会被顺序执行5次，如果配置threaPoolSize=4，下图所示的方法会一次以4个线程并发执行，缩短执行时间。<br>下面的例子是输出进程ID，threadPoolSize用来指明线程池的大小，也就是并发的线程数目是多少</p><p>5次调用，有3个线程可调用</p><p>1、新建com.course.testng.multiThread包，包里新建MuitiThreadOnAnnotion类，如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/1ulrFfSvWMjGyYx.png" alt="1232840-20191111101934183-1576776927.png"></p><p>2、参考代码</p><pre><code>package com.course.testng.multiThread;import org.testng.annotations.Test;/** * @author 北京-宏哥 *  * Java自动化测试框架-11 - TestNG之annotation与并发测试篇 * * 2019年11月11日 *///多线程测试,没有关联的用例可以使用多线程减少执行时间public class MuitiThreadOnAnnotion {    @Test(invocationCount = 5,threadPoolSize = 3)    public void test() {        System.out.println(1);        System.out.printf(&quot;Thrad Id : %s%n&quot;,Thread.currentThread().getId());    }}</code></pre><p>3、控制台页面输出</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/K8sHJaVkBy6oZzF.png" alt="1232840-20191111102757607-673507643.png"></p><p>4、若改成5次调用，有5个线程可调用</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/EP6kjNpTO8FoBzI.png" alt="1232840-20191111103001152-2032081040.png"></p><h4 id="5-testng-xml配置文件"><a href="#5-testng-xml配置文件" class="headerlink" title="5.testng.xml配置文件"></a>5.testng.xml配置文件</h4><p>TestNG可以以多线程的模式运行所有的test，这样可以获得最大的运行速度，最大限度的节约执行时间。当然，并发运行也是有代价的，就是需要我们的代码是线程安全的。</p><p>并发运行测试的话，需要我们指定运行的配置文件，一个示例如下：</p><pre><code>&lt;suite name=&quot;My suite&quot; parallel=&quot;methods&quot; thread-count=&quot;4&quot;&gt;</code></pre><p>说明：在当前测试规划的执行过程中，为每个测试方法的执行使用单独的线程，最多并发4个线程。</p><pre><code>&lt;suite name=&quot;My suite&quot; parallel=&quot;tests&quot; thread-count=&quot;4&quot;&gt;</code></pre><p>说明：在当前测试规划的执行过程中，为每个测试用例的执行使用单独的线程（该测试用例中的测试方法共享一个线程），最多并发4个线程。</p><pre><code>&lt;suite name=&quot;My suite&quot; parallel=&quot;classes&quot; thread-count=&quot;4&quot;&gt;</code></pre><p>说明：在当前测试规划的执行过程中，为每个测试类的执行使用单独的线程（该测试类中的测试方法共享一个线程），最多并发4个线程。</p><pre><code>&lt;suite name=&quot;My suite&quot; parallel=&quot;instances&quot; thread-count=&quot;4&quot;&gt;</code></pre><p>说明：在当前测试规划的执行过程中，为每个测试类实例的执行始终使用唯一的线程（该测试实例中的测试方法共享一个线程），最多并发4个线程。</p><p>注意：这里的parallel默认值为”none”。曾经的”true”, “false”已经过时了，不建议使用。</p><p>1.Parallel=”methods”的意思是指TestNG会将method作为并发的元子单位，即每个method运行在自己的thread中。如果parallel=”tests”,则指会将test 作为并发的元子单位</p><p>2.Thread-count=”2”是指，运行的时候，并发度为2，同时会有两个线程在运行。</p><p>1、新建一个测试类，例如：Test1</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/jZePfuAplwJq9d2.png" alt="1232840-20191112095111389-1930640207.png"></p><p>2、参考代码</p><pre><code>package com.course.testng.multiThread;import org.testng.annotations.Test;/** * @author 北京-宏哥 *  * Java自动化测试框架-11 - TestNG之annotation与并发测试篇  * * 2016年05月22日 */public class Test1 {    @Test(groups = { &quot;t8&quot;})      public void aThreadPool() {          System.out.println(&quot;#ThreadA: &quot; +Thread.currentThread().getId());      }      @Test(groups = { &quot;t8&quot;})      public void bThreadPool() {          System.out.println(&quot;#ThreadB: &quot; +Thread.currentThread().getId());      }      @Test(groups = { &quot;t8&quot;})      public void cThreadPool() {          System.out.println(&quot;#ThreadC: &quot; +Thread.currentThread().getId());      }  }</code></pre><p>3、testng.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;&lt;suite name=&quot;Suite&quot;&gt;  &lt;test name=&quot;Test&quot; parallel=&quot;methods&quot; thread-count=&quot;2&quot;&gt;    &lt;classes&gt;      &lt;class name=&quot;com.course.testng.multiThread.Test1&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; &lt;!-- Test --&gt;&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><p>4、控制台输出结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/iUY2DJ53zyAGIxw.png" alt="1232840-20191112100319468-717012041.png"></p><p>5、修改testng.xml文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;&lt;suite name=&quot;Suite&quot;&gt;  &lt;test name=&quot;Test&quot; parallel=&quot;tests&quot; thread-count=&quot;2&quot;&gt;    &lt;classes&gt;      &lt;class name=&quot;com.course.testng.multiThread.Test1&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; &lt;!-- Test --&gt;&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><p>6、控制台页面输出(因为aThreadPool(),bThreadPool(),cThreadPool()都在一个test下面)</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/ZQj8EKp6cnwqTse.png" alt="1232840-20191112100540616-1149314269.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p> 　　  好了，今天关于TestNG之annotation与并发测试篇 ，就分享到这里。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-10</title>
      <link href="/2016/05/21/testng/"/>
      <url>/2016/05/21/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-10 - TestNG之测试结果篇（详细教程）</strong></p><h4 id="1-测试结果"><a href="#1-测试结果" class="headerlink" title="1.测试结果"></a>1.测试结果</h4><h5 id="1-1成功，失败和断言"><a href="#1-1成功，失败和断言" class="headerlink" title="1.1成功，失败和断言"></a>1.1成功，失败和断言</h5><p>测试被认为是成功的，如果它不引发任何异常完成，还是它扔的预期异常（请参阅文档expectedExceptions属性上找到的@Test注释）。</p><p>您的测试方法通常由可能引发异常的调用或各种断言（使用Java“ assert”关键字）组成。“断言”失败将触发AssertionErrorException，这反过来会将方法标记为失败（如果未看到断言错误，请记住在JVM上使用-ea）。</p><p>这是一个示例测试方法：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-10 - TestNG之 测试结果篇 * * 2019年11月9日 */@Testpublic void verifyLastName() {  assert &quot;Beust&quot;.equals(m_lastName) : &quot;Expected name Beust, for&quot; + m_lastName;}TestNG还包括JUnit的Assert类，该类使您可以对复杂对象执行断言：</code></pre><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-10 - TestNG之 测试结果篇 * * 2019年11月9日 */import static org.testng.AssertJUnit.*;//...@Testpublic void verify() {  assertEquals(&quot;Beust&quot;, m_lastName);}</code></pre><p>请注意，上面的代码使用静态导入，以便能够使用 assertEquals方法而不必在其类之前添加前缀。</p><h5 id="1-2日志和结果"><a href="#1-2日志和结果" class="headerlink" title="1.2日志和结果"></a>1.2日志和结果</h5><p>测试运行的结果在启动SuiteRunner时指定的目录中的index.html文件中创建。该文件指向包含整个测试运行结果的各种其他HTML和文本文件。</p><p>使用TestNG与监听器和报告器生成自己的报告非常容易：</p><p>侦听器实现org.testng.ITestListener接口，并在测试开始，通过，失败等时实时通知。</p><p>报告程序实现org.testng.IReporter接口，并在TestNG已运行所有套件时收到通知。IReporter实例接收描述整个测试运行的对象列表。</p><p>例如，如果要生成测试运行的PDF报告，则无需实时通知测试运行，因此您应该使用IReporter。如果您想编写测试的实时报告，例如带有进度条的GUI或在每次测试被调用时显示点（“。”）的文本报告程序（如下所述），则ITestListener是您的最好的选择。</p><blockquote><p>1.2.1日志侦听器</p></blockquote><p>这是一个显示“。”的侦听器。对于每个通过的测试，对于每个失败，都为“ F”，对于每个跳过均为“ S”：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-10 - TestNG之 测试结果篇 * * 2019年11月9日 */public class DotTestListener extends TestListenerAdapter {  private int m_count = 0;  @Override  public void onTestFailure(ITestResult tr) {    log(&quot;F&quot;);  }  @Override  public void onTestSkipped(ITestResult tr) {    log(&quot;S&quot;);  }  @Override  public void onTestSuccess(ITestResult tr) {    log(&quot;.&quot;);  }  private void log(String string) {    System.out.print(string);    if (++m_count % 40 == 0) {      System.out.println(&quot;&quot;);    }  }}</code></pre><p>在此示例中，我选择扩展TestListenerAdapter，该方法使用空方法实现ITestListener，因此我不必从我不感兴趣的接口中覆盖其他方法。您可以根据需要直接实现该接口。</p><p>这是我调用TestNG来使用此新侦听器的方法：</p><pre><code>java -classpath testng.jar;%CLASSPATH% org.testng.TestNG -listener org.testng.reporters.DotTestListener test\testng.xml和输出：.................................................................................................................................................................................................................................===============================================TestNG JDK 1.5Total tests run: 226, Failures: 0, Skips: 0===============================================</code></pre><p>请注意，当您使用-listener时，TestNG将自动确定您要使用的侦听器的类型。</p><blockquote><p>1.2.2日志记者</p></blockquote><p>该org.testng.IReporter接口只有一个方法：</p><p>public void generateReport(List<isuite> suites, String outputDirectory)</isuite></p><p>当所有套件都已运行时，TestNG将调用此方法，您可以检查其参数以访问刚刚完成的运行中的所有信息。</p><blockquote><p>1.2.3JUnitReports</p></blockquote><p>TestNG包含一个侦听器，该侦听器获取TestNG结果并输出一个XML文件，然后可以将其馈送到JUnitReport。 这是一个示例，以及创建此报告的ant任务：</p><pre><code>&lt;target name=&quot;reports&quot;&gt;  &lt;junitreport todir=&quot;test-report&quot;&gt;    &lt;fileset dir=&quot;test-output&quot;&gt;      &lt;include name=&quot;*/*.xml&quot;/&gt;    &lt;/fileset&gt;    &lt;report format=&quot;noframes&quot;  todir=&quot;test-report&quot;/&gt;  &lt;/junitreport&gt;&lt;/target&gt;</code></pre><p>注意：JDK 1.5和JUnitReports当前不兼容，无法使用框架版本，因此您需要指定“ noframes”才能使其正常工作。</p><blockquote><p>1.2.4-Reporter API</p></blockquote><p>如果需要日志应在生成的HTML报告中显示的消息，则可以使用org.testng.Reporter类：</p><p>Reporter.log （“已呼叫M3” ）；</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/1sESQOUNZy6BR57.png" alt="1232840-20191108110438678-2076949621.png"> <img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/12/WDkrnCdElwTP269.png" alt="1232840-20191108110515383-79351847.png">    </p><blockquote><p>1.2.5-XML报告</p></blockquote><p>TestNG提供了一个XML报告程序，用于捕获JUnit报告中不提供的TestNG特定信息。当用户的测试环境需要使用JUnit格式无法提供的具有TestNG特定数据的XML结果时，此功能特别有用。记者可以通过使用命令行注入TestNG的-reporter。</p><p>这是一个示例用法：-reporter org.testng.reporters.XMLReporter：generateTestResultAttributes = true，generateGroupsAttribute = true。</p><p>下表详细介绍了可以传递的所有选项。确保使用：</p><p>： -将报告者名称与其属性分开</p><p>= -分隔属性的键/值对</p><p>， -分隔多个键/值对<br>以下是此类报告器的输出示例：</p><pre><code>&lt;testng-results&gt;  &lt;suite name=&quot;Suite1&quot;&gt;    &lt;groups&gt;      &lt;group name=&quot;group1&quot;&gt;        &lt;method signature=&quot;com.test.TestOne.test2()&quot; name=&quot;test2&quot; class=&quot;com.test.TestOne&quot;/&gt;        &lt;method signature=&quot;com.test.TestOne.test1()&quot; name=&quot;test1&quot; class=&quot;com.test.TestOne&quot;/&gt;      &lt;/group&gt;      &lt;group name=&quot;group2&quot;&gt;        &lt;method signature=&quot;com.test.TestOne.test2()&quot; name=&quot;test2&quot; class=&quot;com.test.TestOne&quot;/&gt;      &lt;/group&gt;    &lt;/groups&gt;    &lt;test name=&quot;test1&quot;&gt;      &lt;class name=&quot;com.test.TestOne&quot;&gt;        &lt;test-method status=&quot;FAIL&quot; signature=&quot;test1()&quot; name=&quot;test1&quot; duration-ms=&quot;0&quot;              started-at=&quot;2007-05-28T12:14:37Z&quot; description=&quot;someDescription2&quot;              finished-at=&quot;2007-05-28T12:14:37Z&quot;&gt;          &lt;exception class=&quot;java.lang.AssertionError&quot;&gt;            &lt;short-stacktrace&gt;              &lt;![CDATA[                java.lang.AssertionError                ... Removed 22 stack frames              ]]&gt;            &lt;/short-stacktrace&gt;          &lt;/exception&gt;        &lt;/test-method&gt;        &lt;test-method status=&quot;PASS&quot; signature=&quot;test2()&quot; name=&quot;test2&quot; duration-ms=&quot;0&quot;              started-at=&quot;2007-05-28T12:14:37Z&quot; description=&quot;someDescription1&quot;              finished-at=&quot;2007-05-28T12:14:37Z&quot;&gt;        &lt;/test-method&gt;        &lt;test-method status=&quot;PASS&quot; signature=&quot;setUp()&quot; name=&quot;setUp&quot; is-config=&quot;true&quot; duration-ms=&quot;15&quot;              started-at=&quot;2007-05-28T12:14:37Z&quot; finished-at=&quot;2007-05-28T12:14:37Z&quot;&gt;        &lt;/test-method&gt;      &lt;/class&gt;    &lt;/test&gt;  &lt;/suite&gt;&lt;/testng-results&gt;</code></pre><p>该报告程序与其他默认侦听器一起注入，因此默认情况下您可以获得这种类型的输出。侦听器提供了一些属性，可以对报告器进行调整以满足您的需求。下表包含这些属性的列表，并附有简短说明：</p><table><thead><tr><th>Property</th><th>Comment</th><th>Default value</th></tr></thead><tbody><tr><td>outputDirectory</td><td>A String indicating the directory where should the XML files be output.</td><td>The TestNG output directory</td></tr><tr><td>timestampFormat</td><td>Specifies the format of date fields that are generated by this reporter</td><td>yyyy-MM-dd’T’HH:mm:ss’Z’</td></tr><tr><td>fileFragmentationLevel</td><td>An integer having the values 1, 2 or 3, indicating the way that the XML files are generated:1 - will generate all the results in one file.    2 - each suite is generated in a separate XML file that is linked to the main file.    3 - same as 2 plus separate files for test-cases that are referenced from the suite files.</td><td>1</td></tr><tr><td>splitClassAndPackageNames</td><td>This boolean specifies the way that class names are generated for the &lt;class&gt; element. For example, you will get &lt;class class=”com.test.MyTest”&gt; for false and &lt;class class=”MyTest” package=”com.test”&gt; for true.</td><td>false</td></tr><tr><td>generateGroupsAttribute</td><td>A boolean indicating if a groups attribute should be generated for the &lt;test-method&gt; element. This feature aims at providing a straight-forward method of retrieving the groups that include a test method without having to surf through the &lt;group&gt; elements.</td><td>false</td></tr><tr><td>generateTestResultAttributes</td><td>A boolean indicating if an &lt;attributes&gt; tag should be generated for each &lt;test-method&gt; element, containing the test result attributes (See ITestResult.setAttribute() about setting test result attributes). Each attribute toString() representation will be written in a &lt;attribute name=”[attribute name]”&gt; tag.</td><td>false</td></tr><tr><td>stackTraceOutputMethod</td><td>Specifies the type of stack trace that is to be generated for exceptions and has the following values:<br>   0 - no stacktrace (just Exception class and message).<br>   1 - a short version of the stack trace keeping just a few lines from the top<br>   2 - the complete stacktrace with all the inner exceptions<br>   3 - both short and long stacktrace</td><td>2</td></tr><tr><td>generateDependsOnMethods</td><td>Use this attribute to enable/disable the generation of a depends-on-methods attribute for the &lt;test-method&gt; element.</td><td>true</td></tr><tr><td>generateDependsOnGroups</td><td>Enable/disable the generation of a depends-on-groups attribute for the &lt;test-method&gt; element.</td><td>true</td></tr></tbody></table><p>为了配置此报告程序，可以在命令行中使用-reporter选项，也可以将Ant 任务与嵌套的<reporter>元素一起使用。对于其中的每个，您都必须指定org.testng.reporters.XMLReporter类。请注意，您无法配置内置报告器，因为该报告器仅使用默认设置。如果只需要</reporter></p><p>带有自定义设置的XML报告，则必须使用两种方法之一手动添加它并禁用默认侦听器。</p><blockquote><p>1.2.6-TestNG退出代码</p></blockquote><p>当TestNG完成执行时，它将退出并返回代码。</p><p>可以检查此返回码以了解故障的性质（如果有的话）。</p><p>下表总结了TestNG当前使用的不同退出代码。</p><table><thead><tr><th>FailedWithinSuccess</th><th><strong>Skipped</strong></th><th><strong>Failed</strong></th><th><strong>Status Code</strong></th><th><strong>Remarks</strong></th></tr></thead><tbody><tr><td>No</td><td>No</td><td>No</td><td>0</td><td>Passed tests</td></tr><tr><td>No</td><td>No</td><td>Yes</td><td>1</td><td>Failed tests</td></tr><tr><td>No</td><td>Yes</td><td>No</td><td>2</td><td>Skipped tests</td></tr><tr><td>No</td><td>Yes</td><td>Yes</td><td>3</td><td>Skipped/Failed tests</td></tr><tr><td>Yes</td><td>No</td><td>No</td><td>4</td><td>FailedWithinSuccess tests</td></tr><tr><td>Yes</td><td>No</td><td>Yes</td><td>5</td><td>FailedWithinSuccess/Failed tests</td></tr><tr><td>Yes</td><td>Yes</td><td>No</td><td>6</td><td>FailedWithinSuccess/Skipped tests</td></tr><tr><td>Yes</td><td>Yes</td><td>Yes</td><td>7</td><td>FailedWithinSuccess/Skipped/Failed tests</td></tr></tbody></table><h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2.-小结"></a>2.-小结</h4><p>  好了，今天关于TestNG之测试结果，就分享到这里。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-09</title>
      <link href="/2016/05/20/testng/"/>
      <url>/2016/05/20/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-09 - TestNG之依赖注入篇 （详细教程）</strong></p><h4 id="1-依赖注入"><a href="#1-依赖注入" class="headerlink" title="1.依赖注入"></a>1.依赖注入</h4><p>TestNG支持两种不同类型的依赖项注入：本机（由TestNG本身执行）和外部（由诸如Guice的依赖项注入框架执行）。</p><h5 id="1-1本机依赖项注入"><a href="#1-1本机依赖项注入" class="headerlink" title="1.1本机依赖项注入"></a>1.1本机依赖项注入</h5><p>TestNG允许您在方法中声明其他参数。发生这种情况时，TestNG将自动用正确的值填充这些参数。依赖注入可以在以下地方使用：</p><p>任何@Before方法或@Test方法都可以声明ITestContext类型的参数。<br>任何@AfterMethod方法都可以声明ITestResult类型的参数，该参数将反映刚刚运行的测试方法的结果。<br>任何@Before和@After方法（@BeforeSuite和@AfterSuite除外）都可以声明XmlTest类型的参数，该参数包含当前的<test>标记。<br>任何@BeforeMethod（和@AfterMethod）都可以声明java.lang.reflect.Method类型的参数 。此参数将接收此@BeforeMethod完成之后（或在为@AfterMethod运行的方法之后）将调用的测试方法。<br>任何@BeforeMethod都可以声明Object []类型的参数。此参数将接收即将馈入即将到来的测试方法的参数列表，该参数列表可以由TestNG注入，例如java.lang.reflect.Method或来自@DataProvider。<br>任何@DataProvider都可以声明ITestContext或java.lang.reflect.Method类型的参数 。后一个参数将接收将要调用的测试方法。<br>您可以使用@NoInjection批注关闭注入：</test></p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */public class NoInjectionTest {  @DataProvider(name = &quot;provider&quot;)  public Object[][] provide() throws Exception {      return new Object[][] { { CC.class.getMethod(&quot;f&quot;) } };  }  @Test(dataProvider = &quot;provider&quot;)  public void withoutInjection(@NoInjection Method m) {      Assert.assertEquals(m.getName(), &quot;f&quot;);  }  @Test(dataProvider = &quot;provider&quot;)  public void withInjection(Method m) {      Assert.assertEquals(m.getName(), &quot;withInjection&quot;);  }}</code></pre><p>下表总结了可以为各种TestNG注释本地注入的参数类型：</p><table><thead><tr><th><strong>Annotation</strong></th><th><strong>ITestContext</strong></th><th><strong>XmlTest</strong></th><th><strong>Method</strong></th><th><strong>Object[]</strong></th><th><strong>ITestResult</strong></th></tr></thead><tbody><tr><td>BeforeSuite</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>BeforeTest</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>BeforeGroups</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>BeforeClass</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>BeforeMethod</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Test</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>DataProvider</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>AfterMethod</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>AfterClass</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>AfterGroups</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>AfterTest</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>AfterSuite</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr></tbody></table><h5 id="1-2Guice依赖注入"><a href="#1-2Guice依赖注入" class="headerlink" title="1.2Guice依赖注入"></a>1.2Guice依赖注入</h5><p>如果您使用Guice，TestNG为您提供了一种简单的方法，即可通过Guice模块注入测试对象：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */@Guice(modules = GuiceExampleModule.class)public class GuiceTest extends SimpleBaseTest {  @Inject  ISingleton m_singleton;  @Test  public void singletonShouldWork() {    m_singleton.doSomething();  }}</code></pre><p>在此示例中，预计GuiceExampleModule会将接口ISingleton绑定到一些具体的类：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */public class GuiceExampleModule implements Module {  @Override  public void configure(Binder binder) {    binder.bind(ISingleton.class).to(ExampleSingleton.class).in(Singleton.class);  }}</code></pre><p>如果需要更大的灵活性来指定应使用哪些模块实例化测试类，则可以指定模块工厂：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */@Guice(moduleFactory = ModuleFactory.class)public class GuiceModuleFactoryTest {  @Inject  ISingleton m_singleton;  @Test  public void singletonShouldWork() {    m_singleton.doSomething();  }}</code></pre><p>模块工厂需要实现接口IModuleFactory：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */public interface IModuleFactory { /**   * @param context The current test context   * @param testClass The test class   *   * @return The Guice module that should be used to get an instance of this   * test class.   */  Module createModule(ITestContext context, Class&lt;?&gt; testClass);}</code></pre><p>您的工厂将被传递TestNG需要实例化的测试上下文和测试类的实例。您的createModule方法应返回一个Guice模块，它将知道如何实例化此测试类。您可以使用测试上下文来查找有关您的环境的更多信息，例如在testng.xml中指定的参数等。通过父模块和guice-stage套件参数，您将获得更大的灵活性和Guice功能。 guice-stage可让您选择用于创建父注射器的Stage。默认值是DEVELOPMENT。其他允许的值为PRODUCTION和TOOL。这是在test.xml文件中定义父模块的方法：</p><pre><code>&lt;suite parent-module=&quot;com.example.SuiteParenModule&quot; guice-stage=&quot;PRODUCTION&quot;&gt;&lt;/suite&gt;</code></pre><p>对于给定的套件，TestNG将只创建一次此模块。还将使用该模块获取特定于测试的Guice模块和模块工厂的实例，然后将为每个测试类创建子注入器。通过这种方法，您可以在父模块中声明所有公共绑定，也可以在模块和模块工厂中注入在父模块中声明的绑定。这是此功能的示例：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */package com.example;public class ParentModule extends AbstractModule {  @Override  protected void conigure() {    bind(MyService.class).toProvider(MyServiceProvider.class);    bind(MyContext.class).to(MyContextImpl.class).in(Singleton.class);  }}</code></pre><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */package com.example;public class TestModule extends AbstractModule {  private final MyContext myContext;  @Inject  TestModule(MyContext myContext) {    this.myContext = myContext  }  @Override  protected void configure() {    bind(MySession.class).toInstance(myContext.getSession());  }}</code></pre><pre><code>&lt;suite parent-module=&quot;com.example.ParentModule&quot;&gt;&lt;/suite&gt;</code></pre><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */package com.example;@Test@Guice(modules = TestModule.class)public class TestClass {  @Inject  MyService myService;  @Inject  MySession mySession;  public void testServiceWithSession() {    myService.serve(mySession);  }}</code></pre><p>如您所见，ParentModule为MyService和MyContext类声明了绑定。然后使用构造函数注入将MyContext注入到TestModule类中，该类也声明对MySession的绑定。然后将测试XML文件中的parent-module设置为ParentModule类，这将启用在TestModule中的注入。稍后在TestClass中，您会看到两次注入：* MyService-绑定取自ParentModule * MySession-绑定取自TestModule此配置可确保您使用同一会话实例运行该套件中的所有测试，MyContextImpl对象每个套件仅创建一次，这使您可以为套件中的所有测试配置通用环境状态。</p><h4 id="2-侦听方法调用"><a href="#2-侦听方法调用" class="headerlink" title="2.侦听方法调用"></a>2.侦听方法调用</h4><p>每当TestNG即将调用测试（用@Test注释）或配置（用@Before或@After注释中的任何一个注释）方法时 ，侦听器IInvokedMethodListener都会通知您。您需要实现以下接口：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */public interface IInvokedMethodListener extends ITestNGListener {  void beforeInvocation(IInvokedMethod method, ITestResult testResult);  void afterInvocation(IInvokedMethod method, ITestResult testResult);}</code></pre><p>并将其声明为侦听器，如有关TestNG侦听器的部分所述。 </p><h4 id="3-覆盖测试方法"><a href="#3-覆盖测试方法" class="headerlink" title="3.覆盖测试方法"></a>3.覆盖测试方法</h4><p>TestNG允许您重写并可能跳过测试方法的调用。一个有用的例子是，如果您需要使用特定的安全管理器来测试方法。您可以通过提供实现IHookable的侦听器来实现此目的。</p><p>这是JAAS的示例：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */public class MyHook implements IHookable {  public void run(final IHookCallBack icb, ITestResult testResult) {    // Preferably initialized in a @Configuration method    mySubject = authenticateWithJAAs();    Subject.doAs(mySubject, new PrivilegedExceptionAction() {      public Object run() {        icb.callback(testResult);      }    };  }}</code></pre><h4 id="4-变更套件（或）测试"><a href="#4-变更套件（或）测试" class="headerlink" title="4.变更套件（或）测试"></a>4.变更套件（或）测试</h4><p>有时，您可能只需要在运行时更改套件xml中的套件（或）测试标签，而不必更改套件文件的内容。</p><p>一个典型的例子就是尝试利用现有的套件文件，并尝试使用它在“被测应用程序”上模拟负载测试。至少您最终将多次复制&lt;test&gt;标记的内容，并创建一个新的套件xml文件并使用。但这似乎并没有太大的规模。</p><p>TestNG允许您在运行时通过侦听器更改套件xml文件中的套件（或）测试标签。您可以通过提供实现IAlterSuiteListener的侦听器来实现此目的。请参考“ 监听器”部分以了解监听器。</p><p>这是一个示例，显示套件名称在运行时如何更改：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-09 - TestNG之 依赖注入篇 * * 2019年11月8日 */public class AlterSuiteNameListener implements IAlterSuiteListener {    @Override    public void alter(List&lt;XmlSuite&gt; suites) {        XmlSuite suite = suites.get(0);        suite.setName(getClass().getSimpleName());    }}</code></pre><p>只能通过以下两种方式之一添加此侦听器：</p><p>通过套件xml文件中的&lt;listeners&gt;标记。<br>通过服务加载程序<br>不能使用@Listeners批注将此侦听器添加到执行中。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>  好了，今天关于TestNG之依赖注入，就分享到这里。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-08</title>
      <link href="/2016/05/19/testng/"/>
      <url>/2016/05/19/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-08 - TestNG之并行性和超时篇 （详细教程）（详细教程）</strong></p><h4 id="1-并行性和超时"><a href="#1-并行性和超时" class="headerlink" title="1.并行性和超时"></a>1.并行性和超时</h4><p>您可以指示TestNG以各种方式在单独的线程中运行测试。</p><p>可以通过在suite标签中使用 parallel 属性来让测试方法运行在不同的线程中。这个属性可以带有如下这样的值：</p><h4 id="2-并行套件（suites）"><a href="#2-并行套件（suites）" class="headerlink" title="2.并行套件（suites）"></a>2.并行套件（suites）</h4><p>如果您正在运行多个套件文件（例如“ java org.testng.TestNG testng1.xml testng2.xml”），并且希望每个套件在单独的线程中运行，则这个很有用。您可以使用以下命令行标志来指定线程池的大小：</p><p>java org.testng.TestNG -suitethreadpoolsize 3 testng1.xml testng2.xml testng3.xml<br>相应的ant任务名称为suitethreadpoolsize。</p><h4 id="3-并行测试，类和方法"><a href="#3-并行测试，类和方法" class="headerlink" title="3.并行测试，类和方法"></a>3.并行测试，类和方法</h4><p>在并行于&lt;suite&gt;标记属性可以取下列值之一：</p><pre><code>&lt;suite name=&quot;My suite&quot; parallel=&quot;methods&quot; thread-count=&quot;5&quot;&gt;&lt;suite name=&quot;My suite&quot; parallel=&quot;tests&quot; thread-count=&quot;5&quot;&gt;&lt;suite name=&quot;My suite&quot; parallel=&quot;classes&quot; thread-count=&quot;5&quot;&gt;&lt;suite name=&quot;My suite&quot; parallel=&quot;instances&quot; thread-count=&quot;5&quot;&gt;</code></pre><p>parallel =“ methods”：TestNG将在单独的线程中运行所有测试方法。依赖方法也将在单独的线程中运行，但是它们将遵循您指定的顺序。<br>parallel =“ tests”：TestNG将在同一线程中的同一<test>标记中运行所有方法，但是每个<test>标记将位于单独的线程中。这样，您就可以将所有不是线程安全的类归入同一个<test>中，并确保它们都将在同一线程中运行，同时利用TestNG使用尽可能多的线程来运行测试。<br>平行=“类”：TestNG的将运行在相同的线程相同的类的所有方法，但每个类将在单独的线程中运行。<br>parallel =“ instances”：TestNG将在同一线程中的同一实例中运行所有方法，但是在两个不同实例中的两个方法将在不同线程中运行。<br>此外，属性 thread-count允许您指定应为此执行分配多少个线程。<br>注意：@Test属性timeOut在并行和非并行模式下均可工作。<br>您还可以指定从不同的线程调用@Test方法。您可以使用属性threadPoolSize来实现以下结果：</test></test></test></p><pre><code>@Test(threadPoolSize = 3, invocationCount = 10,  timeOut = 10000)public void testServer() {</code></pre><p>在此示例中，将从三个不同的线程调用函数testServer十次。此外，十秒的超时保证没有任何线程将永远在该线程上阻塞。</p><h4 id="4-重新运行失败的测试"><a href="#4-重新运行失败的测试" class="headerlink" title="4.重新运行失败的测试"></a>4.重新运行失败的测试</h4><p>每当套件中的测试失败时，TestNG都会在输出目录中创建一个名为testng-failed.xml的文件。此XML文件包含必要的信息，以仅重新运行失败的这些方法，从而使您可以快速重现失败，而不必运行整个测试。因此，典型的会话如下所示：</p><pre><code>java -classpath testng.jar;%CLASSPATH% org.testng.TestNG -d test-outputs testng.xmljava -classpath testng.jar;%CLASSPATH% org.testng.TestNG -d test-outputs test-outputs\testng-failed.xml</code></pre><p>请注意，testng-failed.xml将包含所有必需的依赖方法，因此可以确保您运行失败的方法而不会出现任何SKIP失败。</p><p>有时，您可能希望TestNG在测试失败时自动重试。在这种情况下，您可以使用重试分析器。当您将重试分析器绑定到测试时，TestNG会自动调用重试分析器，以确定TestNG是否可以再次重试测试用例，以查看是否刚刚通过的测试现在通过。这是使用重试分析器的方法：</p><p>构建接口org.testng.IRetryAnalyzer的实现<br>将此实现绑定到@Test注释，例如@Test（retryAnalyzer = LocalRetry.class）<br>以下是重试分析器的示例实现，该示例最多重试一次测试三次。</p><pre><code>import org.testng.IRetryAnalyzer;import org.testng.ITestResult;/** * @author 北京-宏哥 *  * Java自动化测试框架-08 - TestNG之 TestNG之并行性和超时篇 * * 2019年11月7日 */public class MyRetry implements IRetryAnalyzer {  private int retryCount = 0;  private static final int maxRetryCount = 3;  @Override  public boolean retry(ITestResult result) {    if (retryCount &lt; maxRetryCount) {      retryCount++;      return true;    }    return false;  }}</code></pre><pre><code>import org.testng.Assert;import org.testng.annotations.Test;/** * @author 北京-宏哥 *  * Java自动化测试框架-08 - TestNG之 TestNG之并行性和超时篇 * * 2019年11月7日 */public class TestclassSample {  @Test(retryAnalyzer = MyRetry.class)  public void test2() {    Assert.fail();  }}</code></pre><h4 id="5-JUnit测试"><a href="#5-JUnit测试" class="headerlink" title="5.JUnit测试"></a>5.JUnit测试</h4><p>TestNG可以运行JUnit 3和JUnit 4测试。所有你需要做的就是把JUnit的jar文件在类路径中，在指定JUnit测试类，testng.classNames 属性和设置testng.junit属性设置为true：</p><pre><code>&lt;test name=&quot;Test1&quot; junit=&quot;true&quot;&gt;  &lt;classes&gt;    &lt;!-- ... --&gt;</code></pre><p>在这种情况下，TestNG的行为类似于JUnit，这取决于在类路径上找到的JUnit版本：</p><p>JUnit 3：<br>您的课程中所有以test *开头的方法都将运行<br>如果您的测试类上有一个方法setUp（），它将在每个测试方法之前调用<br>如果您的测试类上有一个方法tearDown（），它将在每个测试方法之后被调用<br>如果您的测试类包含方法suite（），则将调用此方法返回的所有测试<br>JUnit 4：<br>TestNG将使用org.junit.runner.JUnitCore运行程序运行测试</p><h4 id="6-以编程的方式运行testng"><a href="#6-以编程的方式运行testng" class="headerlink" title="6.以编程的方式运行testng"></a>6.以编程的方式运行testng</h4><p>您可以从自己的程序中轻松调用TestNG：</p><pre><code>TestListenerAdapter tla = new TestListenerAdapter();TestNG testng = new TestNG();testng.setTestClasses(new Class[] { Run2.class });testng.addListener(tla);testng.run();</code></pre><p>本示例创建一个TestNG对象并运行测试类Run2。它还添加了一个TestListener。您可以使用适配器类org.testng.TestListenerAdapter或自己实现org.testng.ITestListener。此接口包含各种回调方法，可让您跟踪测试的开始时间，成功时间，失败时间等。</p><p>同样，您可以在testng.xml文件上调用TestNG，也可以自己创建一个虚拟的testng.xml文件。为此，您可以使用发现包org.testng.xml的类： XmlClass，XmlTest等。这些类中的每一个都对应于它们的XML标记对应物。</p><p>例如，假设您要创建以下虚拟文件：</p><pre><code>&lt;suite name=&quot;TmpSuite&quot; &gt;  &lt;test name=&quot;TmpTest&quot; &gt;    &lt;classes&gt;      &lt;class name=&quot;test.failures.Child&quot;  /&gt;    &lt;classes&gt;    &lt;/test&gt;&lt;/suite&gt;</code></pre><p>您将使用以下代码：</p><pre><code>XmlSuite suite = new XmlSuite();suite.setName(&quot;TmpSuite&quot;);XmlTest test = new XmlTest(suite);test.setName(&quot;TmpTest&quot;);List&lt;XmlClass&gt; classes = new ArrayList&lt;XmlClass&gt;();classes.add(new XmlClass(&quot;test.failures.Child&quot;));test.setXmlClasses(classes) ;</code></pre><p>然后，您可以将此XmlSuite传递给TestNG：</p><pre><code>List&lt;XmlSuite&gt; suites = new ArrayList&lt;XmlSuite&gt;();suites.add(suite);TestNG tng = new TestNG();tng.setXmlSuites(suites);tng.run();</code></pre><p>有兴趣的：请参阅JavaDocs了解整个API。</p><h4 id="7-BeanShell和高级组选择"><a href="#7-BeanShell和高级组选择" class="headerlink" title="7.BeanShell和高级组选择"></a>7.BeanShell和高级组选择</h4><p>如果testng.xml中的&lt;include&gt;和&lt;exclude&gt;标记不足以满足您的需要，则可以使用BeanShell表达式来确定是否应在测试运行中包括某种测试方法。您可以在&lt;test&gt;标记下指定此表达式：</p><pre><code>&lt;test name=&quot;BeanShell test&quot;&gt;   &lt;method-selectors&gt;     &lt;method-selector&gt;       &lt;script language=&quot;beanshell&quot;&gt;&lt;![CDATA[         groups.containsKey(&quot;test1&quot;)       ]]&gt;&lt;/script&gt;     &lt;/method-selector&gt;   &lt;/method-selectors&gt;  &lt;!-- ... --&gt;</code></pre><p>当&lt;SCRIPT&gt;标记中发现的testng.xml，TestNG的将忽略随后的&lt;包括&gt;和&lt;排除&gt;在当前组和方法的&lt;试验&gt;标记：你的BeanShell的表达将是决定是否一个测试方法的唯一方式是否包含在内。</p><p>以下是有关BeanShell脚本的其他信息：</p><p>它必须返回一个布尔值。除了此约束之外，还允许使用任何有效的BeanShell代码（例如，您可能希望在工作日返回true，在周末返回false，这将允许您根据日期以不同的方式运行测试）<br>为了方便起见，TestNG定义了以下变量：</p><pre><code>1、java.lang.reflect.Method method：当前的测试方法。2、org.testng.ITestNGMethod testngMethod：当前测试方法的描述。3、java.util.Map &lt;String，String&gt; groups：当前测试方法所属的组的映射。</code></pre><p>您可能希望用CDATA声明包围表达式（如上所示），以避免冗长的保留XML字符引用。</p><h4 id="8-Annotation-Transformers"><a href="#8-Annotation-Transformers" class="headerlink" title="8.Annotation Transformers"></a>8.Annotation Transformers</h4><p>TestNG允许您在运行时修改所有注释的内容。如果源代码中的注释大多数时候都是正确的，则这特别有用，但是在某些情况下，您想覆盖它们的值。</p><p>为了实现此目的，您需要使用注释转换器。</p><p>Annotation Transformer是一个实现以下接口的类：</p><pre><code>public interface IAnnotationTransformer {  /**   * This method will be invoked by TestNG to give you a chance   * to modify a TestNG annotation read from your test classes.   * You can change the values you need by calling any of the   * setters on the ITest interface.   *   * Note that only one of the three parameters testClass,   * testConstructor and testMethod will be non-null.   *   * @param annotation The annotation that was read from your   * test class.   * @param testClass If the annotation was found on a class, this   * parameter represents this class (null otherwise).   * @param testConstructor If the annotation was found on a constructor,   * this parameter represents this constructor (null otherwise).   * @param testMethod If the annotation was found on a method,   * this parameter represents this method (null otherwise).   */  public void transform(ITest annotation, Class testClass,      Constructor testConstructor, Method testMethod);}</code></pre><p>像所有其他TestNG侦听器一样，您可以在命令行或使用ant来指定此类：</p><pre><code>java org.testng.TestNG -listener MyTransformer testng.xml</code></pre><p>或以编程方式：</p><pre><code>TestNG tng = new TestNG();tng.setAnnotationTransformer(new MyTransformer());// ...</code></pre><p>调用 方法transform（）时，可以在TestNG继续进行之前，调用ITest测试参数上的任何设置方法来更改其值。</p><p>例如，这是您如何重写属性invocationCount的方法，但仅在其中一个测试类的测试方法invoke（）上：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-08 - TestNG之 TestNG之并行性和超时篇 * * 2019年11月7日 */public class MyTransformer implements IAnnotationTransformer {  public void transform(ITest annotation, Class testClass,      Constructor testConstructor, Method testMethod)  {    if (&quot;invoke&quot;.equals(testMethod.getName())) {      annotation.setInvocationCount(5);    }  }}</code></pre><p>IAnnotationTransformer仅允许您修改@Test注释。如果需要修改另一个TestNG批注（配置批注@Factory或@DataProvider），请使用IAnnotationTransformer2。</p><h4 id="9-方法拦截器"><a href="#9-方法拦截器" class="headerlink" title="9.方法拦截器"></a>9.方法拦截器</h4><p>一旦TestNG 计算好了测试方法会以怎样的顺序调用，那么这些方法就会分为两组：</p><p>1.按照顺序运行的方法。这里所有的方法都有相关的依赖，并且所有这些方法按照特定顺序运行。</p><p>2.不定顺序运行的方法。这里的方法不属于第一个类别。方法的运行顺序是随机的，下一个说不准是什么（尽管如此，默认情况下TestNG会尝试通过类来组织方法）。</p><p>为了能够让你更好的控制第二种类别，TestNG定义如下接口：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-08 - TestNG之 TestNG之并行性和超时篇 * * 2019年11月7日 */public interface IMethodInterceptor {  List&lt;IMethodInstance&gt; intercept(List&lt;IMethodInstance&gt; methods, ITestContext context);}</code></pre><p>方法中叫做methods的那个列表参数包含了所有以不定序运行的方法。你的 intercept 方法也要返回一个 IMethodInstance列表，它可能是下面情况之一：</p><p>1.内容与参数中接收的一致，但是顺序不同</p><p>2.一组 IMethodInstance 对象</p><p>3.更大的一组 IMethodInstance对象</p><p>一旦你定义了拦截器，就把它传递个TestNG，用下面的方式：</p><pre><code>java -classpath &quot;testng-jdk15.jar:test/build&quot; org.testng.TestNG -listener test.methodinterceptors.NullMethodInterceptor   -testclass test.methodinterceptors.FooTest</code></pre><p>有关等效的ant语法，请参见ant文档中的listeners属性。</p><p>例如，这是一个方法拦截器，它将对方法进行重新排序，以便始终首先运行属于“快速”组的测试方法：</p><pre><code>/** * @author 北京-宏哥 *  * Java自动化测试框架-08 - TestNG之 TestNG之并行性和超时篇 * * 2019年11月7日 */public List&lt;IMethodInstance&gt; intercept(List&lt;IMethodInstance&gt; methods, ITestContext context) {  List&lt;IMethodInstance&gt; result = new ArrayList&lt;IMethodInstance&gt;();  for (IMethodInstance m : methods) {    Test test = m.getMethod().getConstructorOrMethod().getAnnotation(Test.class);    Set&lt;String&gt; groups = new HashSet&lt;String&gt;();    for (String group : test.groups()) {      groups.add(group);    }    if (groups.contains(&quot;fast&quot;)) {      result.add(0, m);    }    else {      result.add(m);    }  }  return result;}</code></pre><h4 id="10-TestNG侦听器"><a href="#10-TestNG侦听器" class="headerlink" title="10.TestNG侦听器"></a>10.TestNG侦听器</h4><p>有几个接口可让您修改TestNG的行为。这些接口广泛地称为“ TestNG侦听器”。以下是一些听众：</p><pre><code>IAnnotationTransformer（doc，javadoc）IAnnotationTransformer2（doc，javadoc）IHookable（doc，javadoc）IInvokedMethodListener（doc，javadoc）IMethodInterceptor（doc，javadoc）IReporter（doc，javadoc）ISuiteListener（doc，javadoc）ITestListener（doc，javadoc）</code></pre><p>当实现这些接口之一时，可以通过以下两种方式之一让TestNG知道它：</p><p>在命令行上使用-listener。<br>将&lt;listeners&gt;与ant一起使用。<br>在您的testng.xml文件中使用&lt;listeners&gt; 。<br>在任何测试类上使用@Listeners批注。<br>使用ServiceLoader。</p><h4 id="11-使用的testng-xml或Java的指定监听器"><a href="#11-使用的testng-xml或Java的指定监听器" class="headerlink" title="11.使用的testng.xml或Java的指定监听器"></a>11.使用的testng.xml或Java的指定监听器</h4><p>这是在testng.xml文件中定义侦听器的方法：</p><pre><code>&lt;suite&gt;  &lt;listeners&gt;    &lt;listener class-name=&quot;com.example.MyListener&quot; /&gt;    &lt;listener class-name=&quot;com.example.MyMethodInterceptor&quot; /&gt;  &lt;/listeners&gt;...</code></pre><p>或者，如果您更喜欢用Java定义这些侦听器，则：</p><pre><code>@Listeners({ com.example.MyListener.class, com.example.MyMethodInterceptor.class })public class MyTest {  // ...}</code></pre><p>该@Listeners注释可以包含任何扩展类org.testng.ITestNGListener 除了 IAnnotationTransformer和IAnnotationTransformer2。原因是这些侦听器需要在过程的早期就知道，以便TestNG可以使用它们来重写您的注释，因此您需要在testng.xml文件中指定这些侦听器。</p><p>请注意，@ Listeners批注将应用于您的整个套件文件，就像您在testng.xml文件中指定的一样。如果要限制其范围（例如，仅在当前类上运行），则侦听器中的代码可以首先检查将要运行的测试方法，然后决定要做什么。这是可以完成的。</p><p>1、首先定义一个新的自定义注释，可用于指定此限制：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target ({ElementType.TYPE})public @interface DisableListener {}</code></pre><p>2、在常规侦听器中添加如下所示的编辑检查：</p><pre><code>public void beforeInvocation(IInvokedMethod iInvokedMethod, ITestResult iTestResult) {  ConstructorOrMethod consOrMethod =iInvokedMethod.getTestMethod().getConstructorOrMethod();  DisableListener disable = consOrMethod.getMethod().getDeclaringClass().getAnnotation(DisableListener.class);  if (disable != null) {    return;  }  // else resume your normal operations}</code></pre><p>3、注释测试类，其中不调用侦听器：</p><pre><code>@DisableListener@Listeners({ com.example.MyListener.class, com.example.MyMethodInterceptor.class })public class MyTest {  // ...}</code></pre><h4 id="12-使用的ServiceLoader指定侦听器"><a href="#12-使用的ServiceLoader指定侦听器" class="headerlink" title="12.使用的ServiceLoader指定侦听器"></a>12.使用的ServiceLoader指定侦听器</h4><p>最后，JDK提供了一种非常优雅的机制，可以通过ServiceLoader类在类路径上指定接口的实现。<br>使用ServiceLoader，您要做的就是创建一个包含侦听器和一些配置文件的jar文件，在运行TestNG时将该jar文件放在类路径中，TestNG会自动找到它们。</p><p>这是其工作方式的具体示例。</p><p>让我们从创建一个监听器开始（任何TestNG监听器都可以工作）：</p><pre><code>package test.tmp;public class TmpSuiteListener implements ISuiteListener {  @Override  public void onFinish(ISuite suite) {    System.out.println(&quot;Finishing&quot;);  }  @Override  public void onStart(ISuite suite) {    System.out.println(&quot;Starting&quot;);  }}</code></pre><p>编译该文件，然后在META-INF / services / org.testng.ITestNGListener位置创建一个文件，该文件将命名您想要此接口的实现。<br>您应该以以下目录结构结束，只有两个文件：</p><pre><code>$ tree|____META-INF| |____services| | |____org.testng.ITestNGListener|____test| |____tmp| | |____TmpSuiteListener.class$ cat META-INF/services/org.testng.ITestNGListenertest.tmp.TmpSuiteListener</code></pre><p>创建此目录的jar：</p><pre><code>$ jar cvf ../sl.jar .added manifestignoring entry META-INF/adding: META-INF/services/(in = 0) (out= 0)(stored 0%)adding: META-INF/services/org.testng.ITestNGListener(in = 26) (out= 28)(deflated -7%)adding: test/(in = 0) (out= 0)(stored 0%)adding: test/tmp/(in = 0) (out= 0)(stored 0%)adding: test/tmp/TmpSuiteListener.class(in = 849) (out= 470)(deflated 44%)</code></pre><p>接下来，在调用TestNG时，将此jar文件放在类路径中：</p><pre><code>$ java -classpath sl.jar:testng.jar org.testng.TestNG testng-single.yamlStartingf2 11 2PASSED: f2(&quot;2&quot;)Finishing</code></pre><p>通过此机制，您只需将jar文件添加到类路径即可将相同的一组侦听器应用于整个组织，而不是要求每个开发人员都记住在其testng.xml文件中指定这些侦听器。</p><h4 id="13-小结"><a href="#13-小结" class="headerlink" title="13.小结"></a>13.小结</h4><p>　　好了，今天关于TestNG之并行性和超时，就分享到这里。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-07</title>
      <link href="/2016/05/18/testng/"/>
      <url>/2016/05/18/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-07 - TestNG之Factory篇 - 欢快畅游梦幻工厂（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　最近忙着装修博客园，没时间更新文章，今天终于抽出时间把上次写的一半的文章给写完了，新的博客园风格，希望大家喜欢。今天继续介绍testng的相关知识–工厂。</p><p>工厂允许你动态的创建测试。例如，假设你需要创建一个测试方法，并用它来多次访问一个web页面，而且每次都带有不同的参数：</p><p>@Factory注解从字面意思上来讲就是采用工厂的方法来创建测试数据并配合完成测试，其主要应对的场景是：对于某一个测试用例或方法，我们需要输入多个测试数据进行测试，并且这些测试数据可以是有一定关系(可以通过代码控制)，此时，我们就可以把自动化或者手动测试时的遇到的只因测试数据不同的多个测试用例合并成一个测试用例，来进行更方便和快捷的测试。</p><p>对编写自己主动化测试代码人员节省了非常多时间</p><p>策略：一般我们会在标有@Factory注解的方法中对测试类进行调用，这时TestNg会自动调用测试类中带有@Test注解的方法</p><p>配置文件：只需要配置带有@Factory注解的类即可</p><p>@Factory必须放在一个返回对象数组的顶部，所有的这些对象都包含测试类的实例，testng会确保@Factory只被调用一次。</p><p>@Factory方法是首先被调用的，在@Test方法和配置方法之前，只有当所有的@Factory方法被调用之后，testng才开始执行配置和测试方法。</p><p>@Factory允许在运行时动态测试。</p><p> 上边说了这么多是不是把大家说的云里雾里，晕头转向的，接下来通过具体的例子给小伙伴和同学们分享一下。</p><h4 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h4><p>为什么要使用@Factory注解呢，先来看下面这个例子</p><h5 id="2-1被测试类Person："><a href="#2-1被测试类Person：" class="headerlink" title="2.1被测试类Person："></a>2.1被测试类Person：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/TKLhoHqAkeOmJXp.png" alt="1232840-20191106131137896-582138384.png"></p><h5 id="2-2参考代码："><a href="#2-2参考代码：" class="headerlink" title="2.2参考代码："></a>2.2参考代码：</h5><pre><code>package hongge;/** * @author 北京-宏哥 *  * Java自动化测试框架-07 - TestNG之Factory篇 * * 2016年05月18日 */import org.testng.annotations.Parameters;import org.testng.annotations.Test;public class Person {    String name;    int age;    @Parameters({&quot;name&quot;,&quot;age&quot;})    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    @Test()    public void say() {        System.out.print(&quot;我是&quot;+name+&quot; &quot;);        if(age&lt;18){            System.out.println(&quot;我未成年&quot;);        }else if(age&gt;=18&amp;&amp;age&lt;=45){            System.out.println(&quot;我是青年人&quot;);        }else if(age&gt;45&amp;&amp;age&lt;=60){            System.out.println(&quot;我是中年人&quot;);        }else if(age&gt;60){            System.out.println(&quot;我是老年人&quot;);        }    }}</code></pre><p>该类的say()方法中有四个判断分支，为了测试充分，必须执行四次这个方法，如果不使用@Factory注解，在TestNG配置文件中必须这样配置：</p><h5 id="2-3TestNG配置文件"><a href="#2-3TestNG配置文件" class="headerlink" title="2.3TestNG配置文件"></a>2.3TestNG配置文件</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/5LQgKZuIahJHEpn.png" alt="1232840-20191106131327235-927855979.png"></p><h5 id="2-4参考代码"><a href="#2-4参考代码" class="headerlink" title="2.4参考代码"></a>2.4参考代码</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;&lt;suite name=&quot;Suite&quot;&gt;  &lt;test name=&quot;Test1&quot;&gt;        &lt;parameter name=&quot;name&quot; value=&quot;小明&quot; /&gt;        &lt;parameter name=&quot;age&quot; value=&quot;10&quot; /&gt;        &lt;classes&gt;            &lt;class name=&quot;hongge.Person&quot; /&gt;        &lt;/classes&gt;    &lt;/test&gt;    &lt;test name=&quot;Test2&quot;&gt;        &lt;parameter name=&quot;name&quot; value=&quot;宏哥&quot; /&gt;        &lt;parameter name=&quot;age&quot; value=&quot;20&quot; /&gt;        &lt;classes&gt;            &lt;class name=&quot;hongge.Person&quot; /&gt;        &lt;/classes&gt;    &lt;/test&gt;    &lt;test name=&quot;Test3&quot;&gt;        &lt;parameter name=&quot;name&quot; value=&quot;刘创&quot; /&gt;        &lt;parameter name=&quot;age&quot; value=&quot;50&quot; /&gt;        &lt;classes&gt;            &lt;class name=&quot;hongge.Person&quot; /&gt;        &lt;/classes&gt;    &lt;/test&gt;    &lt;test name=&quot;Test4&quot;&gt;        &lt;parameter name=&quot;name&quot; value=&quot;爷爷&quot; /&gt;        &lt;parameter name=&quot;age&quot; value=&quot;70&quot; /&gt;        &lt;classes&gt;            &lt;class name=&quot;hongge.Person&quot; /&gt;        &lt;/classes&gt;    &lt;/test&gt;&lt;!-- Test --&gt;&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><p>从上边我们可以清楚地看出来：参数一旦多起来，就难以管理了，所以应该使用工厂来做</p><h4 id="3-工厂"><a href="#3-工厂" class="headerlink" title="3.工厂"></a>3.工厂</h4><h5 id="3-1Factory注解"><a href="#3-1Factory注解" class="headerlink" title="3.1Factory注解"></a>3.1Factory注解</h5><p>如果使用@Factory注解，就比较简单，而且方便扩展，示例如下。</p><p>不需改动原有类，添加一个新类PersonFactory</p><h5 id="3-2新类PersonFactory"><a href="#3-2新类PersonFactory" class="headerlink" title="3.2新类PersonFactory"></a>3.2新类PersonFactory</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/ZrTmkoelHJ23qVY.png" alt="1232840-20191106135516504-499903709.png"></p><h5 id="3-3参考代码"><a href="#3-3参考代码" class="headerlink" title="3.3参考代码"></a>3.3参考代码</h5><pre><code>package hongge;import java.util.ArrayList;import org.testng.annotations.Factory;/** * @author 北京-宏哥 *  * Java自动化测试框架-07 - TestNG之Factory篇 * * 2016年05月18日 */public class PersonFactory {    @Factory    public Object[] factory() {        ArrayList&lt;Person&gt; testList = new ArrayList&lt;&gt;();        Person tp = new Person(&quot;明明&quot;,10);        testList.add(tp);        Person tp2 = new Person(&quot;宏哥&quot;,20);        testList.add(tp2);        Person tp3 = new Person(&quot;刘创&quot;,50);        testList.add(tp3);        Person tp4 = new Person(&quot;朱爷爷&quot;,70);        testList.add(tp4);        return testList.toArray();    }}</code></pre><p>运行时，可以在Eclipse中，在这个factory类（PersonFactory）上点击右键，Run As-&gt; TestNg test执行，</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/BZ69XdQwMtT2E4b.png" alt="1232840-20191106132544655-1416159149.png"></p><p>也可以配置在testng.xml中，只需要配置factory类即可，原类不用管。</p><h5 id="3-4testng-xml"><a href="#3-4testng-xml" class="headerlink" title="3.4testng.xml"></a>3.4testng.xml</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/fZEMBhObatQkCsI.png" alt="1232840-20191106133015522-249965899.png"></p><h5 id="3-5参考代码"><a href="#3-5参考代码" class="headerlink" title="3.5参考代码"></a>3.5参考代码</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;&lt;suite name=&quot;Suite&quot;&gt;  &lt;test name=&quot;Test1&quot;&gt;        &lt;classes&gt;            &lt;class name=&quot;hongge.PersonFactory&quot; /&gt;        &lt;/classes&gt;    &lt;/test&gt;&lt;!-- Test --&gt;&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><h5 id="3-6运行结果"><a href="#3-6运行结果" class="headerlink" title="3.6运行结果"></a>3.6运行结果</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/RHx4Ze7o1waBmAF.png" alt="1232840-20191106133202326-1768521396.png"></p><p>你的testng.xml 只需要引用包含工厂方法的类，而测试实例自己会在运行时创建：</p><pre><code>&lt;class name=&quot;WebTestFactory&quot;/&gt;</code></pre><p>工厂方法可以接受诸如 @Test 和 @Before/After 所标记的参数，并且会返回 Object[]。这些返回的对象可以是任何类（不一定是跟工厂方法相同的类），并且他们甚至都不需要TestNG注解（在例子中会被TestNG忽略掉）</p><h4 id="4-使用-Factory的运行原理"><a href="#4-使用-Factory的运行原理" class="headerlink" title="4.使用@Factory的运行原理"></a>4.使用@Factory的运行原理</h4><p>1、如果不使用@Factory，运行普通的被@Test标注的方法时，实际上是TestNG框架调用了该类的构造函数构造出一个对象，然后再执行对象的这个方法。</p><p>2、使用了@Factory后，可以看到被@Factory标注的方法返回了一个Object数组，数组中每一个元素是一个被测试类的对象。也就是说@Factory构造了多个被测试类对象，然后把每一个对象都传递给了TestNG框架，然后TestNG框架在分别执行这些对象中被@Test标注的方法。<br>通过上面的描述，我们就知道了@Factory可以帮助我们实现简单的数据驱动测试（根据测试数据，执行对应的程序）。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>　　好了，今天关于工厂的知识就分享这么多。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-06</title>
      <link href="/2016/05/17/testng/"/>
      <url>/2016/05/17/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-06 - 来给你的测试报告化个妆整个形 - （下）（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　经过上一次的化妆和整形，有客户提出需求能不能将那个普通会员的套餐再升级一下，再漂亮一点。所以这次咱们就来看看从哪里下刀可以使它变得再漂亮一点点。</p><p>上一篇文章修改了一些基本的ReportNG信息，链接：Java自动化测试框架-05 - 来给你的测试报告化个妆整个形 - （上），本文将继续带大家进行修改，重点是添加饼图，将从普通会员升级到VIP会员。</p><p>经过上次的整容恢复的差不多了，宏哥继续带领下伙伴们和同学们折腾，给reportng来个二次开刀。</p><h4 id="2-第一刀"><a href="#2-第一刀" class="headerlink" title="2.第一刀"></a>2.第一刀</h4><p>1、修改测试结果顺序，修改TestResultComparator类compare方法</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/DC3aWF51LGbSidZ.png" alt="1232840-20191031093519728-971497947.png"></p><p>2、参考代码</p><pre><code>//=============================================================================// Copyright 2006-2013 Daniel W. Dyer//// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);// you may not use this file except in compliance with the License.// You may obtain a copy of the License at////     http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.//=============================================================================package org.uncommons.reportng;import java.util.Comparator;import org.testng.ITestResult;/** * Comparator for sorting TestNG test results alphabetically by method name. * @author Daniel Dyer */class TestResultComparator implements Comparator&lt;ITestResult&gt;{//    public int compare(ITestResult result1, ITestResult result2)//    {//        return result1.getName().compareTo(result2.getName());//    }    public int compare(ITestResult result1, ITestResult result2)    {        //按照名称排序显示//         return result1.getName().compareTo(result2.getName());        //按照运行时间排序显示        int longresult2 = 0;         if(result2.getStartMillis()&lt;result2.getStartMillis()){            longresult2 = -1;        }else{            longresult2 = 1;        }        return longresult2;    }}</code></pre><h4 id="3-第二刀"><a href="#3-第二刀" class="headerlink" title="3.第二刀"></a>3.第二刀</h4><p>1、添加饼图,在overview.html.vm添加</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/uIxR8OpD5iGQXgs.png" alt="1232840-20191031093759036-1184193197.png"></p><p>2、参考代码</p><pre><code>&lt;script src=&#39;http://www.ichartjs.com/ichart.latest.min.js&#39;&gt;&lt;/script&gt;</code></pre><h4 id="4-第三刀"><a href="#4-第三刀" class="headerlink" title="4.第三刀"></a>4.第三刀</h4><p>1、继续在overview.html.vm添加</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/27WJYLZeBlhagk1.png" alt="1232840-20191031094025703-1039078980.png"></p><p>2、参考代码</p><pre><code>&lt;div id=&#39;ichart-render&#39;&gt;&lt;/div&gt;</code></pre><h4 id="5-第四刀"><a href="#5-第四刀" class="headerlink" title="5.第四刀"></a>5.第四刀</h4><p>1、给通过总数，失败总数和跳过总数添加id属性&lt;td class=”passRate suite”&gt;之前添加，找到#if($totalPassed&gt;0),为td标签，添加id属性，如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/l85Jrp9sciaZIj1.png" alt="1232840-20191031094915333-806444491.png"></p><h4 id="6-第五刀"><a href="#6-第五刀" class="headerlink" title="6.第五刀"></a>6.第五刀</h4><p>1、添加饼图js代码，添加在&lt;/body&gt;之前即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/OSBPzoc7HyQFMAJ.png" alt="1232840-20191031095135205-1080599885.png"></p><p>2、参考代码</p><pre><code>&lt;script type=&#39;text/javascript&#39;&gt;    pcount=document.getElementById(&quot;tpn&quot;).innerHTML;    fcount=document.getElementById(&quot;tfn&quot;).innerHTML;    scount=document.getElementById(&quot;tsn&quot;).innerHTML;    $(function(){    var chart = iChart.create({    render:&quot;ichart-render&quot;,    width:800,    height:400,    background_color:&quot;#fefefe&quot;,    gradient:false,    color_factor:0.2,    border:{    color:&quot;BCBCBC&quot;,    width:0    },    align:&quot;center&quot;,    offsetx:0,    offsety:0,    sub_option:{    border:{    color:&quot;#BCBCBC&quot;,    width:1    },    label:{    fontweight:500,    fontsize:11,    color:&quot;#4572a7&quot;,    sign:&quot;square&quot;,    sign_size:12,    border:{    color:&quot;#BCBCBC&quot;,    width:1    }    }    },    shadow:true,    shadow_color:&quot;#666666&quot;,    shadow_blur:2,    showpercent:false,    column_width:&quot;70%&quot;,    bar_height:&quot;70%&quot;,    radius:&quot;90%&quot;,    subtitle:{    text:&quot;&quot;,    color:&quot;#111111&quot;,    fontsize:16,    font:&quot;微软雅黑&quot;,    textAlign:&quot;center&quot;,    height:20,    offsetx:0,    offsety:0    },    footnote:{    text:&quot;&quot;,    color:&quot;#111111&quot;,    fontsize:12,    font:&quot;微软雅黑&quot;,    textAlign:&quot;right&quot;,    height:20,    offsetx:0,    offsety:0    },    legend:{    enable:false,    background_color:&quot;#fefefe&quot;,    color:&quot;#333333&quot;,    fontsize:12,    border:{    color:&quot;#BCBCBC&quot;,    width:1    },    column:1,    align:&quot;right&quot;,    valign:&quot;center&quot;,    offsetx:0,    offsety:0    },    coordinate:{    width:&quot;80%&quot;,    height:&quot;84%&quot;,    background_color:&quot;#ffffff&quot;,    axis:{    color:&quot;#a5acb8&quot;,    width:[1,&quot;&quot;,1,&quot;&quot;]    },    grid_color:&quot;#d9d9d9&quot;,    label:{    fontweight:500,    color:&quot;#666666&quot;,    fontsize:11    }    },    label:{    fontweight:500,    color:&quot;#666666&quot;,    fontsize:11    },    type:&quot;pie2d&quot;,    data:[    {    name:&quot;Passed&quot;,    value:pcount,    color:&quot;#44aa44&quot;    },{    name:&quot;Failed&quot;,    value:fcount,    color:&quot;#ff4444&quot;    },{    name:&quot;Skipped&quot;,    value:scount,    color:&quot;#FFD700&quot;    }    ]    });    chart.draw();    });&lt;/script&gt;</code></pre><h4 id="7-包扎缝合"><a href="#7-包扎缝合" class="headerlink" title="7.包扎缝合"></a>7.包扎缝合</h4><p>这次的包扎缝合宏哥给你们换另一个方式通过ant来导出jar。ant的安装和配置在上一篇大家都可以看到的，这里就不赘述了。</p><p>1、进入代码目录，将其build.xml的jar包版本修改成1.1.8</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/xyCtFuWeMS2UK53.png" alt="1232840-20191031100530896-1004044175.png"></p><p>2、导出jar包。成功。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/vHZWmjipeVNsCyE.png" alt="1232840-20191031100701477-1302869374.png"></p><p>3、到哪个目录下找到jar包。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/dgAZqwJV5BWIUXi.png" alt="1232840-20191031100810732-426198654.png"></p><p>4、新建项目引用jar包。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/dQ5BPeHEV3v6j2N.png" alt="1232840-20191104092105064-805058278.png"></p><h4 id="8-术后恢复效果图："><a href="#8-术后恢复效果图：" class="headerlink" title="8.术后恢复效果图："></a>8.术后恢复效果图：</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/VurPIfb4n2xG3He.png" alt="1232840-20191104085709691-1242083008.png"></p><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>1、小伙伴可能按照宏哥的步骤操作到最后也会一脸懵逼的发现我的饼图在哪里，给谁吃掉了。来跟随宏哥看看，到底是被谁吃掉了。</p><p>（1）首先宏哥看了一看修改的代码，复查了一遍没有问题。</p><p>（2）完了宏哥突然发现有一段引入图标插件的js的代码：&lt;script src=’<a href="http://www.ichartjs.com/ichart.latest.min.js&#39;&gt;" target="_blank" rel="noopener">http://www.ichartjs.com/ichart.latest.min.js&#39;&gt;</a>&lt;/script&gt;是通过一个网址引入的就是在动第二刀的时候，然后宏哥就试着访问网址：<a href="http://www.ichartjs.com/ichart.latest.min.js，结果悲剧了访问到如下：" target="_blank" rel="noopener">http://www.ichartjs.com/ichart.latest.min.js，结果悲剧了访问到如下：</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/qRcFHtOxN4IrmEw.png" alt="1232840-20191104090608099-216599890.png"></p><p>（3）到这里宏哥就确定引入的JS有问题了，所以饼图没有出现那么我们网址访问不到，那么就下载一个到本地，在本地访问</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/ZHU4VQMF1CtsYG6.png" alt="1232840-20191104090906380-882365043.png"></p><p>（4）完成以后，宏哥就开始导出jar包，然后引入jar包以后，仍然没有出现饼图。</p><p>（5）完了宏哥就抱着试一试的心理，把js拷贝到测试报告的文件夹中，再次看测试报告。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/VX9whuYt3UxWcoZ.png" alt="1232840-20191104091225363-1256240728.png"></p><p>（6）饼图出现了，原来是js还是没有被引入，先前做的仅仅是将js引入jar包，而没有引入测试报告，要想引入测试报告还的修改一个地方的代码，仿照上边CSS和JS的引入，如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/mT6azQNvyYbdo8S.png" alt="1232840-20191104091705504-354184020.png"></p><p>（7）再次导出jar包，测试报告的饼图就出现了。</p><p>2、好了，关于这个就到这里了。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-05</title>
      <link href="/2016/05/16/testng/"/>
      <url>/2016/05/16/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-05 - 来给你的测试报告化个妆整个形 - （上）（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　前边通过宏哥的讲解和分享想必小伙伴们和童鞋们都已经见过testng框架生成的测试报告，是不是它的样子和长相实在是不敢让大家伙恭维。那么今天宏哥就当一回美容师，由宏哥来给它美美容；当一回外科医生，做一名整形医生。由宏哥来主刀，给它整整形。让她变得丰满、美丽、可爱一些。</p><h4 id="2-本来面貌"><a href="#2-本来面貌" class="headerlink" title="2.本来面貌"></a>2.本来面貌</h4><p>执行完测试用例之后，会在项目的test-output（默认目录）下生成测试报告</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/UlgCZuab3vNm52f.png" alt="1232840-20191024134949496-668724867.png"></p><p>打开index.html文件，测试结果摘要，包括：套件名、测试用例成功数、测试用例失败数、测试用例忽略数和testng.xml文件</p><h5 id="简略测试报告"><a href="#简略测试报告" class="headerlink" title="简略测试报告"></a>简略测试报告</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/Nhe27yc8Ud5gPjz.png" alt="1232840-20191024135208538-623047752.png"></p><h5 id="详细测试报告"><a href="#详细测试报告" class="headerlink" title="详细测试报告"></a>详细测试报告</h5><p>测试用例都成功的话，测试结果以绿底标志：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/T4pZFI5rw3BNGWs.png" alt="1232840-20191024135737422-1148669297.png"></p><p>测试用例有失败的话，测试结果以红底标志：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/f6ZClEwupLcOra5.png" alt="1232840-20191024135704373-2031355632.png"></p><p>点击”Link”链接，可以查看testng.xml文件的内容：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/X4d7lFpUOKtx2RW.png" alt="1232840-20191024135902621-2033124630.png"></p><p>详细的测试结果介绍：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/sd1DPqEBtUknQ7W.png" alt="141506310643272.png"></p><h4 id="3-套餐一（普通会员）"><a href="#3-套餐一（普通会员）" class="headerlink" title="3.套餐一（普通会员）"></a>3.套餐一（普通会员）</h4><p>ReportNG 是一个配合TestNG运行case后自动帮你在test-output文件内生成一个相对较为美观的测试报告！<br>ReportNG 里面Log 是不支持中文的，我改过ReportNG.jar源码，具体方法看最下面，也可以找我直接要jar！<br>话不多说直接上</p><p>1、首先从GitHub拉取ReportNG源码，地址：<a href="https://github.com/dwdyer/reportng，下载好后解压。" target="_blank" rel="noopener">https://github.com/dwdyer/reportng，下载好后解压。</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/QkMC3miz2ZT1HKh.png" alt="1232840-20191025140457674-435605575.png"></p><p>2、导入到编辑器如Eclipse,注意：import的时候请选择以Maven项目import，请选择reportng-master目录下的reportng文件，作为新的project</p><p> （1）点击File-&gt;import</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/DnaflQ8TRHKAm4z.png" alt="1232840-20191025140622605-925691913.png"></p><p>（2）选择Existing Maven Projects，点击Next</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/atu8qvFW6AMhrp7.png" alt="1232840-20191025140759999-1446558396.png"></p><p>（3）选择解压好的ReportNG项目，点击Finish</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/3hEVojqFu4XBNvy.png" alt="1232840-20191025140900619-1235803740.png"></p><p>（4）导入后的项目如图所示,导入后切记忙于修改源代码，就算你把代码改烂了也改不对，而且会报乱七八糟的错误，让你怀疑人生</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/JWoHCExswNG917Z.png" alt="1007944-20181105220030002-1130760488.png"></p><p>（5）项目导入后，修改项目成如下图所示目录，且添加相应jar包到lib</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/K5T6ucDUsmC79Az.png" alt="1007944-20181105220313879-1143257554.png"></p><p>3、修改原代码</p><p>（1）报告中乱码的解决办法，修改AbstractReporter中的generateFile这个方法中的代码如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/WCPtmnOFKwb8SEy.png" alt="1232840-20191030135047931-765166523.png"></p><p> 参考代码：</p><pre><code> OutputStream out = new FileOutputStream(file); Writer writer = new BufferedWriter(new OutputStreamWriter(out,&quot;utf-8&quot;));</code></pre><p>或者这样也可以：</p><pre><code> OutputStream out = new FileOutputStream(file); Writer writer = new BufferedWriter(new OutputStreamWriter(out,ENCODING));</code></pre><p>（2）修改测试报告名称，修改ReportMetadata中DEFAULT_TITLE</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/kGoMb2u3nLcWDgd.png" alt="1232840-20191030135356101-1443225384.png"></p><p>（3）修改默认generatedBy，修改reportng.properties中的generatedBy</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/LKdItcpYNbEA8Q7.png" alt="1232840-20191030135518370-1966407577.png"></p><p>（4）修改默认日期显示，修改ReportMetadata.java中的DATE_FORMAT，TIME_FORMAT</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/jTECzA12JtoSapY.png" alt="1232840-20191030135605341-1878598902.png"></p><p>（5）修改pom.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;           xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;      &lt;groupId&gt;reportng&lt;/groupId&gt;      &lt;artifactId&gt;reportng&lt;/artifactId&gt;      &lt;version&gt;1.8.8&lt;/version&gt;     &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;             &lt;artifactId&gt;httpclient&lt;/artifactId&gt;             &lt;version&gt;4.3.6&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;            &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;            &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;            &lt;version&gt;2.0&lt;/version&gt;        &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.testng&lt;/groupId&gt;             &lt;artifactId&gt;testng&lt;/artifactId&gt;             &lt;version&gt;6.9.6&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.uncommons&lt;/groupId&gt;             &lt;artifactId&gt;reportng&lt;/artifactId&gt;             &lt;version&gt;1.1.4&lt;/version&gt;             &lt;scope&gt;test&lt;/scope&gt;             &lt;exclusions&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.testng&lt;/groupId&gt;                     &lt;artifactId&gt;testng&lt;/artifactId&gt;                 &lt;/exclusion&gt;             &lt;/exclusions&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;com.google.inject&lt;/groupId&gt;             &lt;artifactId&gt;guice&lt;/artifactId&gt;             &lt;version&gt;3.0&lt;/version&gt;             &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;     &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;version&gt;2.18.1&lt;/version&gt;                 &lt;configuration&gt;                     &lt;properties&gt;                         &lt;property&gt;                             &lt;name&gt;usedefaultlisteners&lt;/name&gt;                             &lt;value&gt;false&lt;/value&gt;                         &lt;/property&gt;                         &lt;property&gt;                             &lt;name&gt;listener&lt;/name&gt;                             &lt;value&gt;org.uncommons.reportng.HTMLReporter, org.uncommons.reportng.JUnitXMLReporter&lt;/value&gt;                         &lt;/property&gt;                     &lt;/properties&gt;                    &lt;!--  &lt;suiteXmlFiles&gt;                         &lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt;                     &lt;/suiteXmlFiles&gt; --&gt;                     &lt;workingDirectory&gt;target/&lt;/workingDirectory&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;     &lt;properties&gt;         &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;     &lt;/properties&gt; &lt;/project&gt;</code></pre><p>4.打包，pom.xml右击选择Run As-&gt;Maven install,</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/p4LafV2rDBseJP5.png" alt="1232840-20191030133728465-751450459.png"></p><p>5.控制台显示BUILD SUCCESS，则构建成功，刷新当前项目，在target目录下会生成一个jar文件：reportng-1.8.8.jar</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/nhkPEbMgqXCND8W.png" alt="1232840-20191030133927924-1820137060.png"></p><p>6.测试，新建一个测试项目(大家请随意)，导入相应jar包，选择运行testng.xml，记得添加</p><pre><code>&lt;listeners&gt;&lt;listener class-name=&quot;org.uncommons.reportng.HTMLReporter&quot; /&gt;&lt;listener class-name=&quot;org.uncommons.reportng.JUnitXMLReporter&quot; /&gt;&lt;/listeners&gt;</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/iryhapIgsRZeSH5.png" alt="1232840-20191030134042833-783040019.png"></p><p>7.报告展示,修改后的jar包已上传到群共享，需要的小伙伴可以加群自己下载哦。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/gnjQ9SLJBl2dCfH.png" alt="1232840-20191030134154337-899128513.png"></p><h4 id="4-套餐二（VIP会员）"><a href="#4-套餐二（VIP会员）" class="headerlink" title="4.套餐二（VIP会员）"></a>4.套餐二（VIP会员）</h4><p>testng-xslt</p><p>testNG自带生成的测试报告不太美观，可以使用testng-xslt进行美化，步骤如下：</p><p>1、官网下载testng-xslt包，<a href="http://testng-xslt.googlecode.com/files/testng-xslt-1.1.zip" target="_blank" rel="noopener">http://testng-xslt.googlecode.com/files/testng-xslt-1.1.zip</a></p><p>　  亲测现在google可能访问不了，可到我的网盘里下载，链接: <a href="https://pan.baidu.com/s/1HC52IgKBRd9agQ1B8HyfVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1HC52IgKBRd9agQ1B8HyfVg</a> 提取码: ferk </p><p>2、解压后的文件目录如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/Zl9gu4diUYekMn7.png" alt="1232840-20191025110640920-1064240088.png"></p><p>3、复制testng-results.xsl（testng-xslt-1.1\src\main\resources）文件到test-output目录下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/GP4fNcVhMKglEDU.png" alt="1232840-20191025132757059-484962911.png"></p><p>4、解压文件testng-xslt-1.1.2，把 lib 文件下的saxon-8.7.jar 和 SaxonLiason.jar 拷贝到项目的lib文件夹（若没有则新建）下，并导入到项目中（lib文件夹的路径必须放在test-output下，不然后面会影响生成构建文件）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/adPj1qGsQAI7XeE.png" alt="1232840-20191025132652428-671023123.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/sF1y3gWz4ljZ28f.png" alt="1232840-20191025110852234-1332144292.png"></p><p>5、安装ant，<a href="http://mirror.bit.edu.cn/apache/ant/binaries/apache-ant-1.9.4-bin.zip" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/ant/binaries/apache-ant-1.9.4-bin.zip</a></p><h4 id="5-Ant-下载安装配置使用教程"><a href="#5-Ant-下载安装配置使用教程" class="headerlink" title="5.Ant 下载安装配置使用教程"></a>5.Ant 下载安装配置使用教程</h4><p>一、Ant 简介</p><p>1、Apache Ant 是一个Java库和命令行工具，其任务是将构建文件中描述的进程作为目标和扩展点相互依赖。Ant提供了许多内置任务，允许编译，组装，测试和运行Java应用程序。</p><p>2、Ant是用Java编写的。Ant的用户可以开发自己的包含Ant任务和类型的“antlibs”，并提供大量现成的商业或开源“antlibs”。</p><p>3、类似于 Maven ，统一构建的项目管理工具。</p><p>二、下载</p><p>1、当前最新版： <a href="http://mirror.bit.edu.cn/apache//ant/binaries/apache-ant-1.10.5-bin.zip" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache//ant/binaries/apache-ant-1.10.5-bin.zip</a></p><p>2、历史版本下载： <a href="https://archive.apache.org/dist/ant/binaries/" target="_blank" rel="noopener">https://archive.apache.org/dist/ant/binaries/</a></p><p>三、安装</p><p>1、解压 apache-ant-1.10.5-bin.zip</p><p>2、目录结构如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/7ZINrzFgRjXkuT3.png" alt="1232840-20191025112722185-1816833526.png"></p><p>3、配置 ANT_HOME , Path ， classpath</p><p>ANT_HOME = F:\soft\ant-1.10.5<br>Path = %ANT_HOME%\bin;<br>classpath = %ANT_HOME%\lib;</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/xkpGE1fouRtSiD3.png" alt="1232840-20191025113143991-1929189099.png"></p><p>4、类似于 MAVEN_HOME , JAVA_HOME 的配置。</p><p>四、测试</p><p>1、 Win + R —&gt; cmd —&gt; 输入 ant ， 出现 如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/MBnmNwVko5Pa3qy.png" alt="1232840-20191025113637186-1332754087.png"></p><p>2、查看 ant 版本 ： ant -version</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/VAqjdaEt3Zv8CR2.png" alt="1232840-20191025113732516-1174873860.png"></p><p>6、在project目录下，新建build.xml文件，内容如下：</p><p>{name} ：自己的项目名字；<br>{in}：对应的是testng生成报告的xml；（指定该路径无需创建）<br>{style}：对应的是testng生成报告的xsl；（指定该路径无需创建）<br>{out}：是要用testNG-xslt生成报告的文件名和路径；（可以创建新的文件也可以指定到test-output）<br>{expression}：是要用testNG-xslt生成报告的路径；</p><pre><code>&lt;project name=&quot;hongge&quot; basedir=&quot;.&quot; &gt;    &lt;property name=&quot;lib.dir&quot; value=&quot;lib&quot; /&gt;    &lt;path id=&quot;test.classpath&quot; &gt;         &lt;!-- adding the saxon jar to your classpath --&gt;        &lt;fileset dir=&quot;${lib.dir}&quot; includes=&quot;*.jar&quot; /&gt;    &lt;/path&gt;    &lt;target name=&quot;transform&quot; &gt;        &lt;!-- 需要根据自己的环境进行配置（将E:/workspace/testNG/替换成你自己project的目录） --&gt;        &lt;xslt in=&quot;F:/workspace/hongge/test-output/testng-results.xml&quot; style=&quot;F:/workspace/hongge/test-output/testng-results.xsl&quot;  out=&quot;F:/workspace/hongge/test-output/index1.html&quot; &gt;             &lt;!-- 需要根据自己的环境进行配置（将E:/workspace/testNG/替换成你自己project的目录） --&gt;            &lt;param name=&quot;testNgXslt.outputDir&quot; expression=&quot;F:/workspace/hongge/test-output/&quot; /&gt;            &lt;classpath refid=&quot;test.classpath&quot; /&gt;        &lt;/xslt&gt;    &lt;/target&gt;&lt;/project&gt; </code></pre><p>7、在cmd里，切换到project的目录，执行ant transform：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/NOKUYqplRsJkoxZ.png" alt="1232840-20191025133318252-454683559.png"></p><p>8、到配置的路径下，打开生成的文件index1.html，以图形化的界面展示测试结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/qsnUyz56SYHTpAI.png" alt="1232840-20191025133612553-3495567.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>好了，今天分享就到这里。</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-04</title>
      <link href="/2016/05/15/testng/"/>
      <url>/2016/05/15/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-04 - TestNG之Test Method篇 - 道法自然，法力无边（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　按照上一篇的计划，这一篇给小伙伴们分享一下测试方法。</p><h4 id="2-设置参数"><a href="#2-设置参数" class="headerlink" title="2.设置参数"></a>2.设置参数</h4><p>测试方法是可以带有参数的。每个测试方法都可以带有任意数量的参数，并且可以通过使用TestNG的@Parameters向方法传递正确的参数。</p><p>设置方式有两种方法：使用testng.xml或者Data Providers 。</p><h5 id="（一）使用-testng-xml-设置参数"><a href="#（一）使用-testng-xml-设置参数" class="headerlink" title="（一）使用 testng.xml 设置参数"></a>（一）使用 testng.xml 设置参数</h5><p>这种方法让我们在testng.xml文件中，定义简单的参数，然后在源码文件引用这些参数。</p><p>1.如果只使用相对简单的参数，可以在 testng.xml文件中指定：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Method篇 * * 2016年05月15日 */@Parameters({ &quot;first-name&quot; })  @Test  public void testSingleString(String firstName) {     System.out.println(&quot;Invoked testString &quot; + firstName);    assert &quot;Cedric&quot;.equals(firstName);  }  </code></pre><p>在这段代码中，我们让 firstName 参数能够接到XML文件中叫做 first-name 参数的值。这个XML参数被定义在 testng.xml：</p><pre><code>&lt;suite name=&quot;My suite&quot;&gt;    &lt;parameter name=&quot;first-name&quot;  value=&quot;Cedric&quot;/&gt;    &lt;test name=&quot;Simple example&quot;&gt; </code></pre><p>类似的，它也可以用在 @Before/After 和 @Factory 注解上：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Method篇 * * 2016年05月15日 */@Parameters({ &quot;datasource&quot;, &quot;jdbcDriver&quot; })  @BeforeMethod  public void beforeTest(String ds, String driver) {    m_dataSource = ...;                              // 查询数据源的值    m_jdbcDriver = driver;  } </code></pre><p>这次有两个Java参数 ds 和 driver 会分别接收到来自属性datasource 和 jdbc-driver 所指定的值。</p><p>2.参数也可以通过 Optional 注释来声明：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Method篇 * * 2016年05月15日 */@Parameters(&quot;db&quot;)  @Test  public void testNonExistentParameter(@Optional(&quot;mysql&quot;) String db) { ... }  </code></pre><p>如果在你的testng.xml文件中没有找到”db”，你的测试方法就会使用 @Optional 中的值：”MySQL”。</p><p>3.@Parameters 可以被放置到如下位置：</p><p>(1)在任何已经被 @Test, @Before/After 或 @Factory 注解过的地方。</p><p>(2)在测试类中至多被放到一个构造函数签。这样，TestNG才能在需要的时候使用 testng.xml 中特定的参数来实例化这个类。这个特性可以被用作初始化某些类中的值，以便稍后会被类中其他的方法所使用。</p><p>注意：</p><p>XML中的参数会按照Java参数在注解中出现的顺序被映射过去，并且如果数量不匹配，TestNG会报错。</p><p>参数是有作用范围的。在testng.xml 中，你即可以在/<suite> 标签下声明，也可以在 /<test>下声明。如果两个参数都有相同的名字，那么，定义在/<test> 中的有优先权。这在你需要覆盖某些测试中特定参数的值时，会非常方便。</test></test></suite></p><h5 id="（二）使用DataProviders提供参数"><a href="#（二）使用DataProviders提供参数" class="headerlink" title="（二）使用DataProviders提供参数"></a>（二）使用DataProviders提供参数</h5><p>在testng.xml 中指定参数可能会有如下的不足：</p><p>1.如果你压根不用 testng.xml.</p><p>2.你需要传递复杂的参数，或者从Java中创建参数（复杂对象，对象从属性文件或者数据库中读取的etc…）或者在testng.xml中指定参数可能不够</p><p>这样的话，你就可以使用Data Provider来给需要的测试提供参数。所谓数据提供者，就是一个能返回对象数组的数组的方法，并且这个方法被@DataProvider注解标注：</p><p>DataProvider的定义如下：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Method篇 * * 2016年05月15日 */@DataProvider(name = &quot;range-provider&quot;)  public Object[][] rangeData() {      int lower = 5;      int upper = 10;      return new Object[][] {      { lower-1, lower, upper, false },      { lower, lower, upper, true },      { lower+1, lower, upper, true },      { upper, lower, upper, true},      { upper+1, lower, upper, false },      };  }  </code></pre><p>调用DataProvider的方式如下：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Method篇 * * 2016年05月15日 */@Test(dataProvider = &quot;range-provider&quot;)  public void testIsBetween(int n, int lower,int upper, boolean expected){      println(&quot;Received &quot; + n + &quot; &quot; + lower + &quot;-&quot;+ upper + &quot; expected: &quot; + expected);      Assert.assertEquals(expected, isBetween(n, lower, upper));  } </code></pre><p>被@Test标注的方法通过dataProvider属性指明其数据提供商。这个名字必须与@DataProvider(name=”…”)中的名字相一致。</p><p>DataProvider返回的是一个Object的二维数组，二维数组中的每个一维数组都会传递给调用函数，作为参数使用。运行的时候，会发现， @Test标识的test method被执行的次数和object[][]包含的一维数组的个数是一致的，而@Test标识的函数的参数个数，也和object内一维数组内的元素数是一致的。</p><p>运行后的输出结果如下：</p><pre><code>Received 4 5-10expected: falseReceived 5 5-10expected: trueReceived 6 5-10expected: trueReceived 10 5-10expected: trueReceived 11 5-10expected: false===============================================Parameter SuiteTotal tests run: 5,Failures: 0, Skips: 0===============================================</code></pre><h5 id="（三）DataProviders扩展"><a href="#（三）DataProviders扩展" class="headerlink" title="（三）DataProviders扩展"></a>（三）DataProviders扩展</h5><p>默认的情况下，数据提供者会查找当前的测试类或者测试类的基类。如果你希望它能够被其他的类所使用，那么就要将其指定为static，并且通过 dataProviderClass 属性指定要使用的类：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Method篇 * * 2016年05月15日 */public static class StaticProvider {      @DataProvider(name = &quot;create&quot;)      public static Object[][] createData() {          return new Object[][] {            new Object[] { new Integer(42) }          }       }  }  public class MyTest {      @Test(dataProvider = &quot;create&quot;, dataProviderClass = StaticProvider.class)      public void test(Integer n) {          // ...      }  }  </code></pre><p>Data Provider方法可以返回如下两种类型中的一种：</p><p>1.含有多个对象的数组 (Object[][])，其中第一个下标指明了测试方法要调用的次数，第二个下标则完全与测试方法中的参数类型和个数相匹配。上面的例子已经说明。</p><p>2.另外一个是迭代器 Iterator&lt;Object[]&gt;。二者的区别是迭代器允许你延迟创建自己的测试数据。TestNG会调用迭代器，之后测试方法会一个接一个的调用由迭代器返回的值。在你需要传递很多参数组给测试组的时候，这样你无须提前创建一堆值。</p><p>下面是使用JDK5 的例子 (注意 JDK 1.4的例子不适用泛型)：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-04 - TestNG之Test Method篇 * * 2016年05月15日 */public Iterator createData() {        return new MyIterator(DATA);      )  @DataProvider(name = &quot;test1&quot;)  public Iterator </code></pre><p>如果你声明的 @DataProvider 使用 java.lang.reflect.Method 作为第一个参数，TestNG 会把当前的测试方法当成参数传给第一个参数。这一点在你的多个测试方法使用相同的@DataProvider的时候，并且你想要依据具体的测试方法返回不同的值时，特别有用。</p><p>例如，下面的代码它内部的 @DataProvider 中的测试方法的名字：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-04 - TestNG之Test Method篇 * * 2016年05月15日 */@DataProvider(name = &quot;dp&quot;)public Object[][] createData(Method m) {  System.out.println(m.getName());    return new Object[][] { new Object[] { &quot;Cedric&quot; }};}@Test(dataProvider = &quot;dp&quot;)public void test1(String s) {}@Test(dataProvider = &quot;dp&quot;)public void test2(String s) {}</code></pre><p>所以会显示：</p><p>test1 </p><p>test2</p><p>Data provider可以通过属性 parallel实现并行运行：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-04 - TestNG之Test Method篇 * * 2016年05月15日 */@DataProvider(parallel = true)  //...</code></pre><p>使用XML文件运行的data provider享有相同的线程池，默认的大小是10.你可以通过修改该在 <suite> 标签中的值来更改：</suite></p><pre><code>&lt;suitename=&quot;Suite1&quot; data-provider-thread-count=&quot;20&quot; &gt;... </code></pre><p>如果你需要让指定的几个data provider运行在不同的线程中，那么就必须通过不同的xml文件来运行。</p><h5 id="（四）两种方法的优缺点"><a href="#（四）两种方法的优缺点" class="headerlink" title="（四）两种方法的优缺点"></a>（四）两种方法的优缺点</h5><p>testng.xml</p><p>优点：值在testng.xml中指定，这方便修改，不需要重新编译代码 ；</p><p>缺点：你需要一个testng.xml文件，值不能够动态算出</p><p>数据提供者</p><p>优点：可以想测试方法传递任何有效的Java类型这种方法非常灵活，值可以通过Java代码动态算出，或者任何存储机制中取得</p><p>缺点：这种方法需要实现某些逻辑，以返回正确的对象</p><h4 id="3-依赖方法"><a href="#3-依赖方法" class="headerlink" title="3.依赖方法"></a>3.依赖方法</h4><p>有些时候，需要按照特定顺序调用测试方法。</p><p>1.确保在进行更多的方法测试之前，有一定数量的测试方法已经成功完成。</p><p>2.在初始化测试的时候，同时希望这个初始化方法也是一个测试方法（ @Before/After 不会出现在最后生成的报告中）。</p><p>为此，你可以使用 @Test 中的 dependsOnMethods 或 dependsOnGroups 属性。</p><p>这两种依赖：</p><p>1.Harddependencies（硬依赖）。所有的被依赖方法必须成功运行。只要有一个出问题，测试就不会被调用，并且在报告中被标记为SKIP。</p><p>2.Softdependencies（软依赖）。 即便是有些依赖方法失败了，也一样运行。如果你只是需要保证你的测试方法按照顺序执行，而不关心他们的依赖方法是否成功。那么这种机制就非常有用。可以通过添加 “alwaysRun=true” 到 @Test 来实现软依赖。 </p><p>硬依赖的例子：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-04 - TestNG之Test Method篇 * * 2016年05月15日 */@Test  public void serverStartedOk() {}  @Test(dependsOnMethods = { &quot;serverStartedOk&quot; })  public void method1() {} </code></pre><p>此例中，method1() 依赖于方法 serverStartedOk()，从而保证 serverStartedOk() 总是先运行。</p><p>也可以让若干方法依赖于组：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-04 - TestNG之Test Method篇 * * 2016年05月15日 */@Test(groups = { &quot;init&quot; })  public void serverStartedOk() {}  @Test(groups = { &quot;init&quot; })  public void initEnvironment() {}  @Test(dependsOnGroups = { &quot;init.* })  public void method1() {} </code></pre><p>本例中,method1()依赖于匹配正则表达式”init.*”的组,由此保证了serverStartedOk()和initEnvironment()总是先于method1()被调用。</p><p>注意：正如前面所说的那样，在相同组中的调用可是在夸测试中不保证顺序的。</p><p>如果你使用硬依赖，并且被依赖方法失败(alwaysRun=false，即默认是硬依赖)，依赖方法则不是被标记为FAIL而是SKIP。被跳过的方法会被在最后的报告中标记出来（HTML既不用红色也不是绿色所表示），主要是被跳过的方法不是必然失败，所以被标出来做以区别。</p><p>无论dependsOnGroups还是dependsOnMethods都可以接受正则表达式作为参数。对于dependsOnMethods，如果被依赖的方法有多个重载，那么所有的重载方法都会被调用。如果你只希望使用这些重载中的一个，那么就应该使用dependsOnGroups。</p><h4 id="4-类级注解"><a href="#4-类级注解" class="headerlink" title="4.类级注解"></a>4.类级注解</h4><p>通常 @Test 也可以用来标注类，而不仅仅是方法：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-04 - TestNG之Test Method篇 * * 2016年05月15日 */@Test  public class Test1 {      public void test1() {      }      public void test2() {      }  }  </code></pre><p>处于类级的 @Test 会使得类中所有的public方法成为测试方法，而不管他们是否已经被标注。当然，你仍然可以用 @Test 注解重复标注测试方法，特别是要为其添加一些特别的属性时。</p><p>例如：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  *java自动化测试交流群：694280102 * *Java自动化测试框架-04 - TestNG之Test Method篇 * * 2016年05月15日 */@Testpublic class Test1 {    public void test1() {    }    @Test(groups = &quot;g1&quot;)    public void test2() {    }}</code></pre><p>上例中 test1() 和 test2() 都被处理，不过在此之上 test2() 现在还属于组 “g1”。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>嘿嘿！今天就分享到这里。下一篇计划是测试方法（Factory），希望小伙伴们和童鞋们喜欢和继续关注宏哥！</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-03</title>
      <link href="/2016/05/14/testng/"/>
      <url>/2016/05/14/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-03 - TestNG之Test Group篇 - 我们一起组团打怪升级（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　其实这篇文章的group宏哥在上一篇中就提到过，但是就是举例一笔带过的，因此今天专门有一篇文章来讲解Group的相关知识。希望大家茅塞顿开 ，有着更进一步认识和了解测试组。</p><h4 id="2-Test-Group（测试组）"><a href="#2-Test-Group（测试组）" class="headerlink" title="2.Test Group（测试组）"></a>2.Test Group（测试组）</h4><p>　　TestNG 允许你将复杂的测试方法归类为不同的组。不仅仅是可以声明某个方法属于某个组，而且还可以让组包含其他的组。这样TestNG可以调用或者请求包含一组特定的组 （或者正则表达式）而排除其他不需要组的集合。这样，如果你打算将测试分成两份的时候，就无需重新编译。这个特点，会给你在划分组的时候带来很大的灵活性。</p><p>　　组（Group）在testng.xml文件中指定，可以在&lt;test&gt;或&lt;suite&gt;标记下找到。&lt;suite&gt;标记中指定的组适用于下面的所有&lt;test&gt;标记。请注意，组在这些标记中是累积的：如果在<suite>中指定组“a”，在<test>中指定“b” ，则将包括“a”和“b”。</test></suite></p><p>例如，通常将测试划分为两种类别是再常见不过的了：</p><p>　　检查性测试（Check-in test）：这些测试在你提交新代码之前就会运行。它们一般都是很快进行的，并且保证没有哪个基本的功能是不好使的。</p><p>　　功能性测试（Functional test）：这些测试涵盖你的软件中所有的功能，并且至少每天运行一次，不过你也可能希望他们持续的运行。</p><p>　　典型的来说，检测性测试通常是功能性测试的一个子集。TestNG允许你根据个人感觉来进行组划分。例如，你可能希望把你所有的测试类都划归为”functest”组，并且额外的有几个方法输入”checkintest”组。</p><p>TestNG允许您以非常直观的方式使用测试组指定。例如，您可以通过说明您的整个测试类属于“functest”组来构建测试，另外还有一些方法属于“checkintest”组：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Group篇 * * 2016年05月14日 */public class Test1 {    @Test(groups = { &quot;functest&quot;, &quot;checkintest&quot; })        public void testMethod1() {        }        @Test(groups = {&quot;functest&quot;, &quot;checkintest&quot;} )        public void testMethod2() {        }        @Test(groups = { &quot;functest&quot; })        public void testMethod3() {        }  }</code></pre><p>通过下面的内容调用TestNG</p><pre><code>&lt;test name=&quot;Test1&quot;&gt;    &lt;groups&gt;      &lt;run&gt;        &lt;include name=&quot;functest&quot;/&gt;      &lt;/run&gt;    &lt;/groups&gt;    &lt;classes&gt;      &lt;class name=&quot;example1.Test1&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; </code></pre><p>以上会运行上面那个类中所有的测试，当要使用checkintest进行调用的时候，就仅仅运行testMethod1()和testMethod2()。</p><p>下面是另外一个例子。这次使用正则表达式。假定有些测试方法不应该运行在Linux环境下，你的测试会看起来像：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Group篇 * * 2016年05月14日 */@Testpublic class Test1 {     @Test(groups = {&quot;windows.checkintest&quot;})        public void testWindowsOnly() {       }       @Test(groups = {&quot;linux.checkintest&quot;})       public void testLinuxOnly() {       }       @Test(groups = {&quot;windows.functest&quot;})       public void testWindowsToo() {       }  }</code></pre><p>然后你就可以使用下面这个 testng.xml 来只运行在Windows下的方法：</p><pre><code>&lt;test name=&quot;Test1&quot;&gt;    &lt;groups&gt;      &lt;run&gt;        &lt;include name=&quot;windows.*&quot;/&gt;      &lt;/run&gt;    &lt;/groups&gt;    &lt;classes&gt;      &lt;class name=&quot;example1.Test1&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; </code></pre><p>注意：TestNG使用的是正则表达式，而不是通配符。注意这二者的区别</p><p>例如，”anything” 是匹配于 “.*” – 点和星号 – 而不是星号 “*”.</p><h4 id="3-MetaGroups（组中组）"><a href="#3-MetaGroups（组中组）" class="headerlink" title="3.MetaGroups（组中组）"></a>3.MetaGroups（组中组）</h4><p>　　测试组也可以包含其他组。这样的组叫做“元组”（MetaGroups）。例如，你可能要定义一个组all来包含其他的组，chekcintest 和functest。”functest”本身只包含了组windows和linux，而”checkintest”仅仅包含windows。你就可以在属性文件中这样定义：</p><pre><code>&lt;test name=&quot;Regression1&quot;&gt;    &lt;groups&gt;      &lt;define name=&quot;functest&quot;&gt;        &lt;include name=&quot;windows&quot;/&gt;        &lt;include name=&quot;linux&quot;/&gt;      &lt;/define&gt;      &lt;define name=&quot;all&quot;&gt;        &lt;include name=&quot;functest&quot;/&gt;        &lt;include name=&quot;checkintest&quot;/&gt;      &lt;/define&gt;      &lt;run&gt;        &lt;include name=&quot;all&quot;/&gt;      &lt;/run&gt;    &lt;/groups&gt;    &lt;classes&gt;      &lt;class name=&quot;test.sample.Test1&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt;  </code></pre><h4 id="4-排除组"><a href="#4-排除组" class="headerlink" title="4.排除组"></a>4.排除组</h4><p>   TestNG 允许你包含组，当然也可以排除之。</p><p>譬如说，因为最近的改动，导致当前的测试中断并且，你还没有时间修复这些问题都是司空见惯的。但是，你还需要自己的功能测试可以正确运行，所以，制药简单的让这些不需要的测试失效就可以了。但是别忘记在以后需要的时候，要重新让其生效。</p><p>   一个简单的办法来解决这个问题就是创建一个叫做”broken”组，然后使得这些测试方法从属于那个组。例如上面的例子，假设我知道testMethod2()会中断，所以我希望使其失效：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Group篇 * * 2016年05月14日 */@Test(groups = {&quot;checkintest&quot;, &quot;broken&quot;} )  public void testMethod2() {}  </code></pre><p>而我所需要做的一切就是从运行中排除这个组：</p><pre><code>&lt;test name=&quot;Simple example&quot;&gt;    &lt;groups&gt;      &lt;run&gt;        &lt;include name=&quot;checkintest&quot;/&gt;        &lt;exclude name=&quot;broken&quot;/&gt;      &lt;/run&gt;    &lt;/groups&gt;    &lt;classes&gt;      &lt;class name=&quot;example1.Test1&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; </code></pre><p>通过这种办法，我们既可以得到整洁的测试运行，同时也能够跟踪那些需要稍后修正的中断的测试。</p><p>注意：你可以可以通过使用”enabled”属性来完成，这个属性适用于@Test 和 @Before/After annotation。</p><h4 id="5-局部组"><a href="#5-局部组" class="headerlink" title="5.局部组"></a>5.局部组</h4><p>可以在类级别定义组，之后还可以在方法级定义组：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-03 - TestNG之Test Group篇 * * 2016年05月14日 */@Test(groups = { &quot;checkin-test&quot; })  public class All {  @Test(groups = { &quot;func-test&quot; )  public void method1() { ... }  public void method2() { ... }  }  </code></pre><p>在这个类中，method2() 类级组”checkin-test”的一部分，而method1()即属于”checkin-test”也属于”func-test”组。</p><h4 id="6-方法组"><a href="#6-方法组" class="headerlink" title="6.方法组"></a>6.方法组</h4><p>你可以排除或者包含单个方法</p><pre><code>&lt;test name=&quot;Test1&quot;&gt;  &lt;classes&gt;    &lt;class name=&quot;example1.Test1&quot;&gt;      &lt;methods&gt;        &lt;include name=&quot;.*enabledTestMethod.*&quot;/&gt;        &lt;exclude name=&quot;.*brokenTestMethod.*&quot;/&gt;      &lt;/methods&gt;     &lt;/class&gt;  &lt;/classes&gt;&lt;/test&gt;</code></pre><p>这可以派上用来停用单个方法而不必重新编译任何东西，但我不建议过多地使用这种技术，因为如果你开始重构Java代码（正则表达式中使用的正则表达式），它会使你的测试框架崩溃。标签可能不再符合您的方法）。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>　　嘿嘿！今天就分享到这里。下一篇计划是测试方法（Test Method），希望小伙伴们和童鞋们喜欢和继续关注宏哥！</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-02</title>
      <link href="/2016/05/13/testng/"/>
      <url>/2016/05/13/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-02 - TestNG之理论到实践 - 纸上得来终觉浅，绝知此事要躬行（详细教程）</strong></p><h4 id="1-理论"><a href="#1-理论" class="headerlink" title="1.理论"></a>1.理论</h4><p>TestNG，即Testing, NextGeneration，下一代测试技术，是一套根据JUnit 和NUnit思想而构建的利用注释来强化测试功能的一个测试框架，即可以用来做单元测试，也可以用来做集成测试。<br>因为TestNG是从Junit的思想构建而来，所以TestNG具备junit等所不具备的多重功能。而且TestNG目前的使用比较广泛，google的一个selenium自动化项目组即采用的是selenium rc的java 接口+ testNG结合的方式。<br>写一个测试通常分为三步：</p><p>1.编写测试业务逻辑，并且在你的代码中插入 TestNG annotations 。</p><p>2.在 testng.xml 或 build.xml 添加你的测试信息。例如类名，希望运行的组等等</p><p>3.运行TestNG.</p><p>文档中会使用到如下的概念：</p><p>1.一套测试（suite）由一个XML文件所表示。它能够包含一个或者多个测试，&lt;suite&gt; 标记来定义。<br>2.test由<test>标记来表示一个测试，并且可以包含一个或者多个TestNG类。<br>3.TestNG 类是包含至少一个TestNG annotation的java类，由&lt;class&gt;标签描述并包含一个或多个测试方法。<br>4.测试方法，就是一个普通的Java方法，在由@Test标记。</test></p><p>testNG.xml<br>testNG的运行需要一个配置文件，默认为testng.xml，其描述了要运行哪些测试等配置。<br>编写testNG.xml如果没有书写提示，给在头部引入<br><code>&lt;!DOCTYPE suite PUBLIC &quot;--//beust.com//testng//testng 1.0//EN&quot; &quot;http://beust.com/testng/testng-1.0.dtd&quot; &gt;</code>就会有提示了</p><h4 id="2-实践"><a href="#2-实践" class="headerlink" title="2.实践"></a>2.实践</h4><p>testng.xml是testNG的配置文件，以xml格式记录测试文件，项目创建成功后并没有自动创建testng.xml文件，需要自己添加，添加步骤如下：</p><p>1)在eclipse中创建项目，如下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/9tlZLQ1vqwmhWYa.png" alt="1232840-20191017112227325-1596448684.png"></p><p>2)选择项目，右击 弹出菜单并选择菜单：【TestNG】-【Convert to TestNG】如下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/1EugZnfo6i5ehRH.png" alt="1232840-20191017112923321-2127618153.png"></p><p>3)勾选 Generate test.xml，并设置testng.xml相关信息，如下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/3CTk6fNmpjiwM7V.png" alt="1232840-20191017113326024-1132243166.png"></p><p>4）设置好testng.xml相关信息后 可以点击 【next】or【Finish】按钮进入下一步，下面是点击【next后的界面】</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/TefhOlrYSmNIipy.png" alt="1232840-20191017113617897-1542347848.png"></p><p>5）再点击【finish】按钮，testng.xml文件创建成功，可在主界面看到</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/Ok2f3e7DlopvhKU.png" alt="1232840-20191017113714684-539400294.png"></p><p>6）双击 testng.xml文件 可对文件内容进行编辑</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/mk4SPHoYlBVhqej.png" alt="1232840-20191017113841092-1607550552.png"></p><p>7）testng.xml文件编辑完毕，选择该文件、右击可运行测试类 如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/mwyNX9TscQvKlnW.png" alt="1232840-20191017114419044-1425191477.png"></p><p>注意：TestNG使用的是 正则表达式，而不是通配符。注意这二者的区别</p><p>例如：”anything” 是匹配于 “.*” – 点和星号 – 而不是星号 “*”</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;&lt;suite name=&quot;Suite&quot;&gt;  &lt;test name=&quot;Test&quot;&gt;    &lt;classes&gt;      &lt;class name=&quot;hongge.NewTest&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; &lt;!-- Test --&gt;&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><p>Groups<br>testNG可以将各个method存放在不同的group里面，然后运行的时候可以指定要运行的group。Group指定的方式如下：</p><pre><code>@Test(groups = {&quot;fast&quot;, &quot;unit&quot;, &quot;database&quot; })public voidrowShouldBeInserted() {}</code></pre><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><p>1.创建测试实例加法类TestSum</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/MEFKwkzQ1HdS4Nm.png" alt="1232840-20191017153919343-146051914.png"></p><p>2.参考代码</p><pre><code>package hongge;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-02 - TestNG之理论实践篇 *  * 2016年05月13日 */public class TestSum {    private int mytestsum;    public int add(int num1,int num2){        mytestsum = num1 + num2;        return mytestsum;    }}</code></pre><p>3.按照一开始的步骤创建TestNG测试业务逻辑类：NewTest</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/x16kswTIpHPGStY.png" alt="1232840-20191017154349965-488184460.png"> </p><p>4.参考代码：</p><pre><code>package hongge;import org.testng.annotations.Test;import static org.testng.Assert.assertEquals;import hongge.TestSum;/** * @author 北京-宏哥 *  * java自动化测试交流群：694280102 * * Java自动化测试框架-01 - TestNG之入门篇 * * 2016年05月13日 */public class NewTest {    private TestSum newSum = new TestSum();    @Test(groups = { &quot;t1&quot;, &quot;t2&quot; })    public void f() {        int mysum = newSum.add(1, 2);        assertEquals(3, mysum, &quot;Right&quot;);        System.out.println(&quot;运行f1方法&quot;);    }    @Test(groups = { &quot;t2&quot; })    public void f2() {        int mysum = newSum.add(2, 2);        assertEquals(3, mysum, &quot;Right&quot;);// 错误的用例        System.out.println(&quot;运行f2方法&quot;);    }    @Test(groups = { &quot;t1&quot; })    public void f3() {        int mysum = newSum.add(1, 2);        assertEquals(3, mysum, &quot;Right&quot;);        System.out.println(&quot;运行f3方法&quot;);    }}</code></pre><p>5.修改testNG.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;&lt;suite name=&quot;Suite&quot;&gt;  &lt;test name=&quot;Test&quot;&gt;      &lt;groups&gt;        &lt;run&gt;            &lt;include name =&quot;t1&quot;/&gt;        &lt;/run&gt;    &lt;/groups&gt;    &lt;classes&gt;      &lt;class name=&quot;hongge.NewTest&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; &lt;!-- Test --&gt;&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><p>6.右键点击testng.xml，选择run as-&gt; testNG suite：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/HBqzJFetXgZIVkS.png" alt="1232840-20191017154936165-1619149771.png"></p><p>7.console输出结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/uaQMXbPWInT3m6q.png" alt="1232840-20191017155108048-857815486.png"> </p><p>8.从上图我们清楚地可以看到：当运行t1测试组时，就仅仅运行f()和f3()方法。</p><p>9.修改testNG.xml运行t2测试组，修改XML文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;&lt;suite name=&quot;Suite&quot;&gt;  &lt;test name=&quot;Test&quot;&gt;      &lt;groups&gt;        &lt;run&gt;            &lt;include name =&quot;t2&quot;/&gt;        &lt;/run&gt;    &lt;/groups&gt;    &lt;classes&gt;      &lt;class name=&quot;hongge.NewTest&quot;/&gt;    &lt;/classes&gt;  &lt;/test&gt; &lt;!-- Test --&gt;&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><p>console结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/thECfsNJUdPevak.png" alt="1232840-20191017155359505-1792917337.png"></p><p>10.其中f2()方法故意留个错误，我们看下出现bug的情况：期望是4，但是不是3.</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/TUoetY2Ahz59vSb.png" alt="1232840-20191017155458175-806936682.png"></p><p>11.哎呀！脑阔短路了，看测试报告不是更加直观啊，现在分享的就是它，请看下边吧：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/892OXlgHxvoULq7.png" alt="1232840-20191017162632781-808873195.png"></p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>额外知识：在java代码中，@Test(groups={“t1”,”t2”})可以在大括号里指定多个组，中间用逗号分开就行。在testng.xml中<run>标签下还可以书写<exclude name="abc">标签，表示不执行属于abc组的用例。<br>好了，今天就分享到这里！！！</exclude></run></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动化测试框架-01</title>
      <link href="/2016/05/12/testng/"/>
      <url>/2016/05/12/testng/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Java自动化测试框架-01 - TestNG之入门篇 - 大佬的鸡肋，菜鸟的盛宴（详细教程）</strong></p><h4 id="1-TestNG是什么"><a href="#1-TestNG是什么" class="headerlink" title="1.TestNG是什么?"></a>1.TestNG是什么?</h4><h5 id="TestNG按照官方的定义："><a href="#TestNG按照官方的定义：" class="headerlink" title="TestNG按照官方的定义："></a>TestNG按照官方的定义：</h5><p>TestNG是一个测试框架，其灵感来自JUnit和NUnit，但引入了一些新的功能，使其功能更强大，使用更方便。</p><p>TestNG是一个开源自动化测试框架;TestNG表示下一代(Next Generation的首字母)。 TestNG类似于JUnit(特别是JUnit 4)，但它不是JUnit框架的扩展。它的灵感来源于JUnit。它的目的是优于JUnit，尤其是在用于测试集成多类时。 TestNG的创始人是Cedric Beust(塞德里克·博伊斯特)。</p><p>TestNG消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。 因为它在很大程度上借鉴了Java注解(JDK5.0引入的)来定义测试，它也可以显示如何使用这个新功能在真实的Java语言生产环境中。</p><h5 id="TestNG的特点"><a href="#TestNG的特点" class="headerlink" title="TestNG的特点"></a>TestNG的特点</h5><blockquote><p>注解<br>TestNG使用Java和面向对象的功能<br>支持综合类测试(例如，默认情况下，不用创建一个新的测试每个测试方法的类的实例)<br>独立的编译时测试代码和运行时配置/数据信息<br>灵活的运行时配置<br>主要介绍“测试组”。当编译测试，只要要求TestNG运行所有的“前端”的测试，或“快”，“慢”，“数据库”等<br>支持依赖测试方法，并行测试，负载测试，局部故障<br>灵活的插件API<br>支持多线程测试</p></blockquote><p>TestNG(Next Generation)是一个测试框架，它受到JUnit和NUnit的启发，而引入了许多新的创新功能，如依赖测试，分组概念，使测试更强大，更容易做到。 它旨在涵盖所有类别的测试：单元，功能，端到端，集成等…</p><p>TestNG，即Testing, Next Generation，下一代测试技术，是一套根据JUnit 和NUnit思想而构建的利用注释来强化测试功能的一个测试框架。TestNG设计涵盖所有类型的测试：单元，功能，端到端，集成等。学习TestNG之前需要先学习编程语言Java、配置本地JDK环境（JDK1.5版本或以上）和安装java开发工具eclipse。</p><h4 id="2-TestNG下载并安装"><a href="#2-TestNG下载并安装" class="headerlink" title="2.TestNG下载并安装"></a>2.TestNG下载并安装</h4><p>从这里 <a href="http://testng.org/doc/download.html" target="_blank" rel="noopener">http://testng.org/doc/download.html</a> 下载当前版本的TestNG，打开zip分发来获取TestNG解压缩文件，其中包含以下子文件：</p><p>Testng-6.jar(请直接添加到您的项目中，也可能无法仅使用此jar来成功构建代码，因为TestNG官方版本不包括所有外部jar文件，以减少包的大小)<br>文档(TestNG教程资料)<br>示例代码<br>Testng 源代码<br>Readme文档</p><p>对于初学者，宏哥推荐你从示例代码和文档开始和编写TestNG。</p><p>如果使用Eclipse IDE，建议按照以下方法插件，建议使用更新站点：</p><p>对于Eclipse 3.4及更高版本，请输入 <a href="http://beust.com/eclipse" target="_blank" rel="noopener">http://beust.com/eclipse</a><br>对于Eclipse 3.3及更低版本，请输入 <a href="http://beust.com/eclipse1" target="_blank" rel="noopener">http://beust.com/eclipse1</a></p><h4 id="3-在Eeclipse中安装testNG"><a href="#3-在Eeclipse中安装testNG" class="headerlink" title="3.在Eeclipse中安装testNG"></a>3.在Eeclipse中安装testNG</h4><p>在官网上部导航区域点击“Download”链接，该页面介绍了集成TestNG的不同方式。</p><p>在“Eclipse plug-in”区域介绍了两种Eclipse安装插件的方式。</p><p>硬性要求：JDK1.7以上版本、Eclipse4.2以上版本。</p><p>Java 1.7+ is required for running the TestNG for Eclipse plugin.</p><p>Eclipse 4.2 and above is required. Eclipse 3.x is NOT supported any more, please update your Eclipse to 4.2 or above.</p><p>两种在线安装方式：</p><h5 id="1、通过Eclipse-Marketplace安装；"><a href="#1、通过Eclipse-Marketplace安装；" class="headerlink" title="1、通过Eclipse Marketplace安装；"></a>1、通过Eclipse Marketplace安装；</h5><p>1）打开Eclipse Help -&gt;MarketPlace，在搜索框里面输入TestNG搜索，然后安装TestNG插件。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/jhfndTKGLoMxszO.png" alt="1232840-20191015095807878-465283044.png"></p><p>2）点击“Install”，稍等几分钟，等待插件下载</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/g8o47TqXVbh9dal.png" alt="1232840-20191015100046864-361794117.png"></p><p>3）下载成功后，点击“Confirm”，进行安装（其中第二个Maven项目可选择安装也可以不安装，但是宏哥建议都安装上）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/DRVynXKfTg9BlOA.png" alt="1232840-20191015100328783-685124913.png"></p><p>4）稍等一会等待安装</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/QtmWI6R5fCoeVjG.png" alt="1232840-20191015100606453-1689565010.png"></p><h5 id="2、通过Update-Site安装；"><a href="#2、通过Update-Site安装；" class="headerlink" title="2、通过Update Site安装；"></a>2、通过Update Site安装；</h5><p>1） 通过update site也可以进行插件的安装，方法是：在Eclipse中点击Help菜单，选择Install New Software选项，在弹出页面中输入安装地址：<a href="http://beust.com/eclipse即可安装。" target="_blank" rel="noopener">http://beust.com/eclipse即可安装。</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/BsveAyu3U2FDdI6.png" alt="1232840-20191016100534821-2019760430.png"></p><h5 id="3、离线安装TestNG插件："><a href="#3、离线安装TestNG插件：" class="headerlink" title="3、离线安装TestNG插件："></a>3、离线安装TestNG插件：</h5><p>受网络等因素影响，在线安装方式速度比较慢，可以通过如下方式离线安装TestNG插件。</p><p>1）通过testng下载网址找到插件下载地址，</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/NHeCJ5rFZaXp8Vm.png" alt="1232840-20191016100930419-774328356.png"></p><p>2）浏览器直接访问网址， <a href="http://beust.com/eclipse" target="_blank" rel="noopener">http://beust.com/eclipse</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/TJwoQVDzkyS1PgE.png" alt="1232840-20191016101306759-1760390438.png"></p><p>3）选择最下部的zipped文件夹链接；</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/AjPXOzRKMk4HD7e.png" alt="1232840-20191016101228455-342061080.png"></p><p>4）选择版本，如：“7.0.0.201908240652/”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/xUirGveM9Ddh83Z.png" alt="1232840-20191016101825258-256441345.png"></p><p>5）点击超链接，即可下载离线安装文件。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/92LZgBQ4km5Rqxd.png" alt="1232840-20191016101901653-119225646.png"></p><p>6）解压压缩包，文件目录如下图所示。可以把features和plugins中的内容分别拷贝到eclipse对应文件夹；</p><p>或把解压后的整个目录拷贝到dropins中。</p><p>验证是否安装成功：</p><p>a) 打开命令行，到当前eclipse的目录下，输入eclipse -clean，重新启动eclipse，这样eclipse就会加上新的插件了。</p><p>b) 如果插件不能生效，则请将eclipse\configuration\org.eclipse.update目录删除后再启动eclipse。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/HWyzfai6wj1I7QR.png" alt="1232840-20191016103639841-1395157078.png"></p><p>7) 不解压文件，通过eclipse的Install new software安装。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/gvte3JGFnORyiD2.png" alt="1232840-20191016103842096-158891322.png"></p><p>8）点击Add，弹出Install Repository对话框，填写Name，点击“Archive”按钮，选择本地要安装的Jar或者Zip文件，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/mNAP3uG12oqSyLg.png" alt="1232840-20191016104006894-329082640.png"></p><p>9）点击OK，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/bu1wqBZ3ihXjpMQ.png" alt="1232840-20191016104101995-1812093482.png"></p><p>10）根据需求勾选上列表框中的安装项，点击“Next”，然后根据提示一直往下操作，直到Finish，这样就完成了。</p><h5 id="4、验证插件安装是否成功"><a href="#4、验证插件安装是否成功" class="headerlink" title="4、验证插件安装是否成功"></a>4、验证插件安装是否成功</h5><p>打开Eclipse，新建-other，选择“TestNG——&gt;TestNG Class”。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/fg3olezRGNxLFE8.png" alt="1232840-20191016104928316-1707715950.png"></p><p>出现这个说明插件安装成功。</p><p>至此环境搭建完成，可以开始写测试的case了。</p><h5 id="5、小试牛刀"><a href="#5、小试牛刀" class="headerlink" title="5、小试牛刀"></a>5、小试牛刀</h5><p>1）安装成功后，在项目的package上右键可以看到TestNG–&gt;Create TestNG class。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/VMwriQzJDZ2RNWg.png" alt="1232840-20191016095257613-406407004.png"></p><p>2）这里可以勾选TestNG的注解方法。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/NngalEXbFLRfQwP.png" alt="1232840-20191016095440319-1328419522.png"></p><p>3）我们先勾选一下@BeforeTest、@AfterTest、@DataProvider，自动生成的类文件如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/pxOhIbmT5vdwBQ7.png" alt="2187242-6c8ccaa79222d1e3.png"></p><p>4）这里报错了，是因为我们还没有将TestNG加入到我们的library中来，点击错误，会有import Library的选项，点击便有了，如图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/Q8ZiSKLMkRGnVPC.png" alt="2187242-1178b9bf120d3a15.png"></p><p>5）从一个简单的测试case开始入手，代码如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/WjNkebIvZSHL1u7.png" alt="1232840-20191016111501166-889053771.png"></p><p>6）将鼠标点击代码任意处，右键Run As –&gt; TestNG Test，</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/4lWZGyr6zSEpDuM.png" alt="1232840-20191016111757415-2078555466.png"></p><p>7）console控制台运行后结果如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/p6tZKhPEoLVw4u7.png" alt="1232840-20191016112007706-1144986533.png"></p><p>从测试的结果可以看到执行的顺序是beforeTest()–&gt;Test()–&gt;afterTest()，同时Test()方法从dataProvider dp里面接收参数。关于这部分知识宏哥在下一篇会讲解，敬请期待和关注宏哥！！！</p><p>8）TestNG默认情况下，会生成两种类型的测试报告HTML和XML，测试报告位于 “test-output” 目录下。右键项目刷新一下项目就可以看到：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/ysX3mzxgd6LOAK4.png" alt="1232840-20191016112601262-984271713.png"></p><p>9）用浏览器打开/test-output/Default suite/Default test.html</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/dGOtTILZA62xVUQ.png" alt="1232840-20191016112711382-2058458457.png"></p><p>10）可以看到如下图的测试报告：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/11/ehLpXCAQD1Y6ix9.png" alt="1232840-20191016112842048-901541196.png"></p><p>11）参考代码</p><pre><code>package hongge;import org.testng.annotations.Test;import org.testng.annotations.DataProvider;import org.testng.annotations.BeforeTest;import org.testng.annotations.AfterTest;/** * @author 北京-宏哥 * * java自动化测试交流群：694280102 * * Java自动化测试框架-01 - TestNG之入门篇 * * 2016年05月12日 */public class NewTest {  @Test(dataProvider = &quot;dp&quot;)  public void f(Integer n, String s) {      System.out.println(&quot;第一个参数是&quot;+n+&quot;,第二个参数是&quot;+s);  }  @DataProvider  public Object[][] dp() {    return new Object[][] {      new Object[] { 1, &quot;a&quot; },      new Object[] { 2, &quot;b&quot; },    };  }  @BeforeTest  public void beforeTest() {      System.out.println(&quot;------------开始测试------------&quot;);  }  @AfterTest  public void afterTest() {      System.out.println(&quot;------------结束测试------------&quot;);  }}　</code></pre><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p> 好了，今天就分享到这里！！！</p><p>有问题加入java自动化测试交流群：694280102</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> TestNG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> TestNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试27</title>
      <link href="/2016/04/22/appium/"/>
      <url>/2016/04/22/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十七）-让你在手机找到溜冰一样的感觉666，溜得飞起来 - 低级滑动（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　随着现在智能手机的普及和应用，小到五六岁或者更小的娃娃，老至七八十岁老头老太太都是智能手机的用户，基本上达到每个人都在用，每次在地铁或者公交上，就看看到这样的场面，手指不停地在手机屏幕上来来回回的的滑呀滑，滑呀滑！滑个不停，那么我们如何在自动化测试中用脚本来实现这些操作呢？？？在这里宏哥给小伙伴们介绍两种操作，一个是比较低级的滑动，另一个是比较高级的滑动。</p><h4 id="2-低级溜冰的滑动"><a href="#2-低级溜冰的滑动" class="headerlink" title="2.低级溜冰的滑动"></a>2.低级溜冰的滑动</h4><p>例如：在app应用日常使用过程中，会经常用到在屏幕滑动操作。如刷朋友圈上下滑操作、浏览图片左右滑动操作、特别是现在抖音上的上下滑动操作等。在自动化脚本该如何实现这些操作呢？</p><p>在Appium中模拟用户滑动操作需要使用swipe方法，让宏哥带着大家一起看一下该方法源码，该方法定义如下：</p><p>start_x - 滑动开始x轴坐标<br>start_y - 滑动开始y轴坐标<br>end_x - 滑动结束x轴偏移量<br>end_y - 滑动结束y轴偏移量<br>duration - (可选) 执行此次滑动时间，单位毫秒.<br>其中end_x和 end_y 为基于start_x和start_y的偏移量。最终在执行中的 to_x = start_x+end_x 并非end_x<br>duration 参数单位为ms（默认5毫秒） 注意1s =1000ms</p><p>滑动解析<br>滑动主要分为：</p><p>水平滑动<br>垂直滑动<br>任意方向滑动<br>滑动轨迹图如下：</p><p>示例：<br>获取屏幕尺寸</p><p>左滑 - x 坐标由大到小，y 坐标不变<br>技巧：左滑是从较大x值 —&gt;较小x值，所以 to_x=sx+(-ex)</p><p>技巧：左滑时y轴值基本无变化，所以ey=0</p><p>技巧：sx的值一定大于屏幕尺寸的53%，否则虽向左滑动但不能生效切换页面</p><p>def swipe_left(self):<br>      s = self.GetPageSize()<br>      sx = s[0] * 0.57<br>      sy = s[1] * 0.75<br>      ex = s[0] * 0.55<br>      ey = 0<br>      self.driver.swipe(sx, sy, -ex, ey, dt)<br>右滑 - x 坐标由小到大，y 坐标不变<br>技巧：sx的值一定不能大于屏幕尺寸的 46%，否则虽然向右滑动但不能生效切换页面</p><p> def swipe_right(self):<br>      s = self.GetPageSize()<br>      sx = s[0] * 0.43<br>      sy = s[1] * 0.75<br>      ex = s[0] * 0.54<br>      ey = 0<br>      self.driver.swipe(sx, sy, ex, ey, dt)<br>上滑 （俗称上拉加载更多）-   x 坐标不变，y 坐标由大到小<br>技巧：上滑是从较大y值—&gt;较小y值，所以to_y=sy+(-ey)</p><p>技巧：上滑时x轴值基本无变化，所以ex = 0</p><p>技巧：sx的值可s[0]范围内随意，sy和ey 需在 s[1]0.2 – s[1]-s[1]0.4 之间取值，<br>因为需要考虑：状态条、导航栏、底部功能栏等所占数值</p><p> def swipe_up(self):<br>     s = self.GetPageSize()<br>     sx = s[0] * 0.43<br>     sy = s[1] * 0.45<br>     ex = 0<br>     ey = s[1] * 0.55<br>     self.driver.swipe(sx, sy, ex, -ey, dt）<br>下滑（俗称下拉刷新）-  x 坐标不变，y 坐标由小到大<br>技巧：sx的值可s[0]范围内随意，sy和ey 需在 s[1]<em>0.2 – s[1]-s[1]</em>0.4 之间取值，<br>因为需要考虑：状态条、导航栏、底部功能栏等所占数值</p><p>def swipe_down(self):<br>      s = self.GetPageSize()<br>      sx = s[0] * 0.35<br>      sy = s[1] * 0.45<br>      ex = 0<br>      ey = s[1] * 0.55<br>      self.driver.swipe(sx, sy, ex, ey, dt)<br>实践应用<br>　　“纸上得来终觉浅，绝知此事要躬行 ”，这句话的意思就是，从书本上看来的东西终究是非常的片面的，因为很多东西，不单单是看到的那个样，而且耳听也是虚的，没有亲自去见证这个东西的存在，他的真假，或者是否存在都是一个未知数，那第二句呢，就是这件事情只有你亲自做了，才能知道是真是假。才会有经验所得。很简单的一个例子，就是如果你出去找工作，都会让你填自己的工作经历，一方面看看你是不是这块料，其实这个也是一块敲门砖，你写了，他们才会看看你的能力能不能驾驭他们这份工作，很多人都是的，如果有的话，那你幸运了，你就是他们公司的重点培养对象，会格外的关注到你，这对找工作的我们也是一个非常好的，非常有利的一件事。好了那么就跟随宏哥来躬行一下吧。</p><p>测试场景<br>安装启动考研帮，手动向水平左滑动首页引导页面。<br>点击“立即体验”进入登录页面。<br>测试环境<br>1.宏哥的系统环境是Windows 10版本 64位系统</p><p>2.j宏哥的dk版本：”1.8.0_181”</p><p>3.宏哥的appium版本：1.4.16 </p><p>4.selenium：3.141.0</p><p>安装selenium：</p><p>输入指令pip install selenium</p><p>验证安装成功：pip show selenium</p><p>5.测试设备：Android 5.1.1 (不能低于5.0版本)</p><p>6.Python：3.7.2</p><p>命令：python -V  ，回车即可。</p><p>7.测试App：考研帮Android app V3.1.0</p><p>想法与思路<br>安装启动考研帮<br>由于目前版本低，会有升级提示，代码实现点击“取消”<br>代码实现向左滑动首页引导页面<br>点击“立即体验”进入登录页面<br>代码实现<br>（1）安装启动考研帮</p><p>（2）升级提示，点击“取消”（这里宏哥将其封装为一个方法，后边调用即可！）</p><p>（3）向左滑动到首尔引导页面，用到我们一开始介绍的swipe方法</p><p>（4）点击“立即体验”，进入登录页面</p><p>运行结果</p><p>运行过程</p><p>参考代码<br> capability.py<br> 1 # coding=utf-8<br> 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行<br> 3<br> 4 # 2.注释：包括记录创建时间，创建人，项目名称。<br> 5 ‘’’<br> 6 Created on 2019-8-05<br> 7 @author: 北京-宏哥   QQ交流群：707699217<br> 8 Project:学习和使用appium自动化测试-滑动<br> 9 ‘’’<br>10 # 3.导入模块<br>11 from  appium import webdriver<br>12 from selenium.common.exceptions import NoSuchElementException<br>13<br>14 desired_caps={}<br>15 desired_caps[‘platformName’]=’Android’<br>16 desired_caps[‘deviceName’]=’127.0.0.1:62025’<br>17 desired_caps[‘platforVersion’]=’5.1.1’<br>18 desired_caps[‘automationName’]=’uiautomator2’<br>19<br>20 desired_caps[‘app’]=r’C:\Users\DELL\Downloads\kaoyanbang.apk’<br>21 desired_caps[‘appPackage’]=’com.tal.kaoyan’<br>22 desired_caps[‘appActivity’]=’com.tal.kaoyan.ui.activity.SplashActivity’<br>23<br>24 desired_caps[‘noReset’]=’False’<br>25 desired_caps[‘unicodeKeyboard’]=”True”<br>26 desired_caps[‘resetKeyboard’]=”True”<br>27<br>28 driver=webdriver.Remote(‘<a href="http://localhost:4723/wd/hub&#39;,desired_caps" target="_blank" rel="noopener">http://localhost:4723/wd/hub&#39;,desired_caps</a>)<br>29 driver.implicitly_wait(2)<br>30<br>31 #定义的点击“取消”按钮方法<br>32 def check_cancelBtn():<br>33     print(‘check cancelBtn’)<br>34<br>35     try:<br>36         cancelBtn = driver.find_element_by_id(‘android:id/button2’)<br>37     except NoSuchElementException:<br>38         print(‘no cancelBtn’)<br>39     else:<br>40         cancelBtn.click()<br>41<br>42 #定义的点击“跳过”按钮方法<br>43 def check_skipBtn():<br>44     print(‘check skipBtn’)<br>45<br>46     try:<br>47         skipBtn = driver.find_element_by_id(‘com.tal.kaoyan:id/tv_skip’)<br>48     except NoSuchElementException:<br>49         print(‘no skipBtn’)<br>50     else:<br>51         skipBtn.click()<br>52<br>53 #调用点击“取消”按钮方法<br>54 check_cancelBtn()<br>55<br>56 #调用点击“跳过”按钮方法<br>57 # check_skipBtn()<br>swipe.py<br> 1 # coding=utf-8<br> 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行<br> 3<br> 4 # 2.注释：包括记录创建时间，创建人，项目名称。<br> 5 ‘’’<br> 6 Created on 2019-8-05<br> 7 @author: 北京-宏哥   QQ交流群：707699217<br> 8 Project:学习和使用appium自动化测试-滑动<br> 9 ‘’’<br>10 # 3.导入模块<br>11 from capability import driver<br>12 from time import sleep<br>13 from selenium.common.exceptions import NoSuchElementException<br>14<br>15 #定义获取手机屏幕大小方法<br>16 def get_size():<br>17     x=driver.get_window_size()[‘width’]<br>18     y=driver.get_window_size()[‘height’]<br>19     return x,y<br>20<br>21 #调用获取手机屏幕大小<br>22 l=get_size()<br>23 print(l)<br>24<br>25 #定义向左滑动方法<br>26 def swipeLeft():<br>27     l=get_size()<br>28     x1=int(l[0]<em>0.9)<br>29     y1=int(l[1]</em>0.5)<br>30     x2=int(l[0]*0.1)<br>31     driver.swipe(x1,y1,x2,y1,1000)<br>32 #定义向上滑动方法<br>33 def swipeUp():<br>34     l = get_size()<br>35     x1 = int(l[0] * 0.5)<br>36     y1 = int(l[1] * 0.95)<br>37     y2 = int(l[1] * 0.35)<br>38     driver.swipe(x1, y1, x1, y2, 1000)<br>39 #定义向下滑动方法<br>40 def swipeDown():<br>41     l=get_size()<br>42     x1 = int(l[0] * 0.5)<br>43     y1 = int(l[1] * 0.35)<br>44     y2 = int(l[1] * 0.85)<br>45     driver.swipe(x1, y1, x1, y2, 1000)<br>46 #定义向右滑动方法<br>47 def swipeRight():<br>48     l=get_size()<br>49     y1 = int(l[1] * 0.5)<br>50     x1 = int(l[0] * 0.25)<br>51     x2 = int(l[0] * 0.95)<br>52     driver.swipe(x1, y1, x2, y1, 1000)<br>53<br>54 for i in range(2):<br>55     #调用向左滑动方法<br>56     swipeLeft()<br>57     sleep(0.5)<br>58<br>59 #定义的点击“立即体验”按钮方法<br>60 def click_experBtn():<br>61     print(‘click experBtn’)<br>62<br>63     try:<br>64         experBtn = driver.find_element_by_id(‘com.tal.kaoyan:id/activity_splash_guidfinish’)<br>65     except NoSuchElementException:<br>66         print(‘no skipBtn’)<br>67     else:<br>68         experBtn.click()<br>69<br>70 #调用点击“立即体验”按钮<br>71 click_experBtn()<br>小结<br> appium的滑动实现和溜冰一样它们是门艺术，实现不好就会出现事与愿违的操作，就拿溜冰来说，做的不好就容易受伤；而appium呢，比如本来想要向上滑动，却出现了下拉的动作，这样使得我们在调试中就要花费大量时间去调试滑动操作。</p><p>以下是宏哥在滑动操作中总结的一点经验，希望可以对遇到这方面问题的童鞋们或者是小伙伴们有一点帮助；</p><p>总结：</p><p>1、滑动时中间要巧妙的加等待时间，不加等待时间容易出错，而且加等待时间的长短也要掌握好，一般在200-1000毫秒之间应该差不多，自己调试几次感觉一下哪个时间比较稳，每个程序可能会有所差异，还要注意的是ios和Android的等待时间也会有差异，ios等待1000毫秒可能出现长安的效果；</p><p>2、滑动的坐标点，滑动的坐标点要掌握好，如果坐标点掌握不好也会导致错误出现，比如Android和ios就有很大区别。</p><p>3、代码</p><p>#定义向左滑动方法<br>def swipeLeft():<br>    l=get_size()<br>    x1=int(l[0]<em>0.9)<br>    y1=int(l[1]</em>0.5)<br>    x2=int(l[0]*0.1)<br>    driver.swipe(x1,y1,x2,y1,1000)<br>问题：</p><p>1、这里面的，[0]、[1]是根据什么来定夺的？<br>2、0.9、0.5、0.1这三个值又是怎么取的？<br>3、[0] * 0.1的意思表示？</p><p>解释：</p><p>将l[0]和l[1]的值打印出来，如图</p><p>因为滑动两次，所以循环2次，由上图可知：l[0]=720，l[1]=1280；从值宏哥理解：l[0]就是整个X轴，l[1]就是整个Y轴。<br>坐标轴一般以左上角为起始点(x=0,y=0) ；getSize()函数是返回屏幕大小，这里可以理解为右下角、即最大的(x,y)的坐标。<br>向左滑： 高度、即y轴不变， 宽度、即x轴由右边(大)-&gt;滑向左边(小)<br>综合来说， y1=getSize()[1]<em>0.5=可以理解为Y轴娶了一半，即y轴的最中央， x1=getSize()[0]</em>0.9=可以理解为X轴娶了多一半，即x轴靠右， x2=getSize()[0]*0.1=可以理解为X轴娶了一点，即x轴靠左<br>我们来看一下。打印结果看看宏哥是不是胡诌的了，答案和宏哥说的大致一样，聪明的你懂了没？实际也不用打印，直接用X轴、Y轴自己一算就知道了。</p><p>打印结果</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试26</title>
      <link href="/2016/04/21/appium/"/>
      <url>/2016/04/21/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十六）- 烟花一瞬，昙花一现 -Toast提示（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天宏哥在这里首先给小伙伴们和童鞋们分享一个有关昙花的小典故：话说昙花原是一位花神，她每天都开花，四季都灿烂。她还爱上了每天给她浇水除草的年轻人。后来，此事给玉帝得知。于是，玉帝大发雷霆，要拆散鸳鸯。他将花神抓了起来，把她贬为每年只能开一瞬间的昙花，不让她再和情郎相见，还把那年轻人送去灵鹫山出家，赐名韦陀，让他忘记前尘，忘记花神。<br>　　多年过去了，韦陀果真忘了花神，潜心习佛，渐有所成。而花神却怎么也忘不了那个曾经照顾她的小伙子。她知道每年暮春时分，韦陀总要下山来为佛祖采集朝露煎茶。所以，昙花就选择在那个时候开放。她把集聚了整整一年的精气绽放在那一瞬间，希望韦陀能回头看她一眼，能记起她。可是，千百年间过去了，韦陀一年年的下山来采集朝露，昙花一年年的默默绽放，韦陀始终没有记起她。直到有一天，一名枯瘦的男子从昙花身边走过，看到花神忧郁孤苦之情，便停下脚步问花神：“你为什么哀伤？”。花神惊异，因为凡人是看不到花神的真身。如果是大罗金仙头上有金光、如果是妖魔头上有黑气、如果而凡人头上是无任何灵光。刚刚从身边走过的明明是一个凡人，如何看得见自己的真身。花神犹豫片刻，只是答到：“你帮不了我”。又默默等待韦陀，不再回答那个男子的话。40年后，那个枯瘦男子又从昙花身边走过，重复问了40年前的那句话：“你为什么哀伤？”花神再次犹豫片刻，只是答道“你也许帮不了我”。枯瘦的男子笑了笑离开。再40年后，一个枯瘦的老人再次出现在花神那里，原本枯瘦的老人看起来更是奄奄一息。当年的男子已经变成老人，但是他依旧问了和80年前一样的话：“你为什么哀伤？”。昙花答道：“谢谢你这个凡人，在你一生问过我3次，但是你毕竟是凡人，而且已经奄奄一息，还怎么帮我，我是因爱而被天罚的花神”。老人笑了笑，说“我是聿明氏，我只是来了断80年前没有结果的那段缘分。花神，我只送你一句‘缘起缘灭缘终尽、花开花落花归尘’”。说完老人闭目坐下。时间渐渐过去，夕阳的最后一缕光线开始从老人的头发向眼睛划去。老人笑道：“昙花一现为韦陀，这般情缘何有错，天罚地诛我来受，苍天无眼我来开”。说罢，老人一把抓住花神。此时的夕阳正好滑到了老人的眼睛，老人随即圆寂，抓着花神一同去往佛国去。花神在佛国见到了韦陀，韦陀也终于想起来前世因缘。佛祖知道后准韦陀下凡了断未了的因缘。<br>　　昙花一现，只为韦陀。所以，昙花又名韦陀花。也因为昙花是在夕阳后见到韦陀，所以昙花都是夜间开放。<br>　　好了，到此故事结束了，开始今天的主题 - 获取toast提示<br>在日常使用App过程中，经常会看到App界面有一些弹窗提示（如下图所示）这些提示元素出现后等待3秒左右就会自动消失，这个和我日常生活中看到的烟花和昙花是多么的相似，那么我们该如何获取这些元素文字内容呢？</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/EqBuIQNHJ6LjU21.png" alt="1232840-20190731104711784-83084378.png"></p><h4 id="2-Toast简介"><a href="#2-Toast简介" class="headerlink" title="2.Toast简介"></a>2.Toast简介</h4><p>Android中的Toast是一种简易的消息提示框。 当视图显示给用户，在应用程序中显示为浮动。和Dialog不一样的是，它永远不会获得焦点，无法被点击。<br>Toast类的思想就是尽可能不引人注意，同时还向用户显示信息，希望他们看到。而且Toast显示的时间有限，一般3秒左右就消失了。因此使用传统的元素定位工具，我们是无法定位到Toast元素的（传说中低调奢华有内涵）。</p><h4 id="3-Appium-Toast内容获取"><a href="#3-Appium-Toast内容获取" class="headerlink" title="3.Appium Toast内容获取"></a>3.Appium Toast内容获取</h4><p>Add ability to verify TOAST messages (these can’t be interacted with, only text retrieval allowed)</p><p>1.Appium 1.6.3开始支持识别Toast内容，主要是基于UiAutomator2，因此需要在Capablity配置如下参数：</p><pre><code>&#39;automationName&#39;:&#39;uiautomator2&#39;</code></pre><p>或者：</p><pre><code>desired_caps[&#39;automationName&#39;]=&#39;uiautomator2&#39;</code></pre><p>2.安装appium-uiautomator2-driver: 安装命令如下：</p><pre><code>cnpm install appium-uiautomator2-driver</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/1jDlFtd9Ir4Pe5i.png" alt="1232840-20190731103440974-1800808696.png"></p><p>安装成功后可以在 C:\Users\Administrator\node_modules看到对应的文件：</p><pre><code>_appium-uiautomator2-driver@1.12.0@appium-uiautomator2-driver_appium-uiautomator2-server@1.10.0@appium-uiautomator2-server</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/t7zySCXNLY2qQ3P.png" alt="1232840-20190731103815142-88803420.png"></p><h4 id="4-测试环境"><a href="#4-测试环境" class="headerlink" title="4.测试环境"></a>4.测试环境</h4><p>1.宏哥的系统环境是Windows 10版本 64位系统</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/kfQgNhMGaOFzu3V.png" alt="1232840-20190731105030392-1196142956.png"></p><p>2.j宏哥的dk版本：”1.8.0_181”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/VZhp18m4g2eOkqf.png" alt="1232840-20190731105159707-2120356275.png"></p><p>3.宏哥的appium版本：1.4.16 </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/9M5OWAE7NXf1UiY.png" alt="1232840-20190731132025095-1135239812.png"></p><p>经查询appium1.6.3以上才能识别toast，之前安装appium版本是1.4.X,于是重整了测试环境</p><p>官方文档是这么说的</p><p>Firstly you should install appium server. Appium getting started. The version 1.6.3 or greater is recommended.</p><p>Since version 5.x there many features based on Java 8. So we recommend to install JDK SE 8 and provide that source compatibility.</p><p>也就是更新appium 到1.6.3以上，java-client版本最好是5.x，jdk要用1.8、selenium要用3.x，其他版本不一定兼容，要自己亲测是否可用</p><p>想识别toast，官网是这么说，因此为了不必要的麻烦折腾环境最好还是卸载低版本的appium，然后安装版本高于1.6.3的appium。</p><p>appium有两种安装方式，看你的需要选择方法一或方法二</p><p>方法一：</p><pre><code>  使用下载地址：https://bitbucket.org/appium/appium.app/downloads/，可以下载exe应用，桌面程序，更适合新手，界面设置，更容易上手，但是目前appium已经更新1.6.3+，以上下载地址还没更新最新的上去。如果不使用UIAUTOMATOR2等appium提供的新功能，不需要下载比较新的ppium,</code></pre><p>方法二：</p><pre><code>  已安装了node.js，可以使用npm命令安装appium，打开cmd,输入npm install -g appium，回车，即可开始安装目前最新的版本，速度会比较慢，毕竟是国外的，如果不安装最新的使用命令：npm install -g appium@xxx，xxx是版本号，如下载appium1.6.3，命令为npm install -g appium@1.7.0，我是一开始使用方法一，之后发现几个功能appium要更新到1.6.3以上才支持，所以我目前版本更新到了1.6.3+以上。</code></pre><p>4.selenium：3.141.0</p><p>安装selenium：</p><p>输入指令pip install selenium</p><p>验证安装成功：pip show selenium</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/yFkvdpQ8XmtKM6f.png" alt="1232840-20190731132334499-1229339080.png"></p><p>5.测试设备：Android 5.1.1 (不能低于5.0版本)</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/MNFspubJTtxLcwV.png" alt="1232840-20190731132705354-1797960705.png"></p><p>6.Python：3.7.2</p><p>命令：python -V  ，回车即可。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/bSX8sEfL2CaBrkH.png" alt="1232840-20190731132853085-35333743.png"></p><p>7.测试App：考研帮Android app V3.1.0</p><p>8.测试场景</p><p>进入登录界面输入错误的用户名或者密码，获取Toast内容：</p><p>“用户名或密码错误，你还可以尝试4次”<br>“验证失败次数过多，请15分钟后再试”</p><h4 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5.代码实现"></a>5.代码实现</h4><p>步骤一：初始化</p><p>在capability配置内部增加：desired_caps[‘uiautomationName’]=’ uiautomator2’</p><p>步骤二：定位toast元素</p><p>（1）定义toast文本内容</p><p>（2）定义路径</p><p>（3）组合文本内容和路径进行定位：用format（）连接路径和文本内容</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/Pt68QLIDmSYF7pU.png" alt="1232840-20190731150029479-725568348.png"></p><h4 id="6-参考代码"><a href="#6-参考代码" class="headerlink" title="6.参考代码"></a>6.参考代码</h4><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-31 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-toast提示 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 from selenium.common.exceptions import NoSuchElementException13 from selenium.webdriver.support.ui import WebDriverWait14 from selenium.webdriver.support import expected_conditions as EC15 16 desired_caps = {&#39;platformName&#39;: &#39;Android&#39;,17 &#39;platforVersion&#39;: &#39;5.1.1&#39;,18 &#39;automationName&#39;: &#39;Uiautomator2&#39;,19 &#39;deviceName&#39;: &#39;127.0.0.1:62001&#39;,20 &#39;app&#39;: r&#39;C:\Users\DELL\Downloads\kaoyanbang.apk&#39;,21 &#39;appPackage&#39;: &#39;com.tal.kaoyan&#39;,22 &#39;appActivity&#39;: &#39;com.tal.kaoyan.ui.activity.SplashActivity&#39;,23 &#39;noReset&#39;: &#39;True&#39;}24 25 driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)26 driver.implicitly_wait(9)27 try:28     driver.find_element_by_id(&quot;android:id/button2&quot;).click()29 except NoSuchElementException:30     print(1)31 try:32     driver.find_element_by_id(&#39;com.tal.kaoyan:id/tv_skip&#39;).click()33 except NoSuchElementException:34     print(2)35 driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_email_edittext&#39;).clear()36 driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_email_edittext&#39;).send_keys(&#39;bjhongge&#39;)37 38 driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_password_edittext&#39;).send_keys(&#39;1213213&#39;)39 driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_login_btn&#39;).click()40 41 error_message = &quot;用户名或密码错误，你还可以尝试3次&quot;42 limit_message = &quot;验证失败次数过多，请15分钟后再试&quot;43 44 message = &#39;//*[@text=\&#39;{}\&#39;]&#39;.format(error_message)45 #message=&#39;//*[@text=\&#39;{}\&#39;]&#39;.format(limit_message)46 47 toast_element = WebDriverWait(driver, 15).until(lambda x:x.find_element_by_xpath(message))48 print(toast_element.text)</code></pre><p>说明：</p><p>连接不同的类型的变量或内容format（）</p><p>显示等待：webdriver（driver，5）</p><p>driver是webdriver的驱动程序，5是超时时间，以秒为单位</p><p>WebDriverWait()一般由 until()或 until_not()方法配合使用，下面是 until()和 until_not()方法的说明。</p><p>until(method, message=’’)</p><p>调用该方法提供的驱动程序作为一个参数，直到返回值不为 False。</p><p>until_not(method, message=’’)</p><p>调用该方法提供的驱动程序作为一个参数，直到返回值为 False。</p><p>动态函数：lambda x：x+5  </p><pre><code>   X是函数的参数，冒号后面是函数的返回值</code></pre><h4 id="7-封装toast判断"><a href="#7-封装toast判断" class="headerlink" title="7.封装toast判断"></a>7.封装toast判断</h4><p>1.单独写一个函数来封装判断是否存在toast消息，存在返回True,不存在返回False</p><pre><code> 1 def is_toast_exist(driver,text,timeout=30,poll_frequency=0.5): 2  3    &#39;&#39;&#39;is toast exist, return True or False 4  5    :Agrs: 6  7     - driver - 传driver 8  9     - text   - 页面上看到的文本内容10 11     - timeout - 最大超时时间，默认30s12 13     - poll_frequency  - 间隔查询时间，默认0.5s查询一次14 15    :Usage:16 17     is_toast_exist(driver, &quot;看到的内容&quot;)18 19    &#39;&#39;&#39;20 21    try:22 23toast_loc = (&quot;xpath&quot;, &quot;.//*[contains(@text,&#39;%s&#39;)]&quot;%text)24 25WebDriverWait(driver, timeout, poll_frequency).until(EC.presence_of_element_located(toast_loc))26 27return True28 29    except:30 31return False</code></pre><h4 id="8-封装后参考代码"><a href="#8-封装后参考代码" class="headerlink" title="8.封装后参考代码"></a>8.封装后参考代码</h4><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-31 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-toast提示 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 from selenium.common.exceptions import NoSuchElementException13 from selenium.webdriver.support.ui import WebDriverWait14 from selenium.webdriver.support import expected_conditions as EC15 16 desired_caps = {&#39;platformName&#39;: &#39;Android&#39;,17 &#39;platforVersion&#39;: &#39;5.1.1&#39;,18 &#39;automationName&#39;: &#39;Uiautomator2&#39;,19 &#39;deviceName&#39;: &#39;127.0.0.1:62001&#39;,20 &#39;app&#39;: r&#39;C:\Users\DELL\Downloads\kaoyanbang.apk&#39;,21 &#39;appPackage&#39;: &#39;com.tal.kaoyan&#39;,22 &#39;appActivity&#39;: &#39;com.tal.kaoyan.ui.activity.SplashActivity&#39;,23 &#39;noReset&#39;: &#39;True&#39;}24 25 def is_toast_exist(driver,text,timeout=30,poll_frequency=0.5):26 27    &#39;&#39;&#39;is toast exist, return True or False28 29    :Agrs:30 31     - driver - 传driver32 33     - text   - 页面上看到的文本内容34 35     - timeout - 最大超时时间，默认30s36 37     - poll_frequency  - 间隔查询时间，默认0.5s查询一次38 39    :Usage:40 41     is_toast_exist(driver, &quot;看到的内容&quot;)42 43    &#39;&#39;&#39;44 45    try:46 47toast_loc = (&quot;xpath&quot;, &quot;.//*[contains(@text,&#39;%s&#39;)]&quot;%text)48 49WebDriverWait(driver, timeout, poll_frequency).until(EC.presence_of_element_located(toast_loc))50 51return True52 53    except:54 55return False56 if __name__ == &quot;__main__&quot;:5758     driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)59     driver.implicitly_wait(9)60     try:61 driver.find_element_by_id(&quot;android:id/button2&quot;).click()62     except NoSuchElementException:63 print(1)64     try:65 driver.find_element_by_id(&#39;com.tal.kaoyan:id/tv_skip&#39;).click()66     except NoSuchElementException:67 print(2)68     driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_email_edittext&#39;).clear()69     driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_email_edittext&#39;).send_keys(&#39;bjhongge&#39;)70 71     driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_password_edittext&#39;).send_keys(&#39;1213213&#39;)72     driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_login_btn&#39;).click()73 74     error_message = &quot;用户名或密码错误，你还可以尝试3次&quot;75     limit_message = &quot;验证失败次数过多，请15分钟后再试&quot;76 77     print is_toast_exist(driver, error_message)</code></pre><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>1.注意：Toast内容为中文时，顶部必须注释# coding=utf-8 否则会因为编解码导致文字识别失败。</p><ol start="2"><li>用npm安装appium-uiautomator2-driver ，会出现错误，卡顿之后安装不成功。</li></ol><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/zYiBvN8G1pC2Hkc.png" alt="1232840-20190731102139408-1017101660.png"></p><p>解决办法</p><p>（1）首先执行这个命令：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>       安装cnpm（完成后如下图）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/OgerB5RzymTqtLc.png" alt="1232840-20190731102051112-22613674.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/Dq4hgr8nsLyYdPW.png" alt="1232840-20190731102139408-1017101660.png"></p><p>（2）然后通过这个命令： cnpm install appium-uiautomator2-driver   安装uiautomator2的配置文件，如图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/1jDlFtd9Ir4Pe5i.png" alt="1232840-20190731102139408-1017101660.png"></p><p>3.cnpm与npm的区别：</p><p>（1）npm介绍</p><p>说明：npm（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）<br>（2）使用npm安装插件：命令提示符执行npm install [-g] [–save-dev]<br>：node插件名称。<br>例：npm install gulp-less –save-dev<br>-g：全局安装。<br>将会安装在C:\Users\Administrator\AppData\Roaming\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录； 全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用；</p><p>–save：将保存配置信息至package.json（package.json是nodejs项目配置文件）；</p><p>-dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；</p><p>为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包）。<br>（3）使用npm卸载插件：npm uninstall [-g] [–save-dev]<br>PS：不要直接删除本地插件包<br>（4）使用npm更新插件：npm update [-g] [–save-dev]<br>（5）更新全部插件：npm update [–save-dev]<br>（6）查看npm帮助：npm help<br>（7）查看当前目录已安装插件：npm list</p><p>PS：npm安装插件过程：从<a href="http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），" target="_blank" rel="noopener">http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），</a></p><p>解决办法：</p><p>选装cnpm</p><p>说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”<br>官方网址：<a href="http://npm.taobao.org" target="_blank" rel="noopener">http://npm.taobao.org</a><br>安装：命令提示符执行npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误<br>注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。</p><p>4.好了，时间不早了！至此，有关toast的提示，就给小伙伴们和童鞋们方向到这里，谢谢你耐心的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试25</title>
      <link href="/2016/04/20/appium/"/>
      <url>/2016/04/20/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十五）- 那些让人抓耳挠腮、揪头发和掉头发的事 - 获取控件ID（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　在前边的第二十二篇文章里，已经分享了通过获取控件的坐标点来获取点击事件的所需要的点击位置，那么还有没有其他方法来获取控件点击事件所需要的点击位置呢？答案是：Yes！因为在不同的大小屏幕的手机上获取控件的坐标点，不是一样的，而是有变化的，因此在不同的手机机型上，我们可能都需要重新获取坐标点，这么操作起来，如果操作控件特别的多，那么获取控件的坐标点就会显得特别的繁琐。因此我们可以通过获取控件的ID来避免获取控件坐标点的这种弊端。<br>　　通过控件ID实现自动化脚本的运行，就性能而言，会比控件坐标的实现差一些；但是对于不同分辨率的设备都通用，不需要动态变换坐标。控件ID的获取主要是通过HierarchyViewer。下面就HierarchyViewer从打开方式和使用两方面进行讲解。</p><h4 id="2-HierarchyViewer的打开方式"><a href="#2-HierarchyViewer的打开方式" class="headerlink" title="2.HierarchyViewer的打开方式"></a>2.HierarchyViewer的打开方式</h4><p>　　HierarchyViewer的打开方式有两种：一种是eclipse中打开HierarchyView视图，另外一种是命令行中执行sdk/tools/hierarchyviewer.bat。<br>　　HierarchyViewer默认只能在非加密设备使用，例如工程机，工程平板或者模拟器。如果要在手机上使用HierarchyViewer，你需要在你的应用中添加一个开源库View Server。链接地址：<a href="https://github.com/romainguy/ViewServer。该篇文章中有讲解如何启动真机View" target="_blank" rel="noopener">https://github.com/romainguy/ViewServer。该篇文章中有讲解如何启动真机View</a> Server，大家如果有兴趣，可参考：<a href="https://dup2.org/node/1538。" target="_blank" rel="noopener">https://dup2.org/node/1538。</a></p><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><p>连接您的真机设备，或打开模拟器，在eclipse中， 依次选择Window-Open Perspective-Other，在Other中，选择HierarchyView视图，即可打开。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/dxI1psig53r2Jm4.png" alt="1232840-20190730130514409-573754458.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/YO391TJ5dQjlnWf.png" alt="980448-20160922090956262-1375543327.png"></p><h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><p>连接您的真机设备或打开模拟器，运行cmd窗口，进入到sdk/tools目录下，输入命令hierarchyviewer.bat，运行hierarchyviewer。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/SDkGVtOFx3qM86A.png" alt="1232840-20190730131615548-952587548.png"></p><p>或者直接在sdk/tools目录下，找到hierarchyviewer.bat，双击运行。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/oBPuvn8rHFXZ5E3.png" alt="1232840-20190730131353734-731352025.png"></p><p>未开启夜神模拟器的HierarchyViewer，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/tQp3kfialeuRwIq.png" alt="1232840-20190730134926292-1404851868.png"></p><p>开启夜神模拟器后的HierarchyViewer，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/ky1KxGQS4vgJWqN.png" alt="1232840-20190730132214943-2094463897.png"></p><p>那么接下来看一下今天的重头戏：讲解利用HierarchyViewer获取控件ID的方法。</p><h4 id="3-HierarchyViewer获取控件ID"><a href="#3-HierarchyViewer获取控件ID" class="headerlink" title="3.HierarchyViewer获取控件ID"></a>3.HierarchyViewer获取控件ID</h4><p>　　HierarchyViewer启动后，首先会看到的第一个窗口显示了设备和模拟器的列表。点击左边的箭头，就会展开当前设备或模拟器的Activity对象列表。列表中显示了设备或模拟器上，UI当前可视的所有Activity对象。这些对象按照它们的Android组件名称列出来。列表中的内容包含应用的Activity对象和系统的Activity对象。<br>当模拟器activity画面变更后，点击refresh可以加载新的页面布局信息。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/NWVv7DhIdfCgHws.png" alt="980448-20160922091114746-1563809556.png"> </p><p>　　从列表中选择你的activity名称，双击，或点击菜单栏的Load View Hierarchy按钮，进入View Hierarchy窗口，查看它的view层次结构；或者点击Inspect Screenshot按钮，进入Pixel Perfect窗口，从而查看UI的一个放大图像。我们这里点击进入View Hierarchy窗口。<br>可以从下图中看到模拟器此activity的画面布局信息，左边部分是hierarchy通过树形结构展示的布局形式，右下角是模拟器上当前页面的UI布局信息。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/wDWfBKslkR3tFgj.png" alt="980448-20160922091152715-557978456.png"></p><p>　　通过滚动鼠标，可以放大每个树节点；拖拽鼠标，移动树形结构布局。双击树节点可以展示单独的UI部分。从下图中，可以看到，id/btn_login即为登录按钮的ID。依次类推，可以查看其它控件ID。<br>注：对于列表、或者弹出框则无法直接通过点击ID操作成功，需要计算ID的坐标。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/uCcGANzfoE1pm6K.png" alt="980448-20160922091220574-1180766061.png"></p><h4 id="4-控件ID之Monkeyrunner脚本演示"><a href="#4-控件ID之Monkeyrunner脚本演示" class="headerlink" title="4.控件ID之Monkeyrunner脚本演示"></a>4.控件ID之Monkeyrunner脚本演示</h4><pre><code>同样的，我们将下面一段Monkeyrunner脚本写到一个test.py文件中，然后运行test.py文件，查看模拟器上是不是做相应的操作。</code></pre><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-30 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-获取控件的ID 9 &#39;&#39;&#39;10 # 3.导入模块11 12 from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice13 14 from com.android.monkeyrunner.easy import EasyMonkeyDevice #提供了根据ID进行访问15 16 from com.android.monkeyrunner.easy import By #根据ID返回PyObject的方法17 18 device=MonkeyRunner.waitForConnection()19 20 #启动activity（这里启动qq）21 22 device.startActivity(component=&quot;com.tencent.mobileqq/.activity.SplashActivity&quot;)23 24 easy_device=EasyMonkeyDevice(device) #必须在activity启动之后25 26 #登录界面，点击账号输入框27 28 easy_device.touch(By.id(&#39;id/0x20e&#39;),MonkeyDevice.DOWN_AND_UP)29 30 device.type(&#39;1918991791&#39;) #输入qq账号</code></pre><p>至此，获取控件ID的方式已经介绍完，由于没有深入研究，肯定有不少功能点没有介绍到，有时间的话再做完善。</p><h4 id="5-控件ID不存在或重复"><a href="#5-控件ID不存在或重复" class="headerlink" title="5.控件ID不存在或重复"></a>5.控件ID不存在或重复</h4><p>　　<br>　　我们在用monkeyrunner进行Android自动化时，通过获取坐标点或控件ID进行一系列操作。由于使用坐标点时，屏幕分辨率一旦更改，则代码中用到坐标的地方都要修改，这样导致代码的复用率较低。因此，我们多采用控件ID操作（注：控件ID需要在模拟器中使用，对于绝大多数真机不适用）。但是，某些控件的ID是不存在的或重复存在，那么，遇到这种情况，我们怎样继续使用控件ID进行自动化测呢？<br>　　例如，下图中，我想要获取最右侧红框中的id/tv，但是，大家会发现，和它并列的也有重复的控件id值。现在我们就讲述一下这种情况（控件ID不存在同样处理）。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/oAvnIuxhHzaUDlE.png" alt="980448-20161031193202002-738900198.png"></p><p>　　我们从这个控件树的节点角度来思考如何获得控件的引用。我们可以看到在上图hierarchy viewer中的每个控件所对应的框形中，右下角都有一个数字。其实这个数字就是该控件在同级兄弟节点中的索引值，我们知道这个索引值后，就可以根据parentView.children[index]属性来获取任意父节点所对应的子节点的对象引用。其中的parentView可以是树形图中有效ID的任意父节点（父节点要保证唯一有效），然后利用python函数的可变参数列表特性来传入所需控件的索引列表即可构造出得到任意节点引用的字符串，从而得到其引用。<br>　　核心代码如下，把如下代码加入自己的python脚本中，直接调用该函数即可。</p><pre><code> 1 #定义获取重复或不存在控件id，寻找子节点函数 2 def getChildView(parentId, *childSeq): 3     hierarchyViewer = device.getHierarchyViewer() 4     childView=&quot;hierarchyViewer.findViewById(&#39;&quot; + parentId +&quot;&#39;)&quot; 5     for index in childSeq: 6         childView += (&#39;.children[&#39; + str(index) + &#39;]&#39;) 7     print childView 8     return eval(childView)  9 10 #获取id的文本11 def getText(view):  12     if view != None:           13         return (view.namedProperties.get(&#39;text:mText&#39;).value)</code></pre><p>有了以上代码之后，我们可以获取上图中的id/tv，方法如下：</p><pre><code>1 getChildView(&#39;id/province_list&#39;,5,0,0)</code></pre><p>其中结合上图可知，getChildView的第一个参数即：有效且唯一的父节点</p><p>参数二、三依次为要获取的控件ID的父节点的父节点</p><p>注：用到的父节点即图中的id/province_list，有效且唯一的值。当前的父节点右下角的角标，不需要在getChildView函数中显示。</p><p>这样，通过以上函数，再结合Hierarchyviewer图形，我们获取到了重复的控件ID。</p><p>由于Hierarchyviewer看起来不是特别方便，这里再推荐一款和Hierarchyviewer类似功能的工具：uiautomatorviewer（存储在sdk\tools中，双击打开即可）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/yZLgk21onBCJae4.png" alt="980448-20161101091806861-1430572516.png"></p><p>由上图中，uiautomatorviewer每个控件前面的数字即相当于Hierarchyviewer的角标，我们同样可以获取到目标ID的最终有效且唯一的父节点，从而调用函数getChildView(‘id/province_list’,5,0,0)</p><p>获取到了不存在或重复的控件ID后，我们可以通过其坐标，进行点击操作。</p><p>首先，定义一个“获取指定按钮坐标”的函数</p><pre><code>1 def getBtnPoint(btn):2     print btn3     point = device.getHierarchyViewer().getAbsoluteCenterOfView(btn);4     return point</code></pre><p>然后我们可以通过坐标，实现点击操作，例如：</p><pre><code>1 askView = getChildView(&#39;id/tabs&#39;,1)2 askPpoint = getBtnPoint(askView)3 device.touch(askPpoint.x,askPpoint.y,&#39;DOWN_AND_UP&#39;)</code></pre><p>至此，我们介绍完了处理控件ID不存在或重复时的方法，有兴趣的小伙伴或者童鞋们可以自己动手实践一把，就会更能体会Hierarchyviewer/uiautomatorviewer+getChildView()获取不存在或重复控件ID的用法、乐趣及其奥秘。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>一、直接在sdk&gt;tools下面找到hierarchyviewer.bat双击运行，然后运行成功了。</p><p>但是出现这个提示：</p><pre><code>The standalone version of hieararchyviewer is deprecated.Please use Android Device Monitor (tools/monitor.bat) instead.</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/aJcuGTw8Ztovpfb.png" alt="1232840-20190730140857618-1317495444.png"></p><p>大概意思是说，单独版本的 hieararchyviewer 已经被弃用了。请使用 Android Device Monitor来代替。Android Device Monitor在tools目录下面找到monitor.bat即可。</p><p>为了紧跟时代潮流，就决定用Android Device Monitor启动即可。</p><p>具体操作启动步骤：</p><p>1、运行命令monitor.bat，如下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/JxMt8so3BQIErAl.png" alt="1232840-20190730141253123-625662968.png"></p><p>2、运行命令后出现，如下图的界面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/j2WLY6AmestUyDK.png" alt="1232840-20190730141418947-1409178958.png"></p><p>3、点击“Window-&gt;Open Perspective”。如图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/hVR6zXJeQClWHLc.png" alt="1232840-20190730141641679-384688578.png"></p><p>4、按第三步操作完以后，出现如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/MOG5tIBAvZWqKCV.png" alt="1232840-20190730142003149-1015864373.png"></p><p>5、选择“hieararchyviewer ”，点击“OK”，即可，如下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/tmUNaTjsoMDgd92.png" alt="1232840-20190730143719810-787496187.png"></p><p> 二、如何在真机上正常使用Hierarchy View</p><p>   Hierarchy Viewer如果不进行“特殊”配置的话是无法连接真机，会报以下错误：</p><pre><code>[hierarchyviewer]Unable to get view server version from device XXXXX[hierarchyviewer]Unable to get view server protocol version from device XXXXXX[ViewServerDevice]Unable to debug device: XXXXX[hierarchyviewer]Missing forwarded port for XXXXX[hierarchyviewer]Unable to get the focused window from device XXXXX</code></pre><p>无法连接真机的原因是：To preserve security, Hierarchy Viewer can only connect to devices running a developer version of the Android system.出于安全性考虑， Hierarchy Viewe 只能连接开发版手机或模拟器。</p><p>   Android源码实现这一限制的地方在/frameworks/base/services/core/java/com/android/server/wm/WindowManageService.java：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/rGXUZIFconvxLD7.png" alt="4093561-ba8fbfcb68f009ff.png"></p><p>检验一台手机/模拟器是否开启了View Server的办法是：</p><p>adb shell service call window 3</p><p>若返回值是：Result: Parcel(00000000 00000000 ‘……..’)” 说明View Server处于关闭状态</p><p>若返回值是：Result: Parcel(00000000 00000001 ‘……..’)” 说明View Server处于开启状态</p><p>有时碰到模拟器或开发发版手机， view Hierarchy 还是无法连接，可以先使用以上方法检查一下View Server状态。如果没有开启，则使用以下命令打开View Server:</p><p>adb shell service call window 1 i32 4939</p><p>也可以使用使用以下命令关闭View Server：</p><p>adb shell service call window 2 i32 4939</p><p>那么如何在真机能够正常使用Hierarchy Viewer了？通过实践目前总结了以下三种方法：</p><p>方法一。</p><p>1，配置设备，打开手机的开发者选项</p><p>如果你的手机是android 4。0 或者以下，请根据开源项目 View  Server（<a href="https://github.com/romainguy/ViewServer）" target="_blank" rel="noopener">https://github.com/romainguy/ViewServer）</a> 进行安装和配置</p><p>如果你的手机是4.1或以上，则必须进行以下环境变量配置：</p><p>1.点击 计算机属性-》高级系统设置-》环境变量</p><p>2.新建环境变量ANDROID_HVPROTO， 并设置其值为 ddm, 保存重启</p><p>PS：该方法参考android 官方文档《Device Setup for Hierachy Viewer》<a href="https://developer.android.com/studio/profile/hierarchy-viewer-setup.html" target="_blank" rel="noopener">https://developer.android.com/studio/profile/hierarchy-viewer-setup.html</a></p><p>然而在本人亲自试用真机（魅族MX4pro android 5.1 和 android 4.4的机顶盒）测试过程中，配置环境变量的方法似乎并没有起到作用，还是连不上。</p><p>不过直接在调试app中集成View Server开源项目是没有任何问题的。</p><p>方法二：</p><p>话说前面Hierarchy Viewer只能连接Android开发版手机或是模拟器，只有ro.secure==0 &amp;&amp; ro.debuggable==1的Android系统（这一句是其他网友的文章看到的，没有在android 官方查证到 ）。ro.xxxx这种句式大家是不是觉得有点熟悉？不就是android系统的 /system/build.prop文件中的配置样式么。推测如果将ro.secure==0 &amp;&amp; ro.debuggable==1这个两个配置添加进来应该能够起作用吧，于是进行以下尝试：</p><p>1.先把手机root</p><p>2.在进到在/system/build.prop 中添加ro.secure==0  和 ro.debuggable==1， 保存配置并重启手机，Hierarchy Viewer连接正常，终于可以正常调试了。</p><p>方法三：</p><p>参照《如何在Root的手机上开启ViewServer，使得HierachyViewer能够连接》<a href="http://maider.blog.sohu.com/255448342.html。该方法本人没有实践过，一看有18个步骤，" target="_blank" rel="noopener">http://maider.blog.sohu.com/255448342.html。该方法本人没有实践过，一看有18个步骤，</a></p><p>还涉及到 android逆向、smail,瞬间脑仁发紧，有兴趣的同学可以自行尝试一下。</p><p>三、好了，关于控件ID的获取，就分享到这里。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试24</title>
      <link href="/2016/04/19/appium/"/>
      <url>/2016/04/19/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十四）- 白素贞千年等一回许仙 - 元素等待（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　许仙小时候最喜欢吃又甜又软的汤圆了，一次一颗汤圆落入西湖，被一条小白蛇衔走了。十几年后，一位身着白衣、有青衣丫鬟相伴的美丽女子与许仙相识了，她叫白娘子。白娘子聪明又善良，两个人很快走到了一起。靠着自己的力量，他们过上了幸福的生活。一天，僧人法海找到许仙，警告说白娘子是一条修行千年的蛇精，许仙不信。到了端午节，勉强喝下了雄黄酒的白娘子现了原形，许仙被吓得昏死过去。原来白娘子真的是之前吃下许仙汤圆的小蛇。白娘子辛苦救回了许仙的性命，但之后法海却以保护许仙的名义将他囚禁起来，白娘子与小青召集虾兵蟹将，要逼法海放出许仙。突然一座宝塔从天而降，把白娘子镇在了塔下……  想必小伙伴和童鞋们都听过，或者是看过这个故事，是多么的痴情感人，尤其是千年等一回的歌曲是一个经典音乐。好了废话还是少说，进入今天的主题–元素等待<br>　　前边介绍了APP页面元素的识别定位、操作等技术，可能你会觉得掌握这两项技术就可以实施APP自动化了，答案基本是这样的，毕竟元素定位和操作是核心技术。但是，在某些场景，脚本的运行并非预期那样，如，要操作的元素用常规方法无法识别、元素可以识别但在脚本运行时却未如期而至等。为了解决这些疑难杂症，接下来内容将会介绍处理这些问题的通用方法。<br>　　在本节，主要介绍元素等待的使用方法和场景，该方法是开发稳定、高容错性自动化脚本的前提。</p><h4 id="2-思考"><a href="#2-思考" class="headerlink" title="2.思考"></a>2.思考</h4><p>　　在自动化过程中，元素出现受网络环境，设备性能等多种因素影响。因此元素加载的时间可能不一致，从而会导致元素无法定位超时报错，但是实际上元素是正常加载了的，只是出现时间晚一点而已。那么如何解决这个问题呢？</p><p>实际测试过程中，比如点击一个控件需要启动一个新activiy界面，或需要加载弹框，或请求网络加载数据成功后刷新界面，此时需要等待一段时间，新界面出现了才能继续执行UI操作，否则还在加载中，程序已开始执行新界面操作的代码，脚本就会报错了。</p><h4 id="2-元素等待作用"><a href="#2-元素等待作用" class="headerlink" title="2.元素等待作用"></a>2.元素等待作用</h4><p>1.设置元素等待可以更加灵活的制定等待定位元素的时间，从而增强脚本的健壮性，提高执行效率。</p><p>2.元素等待是为了解决如下场景的问题：脚本执行时，脚本的执行速度和页面元素的加载速度未必一致，也就是说，可能出现脚本已经运行到某个元素，但该元素尚未加载到页面，此时脚本会因无法定位到该元素而导致执行失败。元素等待本质是为了解决时序上不匹配的问题。</p><h4 id="3-元素等待类型"><a href="#3-元素等待类型" class="headerlink" title="3.元素等待类型"></a>3.元素等待类型</h4><table><thead><tr><th>类型</th><th>特点</th><th>举例</th></tr></thead><tbody><tr><td>强制等待</td><td>设置固定的等待时间</td><td>from time import sleep<br>#强制等待5秒<br>sleep(5)</td></tr><tr><td>隐式等待</td><td>针对全部元素设置的等待时间</td><td>driver.implicitly_wait(5)</td></tr><tr><td>显式等待</td><td>针对某个元素来设置的等待时间</td><td>from selenium.webdriver.support.ui import WebDriverWait<br>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)</td></tr></tbody></table><h5 id="强制等待"><a href="#强制等待" class="headerlink" title="强制等待"></a>强制等待</h5><p>　　这种方法的等待，就相当于白素贞到西湖去等待许仙去，不管许仙是否出现，都要痴情地从白天等到晚上。说白了这种就是白素贞站在西湖那里一动不动地死等许仙出现。纯粹一个傻子！！！</p><p>设置固定的等待时间，使用sleep()方法即可实现</p><p>sleep()： 设置固定休眠时间。 python 的 time 包提供了休眠方法 sleep() ， 导入 time包后就可以使用 sleep()进行脚本的执行过程进行休眠。</p><pre><code>1 from time import sleep2 3 #强制等待5秒4 5 sleep(5)</code></pre><h5 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h5><p>隐式等待是针对全部元素设置的等待时间</p><p>　　这种方法的等待，就相当于白素贞到西湖去等待许仙去，白素贞到了西湖先看看许仙在不在，一看在，白素贞完了再看看小青妹妹来没来，等小青这个电灯泡来了，再去和许仙汇合。</p><pre><code> 1 #implicitly_wait()：是 webdirver 提供的一个超时等待。隐的等待一个元素被发现，或一个命令完成。如果超出了设置时间的则抛出异常。 2 #implicitly_wait():隐式等待 3 #当使用了隐士等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常 4 #换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0 5 #一旦设置了隐式等待，则它存在整个 WebDriver 对象实例的声明周期中，隐式的等到会让一个正常响应的应用的测试变慢， 6 #它将会在寻找每个元素的时候都进行等待，这样会增加整个测试执行的时间。 7  8 #implicitly_wait()方法比 sleep() 更加智能，后者只能选择一个固定的时间的等待，前者可以在一个时间范围内智能的等待。 9 10 driver.implicitly_wait(20)</code></pre><h5 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h5><p>显式等待是针对某个元素来设置的等待时间。</p><p>　　这种方法的等待，就相当于白素贞到西湖去等待许仙去，白素贞到了西湖先看看许仙在不在，一看不在，白素贞自己先去做个头发；过一个小时了，白素贞回来到西湖再去看许仙在不在，一看还是不在，再去买件衣服去；过一个小时了，白素贞回来到西湖再去看许仙在不在，一看仍然不在，再去买个包包去；过一个小时了，白素贞回来到西湖再去看许仙在不在，一看还是不在，白素贞郁闷了，出去喝个小酒去；过了一小时了。。。。。。就这么来来回回的折腾的等许仙。这个白素贞通过修炼进化变得聪明了。</p><p>WebDriverWait()：同样也是 webdirver 提供的方法。在设置时间内，默认每隔一段时间检测一次当前。页面元素是否存在，如果超过设置时间检测不到则抛出异常。</p><p>方法WebDriverWait格式参数如下：</p><pre><code> 1 &#39;&#39;&#39;详细格式如下： 2 WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) 3 driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程) 4 timeout - 最长超时时间，默认以秒为单位 5 poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒 6 ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。 7 WebDriverWai()一般由 until()或 until_not()方法配合使用，下面是 until()和 until_not()方法的说明。 8 until(method, message=’’) 9 调用该方法提供的驱动程序作为一个参数，直到返回值不为 False。10 until_not(method, message=’’)11 调用该方法提供的驱动程序作为一个参数，直到返回值为 False。12 lambda13 lambda 提供了一个运行时动态创建函数的方法。&#39;&#39;&#39;14 15 from selenium.webdriver.support.ui import WebDriverWait16 17 WebDriverWait(driver,10).until(lambda x:x.find_element_by_id(&quot;elementID&quot;))</code></pre><p>其中，三种等待方法的作用和区别，如下：</p><p>强制等待，也就是常说的死等待，使用time模块提供的sleep方法，脚本在等待sleep（x） x秒后才执行，此时脚本也许出现了无效等待，即元素已经出现，可以继续操作，但因指定的时间未到，脚本无法执行，因而，在实际Web UI开发中应杜绝sleep等待；</p><p>显式等待，WebDriver提供的针对元素级别的、灵活、智能的等待方法，通过配合until()、until_not()、ExpectedCondition等条件的使用，默认每500ms检查一次条件状态，可以及时将脚本从等待中唤醒，避免无效等待，在实际应用中推荐使用该方法。</p><p>该等待的调用方法如下：</p><p>WebDriverWait(driver, 超时时长, 调用频率, 忽略异常).until(可执行方法, 超时时返回的信息)</p><p>隐式等待，WebDriver提供的针对driver级别的适用整个生命周期的等待方法，该等待是全局设置，因而只需在实例化driver后设置一次即可。从等待作用上看，是可以满足需要的，但是考虑到实际应用场景，driver要等待的元素和脚本要操作的元素未必相同，也就是说，脚本要操作的元素已经出现，但因为设置了全局等待，driver也会继续等待页面上其他无关元素，直至整个页面加载完毕。因而，与显式等待相比，可能出现无效等待的情况。</p><h4 id="4-等待方法实战举例"><a href="#4-等待方法实战举例" class="headerlink" title="4.等待方法实战举例"></a>4.等待方法实战举例</h4><p>1.强制等待方法应用实例</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-26 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-元素等待 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 import time13 desired_caps = {}14 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa15 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号16 desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看17 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名18 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity19 desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串20 desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来21 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息22 # 休眠五秒等待页面加载完成23 time.sleep(5)   #强制等待5s，不管等待的元素是否出现，都要等5s24 driver.find_element_by_id(&quot;com.taobao.taobao:id/home_searchedit&quot;).click()25 time.sleep(3)  #演示效果26 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).click()27 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).send_keys(u&quot;北京-宏哥&quot;)28 driver.quit()</code></pre><p>2.显示等待方法应用实例</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-26 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-元素等待 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 from selenium.webdriver.support.ui import WebDriverWait13 import time14 desired_caps = {}15 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa16 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号17 desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看18 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名19 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity20 desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串21 desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来22 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息23 try:24     # 显示等待（等待特定元素出现）25     WebDriverWait(driver, 3).until(lambda x: x.find_element_by_id(&#39;com.taobao.taobao:id/home_searchedit&#39;))26     driver.find_element_by_id(&quot;com.taobao.taobao:id/home_searchedit&quot;).click()27     time.sleep(3)  # 演示效果28     driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).click()29     driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).send_keys(u&quot;北京-宏哥&quot;)30 finally:31     driver.quit()</code></pre><p>3.隐式等待方法应用实例</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-26 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-元素等待 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 from selenium.webdriver.support.ui import WebDriverWait13 import time14 desired_caps = {}15 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa16 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号17 desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看18 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名19 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity20 desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串21 desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来22 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息23 24 # 隐式等待(等待所有元素)25 driver.implicitly_wait(3)  #隐式等待,最长3s26 driver.find_element_by_id(&quot;com.taobao.taobao:id/home_searchedit&quot;).click()27 time.sleep(3)  #演示效果28 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).click()29 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).send_keys(u&quot;北京-宏哥&quot;)30 driver.quit()</code></pre><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>1.本节主要介绍appium自动化中三种元素等待方法，并讲解了各自的优缺点，实际开发中推荐使用显示等待，最后，为了便于理解和应用，针对每种等待方法，编写了对应的脚本。</p><p>2.强制等待的方法，在debug时候很有用，不过建议慎用这种方法，因为太死板，严重影响程序执行速度！</p><p>3.以上三种等待方法，在具体的场景中需要根据情况选择合适的方法，灵活运用。。。</p><p>4.做过自动化的小伙伴们或者童鞋们，在启动app的时候，幸运的小伙伴和同学们都会中这个大奖：如果直接做下一步点击操作，经常会报错，于是我们便会自然而然的想到上边介绍的三种方法，会在启动完成的时候加sleep等方法。那么问题来了，宏哥问你这个sleep时间到底设置多少合适呢？你不知道宏哥也不知道这个问题的答案，如果设置长了，就浪费时间，设置短了，就会找不到元素报错了。过长过短都是个让你头疼的事，那么有没有别的方法可以克服这个问题了。当然有，宏哥一般人都不告诉他，大家都是二般人，就分享给各位吧！但是这个只是针对安卓手机的哦，要记住了，iPhone不适合的。这个时候我们可以用wait_activity的语法，等到你想点击的页面activity出现了，再点击，可以有效的节省时间。</p><h5 id="wait-activity"><a href="#wait-activity" class="headerlink" title="wait_activity"></a>wait_activity</h5><p>（1）查看源码</p><pre><code> 1 def wait_activity(self, activity, timeout, interval=1): 2     &quot;&quot;&quot;Wait for an activity: block until target activity presents 3     or time out. 4      5     This is an Android-only method. 6  7     :Agrs: 8      - activity - target activity 9      - timeout - max wait time, in seconds10      - interval - sleep interval between retries, in seconds11     &quot;&quot;&quot;12     try:13         WebDriverWait(self, timeout, interval).until(14             lambda d: d.current_activity == activity)15         return True16     except TimeoutException:17         return False</code></pre><p>（2）解释说明：</p><pre><code> 1 wait_activity(self, activity, timeout, interval=1): 2  3     等待指定的activity出现直到超时，interval为扫描间隔1秒 4  5     即每隔几秒获取一次当前的activity 6      7     android特有的 8  9     返回的True 或 False10 11     :Agrs:12 13      - activity - 需等待的目标 activity14 15      - timeout - 最大超时时间，单位是s16 17      - interval - 循环查询时间18 19     用法:driver.wait_activity(‘.activity.xxx’,5,2)</code></pre><h5 id="获取current-activity"><a href="#获取current-activity" class="headerlink" title="获取current_activity"></a>获取current_activity</h5><p>（1）打开app后，先sleep10秒，等app完全启动完成进入主页面，然后获取当前界面的activity</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-26 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-元素等待 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 from time import sleep13 desired_caps = {14                 &#39;platformName&#39;: &#39;Android&#39;,15                 &#39;deviceName&#39;: &#39;127.0.0.1:62001&#39;,16                 &#39;platformVersion&#39;: &#39;4.4.2&#39;,17                 &#39;appPackage&#39;: &#39;com.baidu.yuedu&#39;,18                 &#39;appActivity&#39;: &#39;com.baidu.yuedu.splash.SplashActivity&#39;19                 }20 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)21 22 sleep(10)23 # 获取当前界面activity24 ac = driver.current_activity25 print(ac)</code></pre><p>（2）运行结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/CVYMjcqNkZultfw.png" alt="1232840-20190726144903464-449330011.png"></p><h5 id="等待activity"><a href="#等待activity" class="headerlink" title="等待activity"></a>等待activity</h5><p>（1）用sleep太浪费时间了，并且不知道什么时候能启动完成，所以尽量不用sleep，宏哥也不推荐使用。因为这个确实是太low了。</p><p>（2）上一步已经获取当主页面的activity了，那就可以用wait_activity等它出现了，再做下一步的点击操作</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/x3aIJkMChnS1BVq.png" alt="img_655261fd782532bb9276d67dac7b5e5b.png"></p><p>（3）参考代码</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-26 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-元素等待 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 from time import sleep13 desired_caps = {14                 &#39;platformName&#39;: &#39;Android&#39;,15                 &#39;deviceName&#39;: &#39;127.0.0.1:62001&#39;,16                 &#39;platformVersion&#39;: &#39;4.4.2&#39;,17                 &#39;appPackage&#39;: &#39;com.baidu.yuedu&#39;,18                 &#39;appActivity&#39;: &#39;com.baidu.yuedu.splash.SplashActivity&#39;19                 }20 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)21 22 # sleep(10)  # 不用sleep23 24 # 获取当前界面activity25 ac = driver.current_activity26 print(ac)27 28 # 等主页面activity出现,30秒内29 driver.wait_activity(&quot;.base.ui.MainActivity&quot;, 30)30 31 # 点知道了32 driver.find_element_by_id(&quot;com.baidu.yuedu:id/positive&quot;).click()</code></pre><ol start="5"><li>好了，关于元素等待目前就说这么多！！！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试23</title>
      <link href="/2016/04/18/appium/"/>
      <url>/2016/04/18/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十三）- 真假美猴王Monkeyrunner与Monkey傻傻的分不清楚（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看《西游记》第五十七回，说是“六耳猕猴”化作孙悟空的摸样，伤了唐僧，后又和孙悟空大打出手…… 这位假孙悟空，实力不用多说了吧，和真孙悟空一般无二，大战孙悟空，闹到上天入地下海。 在唐僧那：念紧箍咒，两个都喊疼，自然看不出哪个真假； 到天宫：拖塔天王拿照妖镜照，也看不出； 又到观音那：观音也看不出。最后到幽冥处阎罗那，经“谛听”听过之后，“谛听”却说：“我看出来了，却不敢说” 最后还是如来老佛爷道出六耳真身并用金钵盂罩住，才被孙悟空一棍子打死。想必各位小伙伴都看过这以精彩片段。不过据知情人士说真假美猴王存在阴谋，这里有黑幕：说是真的孙悟空被打死了，活下来的是假的。好了废话少说，还是回到今天的主题：真假美猴王Monkeyrunner与Monkey傻傻的分不清楚。</p><p>　　今天宏哥就带着各位小伙伴和童鞋们再当一回和尚：如来佛祖辨一辨真假美猴王，前边我们已经对monkey做过一些详细的介绍和讲解，今天我们就再来介绍和讲解一下monkeyrunner。看看他们之间的到底是一样还是有区别的。</p><h4 id="2-monkeyrunner简介"><a href="#2-monkeyrunner简介" class="headerlink" title="2.monkeyrunner简介"></a>2.monkeyrunner简介</h4><p>1.monkeyrunner工具使用Jython，这是一种使用Java编程语言的Python实现。Jython允许monkeyrunner API与Android框架轻松交互。使用Jython，您可以使用Python语法来访问API的常量，类和方法。MonkeyRunner工具是使用Jython(使用Java编程语言实现的</p><p>Python)写出来的，它提供了多个API，通过monkeyrunner API 可以写一个Python的程序来模拟操作控制Android设备app,测试其稳定性并通过截屏可以方便地记录出现的问题。</p><p>2.我们来看一下monkeyrunner官网是如何介绍monkeyrunner的：</p><p>官网介绍（已翻译成中文）宏哥在这里给小伙伴截取一段翻译，如下：</p><p>　　monkeyrunner工具提供了一个API，用于编写从Android代码外部控制Android设备或模拟器的程序。使用monkeyrunner，您可以编写一个Python程序，安装Android应用程序或测试包，运行它，向其发送击键，截取其用户界面，并在工作站上存储屏幕截图、</p><p>monkeyrunner工具主要用于测试功能/框架级别的应用程序和设备以及运行单元测试套件，但您可以将其用于其他目的。</p><p>monkeyrunner工具与UI / Application Exerciser Monkey无关 ，也称为monkey工具。该monkey工具adb直接在设备或仿真器上的shell中运行， 并生成用户和系统事件的伪随机流。相比之下，monkeyrunner工具通过从API发送特定命令和事件来控制工作站中的设备和</p><p>仿真器。</p><p>3.monkeyrunner即android SDK中自带的工具之一，此工具提供API可按制android设备或模拟器。</p><p>4.有兴趣的小伙伴们或者童鞋可以查看一下monkeyrunner官网：<a href="https://www.android-doc.com/tools/help/monkeyrunner_concepts.html" target="_blank" rel="noopener">https://www.android-doc.com/tools/help/monkeyrunner_concepts.html</a></p><p>5.monkeyrunner 路径：Andriod_SDK\tools</p><h4 id="3-MonkeyRunner工具独特功能"><a href="#3-MonkeyRunner工具独特功能" class="headerlink" title="3.MonkeyRunner工具独特功能"></a>3.MonkeyRunner工具独特功能</h4><p>1.多设备控制：monkeyrunner API可以跨多个设备或仿真器应用一个或多个测试套件。您可以物理连接所有设备或立即启动所有模拟器（或两者），以编程方式依次连接到每个设备，然后运行一个或多个测试。您还可以以编程方式启动模拟器配置，运行一个或多个测试，然后关闭模拟器。</p><p>2.功能测试：monkeyrunner可以对Android应用程序进行自动化的从头到尾的测试。您可以通过击键或触摸事件提供输入值，并将结果视为屏幕截图。</p><p>3.回归测试 - monkeyrunner可以通过运行应用程序并将其输出屏幕截图与一组已知正确的屏幕截图进行比较来测试应用程序的稳定性。</p><p>4.可扩展的自动化 - 由于monkeyrunner是一个API工具包，您可以开发一个基于Python的模块和程序的整个系统来控制Android设备。除了使用monkeyrunner API本身，您还可以使用标准的Python os和 subprocess 模块来调用Android工具，例如 Android Debug Bridge。</p><p>您还可以将自己的类添加到monkeyrunner API中。这在“ 使用插件扩展monkeyrunner ”一节中有更详细的描述 。</p><h4 id="4-Monkeyrunner与Monkey区别"><a href="#4-Monkeyrunner与Monkey区别" class="headerlink" title="4.Monkeyrunner与Monkey区别"></a>4.Monkeyrunner与Monkey区别</h4><p>monkeyrunner和money没有什么直接的关系，monkey是在设备直接运行adb shell命令生成随机事件来进行测试的。相比较而言，monkeyrunner则是通过API发送特定的命令和事件来控制设备。</p><p>为了支持黑盒自动化测试的场景，Android SDK提供了monkey和monkeyrunner两个测试工具，这两个测试工具除了名字类似外，还都可以向待测应用发送按键等消息，往往容易产生混淆，以下是他俩的不同之处。</p><h5 id="Monkey："><a href="#Monkey：" class="headerlink" title="Monkey："></a>Monkey：</h5><p>Monkey工具直接运行在设备或模拟器的adb shell中，生成用户或系统的伪随机事件流。</p><p>1.monkey运行在设备或者模拟器上边，可以脱离PC运行，其运行时如下图所示。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/951wVMAzuZUeoYX.png" alt="1232840-20190723151622115-2022255479.png"></p><h5 id="Monkeyrunner："><a href="#Monkeyrunner：" class="headerlink" title="Monkeyrunner："></a>Monkeyrunner：</h5><p>Monkeyrunner工具是在工作站上通过API定义的特定命令和事件控制设备或模拟器。</p><p>而monkeyrunner运行在PC上，需要通过服务器/客户端的的模式向设备或者模拟器上的android应用发送指令来执行测试，其运行时如下图所示。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/lvykZCQ1jEYBbVe.png" alt="1232840-20190723152043213-171977450.png"></p><p>2.普遍的做法是将monkey作为一个向待测应用发送随机按键消息的测试工具，验证待测应用在这些随机性的输入面前是否会有闪退或者崩溃。而monkeyrunner则接受一个明确的测试脚本（使用python语言编写的）。</p><p>3.虽然monkey也可以根据一个指定的命令脚本发送按键消息，但其不支持条件判断，也不支持读取界面的信息来执行验证操作。而monkeyrunner的测试脚本中有明确 的条件判断等语句，可用来做功能测试。</p><p> 总结：</p><p>　　实际操作中，monkey由于缺少必要的条件判断等命令，难以在功能测试上有所作为，只能作为生成一些随机事件的工具，测试应用程序的健壮程度，待测应用崩溃后可以根据monkey打印的日志，再用monkey创建一个重现步骤，供开发调试。monkey服务器模式更适合用于黑盒测试，不建议用于自动化测试。</p><p>　　而Monkeyrunner虽然有Python和Java类库的强大支持，但其自身提供的API有限，还得需要插件扩展其功能。</p><h4 id="5-monkeyrunner-API"><a href="#5-monkeyrunner-API" class="headerlink" title="5.monkeyrunner API"></a>5.monkeyrunner API</h4><p>monkeyrunner API包含在包中的三个模块中 com.android.monkeyrunner：</p><p>1.MonkeyRunner：monkeyrunner程序的一类实用方法。此类提供了将monkeyrunner连接到设备或模拟器的方法。它还提供了为monkeyrunner程序创建UI以及显示内置帮助的方法。</p><p>2.MonkeyDevice：表示设备或模拟器。此类提供了安装和卸载软件包，启动Activity以及向应用程序发送键盘或触摸事件的方法。您还可以使用此类来运行测试包。</p><p>3.MonkeyImage：表示屏幕捕获图像。此类提供捕获屏幕，将位图图像转换为各种格式，比较两个MonkeyImage对象以及将图像写入文件的方法。</p><p>在Python程序中，您可以将每个类作为Python模块进行访问。monkeyrunner工具不会自动导入这些模块。要导入模块，请使用Python from语句：</p><pre><code>1 from com.android.monkeyrunner import &lt;module&gt;</code></pre><p>&lt;module&gt;您要导入的类名 在哪里。from通过用逗号分隔模块名称，可以在同一语句中导入多个模块。</p><h5 id="运行monkeyrunner"><a href="#运行monkeyrunner" class="headerlink" title="运行monkeyrunner"></a>运行monkeyrunner</h5><p>您可以从文件中运行monkeyrunner程序，也可以在交互式会话中输入monkeyrunner语句。您可以通过调用SDK目录子目录中的monkeyrunner命令来执行这两项操作tools/。如果提供文件名作为参数，则该monkeyrunner命令将文件的内容作为Python程序运行; 否则，它会启动一个交互式会话。</p><p>该monkeyrunner命令的语法是</p><pre><code>1 monkeyrunner -plugin &lt;plugin_jar&gt; &lt;program_filename&gt; &lt;program_options&gt;</code></pre><p>表1解释了标志和参数。</p><p>表1. monkeyrunner标志和参数。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-plugin &lt;plugin_jar&gt;</td><td>可选）指定.jar包含monkeyrunner插件的文件。要了解有关monkeyrunner插件的更多信息，请参阅 使用插件扩展monkeyrunner。要指定多个文件，请多次包含该参数。</td></tr><tr><td>&lt;program_filename&gt;</td><td>如果提供此参数，则该monkeyrunner命令将该文件的内容作为Python程序运行。如果未提供参数，则该命令将启动交互式会话。</td></tr><tr><td>&lt;program_options&gt;</td><td>（可选）&lt;program_file&gt;中程序的标志和参数。</td></tr></tbody></table><p>运行monkeyrunner</p><p>命令语法为：</p><pre><code>monkeyrunner -plugin &lt;plugin_jar&gt; &lt;program_filename&gt; &lt;program_options&gt;</code></pre><p>方式一：在CMD命令窗口直接运行monkeyrunner</p><p>方式二：使用Python编写测试代码文件，在CMD中执行monkeyrunner hongge.py运行</p><p>不论使用哪种方式，您都需要调用SDK目录的tools子目录下的monkeyrunner命令。</p><p>注意：在运行monkeyrunner之前必须先运行相应的模拟器或连接真机，否则monkeyrunner无法连接到设备</p><p>运行模拟器有两种方法：1、通过eclipse中执行模拟器 2、在CMD中通过命令调用模拟器</p><p>这里介绍通过命令，在CMD中执行模拟器的方法</p><pre><code>emulator -avd test</code></pre><p>上面命令中test是指模拟器的名称。</p><p>附：这部分前边已经讲解过，在这里就不再赘述）</p><p>问题：CMD运行提示monkeyrunner不是内部或外部命令，也不是可运行的程序或批处理文件。</p><p>解决：电脑环境变量未配置，将monkeyrunner所在目录配在环境变量里。</p><p>变量名：Path</p><p>变量值：D:\android\android-sdk-windows\tools;D:\android\android-sdk-windows\platform-tools</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><blockquote><p>实例一：卸载旧的APP，安装新的APP </p></blockquote><p>*准备</p><p>a. 连接安卓夜神模拟器设备</p><p>b. 运行CMD，检测是否连接成功</p><p>CMD&gt;adb devices</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/YxjSRVulCUqvm29.png" alt="1232840-20190724140453547-1677769529.png"></p><p>附：（这部分前边已经讲解过，在这里就不再赘述）</p><p>问题：CMD运行提示adb不是内部或外部命令，也不是可运行的程序或批处理文件。</p><p>解决：电脑环境变量未配置，将adb所在目录配在环境变量里。  </p><blockquote><p>*方式一： </p></blockquote><p>1.打开CMD，运行monkeyrunner</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/kGrFSW2dK4VYEqH.png" alt="1232840-20190724141816019-389109459.png"></p><p>2.进入monkeyrunner的shell命令交互模式后，逐条输入以下命令</p><pre><code>1 from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage2 device = MonkeyRunner.waitForConnection()3 device.removePackage(&#39;com.taobao.taobao&#39;)4 device.installPackage(&#39;C:\\Users\\DELL\\Desktop\\702757.apk&#39;)</code></pre><p>（1）输入命令前的夜神模拟器：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/Nh7wLIrX6y8Yx5f.png" alt="1232840-20190724141633810-995857666.png"></p><p>（2）输入第三行命令后的夜神模拟器</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/rBlFKZ9ENWQg8fb.png" alt="1232840-20190724141949951-477522064.png"> </p><p>（3）输入第四行的夜神模拟器</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/MzJaXb8NdRfOo9u.png" alt="1232840-20190724142237858-1376009324.png"></p><p>注：每条命令的作用，请见方法二中的注解</p><p>实操如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/NH9yunqAjeDtw8G.png" alt="1232840-20190724142405241-1106331487.png"></p><p>c.检查手机app是否已更新 </p><blockquote><p>*方式二：</p></blockquote><p>a. 编写Python测试代码</p><pre><code> 1 # File:   Test1.py 2 # Vision: V1.0 3 # Author: hongge  QQ群：707699217 4 # 引入本程序所用到的模块 5 from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage 6  7 # 连接手机设备 8 device = MonkeyRunner.waitForConnection() 9 10 # 截图11 result = device.takeSnapshot()12 # 将截图保存到文件 13 result.writeToFile(&#39;E:\\JAVA\\monkeyrunner\\Test1\\Test1_001.png&#39;,&#39;png&#39;)14 15 # 卸载APP16 device.removePackage(&#39;cn.richinfo.thinkdrive&#39;)17 print (&#39;Uninstall Success!&#39;)18 19 # 暂停5秒20 MonkeyRunner.sleep(5)21 22 # 截图23 result = device.takeSnapshot()24 result.writeToFile(&#39;E:\\JAVA\\monkeyrunner\\Test1\\Test1_002.png&#39;,&#39;png&#39;)25 26 # 安装新的APP27 device.installPackage(&#39;E:\\JAVA\\monkeyrunner\\Test1\\ThinkDrive_new.apk&#39;)28 print (&#39;Install Success!&#39;)29 30 # 截图31 result = device.takeSnapshot()32 result.writeToFile(&#39;E:\\JAVA\\monkeyrunner\\Test1\\Test1_003.png&#39;,&#39;png&#39;)</code></pre><p>注：拷贝运行时请去掉中文注释；或者在开头加入 #coding=utf-8 </p><p>b.执行Test1.py脚本</p><p>Monkeyrunner C:\Users\DELL\Desktop\test.py</p><p>实操如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/VHDT8NytXPd7RzU.png" alt="1232840-20190724143612597-1937846247.png"></p><p>c.检查手机app是否已更新</p><p>d.查看截图文件夹，截图和上边逐条输入命令，宏哥截得模拟器一模一样的。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/aB6otJxbe97zfMT.png" alt="1232840-20190724145203353-1716925033.png"></p><p>e.注意如果截图不一样自己加个等待时间，就会一样，参考代码：</p><pre><code> 1 #coding=utf-8  2 # File:   Test1.py 3  4 # Vision: V1.0 5  6 # Author: hongge  QQ群：707699217 7  8 # 引入本程序所用到的模块 9 10 from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage11 12 13 14 # 连接手机设备15 16 device = MonkeyRunner.waitForConnection()17 18 19 20 # 截图21 22 result = device.takeSnapshot()23 24 # 将截图保存到文件 25 26 result.writeToFile(&#39;C:\\Users\\DELL\\Desktop\\test\\Test1_001.png&#39;,&#39;png&#39;)27 28 29 30 # 卸载APP31 32 device.removePackage(&#39;com.taobao.taobao&#39;)33 34 print (&#39;Uninstall Success!&#39;)35 36 37 38 # 暂停5秒39 40 MonkeyRunner.sleep(5)41 42 43 44 # 截图45 46 result = device.takeSnapshot()47 48 result.writeToFile(&#39;C:\\Users\\DELL\\Desktop\\test\\Test1_002.png&#39;,&#39;png&#39;)49 50 51 # 暂停5秒52 53 MonkeyRunner.sleep(5)54 55 56 # 安装新的APP57 58 device.installPackage(&#39;C:\\Users\\DELL\\Desktop\\702757.apk&#39;)59 60 print (&#39;Install Success!&#39;)61 62 # 暂停5秒63 64 MonkeyRunner.sleep(5)65 66 # 截图67 68 result = device.takeSnapshot()69 70 result.writeToFile(&#39;C:\\Users\\DELL\\Desktop\\test\\Test1_003.png&#39;,&#39;png&#39;)</code></pre><h4 id="6-monkeyrunner内置帮助"><a href="#6-monkeyrunner内置帮助" class="headerlink" title="6.monkeyrunner内置帮助"></a>6.monkeyrunner内置帮助</h4><p>您可以通过运行以下命令为monkeyrunner生成API参考：</p><pre><code>1 monkeyrunner help.py &lt;format&gt; &lt;outfile&gt;</code></pre><p>论点是：</p><p><format>或者是text纯文本的输出或html用于HTML输出。<br><outfile> 是输出文件的路径限定名称。</outfile></format></p><h4 id="7-使用插件扩展monkeyrunner"><a href="#7-使用插件扩展monkeyrunner" class="headerlink" title="7.使用插件扩展monkeyrunner"></a>7.使用插件扩展monkeyrunner</h4><p>您可以使用Java编程语言编写的类扩展monkeyrunner API，并将其构建为一个或多个.jar文件。您可以使用此功能使用您自己的类扩展monkeyrunner API或扩展现有类。您还可以使用此功能初始化monkeyrunner环境。</p><p>要为monkeyrunner提供插件，请monkeyrunner使用表1中-plugin <plugin_jar>描述的参数 调用该命令 。</plugin_jar></p><p>在你的插件代码，你可以导入和扩展的主要monkeyrunner类 MonkeyDevice，MonkeyImage和MonkeyRunner在com.android.monkeyrunner（见的monkeyrunner API）。</p><p>请注意，插件不允许您访问Android SDK。您无法导入包等com.android.app。这是因为monkeyrunner与框架API级别下的设备或模拟器交互。</p><h5 id="插件启动类"><a href="#插件启动类" class="headerlink" title="插件启动类"></a>插件启动类</h5><p>.jar插件 的文件可以指定在脚本处理开始之前实例化的类。要指定此类，请将密钥添加 MonkeyRunnerStartupRunner到.jar文件的清单中。该值应该是启动时要运行的类的名称。以下代码段显示了如何在ant构建脚本中执行此操作：</p><pre><code>1 &lt;jar jarfile=&quot;myplugin&quot; basedir=&quot;${build.dir}&quot;&gt;2 &lt;manifest&gt;3 &lt;attribute name=&quot;MonkeyRunnerStartupRunner&quot; value=&quot;com.myapp.myplugin&quot;/&gt;4 &lt;/manifest&gt;5 &lt;/jar&gt;</code></pre><p>要访问monkeyrunner的运行时环境，启动类可以实现 com.google.common.base.Predicate<pythoninterpreter>。例如，此类在默认命名空间中设置一些变量：</pythoninterpreter></p><pre><code> 1 package com.android.example; 2  3 import com.google.common.base.Predicate; 4 import org.python.util.PythonInterpreter; 5  6 public class Main implements Predicate&lt;PythonInterpreter&gt; { 7     @Override 8     public boolean apply(PythonInterpreter anInterpreter) { 9 10         /*11         * Examples of creating and initializing variables in the monkeyrunner environment&#39;s12         * namespace. During execution, the monkeyrunner program can refer to the variables &quot;newtest&quot;13         * and &quot;use_emulator&quot;14         *15         */16         anInterpreter.set(&quot;newtest&quot;, &quot;enabled&quot;);17         anInterpreter.set(&quot;use_emulator&quot;, 1);18 19         return true;20     }</code></pre><h4 id="8-monkeyrunner环境搭建"><a href="#8-monkeyrunner环境搭建" class="headerlink" title="8.monkeyrunner环境搭建"></a>8.monkeyrunner环境搭建</h4><p>1.安装并配置好jdk环境</p><p>2.安装android sdk</p><p>3.安装python </p><p>4.monkeyrunner环境变量配置： {Path}\Andriod_SDK\tools</p><h4 id="9-安装结果检测"><a href="#9-安装结果检测" class="headerlink" title="9.安装结果检测"></a>9.安装结果检测</h4><p>在docs命令控制台输入命令：monkeyrunner出现如下显示内容则说明安装成功</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/rTayuw6HfFlSUt2.png" alt="1232840-20190723141619119-1204423009.png"></p><p>Tips：退出monkeyrunner命令行模式可以 使用快捷键 ctrl+D退出。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/sCanqGv9iTeRUIo.png" alt="1232840-20190723141713371-101370164.png"></p><h4 id="10-小结"><a href="#10-小结" class="headerlink" title="10.小结"></a>10.小结</h4><p>(1)在方式二运行monkeyrunner报错</p><pre><code>（190724 14:33:20.837:S [main] [com.android.monkeyrunner.MonkeyRunnerOptions] Script terminated due to an exception）</code></pre><p>(2)解决方法，报出该错误是使用的notepad++编码格式问题，notepad++默认编码格式是ansi，我们使用的monkeyrunner脚本格式是utf-8，因此有冲突</p><p>修改方法如下</p><p>1.首先，看我们的脚本编码格式是什么，我这里的是utf-8，因此不用再做修改</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/CsqWrI92HDMUh5p.png" alt="1232840-20190724144045351-1660297025.png"></p><p>2.如果编码格式不是utf-8的，就要对它进行修改了，点击格式，选择utf-8，再保存，也可选择无BOM格式的</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/QWru2sOnYeEXy8Z.png" alt="1232840-20190724144158830-1423340720.png"></p><p>3.再来运行一下，这次成功了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/VHDT8NytXPd7RzU.png" alt="1232840-20190724143612597-1937846247.png"></p><p>(3)monkeyrunner常用的知识点</p><pre><code>#引入程序所用的模块1 from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage #引入程序所用的模块，使用别名1 from com.android.monkeyrunner import MonkeyRunner as mr2 from com.android.monkeyrunner import MonkeyDevice as md3 from com.android.monkeyrunner import MonkeyImage as mi4 #如果给导入的模块起了别名，就必须使用别名，否则会出现错误。5 #比如连接设备或模拟器，起了以上别名后，命令应该如下：6 device=mr.waitForConnection()#连接到设备或模拟器1 #参数1：超时时间，单位秒，浮点数。默认是无限期地等待。2 #参数2：串deviceid，指定的设备名称。默认为当前设备（手机优先，比如手机通过USB线连接到PC、其次为模拟器）。3 #默认连接：4 device = MonkeyRunner.waitForConnection()5 #参数连接：6 device = MonkeyRunner.waitForConnection(1.0,&#39;4df74b8XXXXXXX&#39;) #向设备或模拟器安装APK 1 #以下两种方式都是对的2 device.installPackage(&#39;E:/JAVA/monkeyrunner/Test1/ThinkDrive_new.apk&#39;)3 device.installPackage(&#39;E:\\JAVA\\monkeyrunner\\Test1\\ThinkDrive_new.apk&#39;)4 #参数可以为绝对路径，也可为相对路径#卸载设备或模拟器中的APK 1 #参数为APK包名2 device.removePackage(&#39;cn.richinfo.thinkdrive&#39;) #启动任意的Activity1 #device.startActivity(component=&quot;包名/启动Activity&quot;)2 #以下两种都OK3 device.startActivity(component=&quot;cn.richinfo.thinkdrive/cn.richinfo.thinkdrive.ui.activities.NavigateActivity&quot;)4 device.startActivity(component=&quot;cn.richinfo.thinkdrive/.ui.activities.NavigateActivity&quot;)#手机截图 1 #获取设备的屏蔽缓冲区，产生了整个显示器的屏蔽捕获。（截图）2 result=device.takeSnapshot()3 #返回一个MonkeyImage对象（点阵图包装），我们可以用以下命令将图保存到文件4 result.writeToFile(&#39;E:\\JAVA\\monkeyrunner\\Test1\\Test1_001.png&#39;,&#39;png&#39;)#暂停 1 #暂停目前正在运行的程序指定的秒数2 #MonkeyRunner.sleep(秒数，浮点数) 3 MonkeyRunner.sleep(5)#字符串发送到键盘 1 #device.type(&#39;字符串&#39;)2 device.type(&#39;hongge&#39;)#唤醒设备屏幕1 #锁屏后,屏幕关闭，可以用下命令唤醒2 device.wake()#重起手机1 device.reboot()#模拟滑动1 #device.drag(X,Y,D,S)2 #X 开始坐标3 #Y 结束坐标4 #D 拖动持续时间(以秒为单位)，默认1.0秒5 #S 插值点时要采取的步骤。默认值是106 device.drag((100,1053),(520,1053),0.1,10)#在指定位置发送触摸事件 1 #device.touch(x,y,触摸事件类型)2 #x,y的单位为像素3 #触摸事件类型，请见下文中Findyou对device.press描述4 5 device.touch(520,520,&#39;DOWN_AND_UP&#39;)#发送指定类型指定键码的事件 1 #device.press(参数1:键码,参数2:触摸事件类型) 2 #参数1：见android.view.KeyEvent 3 #参数2，如有TouchPressType()返回的类型－触摸事件类型，有三种。 4 #1、DOWN 发送一个DOWN事件。指定DOWN事件类型发送到设备，对应的按一个键或触摸屏幕上。 5 #2、UP 发送一个UP事件。指定UP事件类型发送到设备，对应释放一个键或从屏幕上抬起。 6 #3、DOWN_AND_UP 发送一个DOWN事件，然后一个UP事件。对应于输入键或点击屏幕。 7 以上三种事件做为press()参数或touch()参数 8  9 #按下HOME键10 device.press(&#39;KEYCODE_HOME&#39;,MonkeyDevice.DOWN_AND_UP) 11 #按下BACK键12 device.press(&#39;KEYCODE_BACK&#39;,MonkeyDevice.DOWN_AND_UP) 13 #按下下导航键14 device.press(&#39;KEYCODE_DPAD_DOWN&#39;,MonkeyDevice.DOWN_AND_UP) 15 #按下上导航键16 device.press(&#39;KEYCODE_DPAD_UP&#39;,MonkeyDevice.DOWN_AND_UP) 17 #按下OK键18 device.press(&#39;KEYCODE_DPAD_CENTER&#39;,MonkeyDevice.DOWN_AND_UP) </code></pre><p> 好了时间也不早了，今天就啰嗦、水到这里吧，哈哈！晚安。好梦！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试22</title>
      <link href="/2016/04/17/appium/"/>
      <url>/2016/04/17/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十二）- 三个臭皮匠助你成就一番霸业-控件坐标获取（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　有些小伙伴或者是童鞋可能会好奇会问上一篇中的那个monkey脚本里的坐标点是如何获取的，不是自己随便蒙的猜的，或者是自己用目光或者是尺子量出来的吧，答案当然是：NO。获取控件坐标点的方式这里宏哥给小伙伴们分享和讲解三种方法（也就是三个臭皮匠），宏哥个人喜欢第二种，也推荐小伙伴们和童鞋们使用第二种，当然了萝卜青菜各有所爱，这里不做强制要求。小平同志不是说过：不管白猫还是黑猫抓住耗子就是好猫。适合自己才是最好的，小伙伴们可以根据自己的喜好自行选择。</p><h4 id="2-获取控件的坐标点方法"><a href="#2-获取控件的坐标点方法" class="headerlink" title="2.获取控件的坐标点方法"></a>2.获取控件的坐标点方法</h4><h5 id="第一种方法（MonkeyRecorder获取坐标）"><a href="#第一种方法（MonkeyRecorder获取坐标）" class="headerlink" title="第一种方法（MonkeyRecorder获取坐标）"></a>第一种方法（MonkeyRecorder获取坐标）</h5><p>下面就MonkeyRecorder获取坐标的方式，进行演示。MonkeyRecorder是一个比较好用的获取坐标的工具，它是用来获取真机或模拟器上坐标的工具，当我们点击真机或模拟器上的空间时，就能显示真机或模拟器上的点击点的坐标。</p><blockquote><p>（1）MonkeyRecorder的启动</p></blockquote><p>1.首先安卓手机连接上电脑，并保证以下两个条件成立：</p><p>a．终端USB调成开发者模式</p><p>b．电脑安装手机驱动</p><p>2.手机连接成功后，打开cmd窗口，输入adb devices查看已连接真机或模拟器设备的名称，我们这里仍以夜神模拟器为代表。如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/71bVEcgTCoue9MO.png" alt="1232840-20190722145234091-321349952.png"></p><p>3.在cmd窗口，输入monkeyrunner后，启动Monkeyrunner。做以下操作：导入MonkeyRecorder包、连接模拟器设备、以MonkeyRecorder方式启动模拟器，并依次输入</p><p>如下命令：</p><pre><code>1 from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice2 3 from com.android.monkeyrunner.recorder import MonkeyRecorder as recorder4 5 device=MonkeyRunner.waitForConnection()6 7 recorder.start(device)</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/dhnSAMHEfOLGpka.png" alt="1232840-20190722161600995-102723991.png"></p><p>4.到此，MonkeyRecorder正式启动。截图如下。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/fvjTZLeYwgyiPmB.png" alt="1232840-20190722161650461-821578897.png"></p><blockquote><p>（2）MonkeyRecorder的使用</p></blockquote><p>1.我们这里只是使用MonkeyRecorder来记录坐标，获取坐标的方式很简单。比如qq的登录界面，点击“登录”按钮，右侧就会显示该按钮的坐标；同样，点击账号输入框或密码输入框，右侧同样会显示坐标。这个坐标就是我们需要获得的坐标。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/GmPsT6fvk5eMpDX.png" alt="1232840-20190722162410870-423673859.png"></p><p>2.同时，MonkeyRecorder中的界面是同模拟器页面保持一致的，在MonkeyRecorder中触发任一操作，模拟器上会有相应的触发。如果两者没有保持一致，则点击MonkeyRecorder右上角的Refresh Display即可刷新页面。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/vcBksPxKrln9YmM.png" alt="1232840-20190722162136660-1510249308.png"></p><h5 id="第二种方法（Uiautomatorviewer）"><a href="#第二种方法（Uiautomatorviewer）" class="headerlink" title="第二种方法（Uiautomatorviewer）"></a>第二种方法（Uiautomatorviewer）</h5><p>　　网上很多推荐获取坐标点的方式，是使用 android-sdk/tools 目录下，提供的 uiautomatorviewer 工具来获取。但是这种方式非常的繁琐，而实际上，我们又不需要如此精确的坐标点，毕竟控件那么大，只要点击的坐标落在控件的位置上，即可。</p><p>Uiautomatorviewer是Android sdk自带的工具，位置在sdk/tools下。</p><p>工具打开方法：</p><p>1.sdk/tools下，找到uiautomatorviewer，双击打开</p><p>2.在cmd命令行，直接输入uiautomatorviewer，打开该工具</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/9yzsQD2TtxZMEB6.png" alt="980448-20161019185226326-925509638.png"></p><p>打开该工具后，我们就可以开始使用了。</p><p>运行环境：Windows</p><p>使用方法：</p><p>1.连接模拟器或真机（我们这里使用模拟器）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/VbHDp2mlG1eigLu.png" alt="980448-20161019185241529-1945531127.png"></p><p>2.打开模拟器中指定的app，在uiautomatorviewer中截图指定页面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/5Zuhpvr9nzVbL7X.png" alt="980448-20161019185258435-549593186.png"></p><p>3.截图成功后，页面显示如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/eSozt3bRAPhGLgI.png" alt="980448-20161019185316638-1971835415.png"></p><p>需要注意的是，你的手机设备或模拟器的api要在16以上，也就是android版本得是4.1以上，因为这个工具是google在4.1以后推出来的，只适用于4.1以后的版本</p><p>4.结果分析</p><p>从上图中，可以获取到对应控件的ID及控件左上角、右下角的坐标。</p><p>1）对于控件坐标而言，这里很简单，我们一般取中点坐标，即：</p><p>中点坐标=（（左上角横坐标+右下角横坐标）/2，（左上角纵坐标+右下角纵坐标）/2）</p><p>如，上图中，中点坐标即((30+1009)/2,(268+314)/2)=(519.5,291)</p><p>注：坐标一般取整。</p><p>由此，我们可以得到所需控件的坐标，在脚本中，直接touch该点坐标即可。</p><p>2）对于控件ID而言，即上图中的红色框中部分，同样在脚本中，直接touch该ID即可。</p><p>另外，利用uiautomatorviewer还可以获取父级与子级控件之间的关系，获取到的关系同HierarchyViewer保持一致。</p><p>uiautomatorviewer就介绍到这里。 </p><h5 id="第三种方法（Pointer-location获取坐标）"><a href="#第三种方法（Pointer-location获取坐标）" class="headerlink" title="第三种方法（Pointer location获取坐标）"></a>第三种方法（Pointer location获取坐标）</h5><p>　　那么我推荐另外一种更简单的方式，来获取当前你看见的，在待测试设备上的控件的坐标点的定位方式。那就是利用 Android 设备的开发者选项。</p><p>这里以夜神模拟器为例：</p><p>1.点击设置</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/Z4UPGjCzmup51dh.png" alt="1232840-20190722163038904-1913883052.png"></p><p>2.点击开发者选项</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/e42BHK9IpdQGDhv.png" alt="1232840-20190722163107203-695917822.png"></p><p>3.在指针位置 ，将这个属性开启之后，当手指在屏幕上滑动的时候，就可以在顶部看到当前触摸点的 X、Y 轴的坐标，这就是我们需要的。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/drSNfP8DcqKkIzJ.png" alt="1232840-20190722163146866-1546921374.png"></p><p>注意：开发者选项不是默认可见的，你需要自行开启开发者模式，之后再进行此操作。（这不是可以上网自已查一下，如果是夜神模拟器，可以参考宏哥的小结部分开启开发者选项）</p><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h4><p>1、安卓系统开启开发者模式方法很多，我们模拟器是6.3.0.0版本这里只讲适合夜神模拟器的方法，</p><p>接下来进入图文教程：</p><p>1.点击设置</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/giwhWlfj6AZytIK.png" alt="CqtxtVkVivGATw9sAARxM2Vi9dM911.png"></p><p>2.点击关于平板电脑</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/eALaG6ql9YcZmVo.png" alt="CqtxtVkVivaAZ0gzAADi_oszheM842.png"></p><p>3.点击7下版本号（手残请点击20下）,点击箭头指向处的版本号（最底下的版本号），而不是上面的Android版本号</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/dPVCklrQv31pa4B.png" alt="CqsbdFkVivqATCyYAADukR9fYnE573.png"></p><p>4.返回设置菜单</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/K1dO5jRxstUTioL.png" alt="CqsbdFkViv6AGhTAAADmEJVbeqg254.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/GtjPc13Aq672Z8Q.png" alt="CqtxtVkViwOAWrJdAAIP9YFFg4s283.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/SDVmZvBpjHRChTg.png" alt="CqtxtVkViwmAI0rvAAGWUp47CbM840.png"></p><p>这里补充一点，如果感觉开发者这个选项碍眼，可以选择关闭，关闭方法：</p><p>设置–应用–全部–找到设置软件，点击进入–清除数据<br>这样开发者模式又隐藏了~~</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/ALRV2K7SsHeNDUf.png" alt="CqsbdFkViw6AIiNuAAEvoQmIO3Y420.png"></p><p>教程到此结束O(∩_∩)O~~</p><p>2、好了，今天关于控件坐标点获取就到这里了！哈哈！最后祝大家都能熟练掌握！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试21</title>
      <link href="/2016/04/16/appium/"/>
      <url>/2016/04/16/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十一）- 让猴子按你指令大闹手机，让我们都成为耍猴高手（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>一年一度的暑假如期而至，每年必不可少的，便是《西游记》这部经典电视连续剧的播出，作为一名90后，对于这部经典剧的情谊，就是观看已成为一种习惯。依然深刻的记得，小时候妈妈为了催促我睡觉，而关掉我的《西游记》，那种哀求不成继而绝望的感觉，至今记忆犹新。长大后只要得空在家，哪怕手里做着其他的事情，也要把电视开着，听一听《西游记》。“你挑着担，我牵着马，迎来日出，送走晚霞——”这首基本人人能唱几句的歌曲，陪着我们一代又一代人，走过童年，青年和少年，甚至中年，或许还有将来的老年。坐在沙发上，当熟悉的音乐响起，心中突然冒出一股莫名的激动，电视里活泼生动的师徒几人，即便都能背出的故事情节，依旧能让我露出微笑。猴哥桀骜不驯，开始也不听命令，大闹天宫也是乱打一番，闯进这里，跑出哪里，一会天上一会地下；后来戴上紧箍咒，老实了。猴哥我们不敢耍，但是猴哥的混血弟弟妹妹我们敢耍。耍猴在中国已有悠久历史，最迟于唐朝已有出现，发源于今河南省新野县。古人把猴子视为马的守护神，常于马厩内养猴子以留住马匹，并让猴子表演猴戏作祭祀之用，因此猴子又有“马留”的别称，此名称至今仍保留在粤语中。日本于奈良时代从中国传入猴戏。后来耍猴的宗教性变淡，有些只是纯娱乐观众，一些小贩为招揽顾客，也会养猴子表演卖技艺，尤其常见于卖武术、卖药等行业。现时香港唯一一只获渔农自然护理署发牌由人饲养的猴子金鹰，其已故前主人陈日标生前以卖药为业，金鹰就在主人卖药时表演。下边这幅图片想必大家都不陌生吧。想必耍猴大家在实地或者电视、电影中都看过，看着耍猴人，发出不同的指令猴子根据指令做出各种搞笑的动作，逗的你开怀大笑。这个不是天生的而是后天训练的。前边讲解的monkey都是随机事件流，Monkey（猴子）在手机里像个无头苍蝇乱蹦乱跳地大闹一番；那么今天宏哥今天就教你如何让猴子按您的指令在手机里大闹，教你如何耍猴——Monkey（猴子）自定义脚本。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/RlGPijTME6Wz7nS.png" alt="1232840-20190718135904363-911937250.png"></p><h4 id="2-耍猴第一式-隐藏命令"><a href="#2-耍猴第一式-隐藏命令" class="headerlink" title="2.耍猴第一式 - 隐藏命令"></a>2.耍猴第一式 - 隐藏命令</h4><h5 id="monkey隐藏的两个命令："><a href="#monkey隐藏的两个命令：" class="headerlink" title="monkey隐藏的两个命令："></a>monkey隐藏的两个命令：</h5><pre><code>–pck-blacklist-file&lt;黑名单文件&gt;&lt;br&gt;&lt;br&gt;–pck-whitelist-file&lt;白名单文件&gt;</code></pre><p>monkey还有一个隐藏的命令那就是：</p><pre><code>–f&lt;脚本文件&gt;:可以指定monkey的自定义脚本```　一般monkey测试都是随机的测试事件，假如我们需要测试某一个特定的场景，普通的命令很难办到，这是就是需要自定义脚本这个命令了，它的使用方式也是很简单方便的，只要我们按照monkey的脚本规范写好脚本，之后将它保存到手机中，然后运行monkey的时候使用-f 命令指定脚本就行。#### 3.耍猴第二式 - monkey自定义脚本格式1、虽然，Google 官方并没有提供对 MS 详细讲解的 API 文档，但是我们是可以通过源码来分析出 MS 支持的API的。2、MS 的源码文件是：MonkeySourceScript.java3、monkey的源码MonkeySourceScript.java类中有一段关于monkey脚本规则的描述MonkeySourceScript.java有兴趣的同学可以去看一下这个源码，这里以 5.1.1 为例子，进行讲解，其实这一块的代码变动非常的少，找一个版本了解即可。我们看一下源码（33行到46行）对j脚本规则描述。##### 脚本规则的描述</code></pre><p>33/**<br>34 * monkey event queue. It takes a script to produce events sample script format:<br>35 *<br>36 * <pre><br>37 * type= raw events<br>38 * count= 10<br>39 * speed= 1.0<br>40 * start data >><br>41 * captureDispatchPointer(5109520,5109520,0,230.75429,458.1814,0.20784314,0.06666667,0,0.0,0.0,65539,0)<br>42 * captureDispatchKey(5113146,5113146,0,20,0,0,0,0)<br>43 * captureDispatchFlip(true)<br>44 * ...<br>45 * </pre><br>46 */</p><pre><code>##### 解释他们的意思</code></pre><p>#声明脚本的类型<br>type= raw events</p><p>#脚本的执行次数，由于monkey运行次数在命令设置的，这里的设置是无效的<br>count= 10</p><p>#事件执行时间间隔，这个也是通过命令来设置，这里不起作用<br>speed= 1.0</p><p>#脚本的入口，说明脚本从下面开始执行<br>start data &gt;&gt;</p><p>#下全是monkey命令<br>captureDispatchPointer(5109520,5109520,0,230.75429,458.1814,0.20784314,0.06666667,0,0.0,0.0,65539,0)<br>captureDispatchKey(5113146,5113146,0,20,0,0,0,0)<br>captureDispatchFlip(true)</p><pre><code>##### 知道了monkey脚本书写的基本格式，在来看一眼monkey常见脚本API</code></pre><p>1.LaunchActivity（包名，Activity名称）<br>启动被测应用的某个Activity<br>2.Tap(x,y,TapDuration)<br>一次单击事件<br>x,y：是坐标<br>TapDuration:持续的时间，单位毫秒<br>3.DispatchPress(keyName)<br>模拟一个按键<br>keyName:按键的名称<br>4.RotateScreen(RotationDegree,peresist)<br>旋转屏幕<br>RotationDegree：0~3分别表示顺时针的四个方向<br>peresist：是否存留<br>5.DispatchFiip(true/false)<br>打开或关闭软键盘<br>6.LongPress()长按2秒<br>7.PressAndHold(x,y,PressDuration)<br>模拟长按事件<br>x,y:点击的坐标<br>PressDuration:持续时常，单位毫秒<br>8.DispatchString(input)<br>输入字符串<br>input:输入的内容<br>9.Drag(xStart,yStart,xEnd,yEnd,pCount)<br>模拟拖动操作<br>xStart,yStart:开始的坐标值<br>xEnd,yEnd:结束的坐标值<br>pCount:滑动事件的次数<br>10.PinchZoom(pt1xStart,pt1yStart,pt1xEnd,pt1yEnd,pt2xStart,pt2ystart,pt2xEnd,pt2yEnd)<br>手势缩放事件<br>pt1xStart,pt1yStart:第一个手指起始的坐标位置<br>pt1xEnd,pt1yEnd：第一个手指结束的坐标位置<br>pt2xStart,pt2ystart：第二个手指开始的坐标位置<br>pt2xEnd,pt2yEnd：第二个手指结束的坐标位置<br>11.UserWait(sleepTime)<br>设置睡眠时间<br>sleepTime：等待时间，单位毫秒<br>12.DeviceWake()<br>唤醒设备屏幕</p><pre><code>在源码中，所有我们上面介绍的 API 都是以一个 static final 的形式被声明。这里简单就 LaunchActivity 的方法的源码进行讲解，其他的 API 其实也大同小异。##### LaunchActivity 的方法的源码讲解1、浏览器输入源码地址，找到静态字符串LaunchActivity，如图：![1232840-20190718144529113-1501701619.png](https://i.loli.net/2020/08/10/hc9kewQ8SYqVXDZ.png)2、将鼠标定位到静态字符串LaunchActivity通过ctrl（command）+🖱️左键我们可以定位到方法的位置。大约在597行，如图：![1232840-20190718144738435-190631318.png](https://i.loli.net/2020/08/10/se8rIZcOQMfPyEJ.png)3、将鼠标定位到LaunchActivity的方法通过ctrl（command）+🖱️左键我们可以进入到方法代码。大约在597行，如图：![1232840-20190718145136440-556050354.png](https://i.loli.net/2020/08/10/VSiW1XdfemDK6ER.png)4、如上边LaunchActiviity 方法源码所示，LaunchActiviity 会以数组的形式接收两个参数，分别表示 PackageName 和 Activity 的 ClassName，下面具体对应的实现，我们就不细看了。再参照上面介绍的 API ，就可以很清晰的定位出方法和参数的含义了。5、有兴趣的小伙伴们可以通过以上步骤一一查看哪些方法的API。  #### 4.耍猴第三式 - monkey 脚本的实例1、Monkey脚本主要包含两部分，一部分是头文件信息，一部分是具体的monkey命令。2、按照3.1的脚本描述规则我们来编辑monkeyscript，如下：</code></pre><p>type = user<br>count = 1<br>speed = 500<br>start data &gt;&gt;</p><p>#启动应用程序<br>LaunchActivity(com.michael.words,com.michael.words.activity.SplashActivity)<br>UserWait(5000)</p><p>#点击下步按钮<br>Tap(615,609)<br>UserWait(1000)</p><p>#点击编辑框<br>Tap(200,85,1000)</p><p>#输入sg<br>DispatchString(sg)</p><pre><code>以上脚本主要操作过程：1、点击夜神模拟器的应用中心2、进入应用中心，点击搜索框3、在搜索栏输入：hongge4、结束注意这里分别使用了 DispatchPress 和 DispatchString 来分别使用，就是为了做演示，实际你可以依赖场景选择使用的 API 。而其中涉及到坐标点的问题，这个在后面会讲解如何获取控件的坐标点。#### 5.执行脚本1、编写好脚本，保存为monkey.script 文件。2、通过 adb push 将其上传到待测试的设备中。要push到sdcard文件夹中（这里一夜神模拟器为例），如图：</code></pre><p>adb push C:/Users/DELL/Desktop/monkey.script /sdcard/</p><pre><code>![1232840-20190718153502298-1749791426.png](https://i.loli.net/2020/08/10/K3X2PxwrVD6YgpA.png)3、查看有没有push到设备中，从下图可以看到成功的push进去了。如图：![1232840-20190718154805253-1617429931.png](https://i.loli.net/2020/08/10/FUqsYKQIwzroVgH.png) 4、有兴趣或者不相信的可以查看文件内容，如图：![1232840-20190718155241510-1393935266.png](https://i.loli.net/2020/08/10/yqKNg3oA7uh1lc9.png)5、然后通过 monkey -f 执行此脚本，例如下面执行 1次。</code></pre><p>adb shell monkey -f /sdcard/monkey.script -v 1</p><pre><code>6、效果截图，在应用中心的搜索栏里输入了：hongge。![1232840-20190718171404623-516403572.png](https://i.loli.net/2020/08/10/1aK5Lor4EtZPvxS.png)7、执行完成之后，可以在控制台，看到输出的 Log 信息。![1232840-20190718171535748-741613868.png](https://i.loli.net/2020/08/10/NQcKCBhwd9ab1xp.png) 8、我们一起看一下执行过程小视频，小伙伴们都看到了吧，猴子按你的指令在夜神模拟器上开始表演，如下：&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;    &lt;iframe src=&quot;https://showmore.com/zh/embed/pm3ofxt&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;    &lt;/iframe&gt;&lt;/div&gt; #### 6.小结1、通过adb pull和adb push 手机与电脑之间传输文件（1）将手机卡中的某个文件复制到电脑1，手机连接电脑后，在命令行输入 adb devices，获取到设备序列号后说明手机已经和电脑连接成功。2，输入: adb pull 手机存储路径  电脑路径</code></pre><p>adb pull  /sdcard/xxx  /Users/xxxx/xxx.tx</p><pre><code>（2） 从电脑端向手机复制文件1，输入: adb pull 电脑路径  手机存储路径  </code></pre><p> adb push  /Users/xxxx/xxx.txt   /sdcard/xxx</p><pre><code>2、注意事项（此处有坑要留心注意哦！！！）头文件代码书写注意“=”两边预留空格，否则会出现如下报错。</code></pre><p>java.lang.NumberFormatException: Invalid int: “”<br>```</p><p>3、好了，今天关于耍猴就到这里了！哈哈！最后祝大家都成为耍猴高手！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试20</title>
      <link href="/2016/04/15/appium/"/>
      <url>/2016/04/15/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二十）- 猴哥失散多年的混血弟弟还是妹妹- Monkey（猴子）日志（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p> 　　日志是非常重要的，用于记录系统、软件操作事件的记录文件或文件集合，可分为事件日志和消息日志。具有处理历史数据、诊断问题的追踪以及理解系统、软件的活动等重要作用，在开发或者测试软系统过程中出现了问题，我们首先想到的就是她——logging。她可不像泰戈尔说的：“天空没有留下翅膀的痕迹,但我已经飞过”；Monkey这个小姑娘，她可是一个爱炫耀，爱显摆的人已经达到了人过留名、雁过留声的境界。只要我们按图索骥就一定可以定位到问题所在，然后分析问题，解决问题。好了逗大家一乐，下面开始进入今天的正题。</p><h4 id="2-为什么要看Monkey日志管理"><a href="#2-为什么要看Monkey日志管理" class="headerlink" title="2.为什么要看Monkey日志管理"></a>2.为什么要看Monkey日志管理</h4><p>　　Monkey日志管理是Monkey测试中非常重要的一个环节，通过日志管理分析，可以获取当前测试对象在测试过程中是否会发生异常，以及发生的概率，同时还可以获取对应的错误信息，帮助开发定位和解决问题。这样你就不会只停留在一个点点点的点工上，对自己也是一个很好的提升。</p><h4 id="3-Monkey-Log分析"><a href="#3-Monkey-Log分析" class="headerlink" title="3.Monkey Log分析"></a>3.Monkey Log分析</h4><p>当monkey测试时出现问题，此时我们需要分析定位问题，我们需要分析monkey日志</p><h5 id="Monkey测试出现的异常的原因："><a href="#Monkey测试出现的异常的原因：" class="headerlink" title="Monkey测试出现的异常的原因："></a>Monkey测试出现的异常的原因：</h5><p>一般是两种原因导致的，一个是crash 程序崩溃，导致crash原因如下 </p><p>a)、程序存在空指针<br>b)、cpu不足<br>c)、内存不足</p><p>另一种是ANR 程序无响应，导致anr无响应原因如下：</p><p>a)、线程阻塞<br>b)、cpu不足<br>c）、内存不足</p><h5 id="查找分析原因："><a href="#查找分析原因：" class="headerlink" title="查找分析原因："></a>查找分析原因：</h5><ol><li>当monkey测试出现异常终止，请打开logcat日志搜索关键字‘anrin’,如果存在该关键字，说明app出现了ANR异常，我们需要把/data/anr目录下的trace.txt文件取下来。 </li><li>取下来trace.txt文件后，将出现问题的进程号对应的日志发给软件工程师定位，如果在logcat日志里没有搜索到’anrin’关键字，就搜索’nullpointer’异常关键字的上下日志，发给开发定位 </li><li>当出现ANR后，需要导出,步骤如下： </li><li>输入adb shell </li><li>输入cd /data/anr/ </li><li>输入ls</li></ol><p>退出exit后，直接在cmd下输入</p><ol start="4"><li>adb pull /data/anr/traces.txt   d:\trace.txt </li><li>在logcat将出现anr问题的进程号复制，然后在trace.txt文件里按ctrl+F 查找，粘贴进程号，查找对应的问题</li></ol><h5 id="3-1Monkey结果分类"><a href="#3-1Monkey结果分类" class="headerlink" title="3.1Monkey结果分类"></a>3.1Monkey结果分类</h5><blockquote><p>Monkey运行log输出，按下列顺序输出</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/6ZPox5KcteJrNHF.png" alt="1232840-20190716154829805-1982062701.png"></p><p>下面就是我贴出的详细LOG分析：（表情代替注释符号，以免跟日志搞混）</p><pre><code>☀ 伪随机种子数与事件总数:Monkey: seed=1519697645236 count=10☀ 允许测试包:AllowPackage: 包名1☀ Category包含的LAUNCHER:IncludeCategory: android.intent.category.LAUNCHER☀ Category包含的MONKEY:IncludeCategory: android.intent.category.MONKEY☀ 查询允许包的activity 结果列表// Selecting main activities from category android.intent.category.LAUNCHER☀ 这些都不是指定包的activity//   - NOT USING main activity com.android.browser.BrowserActivity (from package com.android.browser) //   - NOT USING main activity com.android.calendar.homepage.AllInOneActivity (from package com.android.calendar)//   - NOT USING main activity com.android.camera.Camera (from package com.android.camera).... ☀ 中间忽略，从这也可以看出你手机上都安装了哪些应用☀ 这个就是我们指定的包的activity// + Using main activity 包名1.ui.portal.WelcomeActivity (from package 包名1)//   Selecting main activities from category android.intent.category.MONKEY☀ 种子为1519697645236// Seeded: 1519697645236☀ 事件百分比// Event percentages://   0: 15.0%//   1: 10.0%//   2: 2.0%//   3: 15.0%//   4: -0.0%//   5: -0.0%//   6: 25.0%//   7: 15.0%//   8: 2.0%//   9: 2.0%//   10: 1.0%//   11: 13.0%☀ 表示跳转到com.crazyhornets.MyHokageAndroidZSY包中的com.crazyhornets.MyHokage.MyHokageActivity里☀ 查看log中第一个Switch，主要是查看 Monkey 执行的是那一个 Activity，譬如下面的 log 中，执行的是com.yulore.yellowpage/.activity.SplashActivity，在下一个swtich之间的，如果出现了崩溃或其他异常，可以在该Activity中查找问题的所在。:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=cn.yaomaitong.app.daily/cn.yaomaitong.app.ui.portal.WelcomeActivity;end☀ 允许此Intent跳转// Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=cn.yaomaitong.app.daily/cn.yaomaitong.app.ui.portal.WelcomeActivity } in package cn.yaomaitong.app.daily// Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=cn.yaomaitong.app.daily/cn.yaomaitong.app.ui.portal.WelcomeActivity } in package cn.yaomaitong.app.daily☀ 以下就是事件间的延迟和发送的各种事件☀ --pct-nav事件☀ sleeping for 0 milliseconds这句 log 是执行Monkey测试时，throttle设定的间隔时间，每出现一次，就代表一个事件。(这个事件是指从用户角度来说的一个事件，比如点击：实际包括手指按下与抬起两个动作，monkey日记将被记为2个事件）Sleeping for 0 milliseconds   :Sending Key (ACTION_DOWN): 82    // KEYCODE_MENU:Sending Key (ACTION_UP): 82    // KEYCODE_MENUSleeping for 0 milliseconds:Switch:#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=cn.yaomaitong.app.daily/cn.yaomaitong.app.ui.portal.WelcomeActivity;end    // Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=cn.yaomaitong.app.daily/cn.yaomaitong.app.ui.portal.WelcomeActivity } in package cn.yaomaitong.app.daily    // Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=cn.yaomaitong.app.daily/cn.yaomaitong.app.ui.portal.WelcomeActivity } in package cn.yaomaitong.app.daily☀ --pct-touch事件Sleeping for 0 milliseconds :Sending Touch (ACTION_DOWN): 0:(532.0,1392.0):Sending Touch (ACTION_UP): 0:(542.04724,1391.5958)☀ --pct-motion事件Sleeping for 0 milliseconds   :Sending Touch (ACTION_DOWN): 0:(838.0,113.0):Sending Touch (ACTION_UP): 0:(852.82526,101.77225)☀ --pct-trackball事件Sleeping for 0 milliseconds    :Sending Trackball (ACTION_MOVE): 0:(1.0,4.0):Sending Trackball (ACTION_MOVE): 0:(-5.0,-3.0)☀ --pct-rotation屏幕旋转百分比 ####隐藏事件: Sending rotation degree=0, persist=true: Sending rotation degree=1, persist=false:: Sending rotation degree=2, persist=true: Sending rotation degree=3, persist=false☀ 注入事件10Events injected: 10☀ 发送屏幕翻转 度=0，存留=假:Sending rotation degree=0, persist=false☀ 丢弃：键=0，指针=0，轨迹球=0，键盘轻弹=0，屏幕翻转=0:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0☀ 网络状态：占用时间=42ms（手机0ms，wifi0ms，未连接42ms）## Network stats: elapsed time=42ms (0ms mobile, 0ms wifi, 42ms not connected)☀ 如果 Monkey 测试顺利执行完成，在 log 的最后，会打印出当前执行事件的次数和所花费的时间Monkey finished代表执行完成。Monkey 执行完成的 log 具体如下：Events injected: 100:Sending rotation degree=0, persist=false:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0## Network stats: elapsed time=2042ms (0ms mobile, 0ms wifi, 2042ms not connected)// Monkey finished☀ Monkey 执行中断，在 log 的最后也能查看到当前大约已执行的次数:Sending Trackball (ACTION_MOVE): 0:(-3.0,1.0):Sending Trackball (ACTION_MOVE): 0:(4.0,0.0)    //[calendar_time:2018-04-02 11:23:50.322  system_uptime:718998]    // Sending event #7500:Sending Trackball (ACTION_MOVE): 0:(3.0,-2.0)☀ Monkey测试完成// Monkey finished☀ CRASH输出LOG：// CRASH: cn.包名1 (pid 3165)// Short Msg: java.lang.IllegalStateException// Long Msg: java.lang.IllegalStateException: Fragment SingleChatFragment{366281} not attached to Activity// Build Label: Xiaomi/sagit/sagit:7.1.1/NMF26X/V9.2.4.0.NCACNEK:user/release-keys// Build Changelist: V9.2.4.0.NCACNEK// Build Time: 1516183841000// java.lang.IllegalStateException: Fragment SingleChatFragment{366281} not attached to Activity//  at android.support.v4.app.Fragment.getResources(Fragment.java:646)//  at cn.yaomaitong.app.ui.message.fragment.SingleChatFragment$13$1.run(SingleChatFragment.java:586)//  at android.os.Handler.handleCallback(Handler.java:754)//  at android.os.Handler.dispatchMessage(Handler.java:95)//  at android.os.Looper.loop(Looper.java:163)//  at android.app.ActivityThread.main(ActivityThread.java:6365)//  at java.lang.reflect.Method.invoke(Native Method)//  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:901)//  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:791)☀ ANR输出LOG//NOT RESPONDING:com.android.quicksearchbox(pid 6333)ANR in com.android.quicksearchbox(com.android.quicksearchbox/.SearchActivity)CPU usage from 8381ms to 2276ms ago:procrank: -&gt;adb shell procrankanr traces: -&gt;保存于/data/anr/traces.txtmeminfo: -&gt;adb shell dumpsys meminfoBugreport -&gt;adb bugreport 可选通过 --bugreport 参数控制</code></pre><h4 id="4-快速从monkey-txt日志中定位问题"><a href="#4-快速从monkey-txt日志中定位问题" class="headerlink" title="4.快速从monkey.txt日志中定位问题"></a>4.快速从monkey.txt日志中定位问题</h4><h5 id="4-1测试结果初步判断"><a href="#4-1测试结果初步判断" class="headerlink" title="4.1测试结果初步判断"></a>4.1测试结果初步判断</h5><p>1.monkey执行时未加–ignore-crashes –ignore-crashes参数，就先浏览日志中Events injected: 值，查看当前已执行的次数，就知道有无bug</p><p>2.程序无响应的问题：在日志中搜索 “ANR”</p><p>3.崩溃问题：在日志中搜索 “Exception” ，在这里顺便提一下常见的Java异常：</p><pre><code> 1 算术异常类：ArithmeticExecption 2 空指针异常类：NullPointerException 3 类型强制转换异常：ClassCastException 4 数组负下标异常：NegativeArrayException 5 数组下标越界异常：ArrayIndexOutOfBoundsException 6 违背安全原则异常：SecturityException 7 文件已结束异常：EOFException 8 文件未找到异常：FileNotFoundException 9 字符串转换为数字异常：NumberFormatException10 操作数据库异常：SQLException11 输入输出异常：IOException12 违法访问错误：IllegalAccessError13 内存不足错误：OutOfMemoryError14 堆栈溢出错误：StackOverflowError 15.其他，请参考：https://www.cnblogs.com/cvst/p/5822373.html</code></pre><h5 id="4-2找出问题后的操作步骤："><a href="#4-2找出问题后的操作步骤：" class="headerlink" title="4.2找出问题后的操作步骤："></a>4.2找出问题后的操作步骤：</h5><p>1.找到是monkey里面的哪个地方出错</p><p>2.查看Monkey里面出错前的一些事件动作，并手动执行该动作</p><p>3.若以上步骤还不能找出，可以使用之前执行的monkey命令再执行一遍，注意seed值要一样。</p><h4 id="5-日志导出"><a href="#5-日志导出" class="headerlink" title="5.日志导出"></a>5.日志导出</h4><p>　　细心地小伙伴可能通过前边的一系列操作和查找日志定位问题，发现docs命令窗口在查看和操作的时候特别地不方便，那么Monkey有没有像Tomcat等其他工具那样有log日志文件，很不幸告诉小伙伴们答案是：NO！，但是好消息是：我们可以将日志导出到文件中。然后将文件导出到手机或者是电脑上。</p><h5 id="5-1导出方法"><a href="#5-1导出方法" class="headerlink" title="5.1导出方法"></a>5.1导出方法</h5><p>导出到手机：</p><p>C:\Users\Shuqing&gt;adb shell</p><p>monkey -v 100 &gt;/sdcard/monkeylog.log</p><p>注意：不能写成C:\Users\Shuqing&gt;adb shell monkey -f /sdcard/kyb.txt -v 1 &gt; /mnt/sdcard/monkey.log 否则会报错“系统找不到指定的路径”。</p><p>需要将手机连接PC，拷贝以上文件：我们需要对这3个文件进行分析整理，以便提交开发人员处理。</p><p>当然了除了这种方法也比较麻烦，你可以通过命令直接导出到PC电脑端<br>导出到电脑：</p><p>例如：保存到电脑上并命名为monkey.txt</p><blockquote><p>adb shell monkey [option] <count> &gt;d:\monkey.txt</count></p></blockquote><p>eg：</p><p>C:\Users\Shuqing&gt;adb shell monkey -v -v 100 &gt;d:\monkeylog.txt</p><p>以上的导出方法，导出日志后，标准流和错误流的日志混合在一起，给我们定位和分析问题又带来麻烦了，因此需要将其分开导出保存。</p><p>标准流和错误流分开保存：</p><p>标准流与错误流分开保存，代码如下：<br>Monkey [option] <count> 1&gt;/sdcard/monkey.txt 2&gt;/sdcard/error.txt</count></p><p>C:\Users\Shuqing&gt;adb shell monkey -v 100 1&gt;d:\monkey.log  2&gt;d:\error.log<br>执行以上命令，Monkey的运行日志和异常日志将被分开保存。此时Monkey的运行日志将被保存在monkey.txt文件中，而异常日志将被保存在D盘下的error.txt中。<br>各个文件主要内容：</p><p>info.txt：主要记录了MONKEY测试时发送的各种事件，如触摸事件的位置等等。</p><p>error.txt：主要记录了MONKEY测试时产生的一些ANR、强制关闭等异常。</p><p>LOG文件：主要主要记录程序对MONKEY测试时的响应情况。</p><h4 id="6-日志参数"><a href="#6-日志参数" class="headerlink" title="6.日志参数"></a>6.日志参数</h4><p>1、-v 较少的日志信息<br>2、-v -v 较为丰富的日志信息<br>3、-v -v -v 最高级别的日志信息（推荐）</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>初步分析方法：</p><p>（1）、找到是monkey里面的哪个地方出现错误</p><p>（2）、查看monkey里面出错前的一些事件动作，并手动执行该动作</p><p>（3）、若以上步骤还不能找到，可以使用之前执行monkey命令，再执行一遍，注意使用的seed值要一样</p><p>测试结果分析：</p><p>（1）、ANR问题（程序无响应）：在日志中搜索“ANR”(application no response)</p><p>（2）、闪退问题：在日志中搜索”crash”</p><p>（3）、异常：搜索”exception”</p><p>（4）、强制退出：搜索”force closed”</p><p> 好了，今天关于日志就到这里了！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试19</title>
      <link href="/2016/04/14/appium/"/>
      <url>/2016/04/14/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十九）- 猴哥失散多年的混血弟弟还是妹妹- Monkey（猴子）参数（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　前边几篇介绍了Monkey以及Monkey的事件，今天就给小伙伴们介绍和分享一下Monkey的参数。</p><p>　　首先我们看一下这幅图来大致了解一下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/LbgG6VYowZMTEWy.png" alt="1232840-20190715112454724-333059405.png"></p><h4 id="2-Monkey-命令-基本参数介绍"><a href="#2-Monkey-命令-基本参数介绍" class="headerlink" title="2.Monkey 命令 基本参数介绍"></a>2.Monkey 命令 基本参数介绍</h4><h5 id="p-lt-允许的包名列表-gt"><a href="#p-lt-允许的包名列表-gt" class="headerlink" title="-p &lt;允许的包名列表&gt;"></a>-p &lt;允许的包名列表&gt;</h5><p>用此参数指定一个或多个包。指定包之后，monkey将只允许系统启动指定的app。如果丌指定包， monkey将允许系统启动设备中的所有app。  </p><p>指定一个包：</p><pre><code>adb shell monkey -p com.shjt.map 100</code></pre><p>指定多个包：</p><pre><code>adb shell monkey -p fishjoy.control.menu  –p com.shjt.map  100</code></pre><h5 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h5><p>用亍指定反馈信息级别（信息级别就是日志的详细程度），总共分3个级别，分别对应的参数如下 表所示： </p><pre><code>Level 0  :  adb shell monkey -p com.shjt.map -v 100               // 缺省值，仅提供启动提示、测试完成和最终结果等少量信息  Level 1  :  adb shell monkey -p com.shjt.map -v  -v 100          // 提供较为详细的日志，包括每个发送到Activity的事件信息Level 2  :  adb shell monkey -p com.shjt.map -v  -v  -v 100     // 最详细的日志，包括了测试中选中/未选中的Activity信息</code></pre><h5 id="s（随机数种子）"><a href="#s（随机数种子）" class="headerlink" title="-s（随机数种子）"></a>-s（随机数种子）</h5><p>用亍指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。  示例：</p><p>monkey测试1：</p><pre><code>adb shell monkey -p com.shjt.map –s 10 100</code></pre><p>monkey测试2：</p><pre><code>adb shell monkey -p com.shjt.map –s 10 100</code></pre><h5 id="–throttle-lt-毫秒-gt"><a href="#–throttle-lt-毫秒-gt" class="headerlink" title="–throttle &lt;毫秒&gt;"></a>–throttle &lt;毫秒&gt;</h5><p>用亍指定用户操作（即事件）间的时延，单位是毫秒；如果丌指定这个参数，monkey会尽可能快的 生成和发送消息。</p><p>示例：</p><pre><code>adb shell monkey -p com.shjt.map --throttle 3000 100</code></pre><h4 id="3-monkey-参数"><a href="#3-monkey-参数" class="headerlink" title="3.monkey 参数"></a>3.monkey 参数</h4><h5 id="3-1参数分类"><a href="#3-1参数分类" class="headerlink" title="3.1参数分类"></a>3.1参数分类</h5><p>常规类参数<br>事件类参数<br>约束类参数<br>调试类参数</p><h5 id="3-2常规类参数"><a href="#3-2常规类参数" class="headerlink" title="3.2常规类参数"></a>3.2常规类参数</h5><p>常规类参数包括帮助参数和日志信息参数。帮助参数用于输出Monkey命令使用指导；日志信息参数将日志分为三个级别，级别越高，日志的信息越详细。</p><blockquote><p>1.帮助类参数</p></blockquote><pre><code>monkey -h</code></pre><blockquote><p>2.日志级别</p></blockquote><pre><code>$ adb shell monkey -v &lt;event-count&gt;</code></pre><p>-v：打印出日志信息，每个-v将增加反馈信息的级别。-v越多日志信息越详细，不过目前最多支持3个-v，即：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/Qvwxj4oOi6MAIm1.png" alt="1232840-20190715110936919-95955806.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/RcKdiyqfwFheHG8.png" alt="1232840-20190715111001860-305663507.png"></p><h5 id="3-3事件类参数"><a href="#3-3事件类参数" class="headerlink" title="3.3事件类参数"></a>3.3事件类参数</h5><p>事件类参数的作用是对随机事件进行调控，从而使其遵照设定运行，如设置各种事件的百分比、设置事件生成所使用的种子值等。频率参数主要限制事件执行的时间间隔。</p><blockquote><p>1.执行指定脚本</p></blockquote><pre><code>$ adb shell monkey -f &lt;scriptfile&gt; &lt;event-count&gt;eg：$ adb shell monkey -f /mnt/sdcard/test1</code></pre><blockquote><p>2.伪随机数生成种子值</p></blockquote><p>使用 -s命令可以重复执行之前的伪随机操作。本身每次执行伪随机事件操作也会默认生成一个seed值</p><pre><code>$ adb shell monkey -s &lt;seed&gt; &lt;event-count&gt;eg:$ adb shell monkey -s 666 100</code></pre><blockquote><p>3.设置间隔</p></blockquote><p>如果你希望在每一个指令之间加上固定的间隔时间，可以用–throttle（注意，前面是–）命令。</p><pre><code>$ adb shell monkey --throttle &lt;milliseconds&gt;eg:$ adb shell monkey --throttle 3000  5</code></pre><p>–throttle：后面接时间，单位为ms（<milliseconds>），表示事件之间的固定延迟（即执行每一个指令间隔的时间），若不接该选项，monkey将不会延迟。</milliseconds></p><blockquote><p>4.调整触摸事件百分比</p></blockquote><p>如果你希望调整触摸事件的百分比，记住使用–pct-touch。</p><pre><code>$ adb shell monkey --pct-toucheg:$ adb shell monkey -v -v --pct-touch 100 200</code></pre><p><percent>–pct-touch：后面接触摸事件百分比</percent></p><p>注意：触摸事件不单单是按键，它泛指发生在某一位置的一个down-up事件。</p><blockquote><p>5.调整手势事件百分比</p></blockquote><pre><code>$ adb shell monkey --pct-motioneg:$ adb shell monkey -v -v --pct-motion 100 200</code></pre><blockquote><p>6.调整应用启动事件的百分比</p></blockquote><p>如果你希望调整应用启动事件的百分比，记住使用–pct-app-switch。</p><pre><code>$ adb shell monkey --pct-appswtich &lt;percent&gt;</code></pre><p>–pct-appswitch：后面接应用启动事件百分比。</p><p>应用启动事件（即activity launches）俗称打开应用，通过调用startActivity()方法最大限度地开启该package下的所有应用。</p><blockquote><p>7.调整屏幕旋转事件百分比</p></blockquote><pre><code>$ adb shell monkey --pct-rotation &lt;percent&gt;</code></pre><p>–pct-rotation 后面接屏幕旋转事件的比例值。</p><blockquote><p>8.其他参数</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/3fluX8DjhKv65N9.png" alt="1232840-20190715111039309-1865691047.png"></p><h5 id="3-4约束类参数"><a href="#3-4约束类参数" class="headerlink" title="3.4约束类参数"></a>3.4约束类参数</h5><blockquote><p>1.包约束</p></blockquote><p>-p：后面接一个或多个包名（<allowed-package-name>），如果应用需要访问其他包里的Activity，那相关的包也需要在此同时指定。如果不指定任何包，monkey将允许系统启动全部包里的Activity。</allowed-package-name></p><pre><code>$ adb shell monkey -p &lt;allowed-package-name&gt; &lt;event-count&gt;eg：$ adb shell monkey -p com.tal.kaoyan 500$ adb shell monkey -p com.tal.kaoyan -p com.tencent.mm 500</code></pre><blockquote><p>2.activity类约束</p></blockquote><p>如果你希望将monkey限制在一个或几个类别中，使用如下命令：</p><pre><code>adb shell monkey -c &lt;main-category&gt; &lt;event-count&gt;</code></pre><p>以下命令表示运行Intent.CATEGORY_LAUNCHER类别的Activity并发送1000个随机事件。</p><pre><code>$ adb shell monkey -c Intent.CATEGORY_LAUNCHER  1000```　![1232840-20190715111058982-920450952.png](https://i.loli.net/2020/08/10/6dTQ4hlcpvjBGCf.png)##### 3.5调试类参数&gt;1.应用程序崩溃后继续发送事件如果你希望monkey在应用程序崩溃后继续发送事件，则需要用到--ignore-crashes命令</code></pre><p>$ adb shell monkey –ignore-crashes <event-count></event-count></p><pre><code>在设置此选项后，当应用程序崩溃或发生失控异常时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到上述崩溃或异常将停止运行。&gt;2.超时错误继续发送事件如果你希望monkey在任何超时错误发生后继续发送事件，则需要用到--ignore-timeouts命令。</code></pre><p>$ adb shell monkey –ignore-timeouts</p><pre><code>&lt;event-count&gt;--ignore-timeouts：在设置此选项后，当应用程序发生任何超时错误（如ANR，即Application Not Responding）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类超时对话框将停止运行。&gt;3.应用程序权限错误发生后继续发送事件如果你希望monkey在应用程序权限错误发生后继续发送事件，则需要用到--ignore-security-exceptions命令。</code></pre><p>$ adb shell monkey –ignore-security-exceptions</p><pre><code>&lt;event-count&gt;--ignore-security-exceptions：在设置此选项后，当应用程序发生任何权限错误（如启动一个需要某些权限的Activity）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类权限错误将停止运行。&gt;4.其他![1232840-20190715111127163-1226170649.png](https://i.loli.net/2020/08/10/BcLoe3A7TXh2WtK.png)#### 4.Monkey参数应用综合案例##### 4.1测试场景测试考研帮app Android版。测试希望通过Monkey来模拟用户的随机操作，检查被测应用是否会出现异常（应用崩溃或者无响应）。##### 4.2需求分析1、测试是指定应用，因此需要使用-p指定被测app包名：com.tal.kaoyan2、这个测试的目的是希望模拟用户操作，因此需要让Monkey执行的事件尽可能地接近用户的常规操作，这样才可以最大限度地发现用户使用过程中可能出现的问题。因此需要对Monkey执行的事件百分比做一些调整:触摸事件和手势事件是用户最常见的操作，所以通过--pct-touch和--pct-motion将这两个事件的占比调整到40%与25%；目标应用包含了多个Activity，为了能覆盖大部分的Activity，所以通过--pct-appswitch将Activity切换的事件占比调整到10%；被测应用在测试中出现过不少横竖屏之间切换的问题，这个场景也必须关注，因此通过--pct-rotation把横竖屏切换事件调整到10%。3、使用-s参数来指定命令执行的seed值 Monkey会根据seed值来生成对应事件流，同一个seed生成的事件流是完全相同的。这里指定了seed值，是为了测试发现问题时，便于进行问题复现。4、使用--throttle参数来控制Monkey每个操作之间的时间间隔 指定操作之间的时间间隔，一方面是希望能更接近用户的操作场景，正常用户操作都会有一定的时间间隔；另一方面也是不希望因为过于频繁的操作而导致系统崩溃，尤其是在比较低端的手机上执行测试时。因此通过--throttle设置Monkey每个操作固定延迟0.4秒。5、使用--ignore-crashs和--ignore-timeouts参数使Monkey遇到意外时能继续执行 在执行Monkey测试时，会因为应用的崩溃或没有响应而意外终止，所以需要在命令中增加限制参数--ignore-crash和--ignore-timeouts，让Monkey在遇到崩溃或没有响应的时候，能在日志中记录相关信息，并继续执行后续的测试。6、使用-v指定log的详细级别 Monkey的日志输出有3个级别：日志的级别越高，其详细程度也越高。为了方便问题的定位，这里将日志设为 -v -v.##### 4.3测试命令</code></pre><p>adb shell monkey -p com.tal.kaoyan</p><p>–pct-touch 40 –pct-motion 25</p><p>–pct-appswitch 10</p><p>–pct-rotation 5</p><p>-s 1666 –throttle 400</p><p>–ignore-crashes</p><p>–ignore-timeouts</p><p>-v -v  200<br>```</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>　　好了，Monkey参数暂且到这里，告一段落，下一篇计划介绍分享Monkey的日志管理，各位小伙伴敬请期待哈！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试18</title>
      <link href="/2016/04/13/appium/"/>
      <url>/2016/04/13/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十八）- 你难道是猴哥失散多年的混血弟弟还是妹妹？？？- Monkey事件（超详解）</strong></p><h4 id="1-操作事件简介"><a href="#1-操作事件简介" class="headerlink" title="1.操作事件简介"></a>1.操作事件简介</h4><p>　　Monkey所执行的随机事件流中包含11大事件，分别是触摸事件、手势事件、二指缩放事件、轨迹事件、屏幕旋转事件、基本导航事件、主要导航事件、系统按键事件、启动Activity事件、键盘事件、其他类型事件。Monkey通过这11大事件来模拟用户的常规操作，对手机App进行稳定性测试。下面让我们来详细了解这11大事件。</p><h4 id="2-触摸事件"><a href="#2-触摸事件" class="headerlink" title="2.触摸事件"></a>2.触摸事件</h4><p>触摸事件是指在屏幕某处按下并抬起的操作，可通过–pct-touch参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到。 该事件由一组Touch（ACTION_DOWN）和Touch（ACTION_UP）事件组成，在手机上看到实际操作类似于点击。</p><h4 id="3-手势事件"><a href="#3-手势事件" class="headerlink" title="3.手势事件"></a>3.手势事件</h4><p>手势事件是指在屏幕某处的按下、随机移动、抬起的操作，即直线滑动操作。可通过–pct-motion参数来配置其事件百分比。</p><p>该事件是由一个ACTION_DOWN事件、一系列ACTION_MOVE事件和一个ACTION_UP事件组成的，在手机上看到的实际操作是一个没有拐弯的直线滑动操作。</p><h4 id="4-二指缩放事件"><a href="#4-二指缩放事件" class="headerlink" title="4.二指缩放事件"></a>4.二指缩放事件</h4><p>二指缩放事件是指在屏幕上的两处同时按下，并同时移动，最后同时抬起的操作，即智能机上的放大缩小手势操作。可通过–pct-pinchzoom参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p><p>该事件起始是一个ACTION_DOWN事件和一个ACTION_POINTER_DOWN事件，即模拟两个手指同时点下；中间是一系列的ACTION_MOVE事件，即两个手指同时在屏幕上直线滑动；结束是由一个ACTION_POINTER_UP事件和一个ACTION_UP事件组成的，即两个手指同时放开。</p><h4 id="5-轨迹事件"><a href="#5-轨迹事件" class="headerlink" title="5.轨迹事件"></a>5.轨迹事件</h4><p>轨迹事件是由一个或多个随机的移动组成的，有时会伴随着点击。很早之前的Android手机带有轨迹球，这个事件就是模拟的轨迹球的操作。现在的手机几乎都没有轨迹球，但轨迹球事件中包含曲线滑动操作，如果被测程序需要曲线滑动时可以选用此参数。可通过–pct-trackball参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p><p>该事件是由一系列的Trackball（ACTION_MOVE）事件组成的，观察手机上的操作，即为一系列的曲线滑动操作。</p><h4 id="6-屏幕旋转事件"><a href="#6-屏幕旋转事件" class="headerlink" title="6.屏幕旋转事件"></a>6.屏幕旋转事件</h4><p>屏幕旋转事件是一个隐藏事件，在Android官方文档中并没有记录这个事件。它其实是模拟的Android手机的横屏和竖屏切换。可通过–pct-rotation参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件由一个rotation事件组成，其中degree表示的是旋转方向，顺时针旋转，0表示旋转90度的方向，1表示旋转180度的方向，2表示旋转270度的方向，3表示旋转360度的方向。在执行过程中，可以看到手机屏幕在横竖屏之间不断地切换。</p><h4 id="7-基本导航事件"><a href="#7-基本导航事件" class="headerlink" title="7.基本导航事件"></a>7.基本导航事件</h4><p>基本导航事件是指点击方向输入设备的上、下、左、右按键的操作，现在手机上很少有上、下、左、右按键，这种事件一般用得比较少。可通过–pct-nav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p><p>该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上、下、左、右四个方向按键。</p><h4 id="8-主要导航事件"><a href="#8-主要导航事件" class="headerlink" title="8.主要导航事件"></a>8.主要导航事件</h4><p>主要导航事件是指点击“主要导航”按键的操作，这些按键通常会导致UI界面中的动作，如键盘的中间键、回退按键、菜单按键。可通过–pct-majornav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是中间键和菜单键。</p><h4 id="9-系统按键事件"><a href="#9-系统按键事件" class="headerlink" title="9.系统按键事件"></a>9.系统按键事件</h4><p>系统按键事件是指点击系统保留使用的按键的操作，如点击Home键、返回键、音量调节键等。可通过–pct-syskeys参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上面说到的几个系统按键。</p><h4 id="10-启动Activity事件"><a href="#10-启动Activity事件" class="headerlink" title="10.启动Activity事件"></a>10.启动Activity事件</h4><p>启动Activity事件是指在手机上启动一个Activity的操作。在随机的时间间隔中，Monkey将执行一个startActivity（）方法，作为最大限度上覆盖被测包中全部Activity的一种方法。可通过–pct-appswitch参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Switch操作组成的，从手机上看，上面的操作实际是打开了com.android.settings这个应用的一个com.android.settings.Settings的Activity界面。</p><h4 id="11-键盘事件"><a href="#11-键盘事件" class="headerlink" title="11.键盘事件"></a>11.键盘事件</h4><p>键盘事件主要是一些与键盘相关的操作。比如点击输入框、键盘弹起、点击输入框以外区域、键盘收回等。可通过–pct-flip参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 如日志所示，这里主要是键盘的打开和关闭操作。</p><h4 id="12-其他类型事件"><a href="#12-其他类型事件" class="headerlink" title="12.其他类型事件"></a>12.其他类型事件</h4><p>其他类型事件包括了除前面提到的10种事件外其他所有的事件，如按键、其他不常用的设备上的按钮等。可通过–pct-anyevent参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是其他的一些系统按键，如字母按键、数字按键等。因为现在手机很少带字母按键或数字按键，所以这个事件一般使用得比较少。</p><h4 id="13-小结"><a href="#13-小结" class="headerlink" title="13.小结"></a>13.小结</h4><p>好了，Monkey事件暂且到这里，下一篇计划介绍分享Monkey参数！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试17</title>
      <link href="/2016/04/12/appium/"/>
      <url>/2016/04/12/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十七）- 你难道是猴哥失散多年的混血弟弟还是妹妹？？？- Monkey简介之开山篇（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天由宏哥给小伙伴们来介绍猴哥的混血弟弟=Monkey。Monkey 是Android SDK提供的一个命令行工具， 可以简单，方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流，适合对app做压力测试。</p><p>中文名：猴子</p><p>英文名：Monkey</p><p>出身年月：不详</p><p>职业：自动化测试工具</p><p>常住地址：花果山水帘洞1号</p><h4 id="2-Monkey简介"><a href="#2-Monkey简介" class="headerlink" title="2.Monkey简介"></a>2.Monkey简介</h4><p>　　在Android的官方自动化测试领域有一只非常著名的“猴子”叫Monkey，这只“猴子”一旦启动，就会让被测的Android应用程序像猴子一样活蹦乱跳，到处乱跑。人们常用这只“猴子”来对被测程序进行压力测试，检查和评估被测程序的稳定性。</p><p>Android官方对这只“猴子”的描述是这样的：</p><p>　　The Monkey is a program that runs on your emulator or device and generates pseudo-random streams of user events such as clicks, touches, or gestures, as well as a number of system-level events. You can use the Monkey to stress-test applications that you are developing, in a random yet repeatable manner.</p><p>　　Monkey是一个程序，运行在您的模拟器或设备上，并生成伪随机的用户事件流，如点击，触摸或手势，以及一些系统级事件。 您可以使用Monkey以随机但可重复的方式对您正在开发的应用程序进行压力测试。</p><p>　　monkey官方文档：<a href="http://www.android-doc.com/tools/help/monkey.html" target="_blank" rel="noopener">http://www.android-doc.com/tools/help/monkey.html</a></p><h4 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3.环境搭建"></a>3.环境搭建</h4><p>　　安装Android SDK 并配置环境变量</p><h4 id="4-什么是Monkey"><a href="#4-什么是Monkey" class="headerlink" title="4.什么是Monkey"></a>4.什么是Monkey</h4><p>　　顾名思义，Monkey就是猴子，  Monkey测试，就像一只猴子， 在电脑面前，乱敲键盘在测试。  猴子什么都不懂， 只知道乱敲</p><p>　　通过Monkey程序模拟用户触摸屏幕、滑动Trackball、 按键等操作来对设备上的程序进行压力测试，检测程序多久的时间会发生异常</p><h4 id="5-Monkey-用来做什么"><a href="#5-Monkey-用来做什么" class="headerlink" title="5.Monkey 用来做什么"></a>5.Monkey 用来做什么</h4><p>　　Monkey 主要用于Android 的压力测试  自动的一个压力测试小工具， 主要目的就是为了测试app 是否会Crash.</p><h4 id="6-Monkey程序介绍"><a href="#6-Monkey程序介绍" class="headerlink" title="6.Monkey程序介绍"></a>6.Monkey程序介绍</h4><p>（1） Monkey程序由Android系统自带，使用Java诧言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：<br>a）可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试          </p><p>b）在PC上adb shell 进入Android系统，通过执行 monkey {+命令参数} 来进行Monkey 测试          </p><p>c )  在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  </p><h4 id="7-Monkey-架构"><a href="#7-Monkey-架构" class="headerlink" title="7.Monkey 架构"></a>7.Monkey 架构</h4><p>　　Monkey 运行在设备或模拟器上面，可以脱离PC运行（普遍做法是将monkey作为一个像待测应用发送 随机按键消息的测试工具。验证待测应用在这些随机性的输入面前是否会闪退或者崩溃）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/JExMCdFrH6eGLz9.png" alt="263119-20160505223944482-1516389266.png"></p><h4 id="8-Monkey弱点"><a href="#8-Monkey弱点" class="headerlink" title="8.Monkey弱点"></a>8.Monkey弱点</h4><p>　　Monkey虽然可以根据一个指定的命令脚本发送按键消息，但其丌支持条件判断，也丌支持读取待测界 面的信息来执行验证操作。</p><h4 id="9-Moneky-路径"><a href="#9-Moneky-路径" class="headerlink" title="9.Moneky 路径"></a>9.Moneky 路径</h4><p>　　Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的Monkey文件，其jar包是位于Android系统的/system/framework目录的Monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。同时，Monkey还会对测试系统进行监测，当出现以下三种情况时会进行特殊处理：</p><p>如限定了Monkey运行在特定包上，当监测到试图转到其他包的操作，将对其进行阻止。<br>如应用程序崩溃或接收到任何失控异常，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。<br>如果应用程序发生了程序无响应（application not responding）的错误，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。<br>按照选定的不同级别的反馈信息，在Monkey中还可以看到其执行过程报告和生成的事件。</p><h4 id="10-Monkey启动步骤"><a href="#10-Monkey启动步骤" class="headerlink" title="10.Monkey启动步骤"></a>10.Monkey启动步骤</h4><p>1、检查设备连接状态（以夜神模拟器为例）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/VWO2urAKkFpTmPa.png" alt="1232840-20190711154633085-422398990.png"></p><p>2、从上图看出，设备未连接，连接移动设备</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/3kNEj28CYuOIcqS.png" alt="1232840-20190711154803241-1369129532.png"></p><p>3、再次查看设备连接状态</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/5aTncMG1Lh7yQPv.png" alt="1232840-20190711154858243-1427394927.png"></p><p>4、连接成功后输入命令：adb shell</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/AQ3gH9OjdeNivIq.png" alt="1232840-20190711155007128-1945780180.png"></p><p>5、进入到指定目录，命令：cd /system/bin</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/x3YBJpirMbh7D9E.png" alt="1232840-20190711155048379-747931972.png"></p><p>6、输入 monkey命令看到如下提示则说明启动成功。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/HYqcRFpPnO3Tzyf.png" alt="1232840-20190711155158219-940439512.png"></p><h4 id="11-强制关闭monkey"><a href="#11-强制关闭monkey" class="headerlink" title="11.强制关闭monkey"></a>11.强制关闭monkey</h4><p>1、adb shell ps 查看全部在运行的进程</p><p>2、查找出com.android.commands.monkey 进程PID</p><p>3、adb shell kill pid 杀掉monkey进程</p><h4 id="12-monkey-命令"><a href="#12-monkey-命令" class="headerlink" title="12.monkey 命令"></a>12.monkey 命令</h4><p>monkey命令格式如下：</p><p>$ adb shell monkey [options] <event-count></event-count></p><p>[options] 是指monkey可传入的参数，是可选项（如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包）<br><event-count> 是指随机发送事件数。如：输入100就是执行100个伪随机事件，为必选项。</event-count></p><h4 id="13-小结"><a href="#13-小结" class="headerlink" title="13.小结"></a>13.小结</h4><p>  　　好了，Monkey简介暂且到这里，下一篇计划介绍分享Monkey事件！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试16</title>
      <link href="/2016/04/11/appium/"/>
      <url>/2016/04/11/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十六）- ADB命令，知否知否，应是必知必会（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　Android 调试桥(adb)是多种用途的工具，该工具可以帮助你你管理设备或模拟器 的状态。</p><p>　　adb ( Android Debug Bridge)是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用。</p><p>　　Tips： 在 android_sdk/platform-tools/ 中找到 adb 工具，然后根据其具体的路径配置好环境变量。然后启动cmd 输入‘adb’即可查看是否配置成功。</p><p>有小伙伴会问，为什么我需要学习掌握这些东西了，为什么宏哥要对这些做一个简单的分享了，因为在现实具体工作中经常会遇到这样的问题，这里还是通过一个小故事来说明一下。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/PjmX1EDpRu94qAy.jpg" alt="3270074-4ead9a16e552438c.jpg"></p><p>QA：“那个谁谁谁，我刚刚按照上一次那样操作这款款APP，我死活是跑不起测试脚本了。（内心独白：我去，这个奇怪的问题，一定是他给我的安装包有问题”）</p><p>DEV：“嗯？还有这样的问题，那你看一下你手机和电脑连接好了么？。（内心独白：一定是数据线没有连接好）”</p><p>QA：这个、这个…“咦，这个怎么看？（内心独白：我去，我怎么知道怎么看了，你不告诉我，我问手机和电脑，他们也不回答我啊）”</p><p>DEV：“你再看看它的端口，有没有被占用，日志有么有报错。（内心独白：鄙视一番，什么都不懂，这个多简单）”</p><p>一会过去了……</p><p>DEV：“巴拉巴拉，一大堆，要你查看的问题（内心独白：小样，自己啥都不看就来问我）”</p><p>QA：“头上都哗哗的直冒星星，宝宝心里苦，但是宝宝不说！（内心独白：这个。唉。。。。。。。，我都不知道）”</p><p>当你了解掌握adb命令之后：</p><p>QA：“那个谁谁谁，我刚刚按照上一次那样操作这款款APP，我死活是跑不起测试脚本了。我也查看设备连接情况，以及安装包的package和Activity等等一些东西，和我代码里配置的Appium Desired Capabilities参数都正确，你看看是什么问题吧。Oh，对了，我看日志了，应该是那个是么地方的错误，你去我说的那个地方楼一眼，看看是不是”</p><p>DEV：“厉害了Word哥！这个这个我查一下，是不是安装包打的包有问题，你稍等一下。（内心独白：真特么牛逼，都排查完了，还帮我定位了问题）”</p><p>全剧终！</p><p>可以通过下列几种方法加入adb:</p><p>在设备上运行shell命令<br>通过端口转发来管理模拟器或设备<br>从模拟器或设备上拷贝来或拷贝走文件<br>下面对adb进行了介绍并描述了常见的使用.</p><h4 id="2-概要"><a href="#2-概要" class="headerlink" title="2.概要"></a>2.概要</h4><p>Android 调试系统是一个面对客户服务系统，包括三个组成部分:</p><p>一个在你用于开发程序的电脑上运行的客户端。你可以通过shell端使用adb命令启动客户端。 其他Android工具比如说ADT插件和DDMS同样可以产生adb客户端.<br>在你用于发的机器上作为后台进程运行的服务器。该服务器负责管理客户端与运行于模拟器或设备上的adb守护程序(daemon)之间的通信。.<br>一个以后台进程的形式运行于模拟器或设备上的守护程序(daemon)。.<br>当你启动一个adb客户端，客户端首先确认是否已有一个adb服务进程在运行。如果没有，则启动服务进程。当服务器运行， adb服务器就会绑定本地的TCP端口5037并监听adb客户端发来的命令，—所有的adb客户端都是用端口 5037与adb服务器对话的.</p><p>接着服务器将所有运行中的模拟器或设备实例建立连接。它通过扫描所有5555到5585范围内的奇数端口来定位所有的模拟器或设备。一旦服务器找到 了adb守护程序，它将建立一个到该端口的连接。请注意任何模拟器或设备实例会取得两个连续的端口——一个偶数端口用来相应控制台的连接，和一个奇数端口 用来响应adb连接。比如说:</p><p>模拟器1，控制台：端口5554<br>模拟器1，Adb端口5555<br>控制台：端口 5556<br>Adb端口5557…<br>如上所示，模拟器实例通过5555端口连接adb，就如同使用5554端口连接控制台一样.</p><p>一旦服务器与所有模拟器实例建立连接，就可以使用adb命令控制和访问该实例。因为服务器管理模拟器/设备实例的连接，和控制处理从来自多个adb客户端来的命令，你可以通过任何客户端(或脚本)来控制任何模拟器或设备实例.</p><p>以下的部分描述通过命令使用adb和管理模拟器/设备的状态。要注意的是如果你用，装有ADT插件的Eclipse开发Android程序，你就不 需要通过命令行使用adb。ADT插件已经透明的把adb集成到Eclipse中了，当然，如果必要的话你也可以仍然直接使用adb，比如说调试.</p><h4 id="3-发出adb命令"><a href="#3-发出adb命令" class="headerlink" title="3.发出adb命令"></a>3.发出adb命令</h4><p>发出Android命令： 你可以在你的开发机上的命令行或脚本上发布Android命令，使用方法:</p><pre><code>adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; </code></pre><p> 当你发出一个命令，系统启用Android客户端。客户端并不与模拟器实例相关，所以如果双服务器/设备是运行中的，你需要用 -d 选项去为应被控制的命令确定目标实例。关于使用这个选项的更多信息，可以查看模拟器/设备实例术语控制命令 . </p><h4 id="4-查看adb版本"><a href="#4-查看adb版本" class="headerlink" title="4.查看adb版本"></a>4.查看adb版本</h4><pre><code>adb  version</code></pre><h4 id="4-连接夜神模拟器（此处分别演示模拟器和真机连接）"><a href="#4-连接夜神模拟器（此处分别演示模拟器和真机连接）" class="headerlink" title="4.连接夜神模拟器（此处分别演示模拟器和真机连接）"></a>4.连接夜神模拟器（此处分别演示模拟器和真机连接）</h4><pre><code>adb connect 127.0.0.1:62001</code></pre><p>Tips:</p><p>夜神模拟器的端口是规律的，第一个模拟器端口是62001，第二个模拟器端口是62025，第三个是62025+1，依此类推。</p><p>模拟器1：Android 4.4.2 地址：127.0.0.1:62001<br>模拟器2: Andriod 5.1.1 地址：127.0.0.1:62025<br>更多详情：<a href="https://www.yeshen.com/faqs/H15tDZ6YW" target="_blank" rel="noopener">夜神安卓模拟器adb命令详解</a></p><p>在发布adb命令之前，有必要知道什么样的模拟器/设备实例与adb服务器是相连的。可以通过使用devices 命令来得到一系列相关联的模拟器/设备:</p><pre><code>adb devices</code></pre><p>•作为回应，adb为每个实例都制定了相应的状态信息:</p><p>•序列号——由adb创建的一个字符串，这个字符串通过自己的控制端口<type>-<consoleport> 唯一地识别一个模拟器/设备实例。下面是一个序列号的例子： emulator-5554<br>实例的连接状态有三种状态:<br>offline — 此实例没有与adb相连接或者无法响应.<br>device — 此实例正与adb服务器连接。注意这个状态并不能百分之百地表示在运行和操作Android系统，因此这个实例是当系统正在运行的时候与adb连接的。然而，在系统启动之后，就是一个模拟器/设备状态的正常运行状态了.<br>每个实例的输出都有如下固定的格式:</consoleport></type></p><pre><code>[serialNumber] [state]</code></pre><p>下面是一个展示devices 命令和输出的例子 :</p><pre><code>$ adb devicesList of devices attached emulator-5554  deviceemulator-5556  deviceemulator-5558  device</code></pre><p>如果当前没有模拟器/设备运行，adb则返回 no device . </p><h4 id="7-给特定的模拟器-设备实例发送命令"><a href="#7-给特定的模拟器-设备实例发送命令" class="headerlink" title="7.给特定的模拟器/设备实例发送命令"></a>7.给特定的模拟器/设备实例发送命令</h4><p>如果有多个模拟器/设备实例在运行，在发布adb命令时需要指定一个目标实例。 这样做，请使用-s 选项的命令。在使用的-s 选项是</p><pre><code>adb -s &lt;serialNumber&gt; &lt;command&gt; </code></pre><p>如上所示，给一个命令指定了目标实例，这个目标实例使用由adb分配的序列号。你可以使用 devices 命令来获得运行着的模拟器/设备实例的序列号</p><p>示例如下:</p><pre><code>adb -s emulator-5556 install helloWorld.apk</code></pre><p>注意这点，如果没有指定一个目标模拟器/设备实例就执行 -s 这个命令的话，adb会产生一个错误. </p><h4 id="8-安装软件"><a href="#8-安装软件" class="headerlink" title="8.安装软件"></a>8.安装软件</h4><p>你可以使用adb从你的开发电脑上复制一个应用程序，并且将其安装在一个模拟器/设备实例。像这样做，使用install 命令。这个install 命令要求你必须指定你所要安装的.apk文件的路径:</p><pre><code>adb install &lt;path_to_apk&gt;</code></pre><p>为了获取更多的关于怎样创建一个可以安装在模拟器/设备实例上的.apk文件的信息，可参照Android Asset Packaging Tool (aapt).</p><p>要注意的是，如果你正在使用Eclipse IDE并且已经安装过ADT插件，那么就不需要直接使用adb（或者aapt）去安装模拟器/设备上的应用程序。否则，ADT插件代你全权处理应用程序的打包和安装. </p><h4 id="9-转发端口"><a href="#9-转发端口" class="headerlink" title="9.转发端口"></a>9.转发端口</h4><p>可以使用 forward 命令进行任意端口的转发——一个模拟器/设备实例的某一特定主机端口向另一不同端口的转发请求。下面演示了如何建立从主机端口6100到模拟器/设备端口7100的转发。</p><pre><code>adb forward tcp:6100 tcp:7100</code></pre><p>同样地，可以使用adb来建立命名为抽象的UNIX域套接口，上述过程如下所示:</p><pre><code>adb forward tcp:6100 local:logd</code></pre><h4 id="10-从模拟器-设备中拷入或拷出文件"><a href="#10-从模拟器-设备中拷入或拷出文件" class="headerlink" title="10.从模拟器/设备中拷入或拷出文件"></a>10.从模拟器/设备中拷入或拷出文件</h4><p>可以使用adbpull ,push 命令将文件复制到一个模拟器/设备实例的数据文件或是从数据文件中复制。install 命令只将一个.apk文件复制到一个特定的位置，与其不同的是，pull 和 push 命令可令你复制任意的目录和文件到一个模拟器/设备实例的任何位置。</p><p>从模拟器或者设备中复制文件或目录，使用(如下命):</p><pre><code>adb pull &lt;remote&gt; &lt;local&gt;</code></pre><p>将文件或目录复制到模拟器或者设备，使用（如下命令）</p><pre><code>adb push &lt;local&gt; &lt;remote&gt;</code></pre><p>在这些命令中， <local> 和<remote> 分别指通向自己的发展机（本地）和模拟器/设备实例（远程）上的目标文件/目录的路径</remote></local></p><p>下面是一个例子：:</p><pre><code>adb push foo.txt /sdcard/foo.txt </code></pre><h4 id="11-Adb命令列表"><a href="#11-Adb命令列表" class="headerlink" title="11.Adb命令列表"></a>11.Adb命令列表</h4><p>下列表格列出了adb支持的所有命令,并对它们的意义和使用方法做了说明. </p><table border="0">    <tr><th>Category</th><th>Command</th><th>Description</th><th>Comments</th></tr>    <tr>        <td rowspan="3">Options</td>        <td>-d</td>        <td>仅仅通过USB接口来管理abd.</td>        <td>如果不只是用USB接口来管理则返回错误.</td>    </tr>    <tr>        <td>-e</td>        <td>仅仅通过模拟器实例来管理adb.</td>        <td>如果不是仅仅通过模拟器实例管理则返回错误.</td>    </tr>    <tr>        <td>-s&nbsp;&lt;serialNumber&gt;</td>        <td>通过模拟器/设备的允许的命令号码来发送命令来管理adb (比如: "emulator-5556").</td>        <td>如果没有指定号码，则会报错.</td>    </tr>    <tr>        <td rowspan="3">General</td>        <td>devices</td>        <td>查看所有连接模拟器/设备的设施的清单.</td>        <td>查看&nbsp;Querying for Emulator/Device Instances获取更多相关信息.</td>    </tr>    <tr>        <td>help</td>        <td>查看adb所支持的所有命令。.</td>        <td> &nbsp; &nbsp;</td>    </tr>    <tr>        <td>version</td>        <td>查看adb的版本序列号.</td>        <td>&nbsp;&nbsp;</td>        </tr>    <tr>        <td rowspan="3">Debug</td>        <td>logcat&nbsp;[&lt;option&gt;] [&lt;filter-specs&gt;]</td>        <td>将日志数据输出到屏幕上.</td>        <td>&nbsp;</td>    </tr>    <tr>        <td>bugreport</td>        <td>查看bug的报告，如dumpsys&nbsp;,dumpstate&nbsp;,和logcat&nbsp;信息。</td>        <td>&nbsp;</td>    </tr>    <tr>        <td>jdwp</td>        <td>查看指定的设施的可用的JDWP信息.</td>        <td>可以用&nbsp;forward jdwp:&lt;pid&gt;&nbsp;端口映射信息来连接指定的JDWP进程.例如：&nbsp;<br>adb forward tcp:8000 jdwp:472&nbsp;<br>jdb -attach localhost:8000</td>    </tr>    <tr>        <td rowspan="3">Data</td>        <td>install&nbsp;&lt;path-to-apk&gt;</td>        <td>安装Android为（可以模拟器/设施的数据文件.apk指定完整的路径）.</td>        <td>&nbsp;</td>    </tr>    <tr>        <td>pull&nbsp;&lt;remote&gt;&nbsp;&lt;local&gt;</td>        <td>将指定的文件从模拟器/设施的拷贝到电脑上.</td>        <td>&nbsp;</td>    </tr>    <tr>        <td>push&nbsp;&lt;local&gt;&nbsp;&lt;remote&gt;</td>        <td>将指定的文件从电脑上拷贝到模拟器/设备中.</td>        <td>&nbsp;</td>    </tr>    <tr>        <td rowspan="2">Ports and Networking</td>        <td>forward&nbsp;&lt;local&gt;&nbsp;&lt;remote&gt;</td>        <td>用本地指定的端口通过socket方法远程连接模拟器/设施</td>        <td>端口需要描述下列信息:            <ul>                <li>tcp:&lt;portnum&gt;</li>                <li>local:&lt;UNIX domain socket name&gt;</li>                <li>dev:&lt;character device name&gt;</li>                <li>jdwp:&lt;pid&gt;</li>            </ul>        </td>    </tr>    <tr>        <td>ppp&nbsp;&lt;tty&gt;&nbsp;[parm]...</td>        <td>通过USB运行ppp：            <ul>                <li>&lt;tty&gt;&nbsp;— the tty for PPP stream. For exampledev:/dev/omap_csmi_ttyl.</li>                <li>[parm]...&nbsp;&nbsp;&amp;mdash zero or more PPP/PPPD options, such as&nbsp;defaultroute&nbsp;,local&nbsp;,&nbsp;notty&nbsp;, etc.</li>            </ul>            <p>需要提醒你的不能自动启动PDP连接.</p>        </td>        <td>&nbsp;</td>    </tr>    <tr>        <td rowspan="3">Scripting</td>        <td>get-serialno</td>        <td>查看adb实例的序列号.</td>        <td rowspan="2">查看&nbsp;Querying for Emulator/Device Instances可以获得更多信息.</td>    </tr>    <tr>        <td>get-state</td>        <td>查看模拟器/设施的当前状态.</td>    </tr>    <tr>    <td>wait-for-device</td>    <td>如果设备不联机就不让执行,--也就是实例状态是&nbsp;device&nbsp;时.</td>    <td>你可以提前把命令转载在adb的命令器中,在命令器中的命令在模拟器/设备连接之前是不会执行其它命令的. 示例如下:    adb wait-for-device shell getprop    需要提醒的是这些命令在所有的系统启动启动起来之前是不会启动adb的 所以在所有的系统启动起来之前你也不能执行其它的命令. 比如：运用install&nbsp;的时候就需要Android包，这些包只有系统完全启动。例如：    adb wait-for-device install &lt;app&gt;.apk    上面的命令只有连接上了模拟器/设备连接上了adb服务才会被执行，而在Android系统完全启动前执行就会有错误发生.</td>    </tr>    <tr>    <td rowspan="2">Server</td>    <td>start-server</td>    <td>选择服务是否启动adb服务进程.</td>    <td>&nbsp;</td>    </tr>    <tr>    <td>kill-server</td>    <td>终止adb服务进程.</td>    <td>&nbsp;</td>    </tr>    <tr>    <td rowspan="2">Shell</td>    <td>shell</td>    <td>通过远程shell命令来控制模拟器/设备实例.</td>    <td rowspan="2">查看&nbsp;获取更多信息&nbsp;for more information.</td>    </tr>    <tr>    <td>shell&nbsp;[&lt;shellCommand&gt;]</td>    <td>连接模拟器/设施执行shell命令，执行完毕后退出远程shell端l.</td>    </tr></table><p>需要提醒你的不能自动启动PDP连接.</p><p>启动shell命令</p><p>Adb 提供了shell端，通过shell端你可以在模拟器或设备上运行各种命令。这些命令以2进制的形式保存在本地的模拟器或设备的文件系统中:</p><pre><code>/system/bin/...</code></pre><p>不管你是否完全进入到模拟器/设备的adb远程shell端，你都能 shell 命令来执行命令.</p><p>当没有完全进入到远程shell的时候，这样使用shell 命令来执行一条命令:</p><pre><code>adb [-d|-e|-s {&lt;serialNumber&gt;}] shell &lt;shellCommand&gt;</code></pre><p>在模拟器/设备中不用远程shell端时，这样使用shell 命 :</p><pre><code>adb [-d|-e|-s {&lt;serialNumber&gt;}] shell</code></pre><p>通过操作CTRL+D 或exit 就可以退出shell远程连接.</p><p>下面一些就将告诉你更多的关于shell命令的知识. </p><h4 id="12-通过远程shell端运行sqllite3连接数据库"><a href="#12-通过远程shell端运行sqllite3连接数据库" class="headerlink" title="12.通过远程shell端运行sqllite3连接数据库"></a>12.通过远程shell端运行sqllite3连接数据库</h4><p>通过adb远程shell端，你可以通过Android软sqlite3 命令程序来管理数据库。sqlite3 工具包含了许多使用命令，比如：.dump 显示表的内容，.schema 可以显示出已经存在的表空间的SQL CREATE结果集。Sqlite3还允许你远程执行sql命令.</p><p>通过sqlite3 , 按照前几节的方法登陆模拟器的远程shell端，然后启动工具就可以使用sqlite3 命令。当sqlite3 启动以后，你还可以指定你想查看的数据库的完整路径。模拟器/设备实例会在文件夹中保存SQLite3数据库. /data/data/<package_name>/databases/ .</package_name></p><p>示例如下:</p><pre><code>$ adb -s emulator-5554 shell# sqlite3 /data/data/com.example.google.rss.rssexample/databases/rssitems.dbSQLite version 3.3.12Enter &quot;.help&quot; for instructions.... enter commands, then quit...sqlite&gt; .exit </code></pre><p>当你启动sqlite3的时候，你就可以通过shell端发送 sqlite3 ,命令了。用exit 或 CTRL+D 退出adb远程shell端.</p><h4 id="13-UI-软件-试验程序-Monkey"><a href="#13-UI-软件-试验程序-Monkey" class="headerlink" title="13.UI/软件 试验程序 Monkey"></a>13.UI/软件 试验程序 Monkey</h4><p>当Monkey程序在模拟器或设备运行的时候，如果用户出发了比如点击，触摸，手势或一些系统级别的事件的时候，它就会产生随机脉冲，所以可以用Monkey用随机重复的方法去负荷测试你开发的软件.</p><p>最简单的方法就是用用下面的命令来使用Monkey，这个命令将会启动你的软件并且触发500个事件.</p><pre><code>$ adb shell monkey -v -p your.package.name 500</code></pre><p>更多的关于命令Monkey的命令的信息，可以查看UI/Application Exerciser Monkey documentation page.</p><p>文档页面</p><h4 id="14-其它的shell命令"><a href="#14-其它的shell命令" class="headerlink" title="14.其它的shell命令"></a>14.其它的shell命令</h4><p>下面的表格列出了一些adbshell命令，如果需要全部的命令和程序，可以启动模拟器实例并且用adb -help 命令 .</p><pre><code>adb shell ls /system/bin</code></pre><p>对大部门命令来说，help都是可用的.</p><table border="0">    <tr><th>Shell Command</th><th>Description</th><th>Comments</th></tr>    <tr>    <td><code>dumpsys</code></td>    <td>清除屏幕中的系统数据n.</td>    <td rowspan="4">Dalvik Debug Monitor Service&nbsp;(DDMS)工具提供了完整的调试、.</td>    </tr>    <tr>    <td><code>dumpstate</code></td>    <td>清除一个文件的状态.</td>    </tr>    <tr>    <td><code>logcat&nbsp;[&lt;option&gt;]...&nbsp;[&lt;filter-spec&gt;]...</code></td>    <td>启动信息日志并且但因输出到屏幕上.</td>    </tr>    <tr>    <td><code>dmesg</code></td>    <td>输出主要的调试信息到屏幕上.</td>    </tr>    <tr>    <td><code>start</code></td>    <td>启动或重启一个模拟器/设备实例.</td>    <td>&nbsp;</td>    </tr>    <tr>    <td><code>stop</code></td>    <td>关闭一个模拟器/设备实例.</td>    <td>&nbsp;</td>    </tr></table><h4 id="15-启用logcat日志"><a href="#15-启用logcat日志" class="headerlink" title="15.启用logcat日志"></a>15.启用logcat日志</h4><p>Android日志系统提供了记录和查看系统调试信息的功能。日志都是从各种软件和一些系统的缓冲区中记录下来的，缓冲区可以通过 logcat 命令来查看和使用. </p><h5 id="15-1使用logcat命令"><a href="#15-1使用logcat命令" class="headerlink" title="15.1使用logcat命令"></a>15.1使用logcat命令</h5><p>你可以用 logcat 命令来查看系统日志缓冲区的内容:</p><pre><code>[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... </code></pre><p>请查看Listing of logcat Command Options ，它对logcat命令有详细的描述 .</p><p>你也可以在你的电脑或运行在模拟器/设备上的远程adb shell端来使用logcat 命令，也可以在你的电脑上查看日志输出。</p><pre><code>$ adb logcat</code></pre><p>你也这样使用：</p><pre><code># logcat </code></pre><h5 id="15-2过滤日志输出"><a href="#15-2过滤日志输出" class="headerlink" title="15.2过滤日志输出"></a>15.2过滤日志输出</h5><p>每一个输出的Android日志信息都有一个标签和它的优先级.</p><p>日志的标签是系统部件原始信息的一个简要的标志。（比如：“View”就是查看系统的标签）.<br>优先级有下列集中，是按照从低到高顺利排列的:</p><pre><code>V — Verbose (lowest priority)D — DebugI — InfoW — WarningE — ErrorF — FatalS — Silent (highest priority, on which nothing is ever printed)</code></pre><p>在运行logcat的时候在前两列的信息中你就可以看到 logcat 的标签列表和优先级别,它是这样标出的:<priority>/<tag> .</tag></priority></p><p>下面是一个logcat输出的例子,它的优先级就似乎I,标签就是ActivityManage:</p><pre><code>I/ActivityManager(  585): Starting activity: Intent { action=android.intent.action...}</code></pre><p>为了让日志输出能体现管理的级别,你还可以用过滤器来控制日志输出,过滤器可以帮助你描述系统的标签等级.</p><p>过滤器语句按照下面的格式描tag:priority … , tag 表示是标签, priority 是表示标签的报告的最低等级. 从上面的tag的中可以得到日志的优先级. 你可以在过滤器中多次写tag:priority .</p><p>这些说明都只到空白结束。下面有一个列子，例子表示支持所有的日志信息，除了那些标签为”ActivityManager”和优先级为”Info”以上的和标签为” MyApp”和优先级为” Debug”以上的。 小等级,优先权报告为tag.</p><pre><code>adb logcat ActivityManager:I MyApp:D *:S</code></pre><p>上面表达式的最后的元素 *:S ,，是设置所有的标签为”silent”，所有日志只显示有”View” and “MyApp”的，用 *:S 的另一个用处是 能够确保日志输出的时候是按照过滤器的说明限制的，也让过滤器也作为一项输出到日志中.</p><p>下面的过滤语句指显示优先级为warning或更高的日志信息:</p><pre><code>adb logcat *:W</code></pre><p>如果你电脑上运行logcat ，相比在远程adbshell端，你还可以为环境变量ANDROID_LOG_TAGS :输入一个参数来设置默认的过滤</p><pre><code>export ANDROID_LOG_TAGS=&quot;ActivityManager:I MyApp:D *:S&quot;</code></pre><p>需要注意的是ANDROID_LOG_TAGS 过滤器如果通过远程shell运行logcat 或用adb shell logcat 来运行模拟器/设备不能输出日志. </p><h5 id="15-3控制日志输出格式"><a href="#15-3控制日志输出格式" class="headerlink" title="15.3控制日志输出格式"></a>15.3控制日志输出格式</h5><p>日志信息包括了许多元数据域包括标签和优先级。可以修改日志的输出格式，所以可以显示出特定的元数据域。可以通过 -v 选项得到格式化输出日志的相关信息.</p><pre><code>brief — Display priority/tag and PID of originating process (the default format).process — Display PID only.tag — Display the priority/tag only.thread — Display process:thread and priority/tag only.raw — Display the raw log message, with no other metadata fields.time — Display the date, invocation time, priority/tag, and PID of the originating process.long — Display all metadata fields and separate messages with a blank lines.</code></pre><p>当启动了logcat ，你可以通过-v 选项来指定输出格式:</p><pre><code>[adb] logcat [-v &lt;format&gt;]</code></pre><p>下面是用 thread 来产生的日志格式:</p><pre><code>adb logcat -v thread</code></pre><p>需要注意的是你只能-v 选项来规定输出格式 option. </p><h5 id="15-4查看可用日志缓冲区"><a href="#15-4查看可用日志缓冲区" class="headerlink" title="15.4查看可用日志缓冲区"></a>15.4查看可用日志缓冲区</h5><p>Android日志系统有循环缓冲区，并不是所有的日志系统都有默认循环缓冲区。为了得到日志信息，你需要通过-b 选项来启动logcat 。如果要使用循环缓冲区，你需要查看剩余的循环缓冲期:</p><pre><code>radio — 查看缓冲区的相关的信息.events — 查看和事件相关的的缓冲区.main — 查看主要的日志缓冲区</code></pre><p>-b 选项使用方法:</p><pre><code>[adb] logcat [-b &lt;buffer&gt;]</code></pre><p>下面的例子表示怎么查看日志缓冲区包含radio 和 telephony信息:</p><pre><code>adb logcat -b radio </code></pre><h5 id="15-5查看stdout-和stderr"><a href="#15-5查看stdout-和stderr" class="headerlink" title="15.5查看stdout 和stderr"></a>15.5查看stdout 和stderr</h5><p>在默认状态下，Android系统有stdout 和 stderr (System.out 和System.err )输出到/dev/null ，在运行Dalvik VM的进程中，有一个系统可以备份日志文件。在这种情况下，系统会用stdout 和stderr 和优先级 I.来记录日志信息</p><p>通过这种方法指定输出的路径，停止运行的模拟器/设备，然后通过用 setprop 命令远程输入日志</p><pre><code>$ adb shell stop$ adb shell setprop log.redirect-stdio true$ adb shell start</code></pre><p>系统直到你关闭模拟器/设备前设置会一直保留，可以通过添加/data/local.prop 可以使用模拟器/设备上的默认设置 </p><h5 id="15-6Logcat命令列表"><a href="#15-6Logcat命令列表" class="headerlink" title="15.6Logcat命令列表"></a>15.6Logcat命令列表</h5><pre><code>Option    Description-b &lt;buffer&gt;    加载一个可使用的日志缓冲区供查看，比如event 和radio . 默认值是main 。具体查看Viewing Alternative Log Buffers.-c    清楚屏幕上的日志.-d    输出日志到屏幕上.-f &lt;filename&gt;    指定输出日志信息的&lt;filename&gt; ，默认是stdout .-g    输出指定的日志缓冲区，输出后退出.-n &lt;count&gt;    设置日志的最大数目&lt;count&gt; .，默认值是4，需要和 -r 选项一起使用。-r &lt;kbytes&gt;    每&lt;kbytes&gt; 时输出日志，默认值为16，需要和-f 选项一起使用.-s    设置默认的过滤级别为silent.-v &lt;format&gt;    设置日志输入格式，默认的是brief 格式，要知道更多的支持的格式，参看Controlling Log Output Format .</code></pre><h4 id="16-Stopping-the-adb-Server"><a href="#16-Stopping-the-adb-Server" class="headerlink" title="16.Stopping the adb Server"></a>16.Stopping the adb Server</h4><p>在某些情况下，你可能需要终止Android 调试系统的运行,然后再重新启动它。 例如,如果Android 调试系统不响应命令，你可以先终止服务器然后再重启，这样就可能解决这个问题.</p><p>用kill-server 可以终止adb server。你可以用adb发出的任何命令来重新启动服务器.</p><h4 id="17-小结"><a href="#17-小结" class="headerlink" title="17.小结"></a>17.小结</h4><p>以上介绍那么多是不是都需要掌握，答案是：NO，学习android测试，adb是必学的，以下是几个常用的指令需要熟练掌握</p><h5 id="一、检查设备"><a href="#一、检查设备" class="headerlink" title="一、检查设备"></a>一、检查设备</h5><p>1.如何检查手机（或模拟器）是连上电脑的，在cmd输入：</p><pre><code>&gt;adb devices</code></pre><p>2.一定要看到上图红色区域的，设备名称，然后接着是device(如果看到这里是offline，那就是adb端口被占了)</p><h5 id="二、安装app"><a href="#二、安装app" class="headerlink" title="二、安装app"></a>二、安装app</h5><p>1.如何给电脑上的android模拟器安装app呢？</p><p>第一步：先下载apk文件包放到桌面上</p><p>第二步：cmd端口输入adb install app的路径</p><p>第三步：把apk包拖到cmd窗口，回车就能安装了</p><p>2.安装成功后看到Success，模拟器上会出现淘宝的app</p><h5 id="三、卸载app"><a href="#三、卸载app" class="headerlink" title="三、卸载app"></a>三、卸载app</h5><p>1.在cmd输入以下指令，可以删除app</p><pre><code>&gt;adb uninstall 包名</code></pre><p>（这里是app的包名，不是文件名，包名用前面的aapt工具查看）</p><p>2.以淘宝为例，淘宝的包名是：com.taobao.taobao</p><h5 id="四、其它的几个指令"><a href="#四、其它的几个指令" class="headerlink" title="四、其它的几个指令"></a>四、其它的几个指令</h5><p>1.杀掉adb进程</p><pre><code>  adb kill-server</code></pre><p>2.重启adb服务</p><pre><code>  adb start-server</code></pre><p>3.重启手机 </p><pre><code>adb reboot</code></pre><p>4.进shell模式</p><pre><code> adb shell</code></pre><p>5.挂载</p><pre><code> adb remount</code></pre><p>6.从电脑发文件到手机</p><pre><code>adb push &lt;本地路径&gt; &lt;远程路径&gt;</code></pre><p>7.从手机下载文件到本地</p><pre><code>adb pull &lt;远程路径&gt; &lt;本地路径&gt;</code></pre><p>8.输出日志</p><p>第一种：输出到手机存储卡</p><pre><code>adb logcat &gt; /sdcard/mylogcat.txt</code></pre><p>第二种：输出到电脑上</p><pre><code>adb logcat &gt; D:/Temp/1.txt（1.txt必须在电脑上存在，才能写入logcat内容）</code></pre><p> 好了各位小伙伴们，今天就分享到这里了，有问题加群和大佬讨论！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试15</title>
      <link href="/2016/04/10/appium/"/>
      <url>/2016/04/10/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十五）- Android 这些基础知识，你知多少？？？（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　前边具体操作和实战已经讲解和分享了很多了，但是一些android的一些基础知识，你又知道多少了，你都掌握了吗？这篇就由宏哥给小伙伴们既是一个分享，又是对前边的一次总结。为什么要对这些做一个简单的分享了，因为在现实具体工作中经常会遇到这样的问题，这里还是通过一个小故事来说明一下。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/PjmX1EDpRu94qAy.jpg" alt="3270074-4ead9a16e552438c.jpg"></p><p>QA：“那个谁谁谁，我刚刚按照上一次那样操作这款款APP，我死活是跑不起测试脚本了。（内心独白：我去，这个奇怪的问题，一定是他给我的安装包有问题”）</p><p>DEV：“嗯？还有这样的问题，那你看一下你手机和电脑连接好了么？。（内心独白：一定是数据线没有连接好）”</p><p>QA：这个、这个…“咦，这个怎么看？（内心独白：我去，我怎么知道怎么看了，你不告诉我，我问手机和电脑，他们也不回答我啊）”</p><p>DEV：“嗖的一声，打开命令窗口，用这个命令：adb devices。（内心独白：鄙视一番，什么都不懂，这个简单）”</p><p>一会过去了……</p><p>QA：满心欢喜状，那个谁谁谁“我看了连接好了！（内心独白：一脸淫笑，我连接的怎么可能有问题了）”</p><p>DEV：“是不是package或者Activity有问题，你再看看（内心独白：小样，自己啥都不看就来问我）”</p><p>QA：“宝宝心里苦，但是宝宝不说！（内心独白：这个。唉。。。。。。。，我还是不会，硬着头皮再问开发）”</p><p>当你了解掌握android基础知识之后：</p><p>QA：“那个谁谁谁，我刚刚按照上一次那样操作这款款APP，我死活是跑不起测试脚本了。我也查看设备连接情况，以及安装包的package和Activity等等一些东西，和我代码里配置的Appium Desired Capabilities参数都正确，你看看是什么问题吧”</p><p>DEV：“厉害了Word哥！这个这个我查一下，是不是安装包打的包有问题，你稍等一下。（内心独白：真特么牛逼，都排查完了，还帮我定位了问题）”</p><p>全剧终！</p><p>　　以上虽说是个小故事，但是对于刚入职场的，确实是屡见不鲜，很多很多，如果你很幸运遇到个善良的开发，那还不错。反之，呵呵，那你就自求多福吧！！！</p><h4 id="2-ADB工具讲解"><a href="#2-ADB工具讲解" class="headerlink" title="2.ADB工具讲解"></a>2.ADB工具讲解</h4><h5 id="2-1-什么是ADB呢？"><a href="#2-1-什么是ADB呢？" class="headerlink" title="2.1 什么是ADB呢？"></a>2.1 什么是ADB呢？</h5><p>　　我们不去解释官方语言的翻译，给大家说一个通熟易懂的说法，ADB我理解为他就是电脑和手机连接的桥梁。此连接不是充电的连接，大家不要混淆，说他是一个调试工具，可能更贴切。</p><h5 id="2-2-ADB有什么作用呢？"><a href="#2-2-ADB有什么作用呢？" class="headerlink" title="2.2 ADB有什么作用呢？"></a>2.2 ADB有什么作用呢？</h5><p>　　刚说的他是电脑和手机连接的桥梁，我们可以通过ADB操作手机，可以管理手机。可能你说这里手机包括模拟器嘛？答案是肯定的。</p><h5 id="2-3-如何使用ADB？"><a href="#2-3-如何使用ADB？" class="headerlink" title="2.3 如何使用ADB？"></a>2.3 如何使用ADB？</h5><p>　　我们在终端直接输入adb的命令就可以执行相应的操作。在测试过程中我们最常用的就是查看已经连接的android设备有哪些。大概整理了一下常用的：</p><p>1、adb devices 查看已经连接的android设备</p><p>2、adb install Baidu.apk 这个是安装应用，如果我们当前电脑连接了多台android机器时，使用这个命令是不行的，这个时候我们需要指定设备：adb -s install baidu.apk,这里的-s是指设备的信息，就是通过adb devices 查看的设备信息。</p><p>3、adb uninstall Baidu.apk 这个是卸载应用</p><p>4、adb connect 127.0.0.1:62001这个命令大家一定要记住，连接指定设备信息，这里的设备是指虚拟机，如果说我们使用的虚拟机不是官方的，是国产的天天、夜游神等等虚拟机你需要使用connect 命令连接，这里的端口号不一定是6555，这个需要根据你的模拟器的品牌来决定。刚学如果搞不定还是建议用真机，只需要打开adb调试就好。</p><h4 id="3-UIAutomatorviewer工具讲解"><a href="#3-UIAutomatorviewer工具讲解" class="headerlink" title="3.UIAutomatorviewer工具讲解"></a>3.UIAutomatorviewer工具讲解</h4><p>　　UIAutomatorviewer是一个定位工具，无论是在windows下还是mac下都可以用时，他在你androidsdk目录下的tools目录下，我只是按照我的给大家讲的，下面给大家配置一张图片，更加直观：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/dreNy9YpoZAUFKD.png" alt="1232840-20190708152047234-435851858.png"></p><p>　　可以看一下在我的目录，在最后的tools目录下有一个uiautomatorviewer文件，我们之需要在当前目录直接敲击该目录命令就会打开我们的定位工具界面,下面我们直接看我们的效果图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/1yOdg2rasZ7DnGQ.png" alt="1232840-20190708152551480-1978505015.png"> </p><p>　　这个前边介绍过了，宏哥在这里就不啰嗦了，但是在这里需要记住一个问题，因为我用的是国产的模拟器，所以在启动模拟器后需要adb connect 127.0.0.1:xxxx,但是在这个之前你还是需要将模拟器里面的开发者选项打开的，因为只有建立连接后才能够使用定位工具，不然会报错。</p><p>　　我们打开定位工具、模拟器后直接点击定位工具左上角红色圈出的按钮（获取当前屏幕）uiautomatorviewer会自动获取到当前模拟器所打开的页面。</p><p>　　最左边的区域就是捕获的模拟器页面，在该页面鼠标移到你要查找的元素上面，在整个区域右面上面就是当前对象的一个布局结构，能够清晰的看见他是采用的是什么布局。右下角的区域就是我们需要定位的对象的属性值。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/ybWYqNEgFO3zoBm.png" alt="1232840-20190708152725364-1007426543.png"></p><p>　　右下角的属性我做了一个区分，左边红色部分为属性名称，右边的则是属性值，当我在上边选择一个控件或者对象的时候下面的属性就会随着变化，在上图中的属性主要是：index、text、resource-id、class、package、content-desc，这些属性和属性值他们对应起来就是我们后面要讲的页面元素定位，我们做自动化最主要是和这几个属性去交互。这里需要注意一个问题：这个页面属性的text属性定位方式是针对name定位，但是在新版本appium中已经去掉了name定位，所以大家注意一下这个问题，到时候如果报错也不要着急。</p><h4 id="4-Package及Activity讲解"><a href="#4-Package及Activity讲解" class="headerlink" title="4.Package及Activity讲解"></a>4.Package及Activity讲解</h4><p>　　在整理这个知识的时候其实很纠结是否要讲这个知识点，但是权衡了一下决定还是讲解一下，不然后面的章节讲自动化时可能对于一些无基础的读者会有一些莫名其妙。</p><p>　　什么是Package呢？中文翻译过来大家都知道是包的意思，其实没错，你如果非得这么理解也没错，只是在我们的app中这个Package是唯一的，就像你身份证号码一样。在我们做app自动化时，我们就需要知道他的Package，我们知道了Package那么也就知道我们需要对哪个app做自动化，现在能理解Package是什么意思了么？</p><p>　　什么是Activity呢？官方给出的解释Activity是Android组建中最基本也是最为常见用的四大组件之一。看了这个是不是觉得很懵？so，他还有一种不确切的说法，就是和用户进行交互的，每当用户打开app进行操作的时候会发现在不断的跳页面，其实每个页面就是一个activity。我们做自动化时拿到了这个app的Package，但是我们还不能启动起来，因为我们没有告诉需要去操作哪一个Activity，因此在这个时候我们需要讲app启动时的Activity写入到启动参数中，如果你传入一个其他页面的是不行的。</p><h4 id="5-package及activity的获取"><a href="#5-package及activity的获取" class="headerlink" title="5.package及activity的获取"></a>5.package及activity的获取</h4><p>　　前面讲了那么多，但是还不知道怎么获取，对吧。哈哈，只知道作用但是不知道来源这个就没处使尽。</p><p>先说一下获取package和activity的方法，在网上说了有很多种，这里我只给大家说我们常用的。</p><p>1、因为自动化一般都是自己的应用，所以这个肯定是自己公司的，那么你拿这个还不简单？直接找开发要就行。</p><p>2、appium 有界面的客户端，这档你在设置里面选择了apk的路径之后系统会自动将该apk的相关信息展示在下面，所以很简单，不过悲催的是他不能够复制，你写在程序你的时候还是需要你一个一个字母敲击</p><p>3、通过android sdk工具来，在sdk里面有一个工具，叫做aapt，我们可以直接通过这个工具来，在命令行输入：aapt dump badging xxxx.apk,后面这个xxx.apk文件是我们aok所在的绝对路径，敲入之后那么可以显示出来相关信息，可以在里面仔细找了，packageName、lanuchActivity这两个字端，一个在开始1、2行一个在中间部分。如果找不到，在往后边找一找。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p> 　　好了，宏哥觉得介绍这些应该足够你用了，这样你和开发沟通起来也不是那么费劲，那么吃力，更不会看到开发鄙视的眼神，有兴趣的想了解更多的小伙伴们可以看这里（<a href="https://www.runoob.com/w3cnote/android-tutorial-intro.html" target="_blank" rel="noopener">传送门</a>）。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试14</title>
      <link href="/2016/04/09/appium/"/>
      <url>/2016/04/09/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十四）- 与Capability完美懈垢之解读（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　Capability又叫Appium Desired Capabilities，前边写了那么多实例代码，小伙伴可以发现一些规律，就是有一部分代码总是重复的出现在你的视线中。这部分就是对Capability的配置。那么今天给小伙伴们分享、介绍和讲解一下Capability。让你知道她的来龙去脉，知道为什么代码里那么写。</p><h4 id="2-什么是Capability"><a href="#2-什么是Capability" class="headerlink" title="2.什么是Capability"></a>2.什么是Capability</h4><p>　　在讲capability之前大家是否还记得在讲log时给大家看过的启动时的日志？在我们的整个启动日志中会出现一些配置信息，其实那些信息就是capability携带的配置信息，如果我们通过代码来启动我们能够看见的配置信息如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/10/PCLapms45UAMIgO.png" alt="1232840-20190705143514452-1793124471.png"></p><p>　　通过上面的配置信息大家可以看出，在python里面我们所讲的capability其实就是一个字典（我们这里暂且这么说，因为每个语言叫法不一样）。</p><h4 id="3-Capability的作用"><a href="#3-Capability的作用" class="headerlink" title="3.Capability的作用"></a>3.Capability的作用</h4><p>　　我们知道Capability是一个字典之后我们是否需要知道他的作用呢？我们在appium中配置app后我们能够通过log看出里面的信息都是启动的一些必要配置，通过上面的配置信息我么也能够看出capability配置的就是我们做自动化的一些必要信息。他主要是告诉server我们本次测试是浏览器还是app，是ios还是android以及android的版本信息等。如果capability不告诉server，那么server就不认识你，也就无法完成我们的自动化测试。</p><h4 id="4-常用Capability配置讲解"><a href="#4-常用Capability配置讲解" class="headerlink" title="4.常用Capability配置讲解"></a>4.常用Capability配置讲解</h4><h5 id="4-1公用Capability"><a href="#4-1公用Capability" class="headerlink" title="4.1公用Capability"></a>4.1公用Capability</h5><p>　　如果有了解过Capability的人会发现一个问题，其实他主要分成了三部分：公共部分、ios部分、android部分，如果你android想用ios的那是不可能的，so，老老实实去了解每个平台有哪些，他们的作用是什么。下面我们介绍一些公用常用的</p><table><thead><tr><th align="center">能力</th><th align="left">描述</th><th align="left">值</th></tr></thead><tbody><tr><td align="center"><strong>automationName</strong></td><td align="left">使用哪个自动化引擎</td><td align="left">Appium（默认）或Selendroid或者UiAutomator2或者Espresso对于Android或XCUITestiOS或者YouiEngine使用You.i引擎构建的应用程序</td></tr><tr><td align="center"><strong>platformName</strong></td><td align="left">使用哪个移动操作系统平台</td><td align="left">iOS，Android或FirefoxOS</td></tr><tr><td align="center"><strong>platformVersion</strong></td><td align="left">移动操作系统版本</td><td align="left">例如7.1，4.4</td></tr><tr><td align="center"><strong>deviceName</strong></td><td align="left">使用的移动设备或模拟器的种类</td><td align="left">iPhone Simulator，iPad Simulator，iPhone Retina 4-inch，Android Emulator，Galaxy S4，等….在iOS上，这应该是与仪器返回的有效设备之一instruments -s devices。在Android上，这个功能目前被忽略，尽管它仍然是必需的。</td></tr><tr><td align="center"><strong>app</strong></td><td align="left">一个或一个文件的绝对本地路径<em>或</em>远程http URL ，或者包含其中的一个。Appium将首先尝试在适当的设备上安装这个应用程序二进制文件。请注意，如果您指定和功能（请参阅下文），则此功能对于Android不是必需的。与…不兼容。.ipa.apk.zipappPackageappActivitybrowserName</td><td align="left">/abs/path/to/my.apk 要么<a href="http://myapp.com/app.ipa" target="_blank" rel="noopener">http://myapp.com/app.ipa</a></td></tr><tr><td align="center"><strong>browserName</strong></td><td align="left">移动网页浏览器的名称自动化。应该是一个空字符串，而不是自动化应用程序。</td><td align="left">适用于iOS的“Safari”，适用于Android的“Chrome”，“Chromium”或“浏览器”</td></tr><tr><td align="center"><strong>newCommandTimeout</strong></td><td align="left">在假定客户端退出并结束会话之前，Appium将等待来自客户端的新命令（以秒为单位）</td><td align="left">例如 60</td></tr><tr><td align="center"><strong>language</strong></td><td align="left">（Sim / Emu-only）为模拟器/仿真器设置的语言</td><td align="left">例如 fr</td></tr><tr><td align="center"><strong>locale</strong></td><td align="left">（Sim / Emu-only）为模拟器/仿真器设置的语言环境</td><td align="left">例如 fr_CA</td></tr><tr><td align="center"><strong>udid</strong></td><td align="left">连接的物理设备的唯一设备标识符</td><td align="left">例如 1ae203187fc012g</td></tr><tr><td align="center"><strong>orientation</strong></td><td align="left">（Sim / Emu-only）从某个方向开始</td><td align="left">LANDSCAPE 要么 PORTRAIT</td></tr><tr><td align="center"><strong>autoWebview</strong></td><td align="left">直接进入Webview上下文。默认false</td><td align="left">true， false</td></tr><tr><td align="center"><strong>noReset</strong></td><td align="left">在此会话之前不要重置应用程序状态。<a href="https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/other/reset-strategies.md" target="_blank" rel="noopener">在这里</a>看到更多的细节</td><td align="left">true， false</td></tr><tr><td align="center"><strong>fullReset</strong></td><td align="left">执行完整的重置。<a href="https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/other/reset-strategies.md" target="_blank" rel="noopener">在这里</a>看到更多的细节</td><td align="left">true， false</td></tr><tr><td align="center"><strong>eventTimings</strong></td><td align="left">启用或禁用各种Appium内部事件的时间报告（例如，每个命令的开始和结束等）。默认为false。启用，使用true。然后将这些时间作为events回应查询当前会话的财产报告。请参阅<a href="https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/event-timings.md" target="_blank" rel="noopener">事件时间文档</a>了解此响应的结构。</td><td align="left">例如， true</td></tr><tr><td align="center"><strong>enablePerformanceLogging</strong></td><td align="left">（仅限Web和webview）启用Chromedriver（在Android上）或Safari（在iOS上）性能记录（默认false）</td><td align="left">true， false</td></tr></tbody></table><p>&lt;最常用的：</p><table><thead><tr><th align="center">能力</th><th>描述</th><th>值</th></tr></thead><tbody><tr><td align="center"><strong>automationName</strong></td><td>使用哪个自动化引擎</td><td>Appium（默认）或Selendroid或者UiAutomator2或者Espresso对于Android或XCUITestiOS或者YouiEngine使用You.i引擎构建的应用程序</td></tr><tr><td align="center"><strong>platformName</strong></td><td>使用哪个移动操作系统平台(你要测试手机的操作系统)</td><td>iOS，Android或FirefoxOS</td></tr><tr><td align="center"><strong>platformVersion</strong></td><td>移动操作系统版本（手机操作系统版本）</td><td>android或者ios版本，例如7.1，4.4</td></tr><tr><td align="center"><strong>deviceName</strong></td><td>使用的移动设备或模拟器的种类</td><td>iPhone Simulator，iPad Simulator，iPhone Retina 4-inch，Android Emulator，Galaxy S4，等….在iOS上，这应该是与仪器返回的有效设备之一instruments -s devices。在Android上，这个功能目前被忽略，尽管它仍然是必需的。</td></tr><tr><td align="center"><strong>app</strong></td><td>apk或者ipa文件所在的路径</td><td>xxx/xxx.apk</td></tr><tr><td align="center"><strong>browserName</strong></td><td>浏览器名称</td><td>Chrome</td></tr><tr><td align="center"><strong>newCommandTimeout</strong></td><td>超时时间</td><td>60</td></tr><tr><td align="center"><strong>language</strong></td><td>手机或者模拟器语言</td><td></td></tr><tr><td align="center"><strong>udid</strong></td><td>连接设备的uid</td><td>1essd2fd3</td></tr><tr><td align="center"><strong>noReset</strong></td><td>不要在会话前重置应用状态，默认false</td><td>true/false</td></tr></tbody></table><p>在自动化测试过程中这些公用的Capability用的时间比较多，大家需要记住，去熟悉他的用法。</p><h5 id="4-2-Android独有Capability"><a href="#4-2-Android独有Capability" class="headerlink" title="4.2 Android独有Capability"></a>4.2 Android独有Capability</h5><p>　　在自动化测试过程中如果你只知道常用的一些参数配置，这个是远远达不到要求，因为你不知道什么时候有什么样的突发情况发生，所以你需要了解appium所有最常用的配置参数，当然你可以掌握所有，那样更好，熟能生巧。下面我们看一下android的Capability。</p><p>这些功能仅适用于基于Android的驱动程序（例如 <a href="https://github.com/appium/appium/blob/master/docs/en/drivers/android-uiautomator2.md" target="_blank" rel="noopener">UiAutomator2</a>）。</p><table><thead><tr><th align="center">能力</th><th>描述</th><th>值</th></tr></thead><tbody><tr><td align="center"><strong>appActivity</strong></td><td>要从包中启动的Android活动的活动名称。这往往需要在一个.（例如，.MainActivity而不是MainActivity）</td><td>MainActivity， .Settings</td></tr><tr><td align="center"><strong>appPackage</strong></td><td>你想运行的Android应用程序的Java包</td><td>com.example.android.myApp， com.android.settings</td></tr><tr><td align="center"><strong>appWaitActivity</strong></td><td>活动名称/名称，逗号分隔，您想要等待的Android活动</td><td>SplashActivity，SplashActivity,OtherActivity， *， *.SplashActivity</td></tr><tr><td align="center"><strong>appWaitPackage</strong></td><td>您想等待的Android应用程序的Java包</td><td>com.example.android.myApp， com.android.settings</td></tr><tr><td align="center"><strong>appWaitDuration</strong></td><td>用于等待appWaitActivity启动的超时（以毫秒为单位20000）（默认）</td><td>30000</td></tr><tr><td align="center"><strong>deviceReadyTimeout</strong></td><td>在等待设备准备就绪的几秒钟内超时</td><td>5</td></tr><tr><td align="center"><strong>androidCoverage</strong></td><td>完全合格的仪器类。通过-w在adb shell中，仪器-e覆盖率为true -w</td><td>com.my.Pkg / com.my.Pkg.instrumentation.MyInstrumentation</td></tr><tr><td align="center"><strong>androidCoverageEndIntent</strong></td><td>由您自己执行的广播操作，用于将覆盖转储到文件系统。传递到-a在adb外壳广播-a</td><td>com.example.pkg.END_EMMA</td></tr><tr><td align="center"><strong>androidDeviceReadyTimeout</strong></td><td>用于等待设备在启动后准备就绪的秒数</td><td>例如， 30</td></tr><tr><td align="center"><strong>androidInstallTimeout</strong></td><td>用于等待apk安装到设备的超时（以毫秒为单位）。默认为90000</td><td>例如， 90000</td></tr><tr><td align="center"><strong>androidInstallPath</strong></td><td>安装前将在其中安装apk的设备上的目录名称。默认为/data/local/tmp</td><td>例如/sdcard/Downloads/</td></tr><tr><td align="center"><strong>adbPort</strong></td><td>用于连接到ADB服务器的端口（默认5037）</td><td>5037</td></tr><tr><td align="center"><strong>remoteAdbHost</strong></td><td>可选的远程ADB服务器主机</td><td>例如：192.168.0.101</td></tr><tr><td align="center"><strong>androidDeviceSocket</strong></td><td>Devtools套接字名称。只有当测试的应用程序是Chromium嵌入式浏览器时才需要。套接字由浏览器打开，并且Chromedriver作为devtools客户端连接到它。</td><td>例如， chrome_devtools_remote</td></tr><tr><td align="center"><strong>avd</strong></td><td>avd的名称发射</td><td>例如， api19</td></tr><tr><td align="center"><strong>avdLaunchTimeout</strong></td><td>avd启动并连接到ADB需要多长时间（默认值120000）</td><td>300000</td></tr><tr><td align="center"><strong>avdReadyTimeout</strong></td><td>avd完成启动动画需要多长时间（默认120000）</td><td>300000</td></tr><tr><td align="center"><strong>avdArgs</strong></td><td>启动avd时使用的其他仿真器参数</td><td>例如， -netfast</td></tr><tr><td align="center"><strong>useKeystore</strong></td><td>使用自定义密钥库来签署apks，默认 false</td><td>例如， -netfast</td></tr><tr><td align="center"><strong>keystorePath</strong></td><td>自定义密钥库路径，默认〜/ .android / debug.keystore</td><td>例如，/path/to.keystore</td></tr><tr><td align="center"><strong>keystorePassword</strong></td><td>自定义密钥库的密码</td><td>例如， foo</td></tr><tr><td align="center"><strong>keyAlias</strong></td><td>密钥的别名</td><td>例如， androiddebugkey</td></tr><tr><td align="center"><strong>keyPassword</strong></td><td>密钥的密钥</td><td>例如， foo</td></tr><tr><td align="center"><strong>chromedriverExecutable</strong></td><td>webdriver可执行文件的绝对本地路径（如果Chromium embedder提供了自己的webdriver，则应该使用它来代替与Appium捆绑在一起的原始chromedriver）</td><td>/abs/path/to/webdriver</td></tr><tr><td align="center"><strong>autoWebviewTimeout</strong></td><td>等待Webview上下文激活的时间（以毫秒为单位）。默认为2000</td><td>例如 4</td></tr><tr><td align="center"><strong>intentAction</strong></td><td>意图操作将用于启动活动（默认android.intent.action.MAIN）</td><td>例如 android.intent.action.MAIN， android.intent.action.VIEW</td></tr><tr><td align="center"><strong>intentCategory</strong></td><td>意图类别，将用于启动活动（默认android.intent.category.LAUNCHER）</td><td>例如android.intent.category.LAUNCHER，android.intent.category.APP_CONTACTS</td></tr><tr><td align="center"><strong>intentFlags</strong></td><td>将用于启动活动的标志（默认0x10200000）</td><td>例如 0x10200000</td></tr><tr><td align="center"><strong>optionalIntentArguments</strong></td><td>将用于启动活动的其他意图参数。请参阅 <a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">意向参数</a></td><td>例如–esn <extra_key>，–ez <extra_key> <extra_boolean_value>等等。</extra_boolean_value></extra_key></extra_key></td></tr><tr><td align="center"><strong>dontStopAppOnReset</strong></td><td>在使用adb启动应用程序之前，不要停止被测试的应用程序的进程。如果被测试的应用程序是由另一个定位应用程序创建的，那么将其设置为false将允许在使用adb的测试应用程序启动过程中定位应用程序的过程仍然存在。换句话说，在dontStopAppOnReset设置的时候true，我们不会-S在adb shell am start通话中包含标志。有了这个能力被省略或设置为false，我们包括-S标志。默认false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>unicodeKeyboard</strong></td><td>启用Unicode输入，默认 false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>resetKeyboard</strong></td><td>使用unicodeKeyboard功能运行Unicode测试后，将键盘重置为原始状态。如果单独使用，则忽略。默认false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>noSig</strong></td><td>使用调试键跳过检查和签名应用程序，只能使用UiAutomator，而不能使用selendroid，默认false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>ignoreUnimportantViews</strong></td><td>调用setCompressedLayoutHierarchy()uiautomator函数。此功能可以加快测试执行速度，因为辅助功能命令将更快地忽略某些元素。被忽略的元素是不可能找到的，这就是为什么这个功能也被实现为可切换的<em>设置</em>以及功能。默认为false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>disableAndroidWatchers</strong></td><td>禁用观察应用程序没有响应和应用程序崩溃的android观察者，这将减少Android设备/模拟器上的CPU使用率。这个功能只能用于UiAutomator，而不能用于selendroid，默认false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>chromeOptions</strong></td><td>允许ChromeDriver传递chromeOptions功能。有关更多信息，请参阅<a href="https://sites.google.com/a/chromium.org/chromedriver/capabilities" target="_blank" rel="noopener">chromeOptions</a></td><td>chromeOptions: {args: [‘–disable-popup-blocking’]}</td></tr><tr><td align="center"><strong>recreateChromeDriverSessions</strong></td><td>在移至非ChromeDriver网页浏览的情况下杀死ChromeDriver会话。默认为false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>nativeWebScreenshot</strong></td><td>在Web上下文中，使用本地（adb）方法截取屏幕截图，而不是代理ChromeDriver。默认为false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>androidScreenshotPath</strong></td><td>将要放置屏幕截图的设备上的目录名称。默认为/data/local/tmp</td><td>例如/sdcard/screenshots/</td></tr><tr><td align="center"><strong>autoGrantPermissions</strong></td><td>让Appium自动确定您的应用程序需要哪些权限，并在安装时将其授予应用程序。默认为false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>networkSpeed</strong></td><td>设置网络速度模拟。指定最大的网络上传和下载速度。默认为full</td><td>[‘full’,’gsm’, ‘edge’, ‘hscsd’, ‘gprs’, ‘umts’, ‘hsdpa’, ‘lte’, ‘evdo’] 检查 <a href="https://developer.android.com/studio/run/emulator-commandline.html" target="_blank" rel="noopener">-netspeed选项</a> 有关avds速度仿真的更多信息</td></tr><tr><td align="center"><strong>gpsEnabled</strong></td><td>在开始会话之前，切换模拟器的gps位置提供程序。默认情况下，仿真器将根据设置的方式启用或不启用此选项。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>isHeadless</strong></td><td>true当不需要显示设备显示时，将此功能设置为无运行模拟器。false是默认值。<em>isHeadless</em>也支持iOS，请检查XCUITest的具体功能。</td><td>例如， true</td></tr></tbody></table><h5 id="4-3-ios独有Capability"><a href="#4-3-ios独有Capability" class="headerlink" title="4.3 ios独有Capability"></a>4.3 ios独有Capability</h5><p>　　在我选择appium时，最主要是因为他能够同时支持ios和android，在基础参数配置中ios也有他自己的独一份，不和android一样，下面我们大概介绍一下：</p><p>　　BoundleId：这个是必须的，如果不配置就无法启动ios app，这个是该app的唯一标示。eg：caps.setCapability(“boundleId”,”ios.mooc.test”),这个只是一个简单的例子。</p><p>　　autoAcceptAlerts: 这个在我们实际项目中非常实用，他就想web端的一个js弹窗，默认情况下是false，如果你的app中有类似情况建议打开。eg：caps.setCapability(“autoAcceptAlerts”,”true”)</p><p>　　这些功能仅适用于<a href="https://github.com/appium/appium/blob/master/docs/en/drivers/ios-xcuitest.md" target="_blank" rel="noopener">XCUITest驱动程序</a>和过时的<a href="https://github.com/appium/appium/blob/master/docs/en/drivers/ios-uiautomation.md" target="_blank" rel="noopener">UIAutomation驱动程序</a>。</p><table><thead><tr><th align="center">能力</th><th>描述</th><th>值</th></tr></thead><tbody><tr><td align="center"><strong>calendarFormat</strong></td><td>（仅限SIM）为iOS模拟器设置的日历格式</td><td>例如 gregorian</td></tr><tr><td align="center"><strong>bundleId</strong></td><td>测试中的应用程序的捆绑ID。用于在真实设备上启动应用程序或在测试启动期间使用其他需要包ID的大写字母。要使用软件包ID在真实设备上运行测试，可以省略“应用”功能，但必须提供“udid”。</td><td>例如 io.appium.TestApp</td></tr><tr><td align="center"><strong>udid</strong></td><td>连接的物理设备的唯一设备标识符</td><td>例如 1ae203187fc012g</td></tr><tr><td align="center"><strong>launchTimeout</strong></td><td>假设它挂起和失败会话之前以毫秒为单位等待仪器的时间</td><td>例如 20000</td></tr><tr><td align="center"><strong>locationServicesEnabled</strong></td><td>（仅限SIM）强制定位服务处于打开或关闭状态。默认是保持当前的模拟设置。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>locationServicesAuthorized</strong></td><td>（仅限SIM）通过plist将位置服务设置为授权或未授权，以便位置服务警报不会弹出。默认是保持当前的模拟设置。请注意，如果您使用此设置，您还必须使用该bundleId功能发送您的应用的捆绑ID。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>autoAcceptAlerts</strong></td><td>如果弹出，则自动接受所有iOS警报。这包括隐私访问权限提醒（例如，位置，联系人，照片）。默认是false。不适用于XCUITest基于测试。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>autoDismissAlerts</strong></td><td>如果弹出，则自动关闭所有iOS警报。这包括隐私访问权限提醒（例如，位置，联系人，照片）。默认是false。不适用于XCUITest基于测试。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>nativeInstrumentsLib</strong></td><td>使用本机intruments lib（即禁用仪器，无延迟）。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>nativeWebTap</strong></td><td>（仅限SIM）在Safari中启用“真实”，非基于JavaScript的网页浏览。默认：false。警告：根据视口的大小/比例，这可能无法准确地点击一个元素</td><td>true 要么 false</td></tr><tr><td align="center"><strong>safariInitialUrl</strong></td><td>（仅限SIM）（&gt; = 8.1）初始Safari浏览器网址，默认为本地欢迎页面</td><td>例如 <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></td></tr><tr><td align="center"><strong>safariAllowPopups</strong></td><td>（仅限Sim）允许JavaScript在Safari中打开新窗口。默认保持当前的模拟设置</td><td>true 要么 false</td></tr><tr><td align="center"><strong>safariIgnoreFraudWarning</strong></td><td>（仅限SIM）防止Safari显示欺诈网站警告。默认保持当前的模拟设置。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>safariOpenLinksInBackground</strong></td><td>（仅限SIM）Safari是否应允许在新窗口中打开链接。默认保持当前的模拟设置。</td><td>true 要么 false</td></tr><tr><td align="center"><strong>keepKeyChains</strong></td><td>（Sim-only）当appium会话开始/结束时是否保留钥匙串（Library / Keychains）</td><td>true 要么 false</td></tr><tr><td align="center"><strong>localizableStringsDir</strong></td><td>在哪里寻找可本地化的字符串。默认en.lproj</td><td>en.lproj</td></tr><tr><td align="center"><strong>processArguments</strong></td><td>使用工具传递给AUT的参数</td><td>例如， -myflag</td></tr><tr><td align="center"><strong>interKeyDelay</strong></td><td>输入时发送到元素的击键之间的延迟，以毫秒为单位。</td><td>例如， 100</td></tr><tr><td align="center"><strong>showIOSLog</strong></td><td>是否显示从appium日志中的设备捕获的任何日志。默认false</td><td>true 要么 false</td></tr><tr><td align="center"><strong>sendKeyStrategy</strong></td><td>用于将测试类型输入测试领域的策略。模拟器默认：oneByOne。实际设备默认值：grouped</td><td>oneByOne，grouped或者setValue</td></tr><tr><td align="center"><strong>screenshotWaitTimeout</strong></td><td>以秒为单位的最大超时等待生成屏幕截图。默认：10</td><td>例如， 5</td></tr><tr><td align="center"><strong>waitForAppScript</strong></td><td>ios自动化脚本用于确定应用程序是否已启动，默认情况下系统等待页面源不为空。结果必须是布尔值</td><td>例如true;，target.elements().length &gt; 0;，$.delay(5000); true;</td></tr><tr><td align="center"><strong>webviewConnectRetries</strong></td><td>向远程调试器发送连接消息以获取webview的次数。默认：8</td><td>例如， 12</td></tr><tr><td align="center"><strong>appName</strong></td><td>被测应用程序的显示名称。用于在iOS 9+中自动化后台应用程序。</td><td>例如， UICatalog</td></tr><tr><td align="center"><strong>customSSLCert</strong></td><td>（仅限Sim / Emu）向模拟器添加SSL证书。</td><td>例如 <br>—–BEGIN CERTIFICATE—–MIIFWjCCBEKg…<br>—–END CERTIFICATE—–</td></tr><tr><td align="center"><strong>webkitResponseTimeout</strong></td><td>（仅限实际设备）设置时间（以毫秒为单位）以等待Safari会话中WebKit的响应。默认为5000</td><td>例如， 10000</td></tr></tbody></table><h4 id="5-Capability实战"><a href="#5-Capability实战" class="headerlink" title="5.Capability实战"></a>5.Capability实战</h4><p>　　当我们知道基础的Capability 如何使用时，大家是否觉得现在我们已经就可以原原本本的照着去执行了呢？其实没错，是可以照样去执行。但是你有思考过一个问题吗？如果你的app变化了？你的package变化了？你的手机变化了？你的版本变化了等等你怎么去实现？你是不是还需要到程序里面来更改代码？low吗？要想不low我们接着往下看。</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-05 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-与Capability完美懈垢之解读 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 import time13 import os14 15 def testCase(platformName,platformVersion,deviceName,app,appPackage,appActivity,port):16    PATH = lambda p: os.path.abspath(os.path.join(os.path.dirname(__file__), p))17    desired_caps = {}18    desired_caps[&#39;platformName&#39;] = platformName #设置平台19    desired_caps[&#39;platformVersion&#39;] = platformVersion #系统版本20    desired_caps[&#39;deviceName&#39;] = deviceName #设备id21    desired_caps[&#39;autoLaunch&#39;] = &#39;true&#39; #是否自动启动22    desired_caps[&#39;app&#39;] = PATH(app)#安装包路径，放在该py文件的目录下)23    desired_caps[&#39;appPackage&#39;] = appPackage #包名24    desired_caps[&#39;appActivity&#39;] = appActivity #启动的activity25    self.driver = webdriver.Remote(&#39;http://localhost:%s/wd/hub&#39;, desired_caps) % port</code></pre><p>　　从上面的代码我们可以和之前的代码进行比较，大家是否发现了一些不同之处。在做自动化时我们一定要保持数据的灵活性，所以在这里我们做了一些小小的改变，我们将所有的数据都改变成了变量，变量从何而来这个我们后面可能会讲，这个会去读取配置文件。现在从代码层面来看是否要比之前的代码更有可读性呢？其实现实中并不是这样，有更高级的版本，这个后面有时间再讲。</p><p>　　在代码的第11行大家注意一个问题没有，在一个字符串中间我使用了一个%s，这个在python里面代表的意思是取一个变量，这个变量是我后面跟着的 port 这个变量的值，这里唯一的有问题就是这里。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、想要更详细了解的小伙们，可以看一下官方文档：</p><p>官方文档：<a href="https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md" target="_blank" rel="noopener">https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md</a></p><p>　　好了，今天就给小伙伴们分享到这里了，有问题加群讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试13</title>
      <link href="/2016/04/08/appium/"/>
      <url>/2016/04/08/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十三）- 输入中文 - 一次填坑记（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　无论你在哪里，在做什么都会遇到很多坑，这些坑有些事别人挖的，有些是自己挖的。别人挖的叫坑人，自己挖的叫自杀，儿子挖的叫坑爹。因此在做app自动化道路上也不会是一帆风顺的，你会踩很多坑，这些坑和你就是你死我活的节奏，不是坑把你埋了，就是你把坑填了。由于咱们都是黄皮肤的中国人用的大部分都是中文的app，而人家老外都是白皮肤蓝眼睛，用的是英文的APP，人家这个问题可以忽略。我们却不可以的，必须面对的。所以首先宏哥要带小伙伴们解决中文输入的问题！ </p><blockquote><p>你能走多远，取决于你填坑能力有多强</p></blockquote><p>微博上看到一张图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/fFGUVn7pl3AoKkE.png" alt="1232840-20190704130954165-216909833.png"></p><blockquote><p>01</p></blockquote><p>在你的计划中，未来目标是清晰可见的，中间一片坦途，只需要稍微用点力，就可以顺利达成。</p><p>但实际上呢？</p><p>风雨，陡壁，深渊……一路艰难险阻，到处都是坑，最关键是，目之所及全是困难，连目标的影子都看不见！</p><p>可以说非常形象了！我们的生活不就是这样吗？</p><p>成长的路上，总是充满了各种“坑”，而你能走多远，取决于你“填坑”的能力有多强。</p><blockquote><p>02</p></blockquote><p>“为什么你总是下班这么晚？”</p><p>“因为要改的Bug太多了啊。”</p><p>“那为什么跟你同组的其他同事很早就下班了？就你一个人总是走不了？”</p><p>“没办法啊，太复杂的Bug他们改不了，只能我去解决，不然为什么我月薪2万，他们只有1万？”</p><p>“……好吧。”</p><p>没错，工作中就是这样。</p><p>遇到问题，能解决问题的那个人，永远是最被需要的人，而因为被需要，不可或缺，所以才能拿到高薪，获得更好的个人发展。</p><p>改不了的Bug，搞不定的客户，谈不下来的项目……我们习惯性求助于我们的上级领导，而这似乎也解释了，为什么他是上级领导？因为他能解决我们解决不了的问题。</p><p>在职场，你的核心竞争力，在于你“填坑”的能力，是否能填别人填不了的坑。</p><p>　　好了，故事就讲到这里吧。言归正传，本篇就由宏哥把前边留有悬念的中文输入问题的坑，带着小伙伴们一起把这个坑填平它，KO它。</p><p>　　宏哥思路：宏哥将会通过屏蔽软键盘，绕过手机的软键盘方法，解决中文输入的问题。</p><h4 id="2-定位搜索"><a href="#2-定位搜索" class="headerlink" title="2.定位搜索"></a>2.定位搜索</h4><p>1、打开淘宝点搜索按钮，进入到搜索页面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/8sCvoIyZHqYFme2.png" alt="1232840-20190704134148569-262358729.png"> </p><p>2、然后定位到搜索框后用sendkeys方法输入“hongge”,这里定位元素用第四篇讲的uiautomatorviewer工具就可以了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/DgmJzqyxFbjLTZe.png" alt="1232840-20190704134055301-58524613.png"></p><p>3、实例代码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/MkFU6PC5oIaHuw4.png" alt="1232840-20190704135934375-745408341.png"></p><p>4、运行后夜神模拟器、appium、代码的运行过程如下（拼音或者英文），请小伙伴们和宏哥一起仔细看是不是搜索框输入了：hongge 拼音</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://showmore.com/zh/embed/xi3lake" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><p>5、参考代码</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-04 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用appium自动化测试-输入中文 - 一次填坑记 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 import time13 desired_caps = {}14 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa15 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号16 desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看17 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名18 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity19 #desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串20 #desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来21 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息22 # 休眠五秒等待页面加载完成23 time.sleep(5)24 driver.find_element_by_id(&quot;com.taobao.taobao:id/home_searchedit&quot;).click()25 time.sleep(3)26 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).click()27 28 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).send_keys(u&quot;hongge&quot;)</code></pre><h4 id="3-运行脚本"><a href="#3-运行脚本" class="headerlink" title="3.运行脚本"></a>3.运行脚本</h4><p>1、首先要确认手机上的输入法是用的什么输入法，如果默认是中文的输入法，启动后会出现下面情况，无法输入成功</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/tWL24X8uTpzrof1.png" alt="1070438-20170429140322256-221610356.png"></p><p>2、于是可以先把手机上的输入法改成英文的状态，这样就可以输入英文字符串了。那么问题来了，如果想输入中文的字符串呢？如何解决。。。</p><h4 id="4-屏蔽软键盘"><a href="#4-屏蔽软键盘" class="headerlink" title="4.屏蔽软键盘"></a>4.屏蔽软键盘</h4><p>1、通过前面的操作，大概可以知道，在APP里面输入字符串是调用的软键盘输入的，有没办法像selenium做web自动化时候一样，直接sendkeys绕过键盘输入呢？</p><p>2、于是可以想办法屏蔽软键盘，只需在desired_caps{}设置里面加两个参数（注意了，注意力，注意力，能不能填坑就看这里啊！！！），如果直接跟随宏哥的小伙伴们直接把注释去掉了，就可以。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/NEF4LVo73cvhigD.png" alt="1232840-20190704140331133-1617890593.png"></p><p>3、unicodeKeyboard是使用unicode编码方式发送字符串</p><p>4、resetKeyboard是将键盘隐藏起来</p><h4 id="5-输入中文字符"><a href="#5-输入中文字符" class="headerlink" title="5.输入中文字符"></a>5.输入中文字符</h4><p>1、将上面代码改成输入中文u“北京-宏哥”，然后运行脚本，在手机上查看结果。（python2中文前面要加个u，python3的可以忽略）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/OJo5wtjfWSsQ6YN.png" alt="1232840-20190704144612073-676466453.png"></p><p>2、运行后夜神模拟器、appium、代码的运行过程如下：请小伙伴们和宏哥一起仔细看是不是搜索框输入了：北京-宏哥  中文汉字</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://showmore.com/zh/embed/r29l1nc" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><h4 id="6-参考代码"><a href="#6-参考代码" class="headerlink" title="6.参考代码"></a>6.参考代码</h4><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-7-04@author: 北京-宏哥   QQ交流群：707699217Project:学习和使用appium自动化测试-输入中文 - 一次填坑记&#39;&#39;&#39;# 3.导入模块from appium import webdriverimport timedesired_caps = {}desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipadesired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivitydesired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息# 休眠五秒等待页面加载完成time.sleep(5)driver.find_element_by_id(&quot;com.taobao.taobao:id/home_searchedit&quot;).click()time.sleep(3)driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).click()driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).send_keys(u&quot;北京-宏哥&quot;)</code></pre><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>1、如果在输入中文的时候，手机遇到显示中文字符为乱码时：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/9qBsmigJxUrcohO.png" alt="1070438-20170429140354350-124650414.png"></p><p>2、解决办法：前面加上“#-<em>-coding:gb18030-</em>-” 如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Gti4XujEw8Dn7Qo.png" alt="1070438-20170429140406678-1656624777.png"></p><p>3、还原设置</p><p>（1）当运行上面的脚本后，发现手动去输入时候，无法调出软键盘了，如何恢复呢？</p><p>（2）打开手机设置，找到输入法设置选项，会发现默认的输入法被改成appium的输入法了。所以只需把这里的设置，恢复成原来输入法就OK拉。</p><p>　　在实现目标的路上，遇到坑很正常，比临坑痛哭更重要的是，学会把坑填好，继续走下去。最后祝各位小伙伴们填坑顺利，人人都是填坑小能手！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试12</title>
      <link href="/2016/04/07/appium/"/>
      <url>/2016/04/07/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十二）- Android UIAutomator终极定位凶器（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　乍眼一看，小伙伴们觉得这部分其实在异性兄弟那里就做过介绍和分享了，其实不然，上次介绍和分享的大哥是uiautomatorviewer，是一款定位工具。今天介绍的是一个java库，提供执行自动化测试的各种API。</p><p>　　Android团队在4.1版本（API 16）中推出了一款全新的UI自动化测试工具UiAutomator，用来帮助开发人员更有效率的完成App的Debug工作，同时对于测试人员也是一大福音，为什么这么说呢？</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Goa6gk7Z5lBK8Nq.jpg" alt="3270074-4ead9a16e552438c.jpg"></p><p>QA：“那个谁谁谁，我刚刚操作的时候，我发现了一个bug，你写的App打开A页面，再打开B页面有时会出现闪屏问题。（内心独白：我去，这个奇怪的问题”</p><p>DEV：“嗯？还有这样的问题，麻烦你复现给我看看。（内心独白：吹牛逼，我这么牛逼，我写的App怎么会可能有bug，一定是你用的姿势不对）”</p><p>QA：一段忙碌的神操作之后…“咦，怎么不出现了？（内心独白：我去，怎么搞的啊，关键时刻掉链子，你倒是快点出来，让我丢脸丢大发了）”</p><p>DEV：“那你先回去吧，复现再告诉我。（内心独白：呵呵，和我心里想的一样，我写的怎么可能会有bug呢）”</p><p>几天过去了……</p><p>QA：满心欢喜状，那个谁谁谁“上次那个问题我复现了，操作给你看….我去，怎么又不出现了！（内心独白：一脸淫笑，我说有bug，你让我复现，这又回复现出来吧，刚想完。。。。。额。又看不到了，怎么搞的，气死我）”</p><p>DEV：“是不是设备有问题，你换个设备再试试呢？（内心独白：小样，都和你说了没有bug你不信非要复现）”</p><p>QA：“宝宝心里苦，但是宝宝不说！（内心独白：这个。唉。。。。。。。）”</p><p>有了UiAutomator之后：</p><p>QA：“我发现了一个bug，你写的App打开A页面，再打开B页面有时会出现闪屏问题。”</p><p>DEV：“这个简单，我用UiAutomator写个测试用例，分分钟解决。（内心独白：牛气哄哄的）”</p><p>QA：“厉害了Word哥！（内心独白：真特么牛逼，爱死你了）”</p><p>全剧终！</p><p>UiAutomator提供了以下两种工具来支持UI自动化测试：</p><p>uiautomatorviewer：用来分析UI控件的图形界面工具，位于SDK目录下的tools文件夹中。</p><p>uiautomator：一个java库，提供执行自动化测试的各种API。</p><h4 id="2-android-uiautomator-text定位"><a href="#2-android-uiautomator-text定位" class="headerlink" title="2.android uiautomator text定位"></a>2.android uiautomator text定位</h4><p>　　可能有人不知道为什么说android uiautomator是终极定位，而且android uiautomator和appium有什么关系呢？如果之前写了一些脚本，发现有的时候一些元素不能够很好的定位时，那么就需要采用android uiautomator去定位，它是一种非常强有力的定位方式，原理是通过android 自带的android uiautomator的类库去查找元素，都直接用官方公布出来的方法去找了还能找不到吗？</p><p>　　首先和宏哥一起看一下下面的图片：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/MSxyHPVtLqheEzp.png" alt="1232840-20190703134203770-63166267.png"></p><p>在上面的图片中我们不采用appium封装好的方法，直接使用android 的uiautomator去定位结果如下：</p><pre><code>1 user = new Uiobject(new UiSelector().text(&quot;请输入淘宝账户&quot;))2 user.setText(&quot;test&quot;)</code></pre><p>　　这两句话看不懂也没关系，因为我们接下来讲的是appium已经对他进行了封装的方法，这里只是让你看一下他原始方法是怎么做的。首先他会根据你的定位信息new一个对象出来，然后再在你new的对象之上进行相关操作。下面我们看一下在appium中的实现方法:</p><pre><code>1 ele = self.driver.find_element_by_android_uiautomator(&#39;new UiSelector().text(&quot;请输入淘宝账户&quot;)&#39;)2 ele.send_keys(&quot;123&quot;)</code></pre><p>　　对比两种代码的写法，我们可以发现他们的相同之处只是最后的定位信息是一样的，即：new UiSelector().text(“请输入淘宝账户”)，这句话是什么意思呢？简单的话就是根据一定条件来查找元素，我们这里的条件就是text属性为“请输入淘宝账户”，再根据图片去理解是不是很容易呢？android uiautomator的元素定位其实和appium的定位一样，或者说它比appium的定位方式更加多以及更加适用，并不是只有这一个，它也不仅支持className、id等定位，而且还支持模糊匹配进行定位，这样是不是感觉更高大上呢？下面我们简单介绍一下这几种定位方式。</p><h4 id="3-uiautomator-text模糊定位"><a href="#3-uiautomator-text模糊定位" class="headerlink" title="3.uiautomator text模糊定位"></a>3.uiautomator text模糊定位</h4><p>　　模糊定位故名思义，通过text的部分信息就能够进行定位，我们直接看代码：</p><pre><code>1 ele = self.driver.find_element_by_android_uiautomator(&#39;new UiSelector().textContains(&quot;请输入淘&quot;)&#39;)2 ele.send_keys(&quot;123&quot;)</code></pre><p>　　在上面的代码中我们只是将.text()的方法变成了.textContains()，在方法中传入模糊的数据就好。看到这里是否有人思考过一个问题，既然有类似的模糊寻找，那么有没有像正则表达式一样的查找呢？答案是肯定的，看我们下面的方法。</p><h4 id="4-textMatches-正则匹配查找"><a href="#4-textMatches-正则匹配查找" class="headerlink" title="4.textMatches 正则匹配查找"></a>4.textMatches 正则匹配查找</h4><p>　　textMatches故名思义就是通过正则的来进行查找定位，他也是通过text的属性来进行正则匹配，我们直接看代码：</p><pre><code>1 ele = self.driver.find_element_by_android_uiautomator(&#39;new UiSelector().textMatches(&quot;^请输入淘.*&quot;)&#39;)2 ele.send_keys(&quot;123&quot;)</code></pre><p>　　上面匹配的一些信息可能一些刚做测试的小伙伴不是很了解，这个不要紧，下来可以搜索一下正则表达式教程，稍微了解一下就可以。</p><h4 id="5-uiautomator-resourceID定位"><a href="#5-uiautomator-resourceID定位" class="headerlink" title="5.uiautomator resourceID定位"></a>5.uiautomator resourceID定位</h4><p>　　resourceId定位和appium封装好的id定位是一样的，只是这里将写法变成了uiautomator的写法而已，看下面代码：</p><p>1 1 ele = self.driver.find_element_by_android_uiautomator(‘new UiSelector().resourceId(“com.taobao.taobao:id/aliuser_login_account_et”)’)<br>2 2 ele.send_keys(‘234’)<br>　　通过上面的代码和之前的代码对比大家可能发现其实他们前面都是一样的，只是在定位的时候发生了一些变化，text变换成了resourceID即可，也就是页面对象属性的信息进行变更了，其他方法都是一样。下面其他方法我就不浪费篇幅，只给大家做一个简单的案例展示。</p><h4 id="6-resourceIDMatches-定位"><a href="#6-resourceIDMatches-定位" class="headerlink" title="6.resourceIDMatches 定位"></a>6.resourceIDMatches 定位</h4><p>　　通过id进行正则匹配定位</p><pre><code>1 ele = self.driver.find_element_by_android_uiautomator(&#39;new UiSelector().resourceIdMatches(&quot;.+aliuser_login_account_et&quot;)&#39;)2 ele.send_keys(&#39;234&#39;)</code></pre><h4 id="7-uiautomator-className定位"><a href="#7-uiautomator-className定位" class="headerlink" title="7.uiautomator className定位"></a>7.uiautomator className定位</h4><p>　　通过调用android uiautomator使用className进行定位</p><pre><code>1 ele = self.driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;android.widget.EditText&quot;)&#39;)2 ele.send_keys(&#39;234&#39;)</code></pre><h4 id="8-uiautomator-classNameMatches定位"><a href="#8-uiautomator-classNameMatches定位" class="headerlink" title="8.uiautomator classNameMatches定位"></a>8.uiautomator classNameMatches定位</h4><p>　　通过className正则匹配进行定位</p><pre><code>1 ele = self.driver.find_element_by_android_uiautomator(&#39;new UiSelector().classNameMatches (&quot;.*EditText&quot;)&#39;)2 ele.send_keys(&#39;234&#39;)</code></pre><p>　　通过上面的学习我相信大家对uiautomator的定位有一定的了解了，但是我想告诉大家的是这个并不是所有的，还有很多很多的定位方式，这个需要大家在以后不断的学习中去积累，我也不可能把所有的方法都告诉大家，这里只是给大家一个起头，但是我希望大家在学习定位的时候不只是看appium的定位，毕竟他也是封装的uiautomator的定位方式，所以在学习appium的同时把uiautomator去大概学习一下这个很有帮助，并且对以后的提升自己以及工作中重新封装appium有很大的帮助。</p><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>1、以前运行工具没有问题。今天使用uiautomatorviewer 查看android某些页面元素，出现错误Error obtaining UI hierarchy  Reason: Error taking device screenshot: null 如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/MgAKJGR9VFfdxSE.png" alt="1232840-20190703132136400-211968237.png"></p><p>再网上找了很多解决办法依然没解决</p><p>宏哥总结了一下原因：</p><p>1、该app不支持该页面的截屏功能所以uiautomatorviewer捕捉不到</p><p>2、手机需要重启</p><p>3、非原装数据线</p><p>4、appium服务异常需要重新连接</p><p>5、可以尝试切换USB接口</p><p>6、最后可以把手机开发者选项的USB调试撤销权限，在重新获取</p><p>最后记住重启再重启解决一切问题，可能这次报错了，但是重启之后就成功了，这个一般是没地方说理的。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试11</title>
      <link href="/2016/04/06/appium/"/>
      <url>/2016/04/06/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十一）- 元素定位秘籍助你打通任督二脉 - 下卷（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　宏哥看你骨骼惊奇，印堂发亮，必是练武之奇才！ 按照上一篇的节目预告，这一篇还是继续由宏哥给小伙伴们分享元素定位，是不是按照上一篇的秘籍修炼，是不是感觉到头顶盖好像被掀开,内气从头上冒出去,顿时觉得整个身体都融化了，而且身轻如燕啊！而且控制不住手，想要动手操作一番呢？那还在等什么呢，和宏哥一起练起来吧！！！</p><h4 id="2-List定位"><a href="#2-List定位" class="headerlink" title="2.List定位"></a>2.List定位</h4><p>List故名思义就是一个列表，在python里面也有list这一个说法，如果你不是很理解什么是list，这里暂且理解为一个数组或者说一个集合。首先一个list是一个集合，那么他的个数也就成了不确定性，所以这里需要用复数，所以在我们定位时我们不能够接着用find_element_by_id等等定位方式了，我们需要用他的复数形式find_elements_by_id，所有的定位方式都一样需要采用复数加s。这里我们接着上篇的案例讲，如何使用list定位想定位的元素。首先看一下图片：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/qzMdxG3D7OYylTX.png" alt="1232840-20190621110735188-1054483119.png"></p><p>我们查看图片可以知道我们能够很轻松的通过id定位到整个祖父节点，我们接下来需要做的事定位这个祖父节点下所有的“android.widget.RelativeLayout”父节点，同样的首先我们看一张图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/pdD9KhCY6Jql7fR.png" alt="1232840-20190621111347932-1346193760.png"></p><p>这里我们需要直接使用定位复数的方法来操作，直接看代码（祖父节点定位到父节点）：</p><pre><code>element= driver.find_element_by_id(&quot;com.taobao.taobao:id/rv_main_container&quot;)elements = element.find_elements_by_class_name(&quot;android.widget.FrameLayout&quot;)</code></pre><p>通过上面的代码我们直接定位了com.taobao.taobao:id/rv_main_container父节点下的所有android.widget.FrameLayout子节点，但是由于这个android.widget.FrameLayout子节点下边还有许多相同的android.widget.LinearLayout孙节点。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/pdD9KhCY6Jql7fR.png" alt="1232840-20190621111347932-1346193760.png"></p><p>这里我们需要直接使用定位复数的方法来操作，直接看代码（父节点定位到孙节点）：</p><pre><code>1 elements = element.find_elements_by_class_name(&quot;android.widget.FrameLayout&quot;)2 elements1 = elements[1].find_elements_by_class_name(&quot;android.widget.LinearLayout&quot;)</code></pre><p>现在我们需要怎么去操作这个子节点了，这里有两种方法：</p><p>1、前面我们讲了List你可以理解为一个数组或者一个集合，这里定位的所有子节点最后就成了个list，如果我们要访问这个list里面的某一个元素我们可以像访问数组中的数据一样通过下标访问。最后的代码就是下面这个样子：</p><pre><code>1 element= driver.find_element_by_id(&quot;com.taobao.taobao:id/rv_main_container&quot;)2 elements = element.find_elements_by_class_name(&quot;android.widget.FrameLayout&quot;)3 elements1 = elements[1].find_elements_by_class_name(&quot;android.widget.LinearLayout&quot;)4 elements1[1].click()</code></pre><p>上面的代码最后的结果是选择了“聚划算”这个标签页面，然后点击进入。</p><p>备注：如果初学者不理解是如何通过下标访问的，这里说一下下标是从0开始，如果要访问list i中的第一个元素结果就是i[0]，这部分知识可以看一下python基础。</p><p>2、如果你要访问List里面的元素，那么我们是否可以通过for循环语句来依次访问呢？这个在自动化中会经常用到。下面你可以通过这个思路自己去实战一下，看能否达到预期效果。下面看我的代码：</p><pre><code>1 element= driver.find_element_by_id(&quot;com.taobao.taobao:id/rv_main_container&quot;)2 elements = element.find_elements_by_class_name(&quot;android.widget.FrameLayout&quot;)3 elements1 = elements[1].find_elements_by_class_name(&quot;android.widget.LinearLayout&quot;)4 for ele in elements1:5     ele.click()</code></pre><p>看上面的代码，我们通过循环去访问这个list里面的每一个元素，因为每次循环得到的都是其中一个元素，那么我们只需要在这个元素上加上你想要的操作即可，所以我们这里可以直接点击进去。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://showmore.com/zh/embed/ulwaed8" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><p>如果你动手做到这里会发现一个问题，你进入到第一个标签后没一会儿系统就会报错，为什么呢？你也可以试着去解决这个问题，后面我们会讲解这块儿知识。</p><h4 id="3-内嵌H5定位"><a href="#3-内嵌H5定位" class="headerlink" title="3.内嵌H5定位"></a>3.内嵌H5定位</h4><h5 id="3-1-hybrid定位思考"><a href="#3-1-hybrid定位思考" class="headerlink" title="3.1 hybrid定位思考"></a>3.1 hybrid定位思考</h5><p>在web自动化中我们会遇见frame的问题，在遇见这些内嵌的标签后我们需要做的就是切换窗口，那么在app自动化测试也有类似的情况就是我们经常看见的内嵌html，在我们原生的app中增加一个由html做成的页面。大家可以思考一下这种情况怎么操作。</p><h5 id="3-2-hybrid常见定位问题分析"><a href="#3-2-hybrid常见定位问题分析" class="headerlink" title="3.2 hybrid常见定位问题分析"></a>3.2 hybrid常见定位问题分析</h5><p>首先我们看一下下面一张图片：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/mt6y3PK1sqTNxWg.png" alt="imageview.png"></p><p>通过右边的结构图我们能够清晰的看见整个页面就是一个webview，无论从什么角度来定位我们都不能够很好的进行，如果这个时候我们需要操作页面的元素就需要通过切换contexts来完成。但是在讲这个知识点之前大家先按照网上的知识来试一下处理这个页面，看能否成功。下面先说大家会遇见的问题:</p><p>1、可能你看到有的文章显示我们不需要通过切换contexts就能够完成定位，这样的情况有，但是那种情况作者只在微博登录、qq登录等第三方登录时遇见过，如果不是这样的情况而像上面的情况就没办法通过类似的方法进行完成，所以我希望读者遇见这种情况时自己动手去操作，看什么方式更加适合自己的项目。</p><p>2、需要切换contexts那么就需要获取页面的所有contexts，此时你通过官网或者其他文章的知识通过下面的方法来获取，可能会报错，这种情况关系不大。</p><pre><code>1 webview = self.driver.contexts2 print webview</code></pre><p>如果你通过上面的代码来调试但是却报错，但是其他资料却没问题时你也不要着急，这里你需要确定两件事情：（1）、app打包的时候需要开启webview 的debug属性setWebContentDebuggingEnabled(true)，这个直接让开发加上就好。一般情况是开启的，毕竟他们也要调试。（2）、你用很多手机去调试，发现有一些可以有一些不可以，但是你用模拟器却都可以，根据官方给出的答案是这个时候你需要去将手机root，然后再试。目前作者遇见了这两种情况，第二种我也是调试了很久才找到原因。</p><h5 id="3-3-hybrid定位讲解"><a href="#3-3-hybrid定位讲解" class="headerlink" title="3.3 hybrid定位讲解"></a>3.3 hybrid定位讲解</h5><p>这两个问题解决后那么定位webview就轻松搞定，直接看代码：</p><pre><code>1 webview = driver.contexts2 driver.switch_to.context(webview[1])3 driver.find_element_by_link_text(&#39;PHP&#39;).click()</code></pre><p>对于初学者对于上面的代码可能不是很理解，下面我们看一下日志：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/augpMIybJsmLYAF.png" alt="imageview _1_.png"></p><p>大家这里不用管我执行代码和之前的区别（多了一个self），我们看下面控制台的输出，输出的是一个list，前面说过list和数组类似，在这个list里面有两个元素“NATIVE_APP”,“WEBVIEW_cn_com_open_mooc”,第一个元素是我们原生的app的contexts，后面的则是我们的webview的context，所以我们需要获取webview的context时只需要通过这个list的下表来进行访问。</p><p>我们获取到webview的context后只需要通过driver.switch_to.context()进行切换就好。当切换后我们就可以像定位web一样进行定位。</p><p>看下面一张图片我们通过浏览器将h5页面打开：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Az16Fy4iKaqsxob.png" alt="imageview _2_.png"></p><p>通过上面的图片我们就能够很轻松的像web一样进行定位，也就可以使用web的一些定位方式。看到这里是不是觉得解决了一个难题呢？动手去吧。</p><h5 id="3-4-hybrid问题实战"><a href="#3-4-hybrid问题实战" class="headerlink" title="3.4 hybrid问题实战"></a>3.4 hybrid问题实战</h5><p>通过前面的学习我相信你已经有了一些实战能力，这里给大家提一个问题，我们获取到的contexts每次一定是两个吗？如果不是两个那么我们上面的脚本是不是就没办法用了呢？可以思考一下这里怎么解决，在看我们下面的思路以及解决方案。</p><p>无论在什么页面我们去获取contexts时他无论有几个但是他的类型是不是肯定都是一个list呢？既然是list那么我们是否可以取到里面的每一个值，然后把每一个值进行判断，只要找出我们的webview就可以了呢？下面看代码：</p><pre><code>1 #获取当前页面所有的contexts2 webview = driver.contexts3 #在获取到的contexts list里面去挨个循环4 for context in webview:5   #判断循环中单个的context是否是webview，如果是就进行切换，并且跳出循环6   if &#39;WEBVIEW&#39; in context:7     driver.switch_to.context(context)8     break9 driver.find_element_by_link_text(&#39;PHP&#39;).click()</code></pre><p>通过上面的代码我们是否完美的解决了内嵌H5的定位问题呢？动手吧</p><h4 id="4-滑动定位"><a href="#4-滑动定位" class="headerlink" title="4.滑动定位"></a>4.滑动定位</h4><h5 id="4-1-滑动定位方式"><a href="#4-1-滑动定位方式" class="headerlink" title="4.1 滑动定位方式"></a>4.1 滑动定位方式</h5><p>在app自动化中我们经常会遇见一个问题，我们需要查找的元素不在当前可展示的屏幕，至于在什么地方我们不知道，如果这个时候我们一直使用在当前页面查找，那么系统就会报错，为了解决这个问题我们就需要使用滑动查找。</p><p>首先的思路是我们在需要查找对象的页面查找一下该元素，判断该元素是否在当前页面，如果该元素不在该页面那么我们就需要去互动屏幕，到我们的下一屏幕，然后再进行查找，依次类推到找到为止。</p><h5 id="4-2-滑动定位思路分析"><a href="#4-2-滑动定位思路分析" class="headerlink" title="4.2 滑动定位思路分析"></a>4.2 滑动定位思路分析</h5><p>方式我们有了，那么我们就需要知道实现这个功能应该有哪些点。下面跟着我一起来分析一下：</p><p>1、需要查找的元素我们是不是需要知道是什么呢？这个需要先确定</p><p>2、我们需要找的页面是在我们的当前页面的上方还是下方还是左方还是右方，我们不能确定，那么我们是否需要确定我们需要滑动的方向？</p><p>3、元素和方向有了，但是你知道我们每次需要滑动屏幕的多少吗？那么我们是否需要先去获取屏幕的大小，然后针对不同的方向去计算一个滑动的值呢？</p><p>万事具备只欠东风，去按照这个思路动手练习一吧。</p><h5 id="4-3-滑动定位实战"><a href="#4-3-滑动定位实战" class="headerlink" title="4.3 滑动定位实战"></a>4.3 滑动定位实战</h5><p>一、根据上面的思路我们能首先来确定我们需要查找的元素，看下面图片：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/XoHrjMIZSeKUmzb.png" alt="imageview _3_.png"></p><p>我们要找实战推荐后面的“换一换”按钮，然后进行点击。首先我们查看他的定位信息</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Rdk1WYqJZe2Nbv6.png" alt="imageview _4_.png"></p><p>最后我们查找元素的定位信息代码如下：</p><pre><code>1 self.driver.find_element_by_id(&#39;cn.com.open.mooc:id/tv_replace&#39;).click()</code></pre><p>　　对于有一定基础的人可能会觉得这个很low，但是有没有思考过一个问题，我们可以通过这个代码去执行，在没有这按钮的时候却会报错，也就没有办法执行下去了，那么需要怎么处理呢？所以这个时候我们需要有一些python的容错知识，即使我们的代码执行出错了，那么也要让他按照我们的意思执行下去。try…….except…….，这个就是我们python中的容错处理 ，下面我们看添加后的代码：</p><pre><code>1 try:2 self.driver.find_element_by_id(&#39;cn.com.open.mooc:id/tv_replace&#39;).click()3 except Exception,e:4 print e</code></pre><p>try的意思就是告诉编译器试着去执行他下面这一段代码，如果报错了，那么你就把except里面的错误信息打印出来。</p><p>二、有了元素现在我们需要知道的是不是就是该怎么滑动界面了呢？首先我们看一下下面这张图片：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/dCMDPARXSNju5sc.png" alt="imageview _5_.png"></p><p>在我们使用app的过程中存在上面几种滑动情况，我们把整个界面看作为一个坐标系（x，y），如果我们需要往上滑动，那么我们是不是就是x轴不动，y轴从下往上动呢？往下就是x轴不动，y轴从上往下呢？同理左右滑动是不是就是应该y轴不动x轴左右滑动呢？可以好好去体会一下，脑海中有个画面。</p><p>在appium中滑动我们所需要使用的方法就是swipe函数，至于往哪个方向滑动就是看我们里面的x，y的值，如果我们需要下往上滑动那么我们就应该是：</p><pre><code>1 self.driver.swipe(x1,y1,x1,y2,t)</code></pre><p>上面的代码x轴的值不变，y轴的值进行了变化，所以是沿着上下进行滑动的，从y2滑动到了y1点。t代表的是多少时间完成这个动作，或者说这个时间持续多久。</p><p>备注：这里需要注意的是屏幕的x，y的值是从左上角开始取的，左上角为（0，0），右下角是最大。</p><p>三、上面滑动的方法看着是好用，但是我们不可能每次都去填写一个坐标，那样太low，所以我们需要获取屏幕大小，直接看代码：</p><pre><code>1 x = self.driver.get_window_size()[&#39;width&#39;]2 y = self.driver.get_window_size()[&#39;height&#39;]</code></pre><p>　　上面的代码就是我们获取到的x，y轴。通过思路我们的代码都有了，下面我们要做的就是对原来的代码进行修改，进行一个封装。下面看代码，这个暂时看不懂没关系，到后面我们学了python’基础就能够看懂了。先思路，然后了解。</p><pre><code> 1 #获取屏幕大小 2           3 def getSize(self): 4   x = self.driver.get_window_size()[&#39;width&#39;] 5   y = self.driver.get_window_size()[&#39;height&#39;] 6   return (x,y) 7           8           9 #向左滑动10 def swipeLeft(self,t):11   l=self.getSize()12   x1=int(l[0]*0.9)13   y1=int(l[1]*0.5)14   x2=int(l[0]*0.1)15   self.driver.swipe(x1,y1,x2,y1,t)16                17 #向右滑动18 def swipeRight(self,t):19   l=self.getSize()20   x1=int(l[0]*0.25)21   y1=int(l[1]*0.5)22   x2=int(l[0]*0.75)23   self.driver.swipe(x1,y1,x2,y1,t)24                25 #向上滑动26 def swipeUp(self,t):27   l=self.getSize()28   x1=int(l[0]*0.5)29   y1=int(l[1]*0.8)30   y2=int(l[1]*0.4)31   self.driver.swipe(x1,y1,x1,y2,t)32   time.sleep(5)33          34 #向下滑动35 def swipeDown(self,t):36   l=self.getSize()37   x1=int(l[0]*0.5)38   y1=int(l[1]*0.25)39   y2=int(l[1]*0.75)40   self.driver.swipe(x1,y1,x1,y2,t)41          42 #查找元素，没找到滑动43 def findLocal(self):44   x = 145   while x==1:46     if self.fact() == 1:47       self.swipeUp(2000)48       time.sleep(3)49       self.fact()50     else:51       print &quot;找到了&quot;52       x=253              54          55          56 #递归57 def fact(self):58   n =159   try:60     self.driver.find_element_by_id(&#39;cn.com.open.mooc:id/tv_replace&#39;).click()61   except Exception,e:62     return n</code></pre><p>　　通过查看上面代码的整个逻辑就是1、首先去查找元素，如果找到了我就直接点击。2、如果没有找到元素那么我就往上滑动（这里可以自己选择），滑动后再次进行查找，如果找到就点击，没有找到继续滑动。动手动手，这里知识点很重要！虽然后面会有一些替代方法，但是思路、算法很重要。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>   好了，元素定位，常见的大致就这些，这个目前就分享到这里吧，以后如果遇到，宏哥给小伙伴再补上！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试10</title>
      <link href="/2016/04/05/appium/"/>
      <url>/2016/04/05/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（十）- 元素定位秘籍助你打通任督二脉 - 上卷（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　你有道灵光从天灵盖喷出来你知道吗，年纪轻轻就有一身横练的筋骨，简直百年一见的练武奇才啊，如果有一天让你打通任督二脉，那还不飞龙上天啊。正所谓我不入地狱谁入地狱，警恶惩奸维护世界和平这个任务就交个你了，好吗。这本如来神掌秘籍是无价之宝，我看与你有缘，收你十块钱传授给你吧。想必这段经典台词给为都可以的耳熟能详吧，宏哥，没这么牛叉呼啦带闪电，就是希望对你有帮助就可以了。</p><p>　　上一篇宏哥给小伙伴们介绍完定位工具这两个异性兄弟，这篇就给小伙伴们介绍一下定位方法。早就有小伙伴问，这个这个怎么定位，那个那个怎么定位？那么宏哥今天就告诉你，怎么怎么定位。其实定位前边也有所涉及，只不过是一笔带过的。这篇宏哥就给小伙伴们详细的介绍一下。</p><h4 id="2-常用定位方法讲解"><a href="#2-常用定位方法讲解" class="headerlink" title="2.常用定位方法讲解"></a>2.常用定位方法讲解</h4><p>　　对象定位是自动化测试中很关键的一步，也可以说是最关键的一步，毕竟你对象都没定位那么你想操作也不行。所以本章节的知识宏哥希望小伙伴们多动手去操作和实战，不要仅仅只是书本上的知识，毕竟这个我只能够举例说明。下面我们来看我们常用的一些定位方式。</p><h5 id="2-1-ID定位"><a href="#2-1-ID定位" class="headerlink" title="2.1 ID定位"></a>2.1 ID定位</h5><p>　　无论是在web自动化还是app自动化中id都是唯一的，可能有的小伙伴看到这里会有疑问，因为有的资料说是通过name定位是唯一的，为什么你这里是id呢，其实这个在之前是不冲突的，但是如果你用的是appium较新版本是不行的，在新版本中name定位被去掉了，所以在以后的定位中不会有name定位了，通常情况下我们也更喜欢用id进行定位。这里可能刚学的小伙伴会有疑问，有的时候你的应用为什么没有id，或者说在这个手机上有但是另外的手机上没有。1、开发没有添加。2、android版本是4.4以下的。</p><p>我们直接看下面这张图片吧</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/LfCFTtvEPwDoYcr.png" alt="1232840-20190620143859834-1019346780.png"></p><p>上面图片中左边部分用红色圈出来的对象的id我们在右边的属性中可以看到，它的id宏哥同样是用红色圈出，如果我们需要对“请输入淘宝账户”这个输入框进行输入信息，我们只需操作右边的id就行，下面我们直接看代码。</p><pre><code>1 driver.find_element_by_id(&quot;com.taobao.taobao:id/aliuser_login_account_et&quot;).send_keys(&quot;北京宏哥&quot;)</code></pre><p>通过上面的代码我们能够直接在账户信息输入框中输入账户信息北京宏哥。可能对于无基础的人来说这里会又点儿迷糊，这个driver是哪里来的，driver在我们配置启动的时就已经初始化，我们只需要调用他的方法find_element_by_id。如果你的ide有自动补全功能，那么你在输入后面的方法时会发现一个问题，为什么还有一个find_elements_by_id呢？这个在后面宏哥会讲解，有兴趣的小伙伴可以思考一下。</p><h5 id="2-2-className定位"><a href="#2-2-className定位" class="headerlink" title="2.2 className定位"></a>2.2 className定位</h5><p>在实际工作中className定位用得相对而言会比较少。当你经常去看class时你会发现很多的className是一样的，你没有办法对其进行唯一定位，下面我们看下面两张图片</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/l7TfucrxU2s9meV.png" alt="1232840-20190620145211610-876204083.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/qDPgtlYTMv9VScI.png" alt="1232840-20190620144640656-1742231255.png"></p><p>我们可以仔细看一下这两张图片中淘宝账号、密码两个输入框中的className都是一样的，如果在这种情况下你使用下边这种方式去定位，你会发现你永远定位不了密码栏，这是为什么呢？因为在设计的时候如果你查找的元素在页面有多个，系统会自动给你选择第一个，所以你永远操作不了后面的，那么在实际工作或者实战的时候如果遇到此类问题如何解决这种问题呢？宏哥后面会讲解。</p><pre><code>driver.find_element_by_class_name(&quot;android.widget.EditText&quot;).send_keys(&quot;北京宏哥&quot;)</code></pre><h5 id="2-3-xpath定位"><a href="#2-3-xpath定位" class="headerlink" title="2.3 xpath定位"></a>2.3 xpath定位</h5><p>xpath定位在web自动化中是最常见的，而且也是最有效的，使用xpath定位避免了找不到元素导致报错的问题，但是在app中使用xpath定位是一件很low的事情。为什么这么说呢？因为在宏哥过来人的经历中只要遇见使用xpath定位元素他的反应就会比较慢，自动化的目的是为了提高效率，但是使用xpath后会降低效率，所以这里说很 low。但很多时候我们不得不去了解，下面我们大概讲解一下。首先我们要熟悉一下web的xpath定位。</p><p>1）讲web的xpath之前大家先装一下fireFox浏览器，再在浏览器中安装fireBug以及FirePath两个插件。如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/MGPOxwmyRhjqdaS.jpg" alt="imageview _1_.jpg"></p><p>在自动化或者学习xpath时这两个插件是必不可少的，这里我们直接讲xpath，我们来看下面一张图片理解一下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/sA6rhIV9i3wTRYy.jpg" alt="imageview _2_.jpg"></p><p>用红色圈出有虚线的输入框我们看一下xFirePath给我们的定位，在定位的xpath中显示的是“.//<em>[@id=’kw’]”，这个是什么意思呢？我们来一步一步讲解。1、//</em>  选取文档中的所有元素 。2、@id=’kw’]  匹配属性为id且值为kw的节点。这里有的小伙伴可能不是很理解，说这里直接使用id进行定位就行。其实也是，但是当没有这个属性的时候呢？我们看下面这张图片</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/XV2O6NKmWSkcxHC.jpg" alt="imageview _3_.jpg"></p><p>name定位无效的情况下，当你看到这张图片的时候如果你不用xpath怎么定位呢？有一些抓狂的感觉吧。小伙伴可以尝试着自己使用xpath进行定位，可能有一些人发现xpath中定位不是很明白了，为什么呢？.//*[@id=’u1’]/a[4]  在这个xpath中我们没有像之前那样思路清晰了他多了一些层级关系，这个后面我们会仔细讲。这个xpath中首先第一步1、@id=’u1’和之前的一样匹配属性为id值为ul的节点，然后再在他的下面进行定位第二步2、/a[4]  意思就是从根节点下选取第四个a元素。这样一步一步解析是否更加容易理解了呢？下面我们看一下在xpath定位中经常用到的一些语法，下来大家多多练习。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/n9bXplDZrFsTNUP.png" alt="imageview.png"></p><p>这个是我们经常用到的，而且是最基础的知识，只有这些没有办法完成很多古怪的需求，那么就有更难的，下面我们看下面的列表</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/QIB9ofljGNvpZPe.png" alt="imageview _1_.png"></p><p>上面这些知识都是在<a href="http://www.w3school.com.cn/xpath/xpath_examples.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/xpath_examples.asp</a> 里面，大家可以多看看，多练习。</p><p>下面我们直接看在app中xpath的使用</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/nwTmgaortx6M7pZ.png" alt="1232840-20190621103652688-506808560.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/a1ZgGNXDeBy72PJ.png" alt="1232840-20190621102325546-2071797774.png"></p><p>在上面两张图片中我们能够清除的看见他们的id、className都是一样的，这样的情况下不用层级定位方式我们只能够采用xpath来进行定位，首先根据前面web的学习大家可以思考一下该怎么定位。我们直接看代码</p><pre><code>1 driver.find_element_by_xpath(&quot;//android.widget.TextView[@text=&#39;聚划算&#39;]&quot;).click()</code></pre><p>在xpath里面我们的语法是这样“//android.widget.TextView[@text=’JavaScript’]”，这个和我们之前web的xpath一样，意思是查找所有节点中节点为android.widget.TextView （这里使用的是className，也可以使用id，系统会依次去找）并且他的text属性值为JavaScript，这样是否更容易理解呢？下来多练习。这样的定位方式不推荐，效率很慢。</p><h4 id="3-层级定位"><a href="#3-层级定位" class="headerlink" title="3.层级定位"></a>3.层级定位</h4><h5 id="3-1什么是层级定位"><a href="#3-1什么是层级定位" class="headerlink" title="3.1什么是层级定位"></a>3.1什么是层级定位</h5><p>　　在前面的章节中我们已经提到了层级定位，只是不知道具体怎么操作而已。在很多的自动化中如果只是靠简单的定位是没有办法完成自动化的，就像刚xpath定位一样，有的元素的id、name、className都是一样的，xpath定位效率低下，这个时候我们大多数都会采用层级定位。</p><h5 id="3-2项目中层级定位如何运用"><a href="#3-2项目中层级定位如何运用" class="headerlink" title="3.2项目中层级定位如何运用"></a>3.2项目中层级定位如何运用</h5><p>下面我们举一个简单的例子来理解层级定位。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/afNA9kUTbcZtqHl.png" alt="1232840-20190621115229039-501129874.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/p3ilngjLq95rZFM.png" alt="1232840-20190621111347932-1346193760.png"></p><p>从上面的图片我们可以看出id为com.taobao.taobao:id/rv_main_container的节点下面包含了很多的android.widget.FrameLayout</p><p>从下面的图片我们可以看出id为android.widget.FrameLayout的节点下面包含了很多的android.widget.LinearLayout</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Mha3Gp4yZOLlS69.png" alt="1232840-20190621111535260-1518321995.png"></p><p>从这张图片我们不难看出，如果我们要定位这个元素我们是没办法去定位的，这种情况我们大多数使用的是层级定位以及xpath，这里我们来看如何使用层级定位。</p><p>首先我们可以看出三幅图的结构上的区别，第三幅图的元素它是在第二幅图里面的，第二幅图元素它是在第一幅图里面的，这里我们称第一幅图id（com.taobao.taobao:id/rv_main_container）为android.widget.FrameLayout的节点为第二幅图元素的父节点，第二幅图id（android.widget.FrameLayout）为android.widget.FrameLayout的节点为第三幅图元素的父节点，第一幅图id（com.taobao.taobao:id/rv_main_container）为android.widget.LinearLayout的节点为第三幅图元素的祖父节点；我们只需要先通过id定位到祖父节点，然后再从祖父节点往下面依次进行定位就好。现在你可以练习一下，看和我的结果一样吗？看代码：</p><pre><code>1 element= driver.find_element_by_id(&quot;com.taobao.taobao:id/rv_main_container&quot;)2 element1 = element.driver.find_elements_by_class_name(&quot;android.widget.FrameLayout&quot;)3 element2 = element1[1].find_element_by_class_name(&quot;android.widget.LinearLayout&quot;)4 element2.click()</code></pre><p>按照思维我们的代码会是上面的结果，但是你去运行会发现不报错，可也不会点击，这个是为什么呢？我们看下面的图片(宏哥亲测，它会点击第一个天猫，可能是默认点击第一个吧)</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://showmore.com/zh/embed/aru4ij0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/1aPHTkKyu4h8dVB.png" alt="1232840-20190621125559597-572477866.png"></p><p>在祖父节点下的所有子节点他的className都是“android.widget.FrameLayout”，在父节点下的所有子节点他的className都是“android.widget.LinearLayout”，这种情况下他怎么去点击操作呢？所以在这种情况下会引发一个新的定位问题，就是宏哥在接下来要讲的List定位。</p><h5 id="3-3参考代码"><a href="#3-3参考代码" class="headerlink" title="3.3参考代码"></a>3.3参考代码</h5><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-7-01 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用定位元素 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 import time13 desired_caps = {}14 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa15 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号16 desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看17 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名18 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity19 #desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串20 #desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来21 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息22 # 休眠五秒等待页面加载完成23 time.sleep(5)24 25 element= driver.find_element_by_id(&quot;com.taobao.taobao:id/rv_main_container&quot;)26 element1 = element.find_elements_by_class_name(&quot;android.widget.FrameLayout&quot;)27 element2 = element1[1].find_element_by_class_name(&quot;android.widget.LinearLayout&quot;)28 element2.click()29 30 # driver.quit()</code></pre><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>1、前边介绍了一下火狐浏览器，这里宏哥再给小伙伴们总结一下谷歌浏览器如何用xpath定位，当然了，大神和大佬可以忽略不看，因为可以直接手写xpath定位。其实看看他们的语法也很简单，自己后期也可以尝试手写，看看和工具的有哪些区别，这样可以有助于自己的提高和提升。</p><p>2、谷歌浏览器xpath插件下载地址<a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl</a></p><p>3、安装方法，用谷歌浏览器直接访问上边的地址，添加以后即可。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/smcyGL6ogPM4SrD.png" alt="1232840-20190621090122318-1928073650.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/PLVShmBQwsE3bo4.png" alt="1232840-20190621090227696-1147435557.png"></p><p>4、看一下如何使用和其效果</p><p>（1）谷歌浏览器，F12，不可以的话，可以打开“开发者工具”</p><p>（2）点击左边的“箭头”，查找到要定位的元素</p><p>（3）选中控制台的元素，鼠标右键，在copy里，选中“Copy XPath”</p><p>（4）copy的内容：（//*[@id=”kw”]）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/fOojVLrpH1TRuvJ.png" alt="1232840-20190701151358393-328311040.png"></p><p>5、注意find_element和find_elements的区别！！！</p><p>　　好了，时间不多了，天也很晚了，大致就这些吧，今天就给小伙伴们就说到这里吧。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试9</title>
      <link href="/2016/04/04/appium/"/>
      <url>/2016/04/04/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（九）- 定位元素工具(义结金兰的两位异性兄弟)（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>环境搭建好了，其他方面的知识也准备的差不多了，那么我们就开始下一步元素定位，元素定位宏哥主要介绍如何使用uiautomatorviewer，通过定位到页面上的元素，然后进行相应的点击等操作. 此外在介绍另一款工具：Inspector。</p><p>uiautomatorviewer是android-sdk自带的一个元素定位工具，非常简单好用，使用uiautomatorviewer，你可以检查一个应用的UI来查看应用的布局和组件以及相关的属性。</p><p>那么宏哥先来给各位小伙伴们介绍大哥–uiautomatorviewer，再来介绍小弟–Inspector。</p><h4 id="2-大哥–uiautomatorviewer"><a href="#2-大哥–uiautomatorviewer" class="headerlink" title="2.大哥–uiautomatorviewer"></a>2.大哥–uiautomatorviewer</h4><p>大哥人物简介：</p><p>大哥是皇族后裔，但是比刘皇叔强多了。人家有一个好爹–Google。</p><p>Android 4.1发布的，uiautomator是用来做UI测试的。也就是普通的手工测试，点击每个控件元素 看看输出的结果是否符合预期。比如 登陆界面 分别输入正确和错误的用户名密码然后点击登陆按钮看看是否能否登陆以及是否有错误提示等。</p><p>功能性或者黑盒UI测试不需要测试人员了解程序如何实现的，只需要验证各种操作的结果是否符合预期即可。这样的测试可以分离团队的开发人员和测试人员。大家各干各的没有太多的交集。</p><p>常用的UI测试方式就是人工验证啦，就是测试人员拿着各种手机分别安装要测试的程序然后看看是否能正确完成各种预定的功能。但是这种验证方式是非常耗时间的，每次回归都要全部验证一边，并且还容易出现人为错误。比较高效和可靠的UI测试方式就是自动化测试。自动化UI测试创建测试代码来执行测试任务，各种测试任务分别覆盖不同的使用场景，然后使用测试框架来运行这些测试任务。而uiautomator 就是你的自动化UI测试工具。</p><p>Android SDK在4.1中提供了如下工具来支持UI自动化测试：</p><p>uiautomatorviewer – 一个图形界面工具来扫描和分析应用的UI控件。<br>uiautomator – 一个测试的Java库，包含了创建UI测试的各种API和执行自动化测试的引擎。<br>要大哥出山也就是使用该工具，需要满足如下条件：</p><p>Android SDK Tools, Revision 21 or higher<br>Android SDK Platform, API 16 or higher</p><h4 id="3-启动uiautomatorviewer-bat"><a href="#3-启动uiautomatorviewer-bat" class="headerlink" title="3.启动uiautomatorviewer.bat"></a>3.启动uiautomatorviewer.bat</h4><p>两种启动方法：</p><h5 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h5><p>1、打开目录D:\software\android-sdk-windows\tools</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Kq3lusVgSnDfvjH.png" alt="1232840-20190624110628623-1687630901.png"></p><p>2、双击启动，启动之后出现如下界面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/SfOnlNT9Czhbt7i.png" alt="1070438-20170429135814115-1764672145.png"></p><h5 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h5><p>1、如果不喜欢双击启动的话，也可以在cmd里面通过指令启动</p><p>先cd到tools目录下，然后输入uiautomatorviewer.bat回车后启动服务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/3mTL9WdHKUtYDEo.png" alt="1232840-20190624111201818-1142171610.png"></p><h4 id="4-连接手机"><a href="#4-连接手机" class="headerlink" title="4.连接手机"></a>4.连接手机</h4><p>1、cmd打开输入adb devices,确认手机已连上（以夜神模拟器为例）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/24TgmAEcF5NKzPL.png" alt="1232840-20190624133440051-555486932.png"></p><p>2、打开手机淘宝页面，让屏幕处于点亮状态</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/1Ll9MyJ2K4FuIAc.png" alt="1232840-20190624133647648-677131194.png"> </p><p>3、点左上角安卓机器人按钮Devices Screenshot按钮刷新页面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/smOdVBibQSGcpjf.png" alt="1232840-20190624133734299-84945968.png"></p><h4 id="5-定位元素"><a href="#5-定位元素" class="headerlink" title="5.定位元素"></a>5.定位元素</h4><p>1、移动鼠标到需要定位的元素上，如搜索输入框</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/vtHSnJzI5MiNFuW.png" alt="1232840-20190624134138944-477543819.png"></p><p>2、右下角可以看到元素对应的属性</p><p>text:好沙发需要好坐垫</p><p>resource-id:com.taobao.taobao:id/home_searchedit</p><p>class:android.widget.EditText</p><h4 id="6-点搜索框"><a href="#6-点搜索框" class="headerlink" title="6.点搜索框"></a>6.点搜索框</h4><p>1、前面一篇启动app后，休眠五秒，等待页面加载完成</p><p>2、通过id来定位到搜索框，然后点击</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/lcCRQVPxiuaqsS4.png" alt="1232840-20190624144838627-1741687585.png"> </p><h4 id="7-参考代码"><a href="#7-参考代码" class="headerlink" title="7.参考代码"></a>7.参考代码</h4><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-6-24@author: 北京-宏哥   QQ交流群：707699217Project:学习和使用定位元素工具&#39;&#39;&#39;# 3.导入模块from appium import webdriverimport timedesired_caps = {}desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipadesired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity#desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串#desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息# 休眠五秒等待页面加载完成time.sleep(5)driver.find_element_by_id(&quot;com.taobao.taobao:id/home_searchedit&quot;).click()# driver.quit()</code></pre><h4 id="8-元素定位"><a href="#8-元素定位" class="headerlink" title="8.元素定位"></a>8.元素定位</h4><p>1、appium的webdriver提供了11种元素定位方法，在selenium的基础上扩展了三个，可以在pycharm里面输入driver.find_element_by然后会自动匹配出来</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Ie2WKgU1LYDFdjO.png" alt="1232840-20190624135318036-1660807302.png"></p><p>2、多的三种如下，在后面的会详细介绍</p><p>driver.find_element_by_accessibility_id()</p><p>driver.find_element_by_android_uiautomator()</p><p>driver.find_element_by_ios_uiautomation()</p><p>（第三个是ios的可以暂时不用管）</p><h4 id="9-小弟–Inspector"><a href="#9-小弟–Inspector" class="headerlink" title="9.小弟–Inspector"></a>9.小弟–Inspector</h4><p>小弟人物简介：</p><p>小弟不是很牛叉，但是小弟的存在必定有小弟存在的必要，之前看了好多文章都要放弃小弟，我觉地不要放弃，没准小弟可以替大哥大哥挡刀呢，呵呵，说笑了，毕竟过河的卒子可以当车！！！</p><p>Appium Inspector是appium自带的一个元素定位工具，前边介绍了如何使用uiautomatorviewer进行元素定位。这里就学习Appium Inspector是如何定位的。</p><p>Appium Inspector 对于测试的同学不得不说是一个神器，可以查询到我们需要定位的元素的 id 等各种信息 ，还可以 录制用户行为，翻译成脚本。逆天的是可以翻译成多种语言的脚本。这并不意味着测试的同学可以不用学习语言和编程了，因为机器翻译出的脚本一般很难一次执行成功，其中很可能还需要经过人工修改后才能顺利执行，但是这已经可以为测试脚本的编写带来很大的遍历，所以 Appium Inspector 还是值得我们去学习和使用。</p><h4 id="10-设置appium"><a href="#10-设置appium" class="headerlink" title="10.设置appium"></a>10.设置appium</h4><p>1、先不要启动appium，因为启动以后就不能操作appium设置界面，必须在未启动的时候进行操作</p><p>2、点开android setting界面（机器人图标）</p><p>3、勾选Application Path,添加被测app的路径</p><p>4、Devices name处添加设备名称（adb devices查看到的）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/oLFzBhwjcpnV5qH.png" alt="1232840-20190624135847592-309008632.png"></p><p>（注意：通过这种方法也可查看到apk的包名和Launch Activity）<br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/bxqpleCBiQIngDY.png" alt="1232840-20190624135919128-1721179930.png"></p><h4 id="11-开启appium"><a href="#11-开启appium" class="headerlink" title="11.开启appium"></a>11.开启appium</h4><p>1、手机确保连接电脑（adb devices查看）（仍然以夜神模拟器为例）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/24TgmAEcF5NKzPL.png" alt="1232840-20190624133440051-555486932.png"> </p><p>2、点appium右上角三角形图标，会启动服务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/iuB6KfbGo4HUsNL.png" alt="1232840-20190624140050308-126102250.png"></p><p>3、这时候可以看到手机上安装淘宝应用，并会启动淘宝</p><p>4、点appium右上角的搜索图标</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/7nAsSdrtifNc9Vy.png" alt="1232840-20190624140301386-1565349599.png"></p><p>5、点Inspector Window界面的 Refresh 按钮刷新界面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/8sl5tI2zDBTRCnJ.png" alt="1232840-20190624142733493-1164264157.png"></p><h4 id="12-Ispector-Window"><a href="#12-Ispector-Window" class="headerlink" title="12.Ispector Window"></a>12.Ispector Window</h4><p>1、手机上打开需要单位元素的界面，然后点Refresh按钮刷新</p><p>2、左边菜单树，可以挨个点开</p><p>3、如果想单位界面上的“是”和“否”按钮，从菜单树就可以看到这两个元素的结构</p><h4 id="13-查看属性"><a href="#13-查看属性" class="headerlink" title="13.查看属性"></a>13.查看属性</h4><p>1、选中左侧菜单树对应的元素，在右下角查看对应属性</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ehXAbOUrymoi3H9.png" alt="1232840-20190624143355644-1001344577.png"></p><h4 id="14-常见异常"><a href="#14-常见异常" class="headerlink" title="14.常见异常"></a>14.常见异常</h4><p>1、在使用过程中，你会发现经常会报以下这个错误</p><p>2、每次启动都会给你手机上重新安装一次应用</p><p>3、并且不能用鼠标指定某个元素，没有uiautomatorviewer使用方便</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Vc3SJNL5pQskWBd.png" alt="1070438-20170429140010631-199327453.png"></p><p>（要是以上三种问题你都遇到了，怎么办？？？那就放弃吧！！！）​</p><p>相信很多人在使用过程中，都会遇到中文无法输入问题，宏哥在后续文章里会手把手教大家如何输入中文。</p><h4 id="15-小结"><a href="#15-小结" class="headerlink" title="15.小结"></a>15.小结</h4><p>Android SDK中的UIAutomator中本身是不支持网页中的UI元素定位，下面介绍几种常用的定位app内部的网页的UI元素的方法。</p><h5 id="一、使用chrome浏览器调试移动端网页"><a href="#一、使用chrome浏览器调试移动端网页" class="headerlink" title="一、使用chrome浏览器调试移动端网页"></a>一、使用chrome浏览器调试移动端网页</h5><p>这是使用最多的一种方法。首页确保自己的手机已经跟电脑连接且处于开发者模式。</p><p>打开PC端的谷歌浏览器，输入chrome://inspect/#devices，会看到下图所示界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/FkEgfbUjuYn8WCe.png" alt="1063571-20180301160553747-784776548.png"></p><p>点击需要测试的网页下方的inspect，且保证手机界面停留在那个页面。 </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/VUbf8EYLmk5AwtW.png" alt="1063571-20180301161001325-2119759971.png"> </p><p>这样打开后是不是就熟悉了，点击上方红色标记的就可以操作进行定位了~~</p><h5 id="二、Android手机的铺助功能带有TalkBack"><a href="#二、Android手机的铺助功能带有TalkBack" class="headerlink" title="二、Android手机的铺助功能带有TalkBack"></a>二、Android手机的铺助功能带有TalkBack</h5><p> 之前一直用的是谷歌的方法，但是最近发现使用talkback可以直接用UIAutomator定位元素。  </p><p> Android系统一般自带一个TalkeBack功能。但这里千万要注意：打开之后整个系统的操作都变得不同了！！滑动界面需要两个手指，单击变成双击。打开之后用UiAutomatorViewer获取webview界面的内容，你就会发现原来webview里面获取不到的ui元素，现在已经可以可以获取到了。即使现在你关掉TalkBack，也能获取到，除非重启手机才会回到不能获取的状态，所以开启后我们可以立即关闭，以方便操作。有些手机没有talkBack的可以去应用市场下载。</p><p>功能路径：<br>原生系统：设置 – 辅助功能(Accessibility) – TalkBack<br>华为EMUI系统：设置 – 高级设置 – 辅助功能 – TalkBack</p><h5 id="三、宏哥在小弟哪里遇到的问题"><a href="#三、宏哥在小弟哪里遇到的问题" class="headerlink" title="三、宏哥在小弟哪里遇到的问题"></a>三、宏哥在小弟哪里遇到的问题</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ytYHX13LpBxZS9e.png" alt="1232840-20190624141329825-629278191.png"></p><p>查看appium日志的error发现没有设备名字报错</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/N9ZmPTQCIH28Feu.png" alt="1232840-20190624141249859-203274668.png"></p><p>将夜神模拟器的名字加上就成功了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ehXAbOUrymoi3H9.png" alt="1232840-20190624143355644-1001344577.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试8</title>
      <link href="/2016/04/03/appium/"/>
      <url>/2016/04/03/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（八）- 初识琵琶女Appium（千呼万唤始出来，犹抱琵琶半遮面）- 下（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　通过上一篇宏哥给各位小伙伴们的引荐，大家移动对这位美女有了深刻的认识，而且她那高超的技艺和婀娜的身姿久久地浮现在你的脑海里，是不是这样呢？？？不要害羞直接告诉宏哥：是，就对了。宏哥要的就是这个效果。达到这个效果，就说明你学的差不多了，可以出师了。今天继续由宏哥给你引荐这位琵琶美女。</p><p>说明：Appium–奴家的大号，提起奴家的大号在江湖上也是无人不知，无人不晓。奴家==Appium；</p><h4 id="2-界面认识（奴家外表）"><a href="#2-界面认识（奴家外表）" class="headerlink" title="2.界面认识（奴家外表）"></a>2.界面认识（奴家外表）</h4><p>　　在之前安装appium的时候说过我们有两种方法安装，也就有两种结果，一种是有界面的（客户端安装），一种是没有界面的（终端安装），首先我们先讲一下有界面的，以及界面有哪些东西。</p><p>　　首先和宏哥看一下琵琶女的外表，如果你的是windows系统那么界面就应该是这样的，所以当你发现你的和我的琵琶女不一样也不用担心，这个就是所谓的“龙生九子，各有不同”，但是正常windows版整个界面只有7个按钮，宏哥会按照从左到右从上到下的顺序讲。</p><p>（mac的会有一定的差异，但并不是很大，只是排版和样式的问题，但是功能都一样。）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/lJ8dMIqCwZja2Yh.jpg" alt="imageview.jpg"></p><h5 id="1）Android-Settings"><a href="#1）Android-Settings" class="headerlink" title="1）Android Settings"></a>1）Android Settings</h5><p>Android Settings:左边的第一个按钮，主要是配置android的相关设置，他里面的结构图我们看下张图片</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/upU4OCKwQfzPIGL.jpg" alt="imageview _1_.jpg"></p><p>a.Application Path：选择路径，选择需要测试的app在本电脑存放的一个路径。在启动appium时他会默认去该路径下去寻找这个app，然后将他安装到指定的手机上。</p><p>b.Package：之前提到过的，我们这个包的身份证，我们需要通过这个去找到包，不然我们安装后我们通过什么去辨别这些包呢？</p><p>c.Launch Activity：故名思义，启动的activity，activity的时候提到过，我们启动app时需要去运行的activity，这里我们填写首次启动页面的activity。</p><p>备注：这里需要注意一个问题在我们每次通过Choose选择apk后，appium会自动把这个包进行重新签名，那么在package以及activity里面会自动把包名和activity的名称列进去，但是这里会出现一个问题，每次选择apk后列表中会有一个缓存的原因，即使你更改了apk，但是package还是没有变，这样启动的时候就一直报错，遇见这样的情况不要着急，重新启动两次就好。</p><p>d.Wait for Activity: 和上面的差不多，意思是等待某个Activity打开，用的时间不是很多，做了解。</p><p>e.Launch Device：标签下面的东西用得相对比较少，后面大家可以去了解一下。</p><p>f.Capabilities：该标签下和我们做自动化关系很大，后面我们做自动化时如何配置启动app等信息就用的该标签下的数据。         </p><p>g.Platform Name：我们测试的app的类型，ios选择ios，android选择Android就好。</p><p>h.Automation Name：测试引擎的名称，我们使用的是appium，所以你第一眼就能看见Appium，但是他还有一个Selendroid。可能看到这里会有一些疑惑，为什么appium要选择两套系统呢？其实这个应该追溯到android的版本问题，android自己的工具在4.2版本以前是一个，但是后面进行了更新，可能也正是因为这个原因appium也才采用了两套，所以当你测试的app安装的机器时在4.0或之前的版本时那么这里的引擎你就必须选择Selendroid，是否这样大家可以动手去试一试。检验真理的唯一标准就是自己动手尝试。</p><p>i.Platform Version：安装应用手机的版本号，android的是几点几的版本。</p><p>j.Device Name：设备名称。</p><p>备注：这里会有一个问题，如果你测试android时，只把一台手机插入到电脑，即使你输入的Device Name是错误的，但是你依然能够正常安装，使用。但是ios是不行的。不知道在设计的时候是否就是如此考虑的，如果在以后使用中遇见类似问题大家不要惊慌。</p><p>k.Advanced标签下的东西在初级阶段不用担心，这个标签只是在你想同一台电脑同时控制多台手机的时候才能使用，需要更改Bootstrap Port的端口号，记住这一点就好。</p><h5 id="2-General-Setting"><a href="#2-General-Setting" class="headerlink" title="2)General Setting"></a>2)General Setting</h5><p>在General Setting里面在通常情况下我们使用默认设置就好，但还是有一些基础设置可以进行调整，方便后期的学习。整个页面分成了Server和log两部分，默认的情况如下面图片。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ro9U1smcvTC6Iwl.jpg" alt="imageview _2_.jpg">        </p><p>a.Server Address：配置appium服务的地址，正常情况我们不需要更改，但是如果我们需要配置多台手机的时候启动了多个appium服务，那么这里的端口号我们需要进行调整，如果你多个都弄的同一个端口会报错。</p><p>b.Override Existing Session：session覆盖，可能对于初学者不理解什么叫session，你这里暂时理解为会话，我和你会话的唯一标示。</p><p>c.Log To File：默认状态是没有任何数据，但是在做自动化时建议选择，因为选择之后appium在运行时产生的日志都会保留到你设置的问题件，这个对后期的bug定位有相当大的帮助。切记！</p><p>3)开发者设置（左边第三个按钮,小人图标）很少用，可以忽略。如果有兴趣可以作为兴趣了解一下。</p><p>4)关于（左边第四个按钮，问号图标），查看当前appium的版本信息。</p><p>5)元素侦测（右边第二个按钮，放大镜图标）：这个按钮的功能和firebug的定位工具功能类似，但是他还有一个功能，他会检测你的各个系统配置是否正确，如果前面各项参数不正确时，使用该功能会报错。如果你不正常连接手机也不行。还是建议用sdk工具里面自带的uiautomatorviewer。</p><p>6)启动服务（右边第一个按钮，三角图标）：所有参数配置好后你需要做的就是启动appium服务，只有启动之后你才能够做自动化。</p><p>7)清除日志（右下角，垃圾桶图标）：在写脚本、调试过程中会产生很多的日志，但是你可能想看的只是中间某个时间段的，那么你在这个时候可以将页面的日志清除。</p><h4 id="3-日志分析（奴家语言）"><a href="#3-日志分析（奴家语言）" class="headerlink" title="3.日志分析（奴家语言）"></a>3.日志分析（奴家语言）</h4><p>　　通过前面的学习加上自己动手练习我相信很多小伙伴都能够将appium启动起来，并且会自动将app安装到手机或者模拟器，但是这个时候很多人看见appium的面板或者控制台会比较头疼。appium服务页面不断的在滚动日志，但是又看不懂，这个可能是通病。下面我们来分析一下这个日志，我们下面大概来解读一下我这个日志，让自己不再迷茫。在每一行的上面我来配置解读，让大家更容易理解。</p><p>我启动appium服务，指定了ip、端口、以及我的uid</p><pre><code>192:~ ytxu$ appium -a 127.0.0.1 -p 4723 -U 127.0.0.1:62001</code></pre><p>启动成功</p><pre><code>[Appium] Welcome to Appium v1.6.3[Appium] Non-default server args:</code></pre><p>启动成功后的服务地址</p><pre><code>[Appium]   address: ‘127.0.0.1&#39;</code></pre><p>我们的uid，因为我这里是链接的模拟器所以用的这个IP</p><pre><code>[Appium]   udid: &#39;127.0.0.1:62001&#39;[Appium] Deprecated server args:</code></pre><p>系统自动拼接成字典的形式</p><pre><code>[Appium]   -U,--udid =&gt; --default-capabilities &#39;{&quot;udid&quot;:&quot;127.0.0.1:62001&quot;}&#39;[Appium] Default capabilities, which will be added to each request unless overridden by desired capabilities:[Appium]   udid: ‘127.0.0.1:62001&#39;</code></pre><p>REST http接口监听的是哪个端口</p><pre><code>[Appium] Appium REST http interface listener started on 127.0.0.1:4723</code></pre><p>通过POST的方式创建了一个session，这个session里面的值就是我们在配置app时的一些数据，这里系统把他自动转换成了字典的形式，一个key对应一个value。仔细去看你会发现都不陌生。</p><pre><code>[HTTP] --&gt; POST /wd/hub/session {&quot;requiredCapabilities&quot;:{},&quot;desiredCapabilities&quot;:{&quot;deviceName&quot;:&quot;127.0.0.1:62001&quot;,&quot;app&quot;:&quot;/Users/ytxu/Desktop/AppiumPython/apps/mukewang.apk&quot;,&quot;autoLaunch&quot;:&quot;true&quot;,&quot;platformVersion&quot;:&quot;4.1&quot;,&quot;appPackage&quot;:&quot;cn.com.open.mooc&quot;,&quot;platformName&quot;:&quot;Android&quot;,&quot;appActivity&quot;:&quot;cn.com.open.mooc.index.splash.MCSplashActivity&quot;}}[debug] [MJSONWP] Calling AppiumDriver.createSession() with args: [{“deviceName&quot;:&quot;127.0.0.1:62001&quot;,&quot;app&quot;:&quot;/Users/ytxu/Desktop/AppiumPython/apps/mukewang.apk&quot;,&quot;autoLaunch&quot;:&quot;true&quot;,&quot;platformVersion&quot;:&quot;4.1&quot;,&quot;appPackage&quot;:&quot;cn.com.open.mooc&quot;,&quot;platformName&quot;:&quot;Android&quot;,&quot;appActivity&quot;:&quot;cn.com.open.mooc.index.splash.MCSplashActivity&quot;},{},null,null,null]</code></pre><p>创建一个会话，准备开始对话，把开始填写的数据，传入数据后用服务端验证，如果成功就会话开始。</p><pre><code>[Appium] Creating new AndroidDriver session[Appium] Capabilities:[Appium]   deviceName: &#39;127.0.0.1:62001&#39;[Appium]   app: &#39;/Users/ytxu/Desktop/AppiumPython/apps/mukewang.apk&#39;[Appium]   autoLaunch: &#39;true&#39;[Appium]   platformVersion: &#39;4.1&#39;[Appium]   appPackage: &#39;cn.com.open.mooc&#39;[Appium]   platformName: &#39;Android&#39;[Appium]   appActivity: &#39;cn.com.open.mooc.index.splash.MCSplashActivity&#39;[Appium]   udid: &#39;127.0.0.1:62001&#39;[debug] [AndroidDriver] AndroidDriver version: 1.10.38</code></pre><p>看到这里你是否还觉得这个很麻烦？其实只要你仔细去看你会很容易都了解的。可能这里会有小伙伴说这个启动的很容易，但是在实际中遇见的问题就没这么容易了，那么下面我们看一个实际遇见的问题，直接看日志：</p><pre><code> 1 debug] [ADB] We tried to start an activity that doesn&#39;t exist, retrying with . prepended to activity 2  3 [debug] [ADB] Device API level: 19 4  5 [debug] [ADB] Getting connected devices... 6  7 [debug] [ADB] 1 device(s) connected 8  9 [debug] [ADB] Running &#39;/Users/ytxu/Library/Android/sdk/platform-tools/adb&#39; with args: [&quot;-P&quot;,5037,&quot;-s&quot;,&quot;127.0.0.1:62001&quot;,&quot;shell&quot;,&quot;am&quot;,&quot;start&quot;,&quot;-W&quot;,&quot;-n&quot;,&quot;cn.com.open.mooc/.cn.com.open.mooc.aindex.splash.MCSplashActivity&quot;,&quot;-S&quot;,&quot;-a&quot;,&quot;android.intent.action.MAIN&quot;,&quot;-c&quot;,&quot;android.intent.category.LAUNCHER&quot;,&quot;-f&quot;,&quot;0x10200000&quot;]10 11 [ADB] Error: Activity used to start app doesn&#39;t exist or cannot be launched! Make sure it exists and is a launchable activity12 13     at Object.wrappedLogger.errorAndThrow (lib/logger.js:60:13)14 15     at ADB.callee$0$0$ (../../../lib/tools/apk-utils.js:68:13)16 17     at tryCatch (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:67:40)18 19     at GeneratorFunctionPrototype.invoke [as _invoke] (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:315:22)20 21     at GeneratorFunctionPrototype.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:100:21)22 23     at GeneratorFunctionPrototype.invoke (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:136:37)24 25  Error: Activity used to start app doesn&#39;t exist or cannot be launched! Make sure it exists and is a launchable activity26 27     at Object.wrappedLogger.errorAndThrow (lib/logger.js:60:13)28 29     at ADB.callee$0$0$ (../../../lib/tools/apk-utils.js:68:13)30 31     at tryCatch (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:67:40)32 33     at GeneratorFunctionPrototype.invoke [as _invoke] (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:315:22)34 35     at GeneratorFunctionPrototype.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:100:21)36 37     at GeneratorFunctionPrototype.invoke (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:136:37)38 39 [ADB] Error: Error occured while starting App. Original error: Activity used to start app doesn&#39;t exist or cannot be launched! Make sure it exists and is a launchable activity40 41     at Object.wrappedLogger.errorAndThrow (lib/logger.js:60:13)42 43     at ADB.callee$0$0$ (../../../lib/tools/apk-utils.js:80:9)44 45     at tryCatch (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:67:40)46 47     at GeneratorFunctionPrototype.invoke [as _invoke] (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:315:22)48 49     at GeneratorFunctionPrototype.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:100:21)50 51     at GeneratorFunctionPrototype.invoke (/usr/local/lib/node_modules/appium/node_modules/babel-runtime/regenerator/runtime.js:136:37)52 53  Error: Error occured while starting App. Original error: Activity used to start app doesn&#39;t exist or cannot be launched! Make sure it exists and is a launchable activity54 55     at Object.wrappedLogger.errorAndThrow (lib/logger.js:60:13)</code></pre><p>　　从第一眼看见这个日志我知道大家的第一反应已经晕了，没事我们来仔细看。就日志的第一行说的大概意思就是“我们尽力去运行这个Activity了，但是他还是不存在。”那么看到这里小伙伴应该思考一个问题，在前面配置页面时就讲过如果你配置package或者activity错误那么是无法启动的。现在已经告诉我们说这个Activity不存在了是否应该去仔细检查一下呢？</p><p>　　其实在整个日志中我们应该直接去看error的部分，[ADB] Error: Activity used to start app doesn’t exist or cannot be launched! Make sure it exists and is a launchable activity，这是error的日志，给出的提示也是这个activity不能够被启动，让你再次确认后再去启动。</p><p>从这个小小的实验我们能够看出日志本身并不难，难的是我们没仔细看。所以以后遇见问题不要烦躁，应该仔细看日志，然后解决问题。</p><h4 id="4-appium的工作原理（奴家的看家本领）"><a href="#4-appium的工作原理（奴家的看家本领）" class="headerlink" title="4.appium的工作原理（奴家的看家本领）"></a>4.appium的工作原理（奴家的看家本领）</h4><p>　　我们在去熟悉一套系统或者框架的时候，我们想去学好，我们是不是都要了解一下工作原理呢？只有我们知道了他是如何工作之后，在以后我们遇见棘手的问题时才能够从根本去解决问题。但是在讲这个之前需要讲一个题外话，不知道有谁思考过appium是如何实现自动化的吗？无论ios还是android在做自动化时考虑到安全等因素他们都是不允许直接去操作的，所以我们要做自动化那么就必须借助他们本身公布出来的一些工具，android是UIAutomator，ios使用的是UIAutomation，其实我们所谓的自动化就是我们使用的工具去调用他们公布出来的框架的方法，然后再去执行。下面我们来看一下appium的工作原理，首先来看一张图片。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/FlMLxI6EOwHnNgd.jpg" alt="imageview _3_.jpg"></p><p>　　通过上面的图片我们可以知道appium是基于WebDriver协议的，他利用Bootstrap调用google公布的android的自动化测试框架UIautomator的命令来实现我们的app自动化，再能理解一点就是我们的电脑（client）上运行自动化测试脚本，调用的是webdriver的接口，appium server接收到我们client上发送过来的命令后他会将这些命令转换为UIautomator认识的命令，然后由UIautomator来执行自动化。</p><p>　　可能这里有些小伙伴会迷糊，说android是这样那么ios也是这样吗？其实真的差不多，只是他们支持的工具不一样，ios使用的是UIAutomation，首先client发送脚本请求，再到我们的appium服务，这里appium会调用instruments去启动一个server，然后让他去执行后面的操作来完成自动化。备注：UIAutomation是instruments下面的一个工具，所以不要惊慌。</p><h4 id="5-Appium的优势（奴家优点）"><a href="#5-Appium的优势（奴家优点）" class="headerlink" title="5.Appium的优势（奴家优点）"></a>5.Appium的优势（奴家优点）</h4><p>　　现在市面上做自动化的框架无论是成熟还是一般的都有很多，我们不可能都去熟悉，但是我们需要了解一个常见的，不然你怎么知道好与坏呢？我相信在学习自动化时就想过为什么需要学appium，其实我在刚开始做移动自动化时选择的是robotium，但是后来因为项目的需要发现我如果只是用robotium发现ios根本没法做，那么我就需要去单独做一个，这个会很麻烦，这个时候appium刚好出来了，刚接触他我就决定使用了，因为在之前做web自动化时用的就是selenium，所以这个用起来会很方便。下面我们来列举一下他的优点：</p><p>1、可以同时支持android、ios</p><p>2、支持多种语言，java、python、php、Ruby等等</p><p>3、不用为复杂的环境发愁</p><p>4、如果你有selenium经验，直接上手</p><p>从上面来看他的优点还是很多的，当然缺点也有，这里不列举了，免得破坏美好的印象。</p><p>当看到这里的时候你对奴家（appium）是否已经有一个更加清晰的影子了呢？接下来我们需要的就是去动手实战吧。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、appium mac和windows下都有两种安装模式，一种是通过客户端安装，一个是终端安装，这里说一下区别：</p><p>做自动化肯定不可能只是在一台机器上做自动化，因为那样的意义并不是很大，所以很多时候我们都是链接多台电脑去执行，但是appium去链接多台电脑时就需要启动多个appium的服务，如果说你安装是通过客户端去安装的，你链接多台机器就需要启动多次，配置多次，这样对你电脑本身也是一个性能考验。如果你是通过终端命令安装的在启动的时候你只需要通过命令启动多个服务就好。这里为什么说这么多，就是因为曾经作者在做一个项目时统一体啊机器上appium客户端启动了5个，长期运行case后appium的服务会自动挂掉，但是通过终端安装启动超过10个服务，同时去运行依然没有问题。这是我的经历不一定全对，读者可以根据自己爱好进行选择。</p><p>appium客户端安装：</p><p>（1）去官方下载：<a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io/</a>  比较慢，相比之下慢，其实宏哥这边还是嗖嗖的很快地</p><p>（2）国内下载：链接: <a href="https://pan.baidu.com/s/1SqGzEFzWfNjyQBE1lsiKOw" target="_blank" rel="noopener">https://pan.baidu.com/s/1SqGzEFzWfNjyQBE1lsiKOw</a> 提取码: 48af （贼快，推荐）</p><p>现在安装包后直接傻瓜式的安装，一切下一步，默认即可。（windows也是一样）</p><p>appium终端安装：</p><p>直接在终端输入命令：npm install -g appium。（切记不要用sudo去执行） 在安装过程中不报错，你就安装成功了，报错也不要着急，可以百度解决，也可以联系我。appium命令安装默认的是在国外去请求，因为n多原因你失败了，so建议使用如下命令 访问国内的镜像安装npm –registry <a href="http://registry.cnpmjs.org" target="_blank" rel="noopener">http://registry.cnpmjs.org</a> install -g appium  成功后输入appium会提示： Welcome to Appium 说明安装成功了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试7</title>
      <link href="/2016/04/02/selenium/"/>
      <url>/2016/04/02/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（七）- 初识琵琶女Appium（千呼万唤始出来，犹抱琵琶半遮面）- 上（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　“千呼万唤始出来，犹抱琵琶半遮面”，经过前边的各项准备工作，终于才把appium这位琵琶女请出来。那么下边就由宏哥给各位看官、小伙伴们和童鞋们来引荐这位美女（帅哥）。这一篇主要是对前边的内容做一个小小的总结，我们不能只顾得埋头拉车，不记得抬头看路可不行哦！</p><p>说明：Appium–奴家的大号，提起奴家的大号在江湖上也是无人不知，无人不晓。奴家==Appium；</p><h4 id="2-奴家自我介绍"><a href="#2-奴家自我介绍" class="headerlink" title="2.奴家自我介绍"></a>2.奴家自我介绍</h4><p>奴家是一款开源的自动化测试工具，奴家可以支持iOS和安卓平台上的原生的，基于移动浏览器的，混合的应用（APP）。</p><p>1、 请奴家来进行弹奏的好处（使用appium进行自动化测试的好处）</p><p>奴家在不同平台中使用了标准的自动化APIs，所以在跨平台时，不需要重新编译或者修改自己的应用。</p><p>奴家支持Selenium WebDriver支持的所有语言，如java、Object-C、JavaScript、Php、Python、Ruby、C#、Clojure，或者Perl语言，更可以使用Selenium WebDriver的Api。Appium支持任何一种测试框架.Appium实现了真正的跨平台自动化测试。（本文主要介绍Python的用法）</p><p>2、奴家的五脏六腑（Appium架构）</p><pre><code>  奴家是一个用Node.js编写的HTTP server，它创建、并管理多个 WebDriver sessions 来和不同平台交互，如 iOS ，Android等等.   奴家开始一个测试（一曲弹奏）后，就会在被测设备--琵琶（手机）上启动一个 server ，监听来自 Appium server（看官、观众）的指令. 每种平台像 iOS 和Android都有不同的运行、和交互方式。所以奴家会用某个桩程序“侵入”该平台，并接受指令，来完成测试用例的运行（曲谱的弹奏）。</code></pre><p>琵琶女： 下面奴家把时间交还给宏哥，让宏哥继续来引荐奴家。</p><p>宏哥：好了各位看官、小伙伴们和童鞋们不要再盯着美女了，把头往宏哥这边转一转，把目光往宏哥这边汇聚一下。</p><p>宏哥：哎哎哎，说你了，把头转到宏哥这边，听宏哥给您慢慢道来，哎哎哎，对！不要看别人说的就是你。</p><p>宏哥：好了，你们都这样，宏哥就不废话了，还是把头转回去。直接开始正题，进行移动端自动化测试实战（琵琶弹奏-十面埋伏）</p><h4 id="3-奴家实战技艺（以真机-lt-琵琶-gt-为例）"><a href="#3-奴家实战技艺（以真机-lt-琵琶-gt-为例）" class="headerlink" title="3.奴家实战技艺（以真机&lt;琵琶&gt;为例）"></a>3.奴家实战技艺（以真机&lt;琵琶&gt;为例）</h4><p>各位看官这里是给大家列举的一些琵琶女的指法（命令）</p><pre><code>aapt dump badging D:\XXX.apk  获取安装包的所有信息adb devices（查看手机是否连接到电脑）adb shell pm list packages：列出所有的包名，找到所查看包的包名。adb shell dumpsys package com.android.XXX：查看某个包的具体信息</code></pre><p>其它：</p><pre><code>adb devices：查看Android设备是否连接到电脑。adb shell dumpsys activity：查看当前运行的是哪个activity,运行的一些进程等adb shell dumpsys activity activitiesadb shell pm list packages：列出所有的包名。adb shell dumpsys package：列出所有的安装应用的信息adb shell dumpsys package com.android.XXX：查看某个包的具体信息adb shell dumpsys activity | grep mFocusedActivity：查看当前resume的是哪个activityadb logcat | grep ActivityManager：查看当前正在运行的Activityadb logcat | grep Displayed：查看当前正在运行的Activity</code></pre><p>1、 连接真机或者模拟器 – 这里是琵琶女手指和琵琶如何接触连接</p><p>1）连接手机时注意选择手机的开发者模式，cmd打开命令行窗口，输入adb devices获取到设备的deviceName。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/6kotRSnm7ZPLJ2X.png" alt="1232840-20190619103751758-1707327553.png"></p><p>2）启动模拟器，连接模拟器AVD（Google自带），cmd打开命令行窗口，输入adb devices获取到设备的deviceName</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/RVi6pfUDIgZJewt.png" alt="1232840-20190619105318119-270266549.png"></p><p>3）启动模拟器，连接夜神模拟器，要注意先输入  nox_adb.exe connect 127.0.0.1:62001（相当于插入数据线），再继续，输入adb devices</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/q5olUDcjwreFG7k.png" alt="1232840-20190619104637455-153639092.png"></p><p>2、获取Activity（获取曲谱中曲调，就和我们现在音乐中的“到瑞秘法扫垃圾”差不多）</p><p>1）cmd打开命令行窗口，输入aapt dump badging D:\XXX.apk（xxx指安装包名，D:\是指路径）直接查看需要测试app安装包的具体信息。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/bP9JDSA1MIKgqUi.png" alt="1232840-20190614155149448-1723130700.png"></p><p>2）标记的就是包名，继续往下拖拽，可以找到activity的信息。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/4kTPbZHqzSshUKR.png" alt="1232840-20190614155232548-285018810.png"></p><p>这里的红圈就可以看到activity的信息。这两个值，在appium脚本中都需要提前获取到，所以需要提前介绍这个获取方法。如果你觉得在cmd里面不好看，你可以把cmd信息导出到一个txt文件，例如 aapt dump badging shoujibaidu.apk &gt; 123.txt 回车后，会在桌面生成一个123.txt文件，你可以打开，通过查询找到这些信息。通过上面的方法，只要我们有android SDK环境，那么我们就可以获取到任意一个包的包名和Activity信息。</p><p>3、启动Appium </p><p>1）  双击桌面上的appium图标打开，点击Android Settings进行设置。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Y5cL4nRtqyjGoVk.png" alt="1232840-20190619110047431-1859703806.png"></p><p>2）将上方获取到的真机的deviceName填入 ，选择platformName和platformVersion</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/plb1TEQaKW23JU8.png" alt="1232840-20190619110548074-674886506.png"></p><p>3）将服务的session配置成可重写（非必要的配置）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/SfUAHOyG1VWi5bX.png" alt="1232840-20190619110717846-493778346.png"></p><p>4）配置好后，点击右上角的启动按钮进行启动即可。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/aF1T2L98AoYZ3xQ.png" alt="1232840-20190619110827187-788752480.png"></p><p>5）启动成功，下一步该写代码了。</p><p>4、将上方得到的设备和安装包信息写入脚本中</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-6-19 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:初始琵琶女appium 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 import time13 desired_caps = {}14 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa15 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号16 desired_caps[&#39;deviceName&#39;] = &#39;emulator-5554&#39;    #手机设备名称，通过adb devices  查看17 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名18 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity19 # desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串20 # desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来</code></pre><p>5、查找app定位元素</p><p>1）启动Android SDK中的一个神器可以查找app的定位元素进行脚本的编写。在Android SDK中的tools中有一个uiautomatorviewer.bat，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/4n7f1oedmjOtSa2.png" alt="1232840-20190619111411997-94911353.png"></p><p>2）点击uiautomatorviewer.bat进行启动，左上角一共四个按钮，作用分别是打开本地文件（open）、Device Screenshot (uiautomator dump)dump页面、dump压缩格式的页面、保存；启动后点击左上角第三个图标进行真机界面的呈现。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/twYAX1NbBulExkg.png" alt="1232840-20190619112715187-276626247.png"></p><p>3)选择设备模拟器或者真机</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/OyoVkhbK5UL4eNt.png" alt="1232840-20190619112934908-60124758.png"></p><p>4）第一次连接会比较慢，耐心等候一下，连接好后以后就快了。我这里以百度界面为例。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/3CRKiySGro1EUsV.png" alt="1232840-20190619114348531-1591437863.png"></p><p>这是连接夜神模拟器后的界面显示。这样就可以根据id、class、text等定位元素进行定位了。</p><pre><code>1 driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)2 driver.find_element_by_id(&quot;index-kw&quot;).click()3 driver.find_element_by_id(&quot;index-kw&quot;).clear()4 driver.find_element_by_id(&quot;index-kw&quot;).send_keys(&#39;appium测试&#39;)5 6 7 driver.find_element_by_id(&quot;index-bn&quot;).click()8 9 driver.quit()</code></pre><h4 id="4-以淘宝APP为实例"><a href="#4-以淘宝APP为实例" class="headerlink" title="4.以淘宝APP为实例"></a>4.以淘宝APP为实例</h4><p>1、实例代码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/xb7EDi6gPSjQOsK.png" alt="1232840-20190619144459786-1926403195.png"></p><p>2、代码运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/4us2Z7QpehbkayT.png" alt="1232840-20190619145623724-705313216.png"></p><p>3、appium运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/a6iLpyUG9EdDOgh.png" alt="1232840-20190619145648773-485339275.png"> </p><p>4、模拟器运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/CA3E5wreJFsfdIK.png" alt="1232840-20190619145747986-545715058.png"></p><p>5、参考代码</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-6-19 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用python代码appium+pycharm+连接夜神模拟器 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 import time13 desired_caps = {}14 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa15 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号16 desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看17 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名18 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity19 #desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串20 #desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来21 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息22 # 休眠五秒等待页面加载完成23 time.sleep(5)24 25 driver.find_element_by_id(&quot;com.taobao.taobao:id/home_searchedit&quot;).click()26 time.sleep(4)27 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).clear()28 time.sleep(3)29 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchEdit&quot;).send_keys(&quot;琵琶&quot;)30 time.sleep(2)31 driver.find_element_by_id(&quot;com.taobao.taobao:id/searchbtn&quot;).click()32 33 # driver.quit()</code></pre><p>至此运行脚本即可进行自动化测试。（琵琶女弹奏结束，响起来雷鸣般的掌声，琵琶女双手抱拳，豪气十足退出舞台）</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>1、adb.exe connect 127.0.0.1:62001和nox_adb.exe connect 127.0.0.1:62001的效果是一样的，前提就是你已经配置好系统变量和解决了版本冲突。</p><p>2、好了有关appium的总结就到这里了，欲知后事如何，且听下回分解。嘿嘿！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试6</title>
      <link href="/2016/04/01/appium/"/>
      <url>/2016/04/01/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（六）- 连接模拟器并启动淘宝APP（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇讲解完模拟器的安装、配置好以后，就好比我们手机已经买好，并且系统已经做好了，就差我们用数据线和电脑连接开始实战了，这篇宏哥就带着小伙伴们和童鞋们趁热打铁，讲解和分享一下如何连接模拟器（电脑版的虚拟手机），然后再安装一款APP-淘宝为例。</p><h4 id="2-appium-pycharm-连接夜神模拟器并启动淘宝APP（推荐）"><a href="#2-appium-pycharm-连接夜神模拟器并启动淘宝APP（推荐）" class="headerlink" title="2.appium+pycharm+连接夜神模拟器并启动淘宝APP（推荐）"></a>2.appium+pycharm+连接夜神模拟器并启动淘宝APP（推荐）</h4><p>1、首先打开pycharm并写好代码，这里以淘宝APK作为测试Demo,淘宝APK我是放在电脑桌面（或者放置同代码同个目录下）。如下图所示</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/o8pxDKa7wgGhvVf.png" alt="1232840-20190614133223166-1997966576.png"></p><p>其中：driver = webdriver.Remote(‘<a href="http://127.0.0.1:4723/wd/hub&#39;,desired_caps" target="_blank" rel="noopener">http://127.0.0.1:4723/wd/hub&#39;,desired_caps</a>)     #这个地址是怎么来的呢？，见appium设置项，如下图所示</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/r7kJInaSl6tcNgd.png" alt="1232840-20190614130754479-2050021808.png"></p><p>2、打开appium并点击右上角三角符号，如下图所示</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/JUtqxPQzlXR3eWG.png" alt="1232840-20190614130851633-301144956.png"></p><p>3、打开夜神模拟器，如下图所示</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/P7Joe4FYalAqtH1.png" alt="1232840-20190614130959799-1465457262.png"></p><p>4、打开CMD，进入夜神模拟器的安装路径下：D:\software\nox\Nox\bin，运行指令：nox_adb.exe connect 127.0.0.1:62001和指令adb devices查看设备名，如下图所示</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Ai3TtcEV68vFwpl.png" alt="1232840-20190614105151711-1641495799.png"></p><p>5、运行pycharm代码，并查看结果，如下图所示（暂时不理会出错问题，后续会讲解）但是在模拟器看到新增了两个小机器人，就表示已经成功了：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/NqGL4JU6WmicQoE.png" alt="1232840-20190614133122452-461366459.png"></p><p>6、参考代码</p><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-04-01@author: 北京-宏哥   QQ交流群：707699217Project:学习和使用python代码appium+pycharm+连接夜神模拟器&#39;&#39;&#39;# 3.导入模块from appium import webdriverimport timedesired_caps = {}desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipadesired_caps[&#39;platformVersion&#39;] = &#39;4.4.2&#39;  #android系统的版本号desired_caps[&#39;deviceName&#39;] = &#39;127.0.0.1:62001&#39;    #手机设备名称，通过adb devices  查看desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity# desired_caps[&#39;unicodeKeyboard&#39;] = True  # 使用unicodeKeyboard的编码方式来发送字符串# desired_caps[&#39;resetKeyboard&#39;] = True     # # 将键盘给隐藏起来driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)  ##启动服务器地址，后面跟的是手机信息</code></pre><h4 id="3-appium-pycharm-连接AVD模拟器（不推荐）"><a href="#3-appium-pycharm-连接AVD模拟器（不推荐）" class="headerlink" title="3.appium+pycharm+连接AVD模拟器（不推荐）"></a>3.appium+pycharm+连接AVD模拟器（不推荐）</h4><p>1、第一、二步和连接夜神模拟器一样。</p><p>2、启动AVD模拟器（这个上一篇（传送门）都给小伙伴们演示过了，不清楚的返回头复习一下，即可。相当简单的）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/CqJGETiglQYs8p3.png" alt="1232840-20190617100822376-771919911.png"></p><p>3、 我们在进行测试的时候，我们肯定需要查看设备连接是否成功，设备的信息是否能够获取。adb devices 就可以实现，直接在命令行控制台中输入“ adb devices ”，我们就可以看见如图连接成功：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/IGd5WNiPX3TAQEv.png" alt="1232840-20190617100731495-1930014827.png"></p><p>4、修改代码，将一些模拟器的信息修给了即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/EwbFSaB9CARYWtu.png" alt="1232840-20190617101559575-1653764101.png"></p><p>5、未运行代码前的Google自带的AVD模拟器</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/EmBqkWdDwnGrfp9.png" alt="1232840-20190617101917268-802321437.png"></p><p>6、运行代码后的运行结果</p><p>（1）AVD模拟器：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/sxcPlFBfp2417ZS.png" alt="1232840-20190617102227974-1260259525.png"></p><p> 稍等一会，淘宝APP自动启动了：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/E2OgmIFxtNAQecV.png" alt="1232840-20190617102043178-1386418106.png"> </p><p> 同意协议，淘宝APP就可以在AVD模拟器上，启动起来进入主页</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/6rPCSKqTmVRibux.png" alt="1232840-20190617102134977-73797743.png"></p><p>（2）代码运行结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ZH8J7IXkEKB64j9.png" alt="1232840-20190617102729049-1798336082.png"> </p><p>（3）appium运行结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/3sEI7pKoamuTUzG.png" alt="1232840-20190617102928447-688852325.png"></p><p>（7）参考代码：</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-04-01 7 @author: 北京-宏哥   QQ交流群：707699217 8 Project:学习和使用python代码appium+pycharm+连接夜神模拟器 9 &#39;&#39;&#39;10 # 3.导入模块11 from appium import webdriver12 import time13 desired_caps = {}14 desired_caps[&#39;platformName&#39;] = &#39;Android&#39;   #android的apk还是IOS的ipa15 desired_caps[&#39;platformVersion&#39;] = &#39;8.0&#39;  #android系统的版本号16 desired_caps[&#39;deviceName&#39;] = &#39;emulator-5554&#39;    #手机设备名称，通过adb devices  查看17 desired_caps[&#39;appPackage&#39;] = &#39;com.taobao.taobao&#39;  #apk的包名18 desired_caps[&#39;appActivity&#39;] = &#39;com.taobao.tao.welcome.Welcome&#39;  #apk的launcherActivity19 # desired_caps[&#39;unicodeKeyboard&#39;] = True   #使用unicodeKeyboard的编码方式来发送字符串20 # desired_caps[&#39;resetKeyboard&#39;] = True   #将键盘给隐藏起来21 driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) #启动服务器地址，后面跟的是手机信息</code></pre><p>好了，到此夜神模拟器和AVD模拟器启动淘宝APP，已经全部演示完成，大功告成，降龙十八掌已全部打完，打完收回来。额。。。。。还差一掌才十七掌（亢龙有悔）</p><h4 id="4-小结（亢龙有悔）"><a href="#4-小结（亢龙有悔）" class="headerlink" title="4.小结（亢龙有悔）"></a>4.小结（亢龙有悔）</h4><p>亢龙有悔，将前边十七掌合起来总结一下：</p><p>1、介绍一下，标记的信息，如何填写和查找！</p><p>deviceName：这个是设备名称，可以选择模拟器设置的属性中的IMEI填入，或者手机名称</p><p>udid：这里填写上边让你记住的东西，如果使用其他模拟器或者真机等连接，同样的位置，记下就行</p><p>appPackage和appActivity，教大家一个相对简单的方法来获取，当然也可以采取反编译（app压缩成rar或者zip，然后打开看xml文件）的手段，总之，方法很多！</p><p>进入sdk\build-tools\版本号 的目录下（配置系统变量后就尅不用进入了），cmd命令：</p><p>aapt dump badging C:\apps\xxxxx.apk      （路径\app包名，也就是安装包在你电脑的位置）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/bP9JDSA1MIKgqUi.png" alt="1232840-20190614155149448-1723130700.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/4kTPbZHqzSshUKR.png" alt="1232840-20190614155232548-285018810.png"></p><p>看下，上边标记的就是我们要的两个值！</p><p>至于下边的URL是固定格式，不要研究为什么（千年的王八的蛋，万年龟的屁股——喝一口水淡（蛋）定一下，这是规定（龟腚））！</p><p>开始运行报错了，最后通过上边的方法查看是因为appActivity错误了，修改版本号和appActivity后还是继续报错，说：安装包不存在，然后在appium中配置</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Wt1mspzj5y2Y9aJ.png" alt="1232840-20190617094215818-21312514.png"> </p><p>配置好以后，按上边的步骤运行代码，可以看到appium日志没有报错、运行代码没有报错、成功的将淘宝的安装包安装在夜神模拟器上了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/hSLAJFziTRtwX2d.png" alt="1232840-20190614151405996-2073589646.png"></p><p>2、遇到的坑1：在CMD指令中输入appium，提示如下图所示</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/IfLtdRnkEmojsTB.png" alt="6424670-e21a265a632920a9.png"> </p><p>解决方式：降低nodejs的版本，参考链接cmd中提示appium错误</p><p>3、遇到的坑2：运行appium提示error: Couldn’t start Appium REST http interface listener. Requested port is already in use. Please make sure there’s no other instance of Appium running already.</p><p>解决方式：因为端口被node占用，可以用如下退出node，找出PID命令:：netstat -ano|findstr “7922”   （这个4723是被占用的端口，我们需要先找该占用该端口程序的PID）。停止PID命令：taskkill  /pid[进程码] -t(结束该进程) -f（强制结束该进程以及所有子进程）。</p><p>不知道端口占用的小伙伴们可以看宏哥的这篇查看端口占用的博文：传送门</p><p>4、宏哥可能会问为什么推荐夜神模拟器而不推荐AVD模拟器了，是不是宏哥被夜神收买了，实际不是这样的，因为国内现状就是绝大多数给QA人员配置的电脑不是很高，而那个AVD有需要高配置，否则卡的一比，所以就给小伙伴们推荐夜神了，而不是Google自带的模拟器。当然了如果你的电脑配置高那就按照你的喜好和口味选择适合自己的才是硬道理。</p><p>5、好了，就给小伙伴们介绍这两种就够用了，如用其他的可以参考这一篇文章。都是万变不离其宗。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试5</title>
      <link href="/2016/03/31/appium/"/>
      <url>/2016/03/31/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（五）- 模拟器（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　Appium是做安卓自动化的一个比较流行的工具，对于想要学习该工具但是又局限于或许当前有些小伙伴没 android 手机来说，可以通过安卓模拟器来解决该问题，下面就讲解使用appium连接安卓模拟器的操作步骤。而宏哥是由于手机数据线问题，也只好先用模拟器来替代真机玩了。所以没有安卓手机的大款的小伙伴们不要着急，这时候可以在电脑上开个模拟器玩玩，下面就分别介绍两种不同的模拟器：（1）Google自带的（2）夜神模拟器；他们的安装、配置、连接等等。下面和大家一起学习交流、分享一下。第三篇已经将AVD的操作系统下载好，这一篇将AVD将操作系统安装好，启动即可。</p><h4 id="2-android-模拟器-AVD"><a href="#2-android-模拟器-AVD" class="headerlink" title="2.android 模拟器 AVD"></a>2.android 模拟器 AVD</h4><h5 id="模拟器配置"><a href="#模拟器配置" class="headerlink" title="模拟器配置"></a>模拟器配置</h5><p>1、双击启动 AVD Manager，进入配置界面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/7eZSafJnguDvIMR.png" alt="1232840-20190611144233430-1646291131.png"></p><p>2、点 Create 按钮创建</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/uM1SyQonmchsEZi.png" alt="1232840-20190611144450694-1352965806.png"></p><p>3、配置模拟器基本信息</p><p>–AVD Name:设备名称，自己定义一个，用英文（不要用中文）</p><p>–Device:设备型号，如下图选项意思是，4.7 寸手机，768*1280 分辨率，屏幕密度：xhdpi</p><p>–Target:选对应 API 版本号，Android 版本号 4.4.2，对应 API 版本 19</p><p>–CPU/ABI:cpu 型号</p><p>–Keyboard:这个最好勾选，带键盘按钮</p><p>–Skin:皮肤设置，随意设置</p><p>–Front Camera:前置摄像头，设置为 None</p><p>–Back Camera:后置摄像头，设置为 None</p><p>–Memory Option :RAM 运行内存，设置 512 就行，VM Heap 这个是 app 的运行内存默认设置的 64 就行</p><p>–Internal Storage:手机本身的存储卡大小</p><p>–SD Card：外部 SD 卡的内存</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/O9c6rx4bGoW8RhT.png" alt="1232840-20190612151732351-1830655150.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/24rSFeWqZhGRzAO.png" alt="6424670-710dc1285cf4dd5f.png"></p><p>4、设置好后点 OK 保存，弹出以下界面说明保存成功</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/yLutgJw4PWVZQI2.png" alt="6424670-b1a1f3fec9f300f7.png"></p><p>5、选中上面创建成功的模拟器，点 start 按钮，然后点 Launch 按钮就能启动了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/jXsuVyAbTKYSlN9.png" alt="1232840-20190613152258068-1548799332.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/BU6M1Y54yWxpzJ8.png" alt="1232840-20190612154014612-358541529.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Pk9Uiqyt16guOYI.png" alt="1232840-20190613152342382-197418659.png"></p><p>6、接下来就是耐心等待几分钟（电脑性能不好的等 5-10 分钟），运行成功出现，如下界面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/DO2y3chbpHLrPIF.png" alt="1232840-20190613152536849-580360349.png"></p><p>7、看到上面这个界面说明启动成功了，然后跟平常操作手机一样点点点了，接下来用 adb 工具检查下设备，打开 cmd 输入adb devices</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/d3nASltrjbpK4DI.png" alt="1232840-20190613152713549-843910553.png"></p><p>到这里模拟器就启动成功了，这样替代了真机连数据线去连电脑了.(当然，有Android手机的童靴、小伙伴们也可以直接用真机来测试)</p><h4 id="3-夜神模拟器"><a href="#3-夜神模拟器" class="headerlink" title="3.夜神模拟器"></a>3.夜神模拟器</h4><p>1、下载链接：夜神模拟器版本，下载最新版本即可。你也可以使用Genymotion  （也是国外的网站，需要注册使用-不要去看国内中文网，毛用没有，都是外链，都是坑）</p><p>2、安装过程请自行百度（傻瓜式安装即可），不想百度的可以看宏哥这边</p><p>（1）点击下载链接，进入其官方网站</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/4bc6nzZwY2Veop5.png" alt="1232840-20190613154103460-1812136878.png"></p><p>（2）进入历史版本下载界面，选择你要的版本下载即可，在这里宏哥还是下载最新的</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/cSLu9R46pFOz82f.png" alt="1232840-20190613153142790-1446893256.png"></p><p>（3）双击下载好的安装包</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/DOeUEgQkFHGn5dc.png" alt="1232840-20190613154629764-256548364.png"></p><p>（4）点击“自定义安装”，修改安装目录，当然了也可以默认不修改。然后点击“安装”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/t72T3uzFae5cxvJ.png" alt="1232840-20190613155021998-1063556646.png"></p><p>（5）稍等一会，出现如图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/7gL3EwhNvRsn8AF.png" alt="1232840-20190613155230588-816390729.png"></p><p>3、出现如下图即为安装成功</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/SvE27jyucPpVDRZ.png" alt="1232840-20190613160137457-1939324269.png"></p><p>4、模拟器配置和遇到问题及其解决办法</p><blockquote><p>配置系统环境（老方法这里就不细说了）：在Path中添加D:\software\nox\Nox\bin; （夜神模拟器安装的bin目录）</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/TNK18gSUcpt5wAe.png" alt="1232840-20190613160559804-957347888.png"></p><p>然后进入这个目录下，在地址栏输入cmd，启动cmd，输入nox_adb.exe connect 127.0.0.1:62001（为了adb连接模拟器），可能会出现以下的情况，那就是因为你的adb版本和模拟器中的adb版本不同（图1），而且环境变量配置有问题（图2），所以保证环境变量按照上边写的配置好以后，看下边图1和图2</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Vpl7uo1LzdI3qSE.png" alt="1232840-20190614095237196-669511679.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/kNJShu6vOF2CAr1.png" alt="1232840-20190613171751660-1229128010.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/fQe1MLC2S6URugt.png" alt="1232840-20190614095408363-905587892.png"></p><blockquote><p>验证问题描述情况：（验证之前需要用老方法先配置环境变量，将SDK下的adb所在目录（D:\software\android-sdk-windows\platform-tools）、以及夜神模拟器的adb所在目录（D:\software\nox\Nox\bin）加入了系统的环境变量path中）</p></blockquote><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/qoj2IZln76gkLvd.png" alt="1232840-20190614095714154-1600358529.png"></p><blockquote><p>解决办法：</p></blockquote><p>a、关掉夜神模拟器。同时去任务管理器里看下，adb.exe以及nox_adb.exe这2个进程有没有在运行？有的话就结束掉。</p><p>b、找到SDK的目录，将你的sdk\platform-tools目录下的adb.exe复制出来，改名为nox_adb.exe，然后替换掉模拟器的bin目录下的同名文件！，因为夜神模拟器目录下原本的adb文件名字叫做nox_adb.exe，因此复制过去之后也得改名为nox_adb.exe。</p><p>c、重新启动夜神模拟器，再次进入这个目录下，在地址栏输入cmd，启动cmd，输入  nox_adb.exe connect 127.0.0.1:62001（图3），再继续，输入adb devices，看看是不是连接成功了？（图4）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Vpl7uo1LzdI3qSE.png" alt="1232840-20190614095237196-669511679.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/uTxYNktSMevm5jc.png" alt="1232840-20190614100955014-1750456312.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Ai3TtcEV68vFwpl.png" alt="1232840-20190614105151711-1641495799.png"></p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p> 1、安装AVD的时候有了上一篇的基础，这次还是比较顺利的，基本没有遇到什么问题，安装夜神模拟器的时候那个版本不一致的问题替换了nox_adb.exe之后，输入adb.exe还是报那个kill版本不匹配的错误，着了半天才发现原来在夜神模拟器的bin目录下也有一个adb.exe文件，找到问题所在了</p><p>解决办法：简单暴力，将SDK的adb.exe直接替换夜神模拟器bin目录的adb.exe文件。</p><p>　　好了，就给小伙伴们介绍这两种就给用了，如用其他的可以参考这一篇文章。都是换汤不换药的。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试4</title>
      <link href="/2016/03/30/appium/"/>
      <url>/2016/03/30/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（四）- 如何查看程序所占端口号和IP（超详解）（番外篇）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>这篇博文和分类看似没有多大关系，但是也是从上一篇衍生出来的产物，因为涉及到FQ工具Lantern，就算是给关注和支持的小伙伴们拓展一下眼界和知识面。而且好多人都阅读了上一篇没发现那个参考博客点不开吗？那是因为还没来的急，整理和编写，今天再试一下就可以。</p><p>一个软件可能占用多个端口拥有多个目标IP，下面以FQ工具Lantern为例，说明端口查看方法：</p><h4 id="2-借助第三方软件查看"><a href="#2-借助第三方软件查看" class="headerlink" title="2.借助第三方软件查看"></a>2.借助第三方软件查看</h4><p>如果你电脑上安装了360等优化工具，可能会自带查看网络状况的插件如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/mRaBAsHqtK6QOJZ.png" alt="1232840-20190612102626787-1533407115.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/6JF1q8GHOTXIgil.png" alt="781564-20160704105103858-940500520.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/fk1U3aWLj2AO7Eu.png" alt="781564-20160704105126030-2044383571.png"></p><h4 id="3-命令行窗口查看"><a href="#3-命令行窗口查看" class="headerlink" title="3.命令行窗口查看"></a>3.命令行窗口查看</h4><p>在命令行窗口查看时，可以先查看软件的PID，再通过PID查看端口号：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/8pEFHwQ6hzDqKtN.png" alt="781564-20160704105139858-1382094662.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/lYzQ3oAd6xRCEJX.png" alt="781564-20160704105148702-300288134.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/VQt9kanMgezjwDH.png" alt="781564-20160704105156139-865126725.png"></p><p>注意到此处有两个PID号，那么用哪个去查呢？不确定的话就都试一试…</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Mawpel1yKEQ54g6.png" alt="781564-20160704105204249-919443680.png"></p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>电脑管家查看方法：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/hyPwKZS1FsjCfQ8.png" alt="1232840-20190612102942706-1842490017.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/abqoTAKRvlE8pQL.png" alt="1232840-20190612103025686-1441736484.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/sOuQiWpkneqt7gd.png" alt="1232840-20190612103054712-1111929685.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Al7GFPw4Kpt8CUh.png" alt="1232840-20190612103136287-670450439.png"></p><p>由以上分析可知，一个软件可能会占用多对端口和IP值，那么如果我们需要利用FQ工具设置代理的时候应该填哪对IP和端口呢？宏哥的经验是：</p><h5 id="3-1-排除带有本地宽带IP的那些；"><a href="#3-1-排除带有本地宽带IP的那些；" class="headerlink" title="3.1 排除带有本地宽带IP的那些；"></a>3.1 排除带有本地宽带IP的那些；</h5><h5 id="3-2-排除IP为0-0-0-0的那些；"><a href="#3-2-排除IP为0-0-0-0的那些；" class="headerlink" title="3.2 排除IP为0.0.0.0的那些；"></a>3.2 排除IP为0.0.0.0的那些；</h5><h5 id="3-3-剩下的端口号和IP不确定，那么可以挨个去试，一般也没几对…"><a href="#3-3-剩下的端口号和IP不确定，那么可以挨个去试，一般也没几对…" class="headerlink" title="3.3 剩下的端口号和IP不确定，那么可以挨个去试，一般也没几对…"></a>3.3 剩下的端口号和IP不确定，那么可以挨个去试，一般也没几对…</h5><h5 id="3-4-不同的FQ工具可能查询的方式不一，对于蓝灯有更好的查询方法的话，可以留言讨论"><a href="#3-4-不同的FQ工具可能查询的方式不一，对于蓝灯有更好的查询方法的话，可以留言讨论" class="headerlink" title="3.4 不同的FQ工具可能查询的方式不一，对于蓝灯有更好的查询方法的话，可以留言讨论"></a>3.4 不同的FQ工具可能查询的方式不一，对于蓝灯有更好的查询方法的话，可以留言讨论</h5>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试3</title>
      <link href="/2016/03/29/appium/"/>
      <url>/2016/03/29/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（三）- SDK Manager（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>本来宏哥一开始打算用真机做的，所以在前边搭建环境时候就没有下载SDK，但是由于许多小伙伴通过博客发短消息给宏哥留言说是没有真机，所以顺应民意整理一下模拟器，毕竟“得民心者，得天下”。SDK顾名思义，Android SDK Manager就是一个Android软件开发工具包管理器，就像一个桥梁，连通本地和服务器，从服务器下载安卓开发所需工具到本地。而AVD Manager是一个Android虚拟驱动管理器，主要用来创建安卓模拟器（即手机模拟器）。当然，安卓模拟器所需的镜像（可以理解成模拟器的操作系统）是通过SDK Manager来下载的。所以要想用模拟器，必须先使用SDK下载操作系统。</p><p>　　对于SDK Manager和AVD Manager的使用，还需要一个基础工具包tools提供支持。</p><pre><code>   SDK Manager到有哪些东西是必须安装的呢？首先来看一下某位大神的分享！！！是不是一目了然，震撼人心哦。</code></pre><h4 id="2-详解图"><a href="#2-详解图" class="headerlink" title="2.详解图"></a>2.详解图</h4><p>1、以下图是来自大神的神解释，在许多安卓开发的博客中都可以看到的</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/JSbgeANRZ12M6Ci.png" alt="1070438-20170718223009536-1304967972.png"></p><h4 id="3-SDK-Manager"><a href="#3-SDK-Manager" class="headerlink" title="3.SDK Manager"></a>3.SDK Manager</h4><p>1、双击打开SDK Manager就会出现和大神分享一模一样的界面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/M7eIrfEP9uVFLs5.png" alt="下载.png"></p><p>2、这里我再次啰嗦一下各个工具作用如下</p><p>━━┳Tools目录（必须的工具）：</p><p>　　　　　　┣ ━━Android SDK Tools（必须，只需下载一个版本，一般选最新版本）：基础工具包，版本号带rc字样的是预览版。</p><p>　　　　　　┣ ━━Android SDK Platform-tools（必须，只需下载一个版本，一般选最新版本）：从android2.3开始划出此目录，存放公用开发工具，比如adb、sqlite3等，被划分到了这里。</p><p>　　　　　　┗━━ Android SDK Build-tools（必须，可以安装多个版本）：Android项目构建工具。</p><p>　　　　━━┳Android xxx（API xx）目录（可选的各平台开发工具）：　</p><p>　　　　　　┣ ━━Documentation for Android Sdk（可选）：安卓开发者官网的一些离线文档，不过下载下来打开也很慢。</p><p>　　　　　　┣ ━━SDK Platform（必须）：对应平台的开发工具，需要在哪个版本的平台下开发就下载哪个。</p><p>　　　　　　┣ ━━Samples for SDK（可选，此项在高版本tools中已不提供，需要在IDE里通过Import Sample引入，内置的安卓示例程序，推荐安装。</p><p>　　　　　　┣ ━━Sources for Android SDK（可选）：安卓API的源代码，推荐安装。</p><p>　　　　　　┗━━ xxxxxxxx  Image（可选）：各个以Image结尾的东西是支持相应平台的模拟器，我们就把它想象成一个刷机包吧。（使用真机调试或使用其它模拟器的话不需要安装）</p><p>　　　　━━┳Extras目录（可选的扩展）：</p><p>　　　　　　┣ ━━Android Support Libraries（需要，高版本tools中已不见了，应该是集成到了别的地方）：在低版本平台实现高版本平台控件效果时提供支持。</p><p>　　　　　　┣ ━━Android Support Repository（需要）：主要是方便在gradle中使用Android Support Libraries，因为Google并没有把这些库发布到maven center或者jcenter去，而是使用了Google自己的maven仓库。</p><p>　　　　　　┗━━ Intel x86 Emulator Accelerator(HAXM installer)（可选，但非常需要，需要CPU支持虚拟化技术支持）：windows平台的Intel x86模拟器加速工具，配合Intel x86 atom/atom_64 System Image使用可加快模拟器的运行速度。</p><p>3、由上边可知，Tools里面前三个是必须下载的</p><p>–Android SDK Tools里面有各种实用工具，如：uiautomatorviewer</p><p>–Android SDK Platform-tools里面有adb</p><p>–Android SDK Build-tools里面有aapt</p><p>4、SDK Platform下个最新的就可以了，因为它是可以向下兼容</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/FvU5wajrQpdg6fV.png" alt="下载 _1_.png"></p><p>5、Extras这里选下面三个就行了</p><p>–Android Support Respository 安卓兼容库，必须安装</p><p>–最下面一个安卓模拟器加速器，这个随缘吧，安装不了莫强求</p><p>–其它的看心情了，想安装就安装</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/6URaPyoKBxfbS8Y.png" alt="下载 _2_.png"></p><h4 id="4-android版本"><a href="#4-android版本" class="headerlink" title="4.android版本"></a>4.android版本</h4><p>1、Android的版本这里宏哥选择的是4.4.2（API 19）,当然了你可以选择其他版本的。其它的像Android 4.4w.2这种是手表的，还有一些带TV字样的是电视的，别乱勾选一些无关紧要的。</p><p>2、为了保险起见，这里4.4.2全家桶全部勾选了，其它的版本不需要的话，暂时不用勾选了。不然会不仅用不到、下载时间长。而且下载下来放在那里也是占用空间和资源。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Zq4lW26a7YfVJBP.png" alt="下载 _3_.png"></p><h4 id="5-安装与卸载"><a href="#5-安装与卸载" class="headerlink" title="5.安装与卸载"></a>5.安装与卸载</h4><p>1、勾选需要下载的插件后，点击安装即可，然后就是接受安装协议（Accept License），耐心等待下载完成…</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/HS9Lz75f4IyPeYp.png" alt="下载 _4_.png"></p><p>2、如果已经安装了，后面会有Installed标志,勾选后可以选择右下角“Delete”按钮卸载</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/dP9KxRapSqNgjVZ.png" alt="下载 _5_.png"></p><p>3、注意事项</p><p>注1：Google开头的文件初学一般用不到，而且使用需FQ。</p><p>注2：如果Intel系列模拟器无法使用，就改用ARM模拟器。ARM模拟器缺点是慢….</p><p>注3：关于最后那个模拟器加速器的使用，其只支持Intel x86架构系列模拟器，且下载后还需单独安装一次：</p><p>打开加速器的下载目录：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/U3J8c2Ck4LgXSvY.png" alt="781564-20160627184542296-717019074.png"></p><p>安装加速器（一路点击下一步即可）：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/inroawyZFv5G3uD.png" alt="781564-20160627184535359-485954856.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、如果不能安装勾选的插件，可采用代理的设置。这儿是一个可用的国内SDK镜像代理（仅供下载SDK中的资源）：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ezL1sGp7UEkxCbt.png" alt="781564-20160627203629218-1089688734.png"></p><p>2、设置代理的地方：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/GXzyEMP7Sx4inQR.png" alt="781564-20160627203855218-562834707.png"></p><p>3、对于有FQ查询资料需求的小伙伴，特推荐免费的代理小工具蓝灯（Lantern），有桌面版和移动版：</p><p>工具下载地址：<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a></p><p>注：安装蓝灯后但不开启蓝灯，可能会导致默认浏览器失效。所以建议将电脑默认浏览器设置为不常用的IE。工具下载后，解压双击安装即可…</p><p>既然安装了Lantern，那么如果万一无法更新SDK，则可以利用Lantern来设置代理下载SDK，设置方式如下：</p><p>启动Lantern，获取其代理地址和监听端口（注：你那里的端口可能与我这里的不同）。</p><p>　  参考博文：如何查看程序所占端口号和IP</p><p>设置代理，设置结果如图（不同电脑可能不同）：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Vo5TAtyEQwmJiFN.png" alt="781564-20160704032659781-601168657.png"></p><p>4、安卓开发工具和相关镜像</p><p>5、镜像服务地址：</p><p>1、南阳理工学院镜像服务器地址：mirror.nyist.edu.cn     端口：80</p><p>2、中国科学院开源协会镜像站地址：</p><p>IPV4/IPV6:mirrors.opencas.cn          端口：80</p><p>IPV4/IPV6:mirrors.opencas.org        端口：80</p><p>IPV4/IPV6:mirrors.opencas.ac.cn     端口：80</p><p>3、上海GDG镜像服务器地址：sdk.gdgshanghai.com     端口：8000</p><p>4、北京化工大学镜像服务器地址：</p><p>IPv4:ubuntu.buct.edu.cn/       端口：80</p><p>IPv4:ubuntu.buct.cn/              端口：80</p><p>IPv6:ubuntu.buct6.edu.cn/     端口：80</p><p>5、大连东软信息学院镜像服务器地址：mirrors.neusoft.edu.cn     端口：80</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试2</title>
      <link href="/2016/03/28/appium/"/>
      <url>/2016/03/28/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（二）- 环境搭建—下（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>​    宏哥的人品还算说得过去，虽然很久没有搭建环境了，但是换了新电脑设备，一气呵成，将android的测试开发环境已经搭建准备完毕。上一篇android测试开发环境已经准备好， 那么接下来就是appium的环境安装和搭建了。</p><p>​    嘿嘿！宏哥和小伙伴们开个玩笑，不要觉得自人品不好，就不会成功那都是骗人的。搭建环境和人品半毛钱关系也没有，搭建环境环境安装过程中切勿浮躁，静下心来一个一个慢慢地按照步骤一个个来。</p><p>​    遇到问题解决问题即可。宏哥倒是想遇到问题了，可是问题死活不找宏哥，怕被宏哥KO掉了，当然你们遇到问题可以留言给宏哥，宏哥有时间会给大家一一答疑的。 </p><p>  　环境装好后，可以用真机连电脑，也可以用android-sdk里面的模拟器（当然这个模拟器不是很好用），我一般喜欢真机，真机比较快。 而且模拟器和真机还是有一些差别的。</p><h4 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h4><p>想要和宏哥搭建一样的环境，需要安装包的童鞋可以：（1）扫码关注宏哥公众号，发送：appium环境全家桶，即可下载；（2）直接在微信搜索：北京宏哥关注宏哥公众号，发送：appium环境全家桶，即可下载。</p><p>1、宏哥的环境是Windows 10版本 64位系统（32位的同学自己想办法哦）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Kg4MyY32BLaxcwI.png" alt="1232840-20190605155307021-483968621.png"></p><p>2、1.8.0_181 （64位）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/EBVWD24FCXGPn7t.png" alt="1232840-20190605155358338-999867664 _1_.png"></p><p>3、android-sdk_r24.3.4-windows</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/my8e4DrVJ1jEAtz.png" alt="1232840-20190606092119257-10244535.png"></p><p>4、python:3.7</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/K96yYagDtIOF2HX.png" alt="1232840-20190605170445267-971150713.png"></p><p>5、appium：1.4.16.1</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/e8RJzdbGHwcqIZ4.png" alt="1232840-20190606103201375-1873374407.png"> </p><p>6、Node.js：node-v10.16.0-x64</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/3idXtDr4FM2vCEA.png" alt="1232840-20190606103624134-944043025.png"></p><p>7、Appium-Python-Client</p><h4 id="3-Python安装"><a href="#3-Python安装" class="headerlink" title="3.Python安装"></a>3.Python安装</h4><p>1、宏哥的电脑操作系统：win10 64位系统</p><p>2、下载Python安装包，选择2.7版本和3.7版本都可以，宏哥这里安装的是3.7的，宏哥喜欢新的，但不是喜新厌旧的人哦，这个叫此新非彼新。</p><p>　　官网下载地址：<a href="https://www.python.org/15" target="_blank" rel="noopener">https://www.python.org/15</a></p><p>3、Python安装，双击傻瓜式安装（别安装在c盘哦），不会安装的可以看这里：传送门</p><p>4、宏哥的安装目录在d盘：D:\software\Python\Python37</p><p>5、安装完成后，看下这个目录D:\software\Python\Python37\Scripts，有没pip.exe和easy_install.exe（一般都有）。没有也不要急不要怕：可以重新安装或者自己手动安装一下也是可以的。不会找宏哥！！！</p><p>6、将D:\software\Python\Python37和D:\software\Python\Python37\Scripts，添加到环境变量path下。这里如果在安装的时候勾选上后，就不需要手动配置了，如果紧张忘记了。也不要怕，配置一下就可以了.</p><p>7、打开cmd输入python,出现版本号，然后输入print(“Hello python world!”)</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Fi1VIunjGl3P5bW.png" alt="1232840-20190610090315321-781005181.png"></p><h4 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4.安装node.js"></a>4.安装node.js</h4><p>1、下载官网地址：下载地址：<a href="https://nodejs.org/en/（不会下载的在群文件找吧appium交流QQ群：707699217）" target="_blank" rel="noopener">https://nodejs.org/en/（不会下载的在群文件找吧appium交流QQ群：707699217）</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/bvVWOaJiy98fTBM.png" alt="1232840-20190610091148737-1558808440.png"></p><p>2、下载获取到安装文件后，直接双击安装文件，根据程序的提示，一路傻瓜式安装，完成nodejs的安装（一直下一步就行，可以将路径进行修改）。</p><p>（1）双击安装文件</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Ww5qo6OhcLIHjAE.png" alt="1232840-20190610093142722-1222112824.png"></p><p>（2）点击“运行”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ZfCvkRUup3Gq1ad.png" alt="1232840-20190610093308916-2041777351.png"></p><p>（3）点击“next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Xla29LZ31GekKOA.png" alt="1232840-20190610093332847-954874612.png"></p><p>（4）选中“I accept”，点击“Next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/wDvZ5NIg1U8x7cQ.png" alt="1232840-20190610093517933-801702191.png"></p><p>（5）修改安装目录（或者默认也可以），点击“Next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/DwxQ9i1jdecMnft.png" alt="1232840-20190610093604028-697458521.png"></p><p>（6）继续点击“Next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Z7mG5CwRT4LxadX.png" alt="1232840-20190610093640659-1974321584.png"></p><p>（7）点击“install”，等待一会</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/1EhMtJaYblLBR6n.png" alt="1232840-20190610093803299-424360454.png"></p><p>（8）点击“Finish”，完成安装。安装完成后，运行cmd，输入node –v查看版本号，然后输入npm</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/z5gxXUNM9suER8i.png" alt="1232840-20190610094026683-454000640.png"></p><p>3、出现如上图信息，表示node.js安装成功。npm是一个node包管理和分发工具，（宏哥觉得这玩意和python里边的那个皮I皮差不多pip）。</p><p>有了npm，后面就可以输入指令在线安装appium(打开 cmd输入：npm install –g appium但是宏哥一般不推荐这种，下载比较慢，安装过程也看不到，等的心烦的厉害，所以宏哥推荐用下面这种客户端安装</p><h4 id="5-安装-net-framework"><a href="#5-安装-net-framework" class="headerlink" title="5.安装.net framework"></a>5.安装.net framework</h4><p>1、由于Appium是用.net开发的，所以安装之前需要安装.net framework4.5，否则安装过程中会报错，官网下载：<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=30653" target="_blank" rel="noopener">http://www.microsoft.com/zh-cn/download/details.aspx?id=30653</a></p><p>下载成功后直接点击安装即可。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/FWTSC5L1Kgpy7P2.png" alt="1232840-20190610100950208-2017653294.png"></p><h4 id="6-安装appium"><a href="#6-安装appium" class="headerlink" title="6.安装appium"></a>6.安装appium</h4><p>1、下载地址：<a href="https://bitbucket.org/appium/appium.app/downloads/" target="_blank" rel="noopener">https://bitbucket.org/appium/appium.app/downloads/</a></p><p>当前最新版本为 AppiumForWindows_1_4_16_1.zip ，注意这是一个 Windows 版本，如果你的电脑为MAC请下载 appium-1.5.3.dmg 。虽然你已经看到了这些下载包，但我不保证你能下载的下来。</p><p>所以，下载不下来的小伙伴们可以@宏哥留言哦！！！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/kGTJ7fFDYC3c64s.png" alt="1232840-20190610101718032-610868620.png"></p><p>2、 我们以 Windows 为例，将下载的 AppiumForWindows.zip 进行解压，点击 appium-installer.exe 进行安装。直接双击appium-installer.exe文件安装就好，出现如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/rVj6wmONfTPukYZ.png" alt="1232840-20190610101953771-819725478.png"></p><p>3、选择语言，点击“OK”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/79qcHL8iTksCAB2.png" alt="1232840-20190610102052091-1378280176.png"></p><p>4、点击“Next”，修改安装路径</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/DmJYcWZ7vqIMQ9G.png" alt="1232840-20190610102253266-1915870129.png"></p><p>5、点击“Next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/6oXqKjJGgBOtzrc.png" alt="1232840-20190610102321623-265475810.png"></p><p>6、继续点击“Next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/VKxE6L5a2d7SBlF.png" alt="1232840-20190610102403541-952026875.png"></p><p>7、点击“Next”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/YPJiOkHRl7EZapb.png" alt="1232840-20190610102440703-2119715328.png"></p><p>8、点击“Install”等待一下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/lf8mWpvag2MTrXt.png" alt="1232840-20190610102514643-2087919920.png"></p><p>9、点击“Finish”，桌面会生成一个appium的图标，启动后界面显示如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/675Ypjb9LBQ3IiJ.png" alt="1232840-20190610102621069-1165017453.png"></p><h4 id="7-appium-doctor"><a href="#7-appium-doctor" class="headerlink" title="7.appium-doctor"></a>7.appium-doctor</h4><p>1、appium安装好后，找到这个文件目录D:\software\Appium\node_modules.bin</p><p>2、将上面的地址添加到环境变量path下。老办法，宏哥一说老办法，大家都知道了吧！到现在了，应该和宏哥达成这个默契了吧！如果没有，宏哥有点失望，不过没事的，那就从现在和宏哥达成这个默契吧！！！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/ojM7QwkhJ6bBCF3.png" alt="1232840-20190610103214159-1957531096.png"></p><p>3、cmd打开命令行窗口，输入appium-doctor ，输入appium-doctor,检查环境是否OK，出现以下提示，All Checks were successful ,说明环境配置成功。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/vHkW1TUpKflxSgX.png" alt="1232840-20190610103543237-1173984945.png"></p><h4 id="8-安装Appium-Python-Client"><a href="#8-安装Appium-Python-Client" class="headerlink" title="8.安装Appium-Python-Client"></a>8.安装Appium-Python-Client</h4><p>1、首先需要安装Python37，进行环境配置。前面python环境安装，已经准备好pip了，所以这里直接打开cmd，输入：pip install Appium-Python-Client</p><p>这个在这就不赘述了，在这写这个的目的时需要将Python与appium关联起来。</p><p>  关联方法： cmd打开命令行窗口，输入：pip install Appium-Python-Client，提示成功就可以了。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/m6YOZaUD5MBzgrb.png" alt="1232840-20190610103953884-1143458684.png"></p><p>至此，appium环境搭建成功！！！没办法，有点气人啊。宏哥人品还是那么好，一气呵成，没遇到任何问题哦！！！</p><p>到这里，该安装的软件都已经安装好，都已经全部准备就绪。要想和宏哥一起快乐的玩耍，你必须的打怪通关，披荆斩棘的走到这一步。</p><p>接下来就是怎么去用了。各种装备都已经携带好了，那就和宏哥一起进入python+appium的精彩世界开始快乐地组团打怪通关吧！！！</p><p>在学习过程中有遇到疑问的，可以加appium+python QQ群交流:707699217</p><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>1、现在网上这类教程很多，有些小伙伴看到有的教程安装node.js时候，需要配置环境变量，宏哥告诉你，这里不需要，因为已经配置好了，当出现下边的红框的内容就表示环境变量已经配置好了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/dC7zYh286SZnLcR.png" alt="1232840-20190610094719291-937112977.png"></p><p> 不相信的小伙伴们，可以  打开计算机-》属性-》高级系统设置-》环境变量-》编辑path（系统变量），查看一下，宏哥有没有忽悠你，有没有骗你。看到已经配置好了。如图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/kmyZNbIoHr5c7wg.png" alt="1232840-20190610100209527-157621014.png"></p><p>2、安装.net framework4.5时候，出现如图界面，不要慌，仔细一看，是你安装过.net framework4.5，所以会出现，如下，直接关掉。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/7KSlz9dQtr3ovTu.png" alt="1232840-20190610101201624-1502261181.png"></p><p>3、最后宏哥给你说说：此新非彼新。以上两个就是宏哥为什么喜欢新的原因，因为一些东西随着时间演变，版本的更新，软件会趋于人性化让你省许多事，节省好多时间。比如这里不用配置环境变量和安装.net framework4.5。</p><p>当然了这个是宏哥的猜测，有兴趣的小伙伴可以安装低版本的node.js，看一看是不是需要配置环境变量呢，时间的关系这个就不在这里演示了。实测过这个的可以给宏哥一个答案哦！</p><p>4、appium环境搭建思路</p><h5 id="思考如何构建环境思路图"><a href="#思考如何构建环境思路图" class="headerlink" title="思考如何构建环境思路图"></a>思考如何构建环境思路图</h5><p>　　首先我们需要搞定一个环境，这里无论是appium、还是selenium还是其他的什么自动化、开发环境我们都可以按照这个思路来，首先你需要知道整个框架是做什么的？然后他的整个工作流程或者说整个框架他各个软件之间的依赖是什么。这里迷茫也无所谓，我们回过头看前面的appium环境，这里拿windows说。</p><p>1、appium环境是不是需要appium的一个安装包？（先别安装）</p><p>2、我们针对android进行测试我们是不是需要android本身的一个android 的sdk？</p><p>3、android 这个本身就是java基础上的，我们是不是需要配置java 的jdk？</p><p>4、appium是node.js开发的，他的依赖是不是就是node.js的安装包？</p><p>5、我们既然要做自动化是不是需要选择一个开发语言、这里python那么我们是不是要把python给安装好？</p><p>6、python如何和appium之间进行交互呢？那么我们是不是需要一个appium-python-client的一个第三方扩展包？</p><p>7、工欲善其事必先利其器，我们是不是要选择一个好的代码编辑ide，哈哈，sublime 我这里选择的。</p><pre><code>好了到这里整个思路图是否在你的脑子里面了？那么我们是不是就可以按照这个思路去一个一个完善呢？搭建环境都是从基础开始，所以我们的第一步是不是就是jdk、然后sdk、然后node、然后python、appium、appium-python-client、编辑软件这样的结果来呢？所以整理思路很重要</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+appium自动化测试1</title>
      <link href="/2016/03/27/appium/"/>
      <url>/2016/03/27/appium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 Appium+python自动化（一）- 环境搭建—上（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天是高考各地由于降水，特别糟糕，各位考生高考加油，全国人民端午节快乐。最近整理了一下自动化的东西，先前整理的python接口自动化已经接近尾声。即将要开启新的征程和篇章（Appium&amp;python）。那么首相的问题就是搭建环境了。好久没搭建环境又踩了不少坑，appium的环境搭建比较繁琐，好多同行估计都在环境上被卡死了。所以特此分享一下~~</p><p>　　appium可以说是做app最火的一个自动化框架，它的主要优势是支持android和ios，另外脚本语言也是支持java和Python。而且现在招聘要求也需要这项技能。还有就是5G时代的到来。各种app借力丛生。所以我们必须掌握这项技能。宏哥擅长Python，所以接下来的教程是appium+python的实例。</p><p>　　学习appium最大的难处在于环境的安装和搭建，80%的人死于环境安装和搭建，然后就没然后了；10%的人被环境折腾的死去活来，最后夭折；只有剩下的10%人品好，可以顺利安装，一步到位。</p><h4 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h4><p>想要和宏哥搭建一样的环境，需要安装包的童鞋可以：（1）扫码关注宏哥公众号，发送：appium环境全家桶，即可下载；（2）直接在微信搜索：北京宏哥关注宏哥公众号，发送：appium环境全家桶，即可下载。</p><p>1、宏哥的环境是Windows 10版本 64位系统（32位的同学自己想办法哦）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Kg4MyY32BLaxcwI.png" alt="1232840-20190605155307021-483968621.png"></p><p>2、1.8.0_181 （64位）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/EBVWD24FCXGPn7t.png" alt="1232840-20190605155358338-999867664 _1_.png"></p><p>3、android-sdk_r24.3.4-windows</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/my8e4DrVJ1jEAtz.png" alt="1232840-20190606092119257-10244535.png"></p><p>4、python:3.7</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/K96yYagDtIOF2HX.png" alt="1232840-20190605170445267-971150713.png"></p><p>5、appium：1.4.16.1</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/e8RJzdbGHwcqIZ4.png" alt="1232840-20190606103201375-1873374407.png"> </p><p>6、Node.js：node-v10.16.0-x64</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/3idXtDr4FM2vCEA.png" alt="1232840-20190606103624134-944043025.png"></p><p>7、Appium-Python-Client</p><h4 id="3-jdk安装"><a href="#3-jdk安装" class="headerlink" title="3.jdk安装"></a>3.jdk安装</h4><p>1、下载jdk包，小编的是64位1.8版本，其它高级版本应该也是可以的。根据自己的系统选择对应版本</p><p>2、一路傻瓜式安装，注意安装路径不要有空格，不要有中文。jdk和jre不要放在一个文件夹下</p><p>3、设置三个环境变量,我的电脑&gt;选择“属性”-&gt;“高级”-&gt;“环境变量”-&gt;“系统变量”-&gt;“新建”</p><p>（1）JAVA_HOME—-D:\software\Java\jdk1.8.0_181” （根据自己安装路径填写）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Rjba7UBJCDFdl2K.png" alt="1232840-20190606133145641-556997238.png"></p><p>（2）CLASSPATH— .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar;</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/LVxb4uOzUa5tfAo.png" alt="1070438-20170429135040600-1839493459.png"></p><p>（3）PATH—–;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</p><p>在path路径下加上面那两个，这里就不多说了</p><p>4、打开cmd验证是否安装成功，输入java -version，然后输入javac</p><p>能显示版本号和下面的帮助信息说明安装成功</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/EBVWD24FCXGPn7t.png" alt="1232840-20190605155358338-999867664 _1_.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/WbKagUS5TlROG3J.png" alt="1232840-20190606133701520-1449624162.png"></p><h4 id="4-android-sdk下载安装"><a href="#4-android-sdk下载安装" class="headerlink" title="4.android-sdk下载安装"></a>4.android-sdk下载安装</h4><p>1、下载android-sdk,这个是做android测试和开发的必备环境，如果不会下载的话，可以找我要，后期建个群或将其上传上去</p><p>好多人都是直接下载Android Studio，但是如果只是做自动化的话只需要下载Android SDK就行了。</p><p>下载地址：<a href="http://tools.android-studio.org/index.php/sdk/（推荐使用）" target="_blank" rel="noopener">http://tools.android-studio.org/index.php/sdk/（推荐使用）</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/i4qKCpLEOY3DXQ7.png" alt="1232840-20190606134228631-276770895.png"> </p><p>2、解压后，里面有个SDK manager.exe双击打开</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/TM16JGqrvuwflHe.png" alt="1232840-20190606134103813-1552926770.png"></p><p>3、勾选你要下载的API版本和对应的android版本，后面模拟器会用到（不下载用其它模拟器也行，或者真机），然后坐等下载。安装Tools下的Android SDK Platform-tools和Android SDK Build-tools，Android SDK Tools可以选择是否更新，建议直接更新。镜像：随便选个版本也可以选择多个版本安装，我喜欢直接连接真机进行，由于镜像比较大，所以喜欢真机的朋友们可以不下载镜像，GoogleFQ安装：Extras文件夹下所有的全部安装。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/T1GxdsoZ8gp4jQc.png" alt="1232840-20190606143637999-1974062484.png"></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/7oHu3ChwPU4kXrq.png" alt="1070438-20170429135105319-1618108638.png"> </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/CDSF1a9ZTrvBjIh.png" alt="1232840-20190606143658321-635554409.png"></p><h4 id="5-android-sdk环境变量"><a href="#5-android-sdk环境变量" class="headerlink" title="5.android-sdk环境变量"></a>5.android-sdk环境变量</h4><p>1、在系统变量新建：ANDROID_HOME，对应变量值为：D:\software\android-sdk-windows（sdk安装路径）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/MoQlT5mDCKwW3Sk.png" alt="1232840-20190606144050400-81431361.png"></p><p>2、path添加两个变量，将以下箭头所指的两个文件路径添加到path里</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/Co5Onptbqe4V8Qz.png" alt="1232840-20190606144238313-483256153.png"></p><p>3、path里面添加D:\software\android-sdk-windows\tools和D:\software\android-sdk-windows\platform-tools，或者%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools</p><h4 id="6-adb环境"><a href="#6-adb环境" class="headerlink" title="6.adb环境"></a>6.adb环境</h4><p>1.因为adb是在D:\software\android-sdk-windows\platform-tools这个目录下的，所以上面添加了环境变量后，可以直接在cmd里面运行了。</p><p>2.在cmd输入adb可以查看对应版本号</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/qNTDpoA1Ku2aglV.png" alt="1232840-20190606160438193-174188845.png"></p><h4 id="7-连接手机"><a href="#7-连接手机" class="headerlink" title="7.连接手机"></a>7.连接手机</h4><p>1.手机用数据线连电脑，如果安装了91助手或者360什么的可以先下载手机驱动，确认手机能连上</p><p>2.打开cmd输入：adb devices,当屏幕上出现一串字符，后面显示devices说明连接成功（出现其它的提示，得检查自己的环境了）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/07/7fupOVmEZeqLDKv.png" alt="1232840-20190606162557563-1163268832.png"></p><p>到这里android的测试开发环境已经装好了，下一篇会教搭建搭建appium环境。安装过程中遇到各种奇葩问题，请卸载完后，仔细阅读，从第一行开始，一步一步走下来，中间任何一个环境出问题，都会导致最后appium运行失败。</p><p>在学习过程中有遇到疑问的，可以加appium（python+appium） QQ群交流:707699217</p><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h4><p>1、搭建编译环境时为什么有时候要设置环境变量，而有时又设置用户变量？ </p><p>答：环境变量分为系统环境变量和用户环境变量。 你所说的环境变量是指系统环境变量，对所有用户起作用 。而用户环境变量只对当前用户起作用。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化42</title>
      <link href="/2016/03/26/interface/"/>
      <url>/2016/03/26/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（四十二）- 项目架构设计之大结局（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　这一篇主要是将前边的所有知识做一个整合，把各种各样的砖块—模块（post请求，get请求，logging，参数关联，接口封装等等）垒起来，搭建一个房子。并且有很多小伙伴对于接口项目测试的框架一筹莫展，吵吵着什么时候才可以看到一篇相对于比较完整的项目源码，但是由于完整的项目属于公司内部的代码，这个是说句大实话是没法分享的，这个想必大家都知道吧，不知道入职的时候都签过保密协议吧。所以由于种种原因没办法给小伙伴们分享公司内部的项目源码，就算别人分享了，也只适用于本公司内部的业务。你拿过来也不能用的，需要修修补补。所以用例的代码还是得自己去一个个写，这个宏哥只能分享项目框架，自己在框架里添加自己公司的业务测试用例，使她变的丰满充实，适合自己公司的业务。希望对小伙伴们有所指导或者是启发，好了时间不早了，废话少说，还是尽快进入今天的主题吧—接口项目测试结构（框架）设计。</p><h4 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2.项目结构"></a>2.项目结构</h4><p>关注公众号发送：项目架构设计源码。获取源码下载地址</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/K25TE9Qneo3rZJs.png" alt="1232840-20200511150147357-507855537.png"></p><p>1、新建一个工程（一定要创建工程），工程名称自己定义，如：hongge_jiekou</p><p>2、在工程的跟目录新建一个脚本：run_main.py,用来执行全部用例</p><p>3、在工程下创建以下几个pakage包:</p><p>–case:这个包放test开头的测试用例，也可以放一些封装接口的方法，如：login(如果封装的接口比较多，也可以单独放一个包，可以命名为：framework，当然了可以随便但是要见名知义，不要奇葩、不要关键字等等）</p><p>–common:这个包放一些公共的方法，如：读取excel文件方法，读取mysql、oracle，logger.py这个是封装日志的输入</p><p>–config:cfg.ini这里是配置文件，如邮箱的一些参数：收件人，发件人，密码等,readConfig.py用于读取配置文件</p><p>–logs:这里存放日志信息</p><p>–report:这里存放测试报告</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/1VFOChj5uyQ36ZP.png" alt="1232840-20190531165759363-1788586090.png"></p><h4 id="3-run-main"><a href="#3-run-main" class="headerlink" title="3.run_main"></a>3.run_main</h4><p>第一步：用discover方法加载所有的测试用例</p><p>1、cur_path这个参数是读取当前这个脚本的真实路径，也就是run_main.py的真实路径</p><p>2、caseName=”case”这个case是存放测试用例的文件夹，如果没有的话，自动创建。如果想运行其它文件夹的用例，就改下caseName这个参数值</p><p>3、rule=”test*.py”这个是匹配用例脚本名称的规则，默认匹配test开头的所有用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/NmPFzRLogQp15ay.png" alt="1232840-20190531170242245-89309306.png"></p><p>第二步：生成HTML报告</p><p>1.把上一步加载到用例的参数传入这个函数，测试报告的文件名称默认report文件夹：reportName=”report</p><p>2.如果没有这个report文件夹也没关系，可以自动创建的</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/azbGKkyJtOxfTid.png" alt="1232840-20190531170326967-1509488137.png"></p><p>第三步：获取最新的测试报告</p><p>1.如果第二步生成的测试报告加了时间戳，想找到最新的文件就用第三步</p><p>2.如果第二步不加时间戳，只是生成result.html，那这一步其实没卵用，可以忽略</p><p>（个人觉得报告用一个名称result.html就行,新的自动覆盖旧的）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/O14eitxL3PFhczd.png" alt="1232840-20190531170416742-1301943554.png"></p><p>第四步：发送测试报告到邮箱</p><p>1、像QQ邮箱这种ssl加密的就走SMTP_SSL，用授权码登录</p><p>2、其它邮箱就正常账号密码登录，走SMTP</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/sOKhX4AvCqyYEp9.png" alt="1232840-20190531170535622-1040310707.png"></p><p>3、最后执行代码</p><p>这里邮箱的内容读的配置文件</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/tGLgCqRr2i5VhT6.png" alt="1232840-20190531170659637-957783789.png"></p><h4 id="4-config配置"><a href="#4-config配置" class="headerlink" title="4.config配置"></a>4.config配置</h4><p>1、cfg.ini打开，这里写配置文件内容</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/HEPvo7CtUTGfZzw.png" alt="1232840-20190531170853089-32854243.png"></p><p>2、用readConfig.py读取配置文件</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/MsJAa3DKToc9Y8V.png" alt="1232840-20190531171110029-485892658.png"></p><p>3、读取的内容就是传入第二步操作里面需要调用邮箱的配置信息</p><h4 id="5-logger"><a href="#5-logger" class="headerlink" title="5.logger"></a>5.logger</h4><p>1、logger.py这个文件放到common目录下，封装日志文件的读取</p><p>2、日志保存到logs文件夹</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/OXrzCJW8xVhFlyT.png" alt="1232840-20190531171503939-1861371115.png"></p><p>3、参开代码：</p><pre><code> 1 # -*- coding:utf-8 -*- 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-26 7 @author: 北京-宏哥     QQ交流群：984942724 8 Project:项目结构设计 9 &#39;&#39;&#39;10 # 3.导入模块11 import logging, time12 import os13 14 # log_path是存放日志的路径15 cur_path = os.path.dirname(os.path.realpath(__file__))16 log_path = os.path.join(os.path.dirname(cur_path), &#39;logs&#39;)17 # 如果不存在这个logs文件夹，就自动创建一个18 if not os.path.exists(log_path): os.mkdir(log_path)19 20 21 class Log():22     def __init__(self):23         # 文件的命名24         self.logname = os.path.join(log_path, &#39;%s.log&#39; % time.strftime(&#39;%Y_%m_%d&#39;))25         self.logger = logging.getLogger()26         self.logger.setLevel(logging.DEBUG)27         # 日志输出格式28         self.formatter = logging.Formatter(&#39;[%(asctime)s] - %(filename)s] - %(levelname)s: %(message)s&#39;)29 30     def __console(self, level, message):31         # 创建一个FileHandler，用于写到本地32         # fh = logging.FileHandler(self.logname, &#39;a&#39;)  # 追加模式  这个是python2的33         fh = logging.FileHandler(self.logname, &#39;a&#39;, encoding=&#39;utf-8&#39;)  # 这个是python3的34         fh.setLevel(logging.DEBUG)35         fh.setFormatter(self.formatter)36         self.logger.addHandler(fh)37 38         # 创建一个StreamHandler,用于输出到控制台39         ch = logging.StreamHandler()40         ch.setLevel(logging.DEBUG)41         ch.setFormatter(self.formatter)42         self.logger.addHandler(ch)43 44         if level == &#39;info&#39;:45             self.logger.info(message)46         elif level == &#39;debug&#39;:47             self.logger.debug(message)48         elif level == &#39;warning&#39;:49             self.logger.warning(message)50         elif level == &#39;error&#39;:51             self.logger.error(message)52         # 这两行代码是为了避免日志输出重复问题53         self.logger.removeHandler(ch)54         self.logger.removeHandler(fh)55         # 关闭打开的文件56         fh.close()57 58     def debug(self, message):59         self.__console(&#39;debug&#39;, message)60 61     def info(self, message):62         self.__console(&#39;info&#39;, message)63 64     def warning(self, message):65         self.__console(&#39;warning&#39;, message)66 67     def error(self, message):68         self.__console(&#39;error&#39;, message)69 70 71 if __name__ == &quot;__main__&quot;:72     log = Log()73     log.info(&quot;---测试开始----&quot;)74     log.info(&quot;操作步骤1,2,3&quot;)75     log.warning(&quot;----测试结束----&quot;)</code></pre><h4 id="6-case放用例"><a href="#6-case放用例" class="headerlink" title="6.case放用例"></a>6.case放用例</h4><p>1、常用的接口，需要检查被调用的单独封装处理，如登录等</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/TfgmVvABjPQN39W.png" alt="1232840-20190531171748383-1753319229.png"></p><p>2、test开头的用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/O16p8sQCRo2tGdl.png" alt="1232840-20190531171908237-446450855.png"></p><h4 id="7-logs日志查看"><a href="#7-logs日志查看" class="headerlink" title="7.logs日志查看"></a>7.logs日志查看</h4><p>1、运行完后日志都会收集到logs文件夹以日期命名</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/fytA7UdQu2CaH91.png" alt="1232840-20190531171940583-1727491326.png"></p><h4 id="8-生成测试报告"><a href="#8-生成测试报告" class="headerlink" title="8.生成测试报告"></a>8.生成测试报告</h4><p>1、这里调用的是HTMLTestRunner生成html的测试报告</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/LMmSqgYnVGo1Zi6.png" alt="1232840-20190531172052103-1887703389.png"> </p><h4 id="9-发送报告到邮箱"><a href="#9-发送报告到邮箱" class="headerlink" title="9.发送报告到邮箱"></a>9.发送报告到邮箱</h4><p>1、运行run_main.py就会自动生成报告，然后发送到邮箱了</p><p>（这里QQ邮箱的展示是有问题的，一般用企业邮箱的话，是可以正常展示的）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ivSnMZ31xXeCtBf.png" alt="1232840-20190531172027804-1063205594.png"></p><h4 id="10-小结"><a href="#10-小结" class="headerlink" title="10.小结"></a>10.小结</h4><p>1、问题：在python3.7中使用sendmail进行邮件发送，mailInfo[“to”]为逗号分隔的str类型，结果只有第一个邮件地址能收到邮件。将邮箱前后对调后，还是第一个邮箱可以收到测试报告，后边的邮箱收不到邮件。</p><p>折腾好久，邮件里可以看到收件人有多个，实际上始终只能第一个收件人可以收到邮件。经多次搜索，发现是这样：email中收件人和sendmail中的收件人是没啥联系的。</p><p>sendmail中收件人，它的格式应该为list。这个为实际的收件人地址。</p><p>而msg[‘To’] 格式是字符串(str)。这个只是为了邮件中打印出来而已。</p><p>sendmail查源码，python/lib/smtplib.py大概690行左右，或者搜索tolist。</p><p>解决方法：经过多次测试发现MIMEText()[“to”]的数据类型与sendmail(from_addrs,to_addrs,…)的to_addrs不同；前者为str类型，多个地址使用逗号分隔，后者为list类型。</p><p>知道这个原因后，将这一行代码：</p><p>smtp.sendmail(sender, receiver, msg.as_string())<br>替换为下边这样就可以了：</p><p>smtp.sendmail(sender, receiver.split(‘,’), msg.as_string())<br>当然了，以上是个人的愚见，如果你有更巧妙的解决办法，欢迎指教和讨论。</p><p>2、问题：在边写边做的过程中，遇到的另为一个奇葩的问题就是，在配置文件里加上中文的注释之后，老是报编码错误，报错如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/a5Mwj2bGNkCPFXt.png" alt="1232840-20190603105957831-670555003.png"></p><p>这个也折腾了好久，由于时间太晚了，实在是不想折腾了，所以就想着，那我不加注释了，先让代码跑起来再说了，但是这个问题一直困扰着我，如果不解决，以后遇到类似的问题，人家非要你加注释，你绕都绕不过，怎么办？？？吾日三省吾身，自己问自己。完了还</p><p>是没办法，自己放不过自己，还是解决吧。完了自己 冷静了一下，静下心来捋了一下思路，由于胡子不够长，所有就只能摸摸自己头，冷静分析了一下：</p><p>（1）分析问题（bug）——–读取配置文件报编码错误，那就一定是在读取配置文件的时候，没有注意编码的问题导致出错</p><p>（2）解决问题（bug）——–读取配置文件的时候，加上编码encoding=”utf-8” 即可</p><p>（3）定位问题（bug）——–全部代码，读取配置文件的只有邮箱信息，邮箱信息又在readconfig.py文件里，问题范围有缩小了，怀疑对象有缩小了，目标嫌疑人已经锁定，下一步找出证据，判他死刑</p><p>（4）用证据说话—————-查看读取配置文件时，是否有编码问题，没有注意，果不其然是这个问题 ：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/7PT3rj6Wa4ZhsyA.png" alt="1232840-20190603111923772-1917565231.png"></p><p>（5）弹药上膛————-加上编码  encoding=”utf-8”  即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/oWYL7hBDdOg5P3f.png" alt="1232840-20190603112127874-492475480.png"> </p><p>（6）下令开枪，判处死刑———-运行代码，顺利通过，邮件发出，大功告成</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/EFboQlsRK1gxN2w.png" alt="1232840-20190603112245615-895264534.png"></p><p>　　嘿嘿，时光穿越，当了一回狄仁杰，过了一把神探的瘾，不过那个时候没有枪，应该是大刀举起，砍下人头，但是大晚上一个人害怕，又太血腥，还是穿越到现代拿把枪过去再行刑。好了，时间太晚了。这时候我是不是应该说：“元芳，你怎么看”。。。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化41</title>
      <link href="/2016/03/25/interface/"/>
      <url>/2016/03/25/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（四十一）- 发xml格式参数的post请求（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　最近在工作中，遇到一种奇葩的接口，它的参数数据是通过xml，进行传递的，不要大惊小怪的，林子大了什么鸟都有，每个人的思路想法不一样，开发的接口也是各式各样的，如果想要统一的话，必须是提前团队已经做好沟通定好规则，这样就像在产品线上生成一样规格大小一致。就不会出现前边的问题了，如果出现了怎么办？而且项目进度比较急，没有时间修改，一期上线就只能凑合着用这组接口了，那么作为QA的你，会不会测试，如何用代码、工具实现呢？？？等等问题跟着就产生了。</p><p>　　前边就有介绍到有关：post请求相对于get请求多一个body部分，body部分常见的数据类型有以下四种（注意是常见的，并不是只有4种）</p><pre><code>application/x-www-form-urlencodedapplication/jsontext/xmlmultipart/form-data</code></pre><p>　　本篇就来给各位看官和小伙伴们来讲xml这种类型的body案例，如何用python去实现，由于公司的制度的保密性，所以公司的接口就不能在这里给小伙伴们演示了，我给小伙伴们模拟了一个类似的接口，来给小伙伴们讲解一下思路，希望小伙伴们在遇到的时候不至于慌了神，不知道从何处入手，其实说到底，说破大天了，它的本质还是一个接口，那就还是按照接口的那套思路往上边靠，这样就思路不至于太偏，也会走很少的弯路。好了就不啰嗦了，直接进入今天的正题吧。</p><h4 id="2-text-xml的数据类型"><a href="#2-text-xml的数据类型" class="headerlink" title="2.text/xml的数据类型"></a>2.text/xml的数据类型</h4><p>1、首先要确定post请求的body部分类型是xml格式，可以用fiddler抓包工具、postman、jemter、Google浏览器接口调试插件来进行缺洞，这里我是用fiddler抓包工具来确定的。看到body部分格式如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/4DGN1dqEuQvpxMe.png" alt="1232840-20190529103203555-917537625.png"></p><p>2、body里xml的参数：</p><pre><code>&lt;?xml version=“1.0” encoding = “UTF-8”?&gt;&lt;COM&gt;&lt;REQ name=&quot;北京-宏哥&quot;&gt;&lt;USER_ID&gt;bjhongge&lt;/USER_ID&gt;&lt;COMMODITY_ID&gt;123456&lt;/COMMODITY_ID&gt;&lt;SESSION_ID&gt;absbnmasbnfmasbm1213&lt;/SESSION_ID&gt;&lt;/REQ&gt;&lt;/COM&gt;</code></pre><h4 id="3-模拟接口请求"><a href="#3-模拟接口请求" class="headerlink" title="3.模拟接口请求"></a>3.模拟接口请求</h4><p>　　PS：！！！先不要着急的去用代码实现，而是先用工具请求一次，看是否可以请求是否可以成功。不要一开始就抨击怕啦的敲了半天，运行代码，傻眼了，运行结果和股市一样行情大涨，一片红色。结果你费了半天劲调试代码，也没查出错误。一问开发，开发用工具一试，一脸淫笑，然后笑呵呵的告诉你：额。。。，这个接口有点小问题，我需要调整一下下，这个时候是不是有一种想把开发接口的人痛揍一顿冲动，但是仔细想想还是自己的问题，如果一开始你就用工具模拟一下，出现问题立马找开发人员确认沟通，就不会有后面的剧情了。这种场景一般是萌新、小白可能会遇到的。好了，以下给小伙伴们列举了两种方法，当然了你也可以用其他方法模拟，条条大路通罗马，即可。</p><p>(1)Google浏览器接口调试插件模拟<br>1、将url、请求方法、参数在插件中填写好，以后直接点击“Send”，即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/fpL97cWlYOPxyVI.png" alt="1232840-20190528162904549-347505053.png"></p><p>(2)使用fiddler模拟<br>1、点开fiddler工具上composer菜单</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/DUWrGsPF4kItVf3.png" alt="1232840-20190529111000157-219486083.png"> </p><p>2、填写URL、选择请求方法、将xml数据直接复制到右下方Request Body部分，然后点右上角Execute就能执行了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/3s8KDxlERUijgaz.png" alt="1232840-20190529110827734-469829660.png"></p><h4 id="4-python3代码实现"><a href="#4-python3代码实现" class="headerlink" title="4.python3代码实现"></a>4.python3代码实现</h4><p>1、宏哥演示环境：</p><p>（1）python37 （2）PyCharm 2018.3.5 x64  （3）操作系统win10</p><p>2、其实很简单的，难而不会，会而不难。将xml格式的body部分直接写成一个字符串类型就行了，遇到换行的字符串，在后面加个反斜杠</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/LROIVZqbYUSQaFP.png" alt="1232840-20190529115030121-1515245717.png"></p><p>3、body参数用data去接收传入，要是遇到编码问题报错，就对body部分encode下再传入</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/PBf4ErT1k3dNqSL.png" alt="1232840-20190529114810548-1659119572.png"></p><p>4、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/sfhmFpaTKbYQV5P.png" alt="1232840-20190529115116941-117439250.png"></p><p>5、参考代码</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-25 7 @author: 北京-宏哥     QQ交流群：984942724 8 Project:学习和使用 发xml格式参数的post请求 9 &#39;&#39;&#39;10 # 3.导入模块11 import requests12 url = &quot;http://httpbin.org/post&quot;13 14 # python3字符串换行，在右边加个反斜杠15 body = &#39;&lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&#39; \16        &#39;&lt;COM&gt;&#39; \17        &#39;&lt;REQ name=&quot;北京-宏哥&quot;&gt;&#39; \18        &#39;&lt;USER_ID&gt;&lt;/USER_ID&gt;&#39; \19        &#39;&lt;COMMODITY_ID&gt;123456&lt;/COMMODITY_ID&gt;&#39; \20        &#39;&lt;SESSION_ID&gt;absbnmasbnfmasbm1213&lt;/SESSION_ID&gt;&#39; \21        &#39;&lt;/REQ&gt;&#39; \22        &#39;&lt;/COM&gt;&#39;23 24 # 遇到编码报错时候，对body进行encode25 r = requests.post(url, data=body.encode(&quot;utf-8&quot;))26 print(r.text)</code></pre><h4 id="5-从文件中读取XML数据"><a href="#5-从文件中读取XML数据" class="headerlink" title="5.从文件中读取XML数据"></a>5.从文件中读取XML数据</h4><p>1、xml格式的数据写到代码里面，不太直观，后期维护也不方便，可以把xml格式数据单独拿出来写到一个文件里，再用open函数去读取</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/1gEHcVMSlXy2ktf.png" alt="1232840-20190529113555518-1045039716.png"></p><p>2、新建一个body1_xml文件，写入内容如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/weRAlECdGLqSzgk.png" alt="1232840-20190529113715561-117859115.png"></p><p>3、参考内容</p><pre><code>&lt;?xml version=“1.0” encoding = “UTF-8”?&gt;&lt;COM&gt;    &lt;REQ name=&quot;北京-宏哥&quot;&gt;        &lt;USER_ID&gt;bjhongge&lt;/USER_ID&gt;        &lt;COMMODITY_ID&gt;123456&lt;/COMMODITY_ID&gt;        &lt;SESSION_ID&gt;absbnmasbnfmasbm1213&lt;/SESSION_ID&gt;    &lt;/REQ&gt;&lt;/COM&gt;</code></pre><p>4、用open函数去读xml内容</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/IvljHDhdxtqkP6i.png" alt="1232840-20190529113847169-838819342.png"></p><p>5、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/6ZDGx2kcT3pXqJ4.png" alt="1232840-20190529114236318-1821806204.png"></p><p>6、参考代码</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-25 7 @author: 北京-宏哥     QQ交流群：984942724 8 Project:学习和使用 发xml格式参数的post请求 9 &#39;&#39;&#39;10 # 3.导入模块11 import requests12 url = &quot;http://httpbin.org/post&quot;13 14 # python3字符串换行，在右边加个反斜杠15 body = &#39;&lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&#39; \16        &#39;&lt;COM&gt;&#39; \17        &#39;&lt;REQ name=&quot;北京-宏哥&quot;&gt;&#39; \18        &#39;&lt;USER_ID&gt;&lt;/USER_ID&gt;&#39; \19        &#39;&lt;COMMODITY_ID&gt;123456&lt;/COMMODITY_ID&gt;&#39; \20        &#39;&lt;SESSION_ID&gt;absbnmasbnfmasbm1213&lt;/SESSION_ID&gt;&#39; \21        &#39;&lt;/REQ&gt;&#39; \22        &#39;&lt;/COM&gt;&#39;23 24 with open(&#39;body1.xml&#39;,encoding=&#39;utf-8&#39;) as fp:25        body = fp.read()26 print(body)</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p> 　　嘿嘿，今天到这里有关发xml格式参数的post请求就给小伙伴们介绍完了，看起来是不是相当简单啊，但是在工作中遇到类似的问题，要灵活应用，不要生搬硬套。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化40</title>
      <link href="/2016/03/24/interface/"/>
      <url>/2016/03/24/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（四十）- logger 日志 - 下（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　按照上一篇的计划，这一篇给小伙伴们讲解一下：（1）多模块使用logging，（2）通过文件配置logging模块，（3）自己封装一个日志（logging）类。可能有的小伙伴在这里会有个疑问一个logging为什么分两篇的篇幅来介绍她呢？？？那是因为日志是非常重要的，用于记录系统、软件操作事件的记录文件或文件集合，可分为事件日志和消息日志。具有处理历史数据、诊断问题的追踪以及理解系统、软件的活动等重要作用，在开发或者测试软系统过程中出现了问题，我们首先想到的就是她——logging。她可不像泰戈尔说的：“天空没有留下翅膀的痕迹,但我已经飞过”；这个90后的小姑娘，她可是一个爱炫耀，爱显摆的人已经达到了人过留名、雁过留声的境界。好了逗大家一乐，下面开始进入今天的正题。</p><h4 id="2-多模块使用logging"><a href="#2-多模块使用logging" class="headerlink" title="2.多模块使用logging"></a>2.多模块使用logging</h4><h5 id="1、父模块fatherModule-py："><a href="#1、父模块fatherModule-py：" class="headerlink" title="1、父模块fatherModule.py："></a>1、父模块fatherModule.py：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/PgEjXRlZS9s65hM.png" alt="1232840-20190524104150326-666690859.png"></p><h5 id="2、子模块sonModule-py："><a href="#2、子模块sonModule-py：" class="headerlink" title="2、子模块sonModule.py："></a>2、子模块sonModule.py：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/MFDzfnPCH971tvZ.png" alt="1232840-20190524104347368-1905717054.png"> </p><h5 id="3、运行结果"><a href="#3、运行结果" class="headerlink" title="3、运行结果"></a>3、运行结果</h5><p>在控制和日志文件log.txt中输出：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/A4UIc7HVdRnosyO.png" alt="1232840-20190524104511872-1375688510.png"></p><p>　　首先在父模块定义了logger’fatherModule’，并对它进行了配置，就可以在解释器进程里面的其他地方通过getLogger(‘fatherModule’)得到的对象都是一样的，不需要重新配置，可以直接使用。定义的该logger的子logger，</p><p>都可以共享父logger的定义和配置，所谓的父子logger是通过命名来识别，任意以’fatherModule’开头的logger都是它的子logger，例如’fatherModule.son’。</p><p>　　实际开发一个application，首先可以通过logging配置文件编写好这个application所对应的配置，可以生成一个根logger，如’PythonAPP’，然后在主函数中通过fileConfig加载logging配置，接着在application的其他地方、不同的模块中，可以使用根logger的子logger，</p><p>如’PythonAPP.Core’，’PythonAPP.Web’来进行log，而不需要反复的定义和配置各个模块的logger。</p><h5 id="4、参考代码"><a href="#4、参考代码" class="headerlink" title="4、参考代码"></a>4、参考代码</h5><h6 id="fatherModule-py文件："><a href="#fatherModule-py文件：" class="headerlink" title="fatherModule.py文件："></a>fatherModule.py文件：</h6><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-24 7 @author: 北京-宏哥 8 Project:学习和使用python的logging日志模块-多模块使用logging 9 &#39;&#39;&#39;10 # 3.导入模块11 import logging12 import sonModule13 logger = logging.getLogger(&quot;fatherModule&quot;)14 logger.setLevel(level = logging.INFO)15 handler = logging.FileHandler(&quot;log.txt&quot;)16 handler.setLevel(logging.INFO)17 formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)18 handler.setFormatter(formatter)19 20 console = logging.StreamHandler()21 console.setLevel(logging.INFO)22 console.setFormatter(formatter)23 24 logger.addHandler(handler)25 logger.addHandler(console)26 27 28 logger.info(&quot;creating an instance of sonModule.sonModuleClass&quot;)29 a = sonModule.SonModuleClass()30 logger.info(&quot;calling sonModule.sonModuleClass.doSomething&quot;)31 a.doSomething()32 logger.info(&quot;done with  sonModule.sonModuleClass.doSomething&quot;)33 logger.info(&quot;calling sonModule.some_function&quot;)34 sonModule.som_function()35 logger.info(&quot;done with sonModule.some_function&quot;)</code></pre><h6 id="sonModule-py文件："><a href="#sonModule-py文件：" class="headerlink" title="sonModule.py文件："></a>sonModule.py文件：</h6><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-24 7 @author: 北京-宏哥 8 Project:学习和使用python的logging日志模块-多模块使用logging 9 &#39;&#39;&#39;10 # 3.导入模块11 import logging12 13 module_logger = logging.getLogger(&quot;fatherModule.son&quot;)14 class SonModuleClass(object):15     def __init__(self):16         self.logger = logging.getLogger(&quot;fatherModule.son.module&quot;)17         self.logger.info(&quot;creating an instance in SonModuleClass&quot;)18     def doSomething(self):19         self.logger.info(&quot;do something in SonModule&quot;)20         a = []21         a.append(1)22         self.logger.debug(&quot;list a = &quot; + str(a))23         self.logger.info(&quot;finish something in SonModuleClass&quot;)24 25 def som_function():26     module_logger.info(&quot;call function some_function&quot;)</code></pre><h4 id="3-文件配置logging模块"><a href="#3-文件配置logging模块" class="headerlink" title="3.文件配置logging模块"></a>3.文件配置logging模块</h4><p>1、通过logging.config模块配置日志构造信息</p><p>logger.conf文件：</p><pre><code>[loggers]keys = root, example01, example02[logger_root]level = DEBUGhandlers = hand01, hand02[logger_example01]handlers = hand01, hand02qualname = example01propagate = 0[logger_example02]handlers = hand01, hand03qualname = example02propagate = 0[handlers]keys = hand01, hand02, hand03[handler_hand01]class = StreamHandlerlevel = INFOformatter = form01args=(sys.stdout, )[handler_hand02]class = FileHandlerlevel = DEBUGformatter = form01args = (&#39;log/test_case_log.log&#39;, &#39;a&#39;)[handler_hand03]class = handlers.RotatingFileHandlerlevel = INFOformatter = form01args = (&#39;log/test_case_log.log&#39;, &#39;a&#39;, 10*1024*1024,3)[formatters]keys = form01, form02[formatter_form01]format = %(asctime)s-%(filename)s-[line:%(lineno)d]-%(levelname)s-[LogInfoMessage]: %(message)sdatefmt = %a, %d %b %Y %H:%M:%S[formatter_form02]format = %(name)-12s: %(levelname)-8s-[日志信息]: %(message)sdatefmt = %a, %d %b %Y %H:%M:%S</code></pre><p>一、实例</p><p>1、实例代码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/HLaCeitSNxb2mup.png" alt="1232840-20190524125154533-1552402737.png"></p><p>2、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/5cR7pVorbtBCXHJ.png" alt="1232840-20190524125217003-505532949.png"></p><p>3、参考代码</p><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-5-27@author: 北京-宏哥Project:学习和使用python的logging日志模块-多模块使用logging&#39;&#39;&#39;# 3.导入模块import loggingimport logging.configlogging.config.fileConfig(&quot;logger.conf&quot;)logger = logging.getLogger(&quot;example01&quot;)logger.debug(&#39;This is debug message&#39;)logger.info(&#39;This is info message&#39;)logger.warning(&#39;This is warning message&#39;)</code></pre><p>二、实例</p><p>1、实例代码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/PMXHLBUqTam67GS.png" alt="1232840-20190524125420483-29316957.png"></p><p>2、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/kqOepQghVSNUKTr.png" alt="1232840-20190524125443008-170420070.png"></p><p>3、参考代码</p><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-5-24@author: 北京-宏哥Project:学习和使用python的logging日志模块-多模块使用logging&#39;&#39;&#39;# 3.导入模块import loggingimport logging.configlogging.config.fileConfig(&quot;logger.conf&quot;)logger = logging.getLogger(&quot;example02&quot;)logger.debug(&#39;This is debug message&#39;)logger.info(&#39;This is info message&#39;)logger.warning(&#39;This is warning message&#39;)</code></pre><p>2、通过JSON文件配置</p><p>json配置文件：</p><pre><code>{    &quot;version&quot;:1,    &quot;disable_existing_loggers&quot;:false,    &quot;formatters&quot;:{        &quot;simple&quot;:{            &quot;format&quot;:&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;        }    },    &quot;handlers&quot;:{        &quot;console&quot;:{            &quot;class&quot;:&quot;logging.StreamHandler&quot;,            &quot;level&quot;:&quot;DEBUG&quot;,            &quot;formatter&quot;:&quot;simple&quot;,            &quot;stream&quot;:&quot;ext://sys.stdout&quot;        },        &quot;info_file_handler&quot;:{            &quot;class&quot;:&quot;logging.handlers.RotatingFileHandler&quot;,            &quot;level&quot;:&quot;INFO&quot;,            &quot;formatter&quot;:&quot;simple&quot;,            &quot;filename&quot;:&quot;info.log&quot;,            &quot;maxBytes&quot;:&quot;10485760&quot;,            &quot;backupCount&quot;:20,            &quot;encoding&quot;:&quot;utf8&quot;        },        &quot;error_file_handler&quot;:{            &quot;class&quot;:&quot;logging.handlers.RotatingFileHandler&quot;,            &quot;level&quot;:&quot;ERROR&quot;,            &quot;formatter&quot;:&quot;simple&quot;,            &quot;filename&quot;:&quot;errors.log&quot;,            &quot;maxBytes&quot;:10485760,            &quot;backupCount&quot;:20,            &quot;encoding&quot;:&quot;utf8&quot;        }    },    &quot;loggers&quot;:{        &quot;my_module&quot;:{            &quot;level&quot;:&quot;ERROR&quot;,            &quot;handlers&quot;:[&quot;info_file_handler&quot;],            &quot;propagate&quot;:&quot;no&quot;        }    },    &quot;root&quot;:{        &quot;level&quot;:&quot;INFO&quot;,        &quot;handlers&quot;:[&quot;console&quot;,&quot;info_file_handler&quot;,&quot;error_file_handler&quot;]    }}</code></pre><p>1、通过JSON加载配置文件，然后通过logging.dictConfig配置logging：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/GplZM3woTIPWY7a.png" alt="1232840-20190527090325936-961419652.png"> </p><p>2、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Me2NtoBquxYIld7.png" alt="1232840-20190527091122513-2051246113.png"> </p><p>3、参考代码</p><pre><code> 1 import json   2 import logging.config   3 import os   4     5 def setup_logging(default_path = &quot;logging.json&quot;,default_level = logging.INFO,env_key = &quot;LOG_CFG&quot;):   6     path = default_path   7     value = os.getenv(env_key,None)   8     if value:   9         path = value  10     if os.path.exists(path):  11         with open(path,&quot;r&quot;) as f:  12             config = json.load(f)  13             logging.config.dictConfig(config)  14     else:  15         logging.basicConfig(level = default_level)  16    17 def func():  18     logging.info(&quot;start func&quot;)  19    20     logging.info(&quot;exec func&quot;)  21    22     logging.info(&quot;end func&quot;)  23    24 if __name__ == &quot;__main__&quot;:  25     setup_logging(default_path = &quot;logging.json&quot;)  26     func()</code></pre><p>3、通过YAML文件配置</p><p>1、首先要导入yaml模块，输入命令  python2： pip install yaml          python3：pip install pyyaml</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ReJwnkabjfsU8oM.png" alt="1232840-20190524152951024-76925686.png"></p><p>2、通过YAML文件进行配置，比JSON看起来更加简介明了：</p><p>logging.yaml文件：</p><pre><code>version: 1disable_existing_loggers: Falseformatters:        simple:            format: &quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;handlers:    console:            class: logging.StreamHandler            level: DEBUG            formatter: simple            stream: ext://sys.stdout    info_file_handler:            class: logging.handlers.RotatingFileHandler            level: INFO            formatter: simple            filename: info.log            maxBytes: 10485760            backupCount: 20            encoding: utf8    error_file_handler:            class: logging.handlers.RotatingFileHandler            level: ERROR            formatter: simple            filename: errors.log            maxBytes: 10485760            backupCount: 20            encoding: utf8loggers:    my_module:            level: ERROR            handlers: [info_file_handler]            propagate: noroot:    level: INFO    handlers: [console,info_file_handler,error_file_handler]</code></pre><p>3、通过YAML加载配置文件，然后通过logging.dictConfig配置logging：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/kQX2H8PnmFGx1e5.png" alt="1232840-20190524153857018-1380309551.png"></p><p>4、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/tP5ungT6CEhHAWL.png" alt="1232840-20190524154010112-374565545.png"></p><p>5、参考代码</p><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-5-24@author: 北京-宏哥Project:学习和使用python的logging日志模块-yaml文件配置logging&#39;&#39;&#39;# 3.导入模块import yamlimport logging.configimport osdef setup_logging(default_path = &quot;logging.yaml&quot;,default_level = logging.INFO,env_key = &quot;LOG_CFG&quot;):    path = default_path    value = os.getenv(env_key,None)    if value:        path = value    if os.path.exists(path):        with open(path,&quot;r&quot;) as f:            config = yaml.load(f)            logging.config.dictConfig(config)    else:        logging.basicConfig(level = default_level)def func():    logging.info(&quot;start func&quot;)    logging.info(&quot;exec func&quot;)    logging.info(&quot;end func&quot;)if __name__ == &quot;__main__&quot;:    setup_logging(default_path = &quot;logging.yaml&quot;)    func()</code></pre><p>注意：配置文件中“disable_existing_loggers” 参数设置为 False；如果不设置为False，创建了 logger，然后你又在加载日志配置文件之前就导入了模块。logging.fileConfig 与 logging.dictConfig 默认情况下会使得已经存在的 logger 失效。那么，这些配置信息就不会应用到你的 Logger 上。“disable_existing_loggers” = False解决了这个问题</p><p>自己封装一个logging类</p><p>1、实例代码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/mVtqT7aNrPLYxbB.png" alt="1232840-20190527104809398-14622080.png"></p><p>2、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/N3YSgBz1OFCL4He.png" alt="1232840-20190527115636826-1726374909.png"></p><p>3、参考代码</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-27 7 @author: 北京-宏哥 8 Project:学习和使用python的logging日志模块-自己封装logging 9 &#39;&#39;&#39;10 # 3.导入模块11 import logging12 class Log(object):13     def __init__(self, name=__name__, path=&#39;mylog.log&#39;, level=&#39;DEBUG&#39;):14         self.__name = name15         self.__path = path16         self.__level = level17         self.__logger = logging.getLogger(self.__name)18         self.__logger.setLevel(self.__level)19 20     def __ini_handler(self):21         &quot;&quot;&quot;初始化handler&quot;&quot;&quot;22         stream_handler = logging.StreamHandler()23         file_handler = logging.FileHandler(self.__path, encoding=&#39;utf-8&#39;)24         return stream_handler, file_handler25 26     def __set_handler(self, stream_handler, file_handler, level=&#39;DEBUG&#39;):27         &quot;&quot;&quot;设置handler级别并添加到logger收集器&quot;&quot;&quot;28         stream_handler.setLevel(level)29         file_handler.setLevel(level)30         self.__logger.addHandler(stream_handler)31         self.__logger.addHandler(file_handler)32 33     def __set_formatter(self, stream_handler, file_handler):34         &quot;&quot;&quot;设置日志输出格式&quot;&quot;&quot;35         formatter = logging.Formatter(&#39;%(asctime)s-%(name)s-%(filename)s-[line:%(lineno)d]&#39;36                                       &#39;-%(levelname)s-[日志信息]: %(message)s&#39;,37                                       datefmt=&#39;%a, %d %b %Y %H:%M:%S&#39;)38         stream_handler.setFormatter(formatter)39         file_handler.setFormatter(formatter)40 41     def __close_handler(self, stream_handler, file_handler):42         &quot;&quot;&quot;关闭handler&quot;&quot;&quot;43         stream_handler.close()44         file_handler.close()45 46     @property47     def Logger(self):48         &quot;&quot;&quot;构造收集器，返回looger&quot;&quot;&quot;49         stream_handler, file_handler = self.__ini_handler()50         self.__set_handler(stream_handler, file_handler)51         self.__set_formatter(stream_handler, file_handler)52         self.__close_handler(stream_handler, file_handler)53         return self.__logger54 55 56 if __name__ == &#39;__main__&#39;:57     log = Log(__name__, &#39;file.log&#39;)58     logger = log.Logger59     logger.debug(&#39;I am a debug message&#39;)60     logger.info(&#39;I am a info message&#39;)61     logger.warning(&#39;I am a warning message&#39;)62     logger.error(&#39;I am a error message&#39;)63     logger.critical(&#39;I am a critical message&#39;)</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、在yaml文件配置logging的时候，会有个报警信息。有代码洁癖的人，可以处理一下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/OvXogJ75Rq328Uc.png" alt="1232840-20190524154057268-926674480.png"></p><p>2、是什么原因造成上面的告警呢？？？是因为：YAML 5.1版本后弃用了yaml.load(file)这个用法，因为觉得很不安全，5.1版本之后就修改了需要指定Loader，通过默认加载​​器（FullLoader）禁止执行任意函数，该load函数也变得更加安全。</p><p>3、解决办法：</p><p>   不用改很多代码 加一句就行了 在yaml.load(f, Loader=yaml.FullLoader) 加上 Loader=yaml.FullLoader 就行了。这里要注意的是L要大写的，否则会报错的。</p><p>4、加上以后，看一下运行结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/NDTbgaildFG4UJS.png" alt="1232840-20190527090711077-568061041.png"></p><p>  最后给大家留个彩蛋：文章中有一处bug，会影响运行结果而报错，聪明的你，可以找到吗？？？嘿嘿！！！欢迎互动和留言</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化39</title>
      <link href="/2016/03/23/interface/"/>
      <url>/2016/03/23/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十九）- logger 日志 - 上（超详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　Python的logging模块提供了通用的日志系统，可以方便第三方模块或者是应用使用。这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现具体的日志记录方式。</p><pre><code>logging模块与log4j的机制是一样的，只是具体的实现细节不同。模块提供logger，handler，filter，formatter。</code></pre><h6 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h6><p>提供日志接口，供应用代码使用。logger最长用的操作有两类：配置和发送日志消息。可以通过logging.getLogger(name)获取logger对象，如果不指定name则返回root对象，多次使用相同的name调用getLogger方法返回同一个logger对象。</p><h6 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h6><p>将日志记录（log record）发送到合适的目的地（destination），比如文件，socket等。一个logger对象可以通过addHandler方法添加0到多个handler，每个handler又可以定义不同日志级别，以实现日志分级过滤显示。</p><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><p>提供一种优雅的方式决定一个日志记录是否发送到handler。</p><h6 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h6><p>指定日志记录输出的具体格式。formatter的构造方法需要两个参数：消息的格式字符串和日期字符串，这两个参数都是可选的。</p><p>　　与log4j类似，logger，handler和日志消息的调用可以有具体的日志级别（Level），只有在日志消息的级别大于logger和handler的级别。</p><p>logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：</p><p>可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；<br>print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出</p><h4 id="2-logging模块使用"><a href="#2-logging模块使用" class="headerlink" title="2.logging模块使用"></a>2.logging模块使用</h4><h5 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h5><p>配置logging基本的设置，然后在控制台输出日志：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/SH19UEeuMIpWgZf.png" alt="1232840-20190523163226547-116042738.png"></p><p>运行时，控制台输出：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ScVZTDlKW72tyjv.png" alt="1232840-20190523163243873-1698370026.png"></p><p>logging中可以选择很多消息级别，如debug、info、warning、error以及critical。通过赋予logger或者handler不同的级别，开发者就可以只输出错误信息到特定的记录文件，或者在调试时只记录调试信息。</p><p>例如，我们将logger的级别改为DEBUG，再观察一下输出结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/3YvoFX86cWV4Q7J.png" alt="1232840-20190523163334355-319210850.png"></p><p>控制台输出，可以发现，输出了debug的信息：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/tCcO5lTX18KJmUL.png" alt="1232840-20190523163357967-1582334671.png"></p><p>logging.basicConfig函数各参数：</p><p>filename：指定日志文件名；</p><p>filemode：和file函数意义相同，指定日志文件的打开模式，’w’或者’a’；</p><p>format：指定输出的格式和内容，format可以输出很多有用的信息，</p><p>参数：作用</p><pre><code>%(levelno)s：打印日志级别的数值%(levelname)s：打印日志级别的名称%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]%(filename)s：打印当前执行程序名%(funcName)s：打印日志的当前函数%(lineno)d：打印日志的当前行号%(asctime)s：打印日志的时间%(thread)d：打印线程ID%(threadName)s：打印线程名称%(process)d：打印进程ID%(message)s：打印日志信息</code></pre><p>datefmt：指定时间格式，同time.strftime()；</p><p>level：设置日志级别，默认为logging.WARNNING；</p><p>stream：指定将日志的输出流，可以指定输出到sys.stderr，sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略；</p><h5 id="2-将日志写入到文件"><a href="#2-将日志写入到文件" class="headerlink" title="2.将日志写入到文件"></a>2.将日志写入到文件</h5><h6 id="2-1-将日志写入到文件"><a href="#2-1-将日志写入到文件" class="headerlink" title="2.1 将日志写入到文件"></a>2.1 将日志写入到文件</h6><p>设置logging，创建一个FileHandler，并对输出消息的格式进行设置，将其添加到logger，然后将日志写入到指定的文件中：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/JxefZEau5wXp3Db.png" alt="1232840-20190523163612984-46794816.png"></p><p>log.txt中日志数据为：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/9HC7fgzedmtOUQk.png" alt="1232840-20190523163636039-1336132393.png"></p><h6 id="2-2-将日志同时输出到屏幕和日志文件"><a href="#2-2-将日志同时输出到屏幕和日志文件" class="headerlink" title="2.2 将日志同时输出到屏幕和日志文件"></a>2.2 将日志同时输出到屏幕和日志文件</h6><p>logger中添加StreamHandler，可以将日志输出到屏幕上：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/fw1PDkLn762SFvV.png" alt="1232840-20190523163756741-1913210288.png"></p><p>可以在log.txt文件和控制台中看到：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/V7abRwigpZGhPLu.png" alt="1232840-20190523163924184-136454992.png"></p><p>可以发现，logging有一个日志处理的主对象，其他处理方式都是通过addHandler添加进去，logging中包含的handler主要有如下几种：</p><p>handler名称：位置；作用</p><pre><code>StreamHandler：logging.StreamHandler；日志输出到流，可以是sys.stderr，sys.stdout或者文件FileHandler：logging.FileHandler；日志输出到文件BaseRotatingHandler：logging.handlers.BaseRotatingHandler；基本的日志回滚方式RotatingHandler：logging.handlers.RotatingHandler；日志回滚方式，支持日志文件最大数量和日志文件回滚TimeRotatingHandler：logging.handlers.TimeRotatingHandler；日志回滚方式，在一定时间区域内回滚日志文件SocketHandler：logging.handlers.SocketHandler；远程输出日志到TCP/IP socketsDatagramHandler：logging.handlers.DatagramHandler；远程输出日志到UDP socketsSMTPHandler：logging.handlers.SMTPHandler；远程输出日志到邮件地址SysLogHandler：logging.handlers.SysLogHandler；日志输出到syslogNTEventLogHandler：logging.handlers.NTEventLogHandler；远程输出日志到Windows NT/2000/XP的事件日志MemoryHandler：logging.handlers.MemoryHandler；日志输出到内存中的指定bufferHTTPHandler：logging.handlers.HTTPHandler；通过&quot;GET&quot;或者&quot;POST&quot;远程输出到HTTP服务器</code></pre><h6 id="2-3-日志回滚"><a href="#2-3-日志回滚" class="headerlink" title="2.3 日志回滚"></a>2.3 日志回滚</h6><p>其实意思就是log会写在一个文件，这个文件定义成1K大小，日志太多写不下的话，它会自动备份成log.txt.1,log.txt.2 ……，然后再创建一个log.txt开始写log。使用RotatingFileHandler，可以实现日志回滚：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/fMj4AOIC2wW7vVQ.png" alt="1232840-20190523164831868-922821136.png"></p><p>可以在工程目录中看到，备份的日志文件：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/w7Q86nxSDHdsTjB.png" alt="1232840-20190523164859502-1243120788.png"></p><h4 id="3-设置消息的等级"><a href="#3-设置消息的等级" class="headerlink" title="3.设置消息的等级"></a>3.设置消息的等级</h4><p>可以设置不同的日志等级，用于控制日志的输出：</p><p>日志等级：使用范围</p><pre><code>FATAL：致命错误CRITICAL：特别糟糕的事情，如内存耗尽、磁盘空间为空，一般很少使用ERROR：发生错误时，如IO操作失败或者连接问题WARNING：发生很重要的事件，但是并不是错误时，如用户登录密码错误INFO：处理请求或者状态变化等日常事务DEBUG：调试过程中使用DEBUG等级，如算法中每个循环的中间状态</code></pre><h4 id="4-捕获traceback"><a href="#4-捕获traceback" class="headerlink" title="4.捕获traceback"></a>4.捕获traceback</h4><p>Python中的traceback模块被用于跟踪异常返回信息，可以在logging中记录下traceback。</p><p>代码如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ytbVLRopjTBCu2X.png" alt="1232840-20190523165055695-1632324263.png"></p><p>控制台和日志文件log.txt中输出：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/nuzHapKMo8mYOv3.png" alt="1232840-20190523165236662-1697593011.png"></p><p>也可以使用logger.exception(msg,_args)，它等价于logger.error(msg,exc_info = True,_args)，所以你可以将</p><pre><code>1 logger.error(&quot;Faild to open sklearn.txt from logger.error&quot;,exc_info = True)</code></pre><p>替换为：</p><pre><code>logger.exception(&quot;Failed to open sklearn.txt from logger.exception&quot;)</code></pre><p>控制台和日志文件log.txt中输出：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/LZIQXivj5aEqSfA.png" alt="1232840-20190523165410285-129905082.png"></p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>　　　　嘿嘿，又完成了一篇，下一篇给小伙伴们介绍一下，有关通过JSON或者YAML文件配置logging模块、多模块使用logging和自己封装一个日志类！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化38</title>
      <link href="/2016/03/22/interface/"/>
      <url>/2016/03/22/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十八）-python操作mysql数据库（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　现在的招聘要求对QA人员的要求越来越高，测试的一些基础知识就不必说了，来说测试知识以外的，会不会一门或者多门开发与语言，能不能读懂代码，会不会Linux，会不会搭建测试系统，会不会常用的数据库，会不会SQL等等，因此我们这篇文章来讲解如何用python语言操作mysql数据库。</p><p> 本科阶段曾学过使用java对MySQL数据库进行操作，基本思路是先连接数据库，然后执行SQL语句对数据库进行操作，最后打印结果并断开连接。使用Python操作数据库的流程和以上过程基本一致，在对其进行介绍之前，先介绍一些基本的概念。</p><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><h5 id="2-1python操作数据库的流程"><a href="#2-1python操作数据库的流程" class="headerlink" title="2.1python操作数据库的流程"></a>2.1python操作数据库的流程</h5><p>以流程图的方式展示python操作MySQL数据库的流程：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/reNgMZyDJvLzOA3.png" alt="1232840-20190523083805321-664856846.png"></p><p>　　对上图的解读：首先检查是否依次创建Connection对象（数据库连接对象）用于打开数据库连接，创建Cursor对象（游标对象）用于执行查询和获取结果；然后执行SQL语句对数据库进行增删改查等操作并提交事务，此过程如果出现异常则使用回滚技术使数据库恢复到执行SQL语句之前的状态；最后，依次销毁Cursor对象和Connection对象，以避免多计算机内存过多的占用和浪费。</p><p>　　下面依次对Connection对象、Cursor对象和事务等概念进行介绍。</p><h5 id="2-2Connection对象"><a href="#2-2Connection对象" class="headerlink" title="2.2Connection对象"></a>2.2Connection对象</h5><p>Connection对象即为数据库连接对象，在python中可以使用pymysql.connect()方法创建Connection对象，该方法的常用参数如下：</p><p>host：连接的数据库服务器主机名，默认为本地主机（localhost）；字符串类型（String） 。</p><p>user：用户名，默认为当前用户；字符串类型（String） 。</p><p>passwd：密码，无默认值；字符串类 （String）。</p><p>db：数据库名称，无默认值；字符串类型（String） 。</p><p>port：指定数据库服务器的连接端口，默认为3306；整型（int）。</p><p>charset：连接字符集；字符串类型（String）</p><h6 id="2-2-1Connection对象常用的方法如下："><a href="#2-2-1Connection对象常用的方法如下：" class="headerlink" title="2.2.1Connection对象常用的方法如下："></a>2.2.1Connection对象常用的方法如下：</h6><p>cursor()：使用当前连接创建并返回游标 。</p><p>commit()：提交当前事务 。</p><p>rollback()：回滚当前事务 。</p><p>close()：关闭当前连接</p><h5 id="2-3Cursor对象"><a href="#2-3Cursor对象" class="headerlink" title="2.3Cursor对象"></a>2.3Cursor对象</h5><p>Cursor对象即为游标对象，用于执行查询和获取结果，在python中可以使用conn.cursor()创建，conn为Connection对象。Cursor对象常用的方法和属性如下：</p><p>execute()：执行数据库查询或命令，将结果从数据库获取到客户端 fetchone()：获取结果集的下一行 fetchmany()：获取结果集的下几行 fetchall()：获取结果集中剩下的所有行 close()：关闭当前游标对象 rowcount：最近一次的execute返回数据的行数或受影响的行数</p><h4 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h4><h6 id="1、事务机制可以确保数据一致性。"><a href="#1、事务机制可以确保数据一致性。" class="headerlink" title="1、事务机制可以确保数据一致性。"></a>1、事务机制可以确保数据一致性。</h6><p>事务是数据库理论中一个比较重要的概念，指访问和更新数据库的一个程序执行单元，具有ACID特性：</p><p>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。<br>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p><p>在开发时，我们以以下三种方式使用事务：</p><p>正常结束事务：conn.commit() 异常结束事务：conn.rollback() 关闭自动commit：设置 conn.autocommit(False)</p><h6 id="2-、使用python实现对MySQL数据库的增删改查等操作"><a href="#2-、使用python实现对MySQL数据库的增删改查等操作" class="headerlink" title="2 、使用python实现对MySQL数据库的增删改查等操作"></a>2 、使用python实现对MySQL数据库的增删改查等操作</h6><p>在python中操作MySQL数据库时，要使用的模块是：</p><p>Python2中：mysqldb（pip2 install mysqldb） Python3中：pymysql（pip3 install pymysql）</p><p>本篇博客所使用的环境为：</p><p>python 3.7 win 10 pycharm 2018.3.5 pymysql 0.9.2 mysql 5.6 </p><p>下面将以具体代码的形式依次介绍python中如何实现对MySQL数据库的增删改查等操作。</p><h4 id="4-python操作数据库"><a href="#4-python操作数据库" class="headerlink" title="4.python操作数据库"></a>4.python操作数据库</h4><p>Python 标准数据库接口为 Python DB-API，Python DB-API为开发人员提供了数据库应用编程接口。</p><p>Python 数据库接口支持非常多的数据库，你可以选择适合你项目的数据库：</p><p>GadFly<br>mSQL<br>MySQL（小公司、小厂首选）<br>PostgreSQL<br>Microsoft SQL Server 2008（中型厂、中等公司首选）<br>Informix<br>Interbase<br>Oracle（大厂、大企业首选）<br>Sybase</p><p>你可以访问Python数据库接口及API查看详细的支持数据库列表。</p><p>不同的数据库你需要下载不同的DB API模块，例如你需要访问Oracle数据库和Mysql数据，你需要下载Oracle和MySQL数据库模块。</p><p>DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。</p><p>Python的DB-API，为大多数的数据库实现了接口，使用它连接各数据库后，就可以用相同的方式操作各数据库。</p><h4 id="5-Python-DB-API使用流程："><a href="#5-Python-DB-API使用流程：" class="headerlink" title="5.Python DB-API使用流程："></a>5.Python DB-API使用流程：</h4><p>引入 API 模块。<br>获取与数据库的连接。<br>执行SQL语句和存储过程。<br>关闭数据库连接。</p><h4 id="6-什么是MySQLdb"><a href="#6-什么是MySQLdb" class="headerlink" title="6.什么是MySQLdb?"></a>6.什么是MySQLdb?</h4><p>PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。</p><p>PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。</p><h4 id="7-如何安装MySQLdb"><a href="#7-如何安装MySQLdb" class="headerlink" title="7.如何安装MySQLdb?"></a>7.如何安装MySQLdb?</h4><p>在使用 PyMySQL 之前，我们需要确保 PyMySQL 已安装。</p><p>PyMySQL 下载地址：<a href="https://github.com/PyMySQL/PyMySQL。" target="_blank" rel="noopener">https://github.com/PyMySQL/PyMySQL。</a></p><p>如果还未安装，我们可以使用以下命令安装最新版的 PyMySQL：</p><pre><code>1 pip install PyMySQL</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/oxqmf8FBYup5sTw.png" alt="1232840-20190522134717229-660691548.png"></p><p>如果你的系统不支持 pip 命令，可以使用以下方式安装：</p><p>1、使用 git 命令下载安装包安装(你也可以手动下载)：</p><pre><code>1 git clone https://github.com/PyMySQL/PyMySQL2 cd PyMySQL/3 python3 setup.py install</code></pre><p>2、如果需要制定版本号，可以使用 curl 命令来安装：</p><pre><code>1 # X.X 为 PyMySQL 的版本号2 url -L https://github.com/PyMySQL/PyMySQL/tarball/pymysql-X.X | tar xz3 cd PyMySQL*4 python3 setup.py install5 # 现在你可以删除 PyMySQL* 目录</code></pre><p>注意：请确保您有root权限来安装上述模块。</p><p>安装的过程中可能会出现”ImportError: No module named setuptools”的错误提示，意思是你没有安装setuptools，你可以访问<a href="https://pypi.python.org/pypi/setuptools" target="_blank" rel="noopener">https://pypi.python.org/pypi/setuptools</a> 找到各个系统的安装方法。</p><p>Linux 系统安装实例：</p><pre><code>1 $ wget https://bootstrap.pypa.io/ez_setup.py2 $ python3 ez_setup.py</code></pre><h4 id="8-数据库连接"><a href="#8-数据库连接" class="headerlink" title="8.数据库连接"></a>8.数据库连接</h4><p>连接数据库前，请先确认以下事项：</p><p>您已经创建了数据库 TESTDB（测试数据库）<br>在TESTDB数据库中您已经创建了表 EMPLOYEE（测试用的测试表）<br>EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。<br>连接数据库TESTDB（测试数据库）使用的用户名为 “testuser” ，密码为 “test123”,你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令。<br>在你的机子上已经安装了 Python MySQLdb 模块。<br>如果你对sql语句不熟悉，可以自己先简单的学习一下</p><p>1、查看有没有创建数据库TESTDB（测试数据库），打开MySQL的client界面输入密码 后，输入命令：</p><pre><code>1 show databases;</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/FNofdcPSyAVOKtT.png" alt="1232840-20190522133027447-1253841502.png"></p><p>2、看到没有那个数据库，那我们就开始创建一个TESTDB数据库，输入命令：</p><pre><code>1 create database TESTDB;</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/o97A8KtSNVwDQPE.png" alt="1232840-20190522133659838-489646343.png"></p><p>3、再次输入第一步的命令查看，看到已经成功创建</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/VDvNWoqKc8p1Iwn.png" alt="1232840-20190522133728435-496568491.png"></p><p>4、查看TESTDB数据库里，有没有EMPLOYEE（测试用的测试表），输入命令：</p><pre><code>1 use testdb;2 show tables;</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/V48wT5DhIxKs6Wi.png" alt="1232840-20190522134117555-151928111.png"></p><p>5、查看到在TESTDB数据库中没有EMPLOYEE表，那么没有我们就创建一张EMPLOYEE表即可。</p><h4 id="9-创建一个实例"><a href="#9-创建一个实例" class="headerlink" title="9.创建一个实例"></a>9.创建一个实例</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/7rMal8DxywsC4pZ.png" alt="1232840-20190522135623241-766602808.png"></p><p>运行结果：（从结果中我们可以看见成功创建了一个Connection和Cursor对象。）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Ij6pudJWClxL7oF.png" alt="1232840-20190522135652161-1858329714.png"></p><p>下面将以具体代码的形式依次介绍python中如何实现对MySQL数据库的增删改查等操作。</p><h4 id="10-实例"><a href="#10-实例" class="headerlink" title="10.实例"></a>10.实例</h4><h5 id="1、连接数据库"><a href="#1、连接数据库" class="headerlink" title="1、连接数据库"></a>1、连接数据库</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/JqeIO9VpXC6jGRH.png" alt="1232840-20190522140536120-1399975454.png"></p><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/5ES7HxIArOCfkhd.png" alt="1232840-20190522140638667-843910318.png"></p><h6 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-22 7 @author: 北京-宏哥 8 Project:学习和使用python操作MySQL数据库 9 &#39;&#39;&#39;10 # 3.导入模块11 import pymysql12 13 import pymysql14 15 # 打开数据库连接16 conn = pymysql.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testdb&#39;)17 18 # 使用cursor()方法创建一个游标对象19 cursor = conn.cursor()20 21 # 使用execute()方法执行SQL查询22 cursor.execute(&#39;SELECT VERSION()&#39;)23 24 # 使用fetchone()方法获取单条数据25 data = cursor.fetchone()26 27 # 打印28 print(&#39;database version: %s&#39; % data)29 30 # 关闭数据库连接31 conn.close()</code></pre><h5 id="2、创建数据库表"><a href="#2、创建数据库表" class="headerlink" title="2、创建数据库表"></a>2、创建数据库表</h5><p>如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表EMPLOYEE：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/51PRl8ChpD7SnsU.png" alt="1232840-20190522140959322-930458326.png"></p><p>运行代码后查看有没有表创建，输入命令：</p><pre><code>1 use TESTDB；2 show tables;</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/WmZN95dD6uGTvrS.png" alt="1232840-20190522141802760-1972503197.png"></p><h6 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Se8RQjZz9TG6AgE.png" alt="1232840-20190522142104484-1886215381.png"></p><h6 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-22 7 @author: 北京-宏哥 8 Project:学习和使用python操作MySQL数据库 9 &#39;&#39;&#39;10 # 3.导入模块11 import pymysql12 13 import pymysql14 15 # 打开数据库连接16 conn = pymysql.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testdb&#39;)17 18 # 使用cursor()方法创建一个游标对象cursor19 cursor = conn.cursor()  # 游标对象用于执行查询和获取结果20 21 # 使用execute()方法执行SQL，如果表存在则将其删除22 cursor.execute(&#39;DROP TABLE IF EXISTS EMPLOYEE&#39;)23 24 # 使用预处理语句创建表25 sql = &quot;&quot;&quot;CREATE TABLE `employee` (26   `first_name` varchar(255) DEFAULT NULL COMMENT &#39;姓&#39;,27   `last_name` varchar(255) DEFAULT NULL COMMENT &#39;名&#39;,28   `age` int(11) DEFAULT NULL COMMENT &#39;年龄&#39;,29   `sex` varchar(255) DEFAULT NULL COMMENT &#39;性别&#39;,30   `income` varchar(255) DEFAULT NULL COMMENT &#39;收入&#39;31 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;32 &quot;&quot;&quot;33 34 # 执行SQL语句35 cursor.execute(sql)36 37 # 关闭数据库连接38 conn.close()</code></pre><h5 id="3、数据库插入操作"><a href="#3、数据库插入操作" class="headerlink" title="3、数据库插入操作"></a>3、数据库插入操作</h5><p>以下实例使用执行 SQL INSERT 语句向表 EMPLOYEE 插入记录：</p><p>1、首先查询有没有记录输入查询语句：</p><pre><code>1 select * from employee;</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/QesWvmMUHCgJ42K.png" alt="1232840-20190522142734620-715136586.png"></p><p>2、代码实现</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/siMDplQTc58X9wo.png" alt="1232840-20190522143028200-1161510174.png"></p><h6 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/BeiRpJ7O5zj61IA.png" alt="1232840-20190522143058549-976392202.png"></p><p>再次查看有没有记录，输入第一步的sql语句：（可以看到插入一条记录）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/CsVnpSx6YvHOyhU.png" alt="1232840-20190522143215144-1434316013.png"></p><h6 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-03-22@author: 北京-宏哥Project:学习和使用python操作MySQL数据库&#39;&#39;&#39;# 3.导入模块import pymysqlimport pymysql# 打开数据库连接conn = pymysql.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testdb&#39;)# 使用cursor()方法获取操作游标cursor = conn.cursor()# SQL语句：向数据表中插入数据sql = &quot;&quot;&quot;INSERT INTO EMPLOYEE(FIRST_NAME,         LAST_NAME, AGE, SEX, INCOME)         VALUES (&#39;Mac&#39;, &#39;Mohan&#39;, 20, &#39;M&#39;, 2000)&quot;&quot;&quot;# 异常处理try:    # 执行SQL语句    cursor.execute(sql)    # 提交事务到数据库执行    conn.commit()  # 事务是访问和更新数据库的一个程序执行单元except:    # 如果发生错误则执行回滚操作    conn.rollback()# 关闭数据库连接conn.close()</code></pre><h6 id="另一种写法："><a href="#另一种写法：" class="headerlink" title="另一种写法："></a>另一种写法：</h6><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-03-22@author: 北京-宏哥Project:学习和使用python操作MySQL数据库&#39;&#39;&#39;# 3.导入模块import pymysqlimport pymysql# 打开数据库连接conn = pymysql.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testdb&#39;)# 使用cursor()方法获取操作游标cursor = conn.cursor()# SQL语句：向数据表中插入数据sql = &quot;INSERT INTO EMPLOYEE(FIRST_NAME, \       LAST_NAME, AGE, SEX, INCOME) \       VALUES (&#39;%s&#39;, &#39;%s&#39;,  %s,  &#39;%s&#39;,  %s)&quot; % \       (&#39;Mac&#39;, &#39;Mohan&#39;, 20, &#39;M&#39;, 2000)# 异常处理try:    # 执行SQL语句    cursor.execute(sql)    # 提交事务到数据库执行    conn.commit()  # 事务是访问和更新数据库的一个程序执行单元except:    # 如果发生错误则执行回滚操作    conn.rollback()# 关闭数据库连接conn.close()</code></pre><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p>以下代码使用变量向SQL语句中传递参数:</p><pre><code>1 ..................................2 user_id = &quot;root&quot;3 password = &quot;root&quot;4 5 con.execute(&#39;insert into Login values( %s,  %s)&#39; % \6              (user_id, password))7 ..................................</code></pre><h5 id="3、数据库查询操作"><a href="#3、数据库查询操作" class="headerlink" title="3、数据库查询操作"></a>3、数据库查询操作</h5><p>Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。</p><p>fetchone(): 该方法获取下一个查询结果集。结果集是一个对象<br>fetchall():接收全部的返回结果行.<br>rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。</p><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p>查询EMPLOYEE表中salary（工资）字段大于1000的所有数据：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/rzHqOe1U84LKEyJ.png" alt="1232840-20190522143846155-1580202610.png"></p><h6 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/GykDYIWAslgrvto.png" alt="1232840-20190522143913198-328248229.png"></p><h6 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-22 7 @author: 北京-宏哥 8 Project:学习和使用python操作MySQL数据库 9 &#39;&#39;&#39;10 # 3.导入模块11 import pymysql12 13 import pymysql14 15 # 打开数据库连接16 conn = pymysql.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testdb&#39;)17 18 # 使用cursor()方法获取操作游标19 cursor = conn.cursor()20 21 # SQL语句：查询22 sql = &quot;SELECT * FROM employee WHERE income &gt; 1000 &quot;23 24 # 异常处理25 try:26     # 执行SQL语句27     cursor.execute(sql)28     # 获取所有的记录列表29     results = cursor.fetchall()30     # 遍历列表31     for row in results:32         # 打印列表元素33         print(row)34         # 姓35         first_name = row[0]36         # 名37         last_name = row[1]38         # 年龄39         age = row[2]40         # 性别41         sex = row[3]42         # 收入43         income = row[4]44         # 打印列表元素45         print(first_name, last_name, age, sex, income)46 except:47     print(&#39;Uable to fetch data!&#39;)48 49 # 关闭数据库连接50 conn.close()</code></pre><h5 id="4、数据库更新操作"><a href="#4、数据库更新操作" class="headerlink" title="4、数据库更新操作"></a>4、数据库更新操作</h5><p>更新操作用于更新数据表的的数据，以下实例将 EMPLOYEE 表中的 SEX 字段为 ‘M’ 的 AGE 字段递增 5：</p><p>1、以前age是20，</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/gQn1P2loDT47tIE.png" alt="1232840-20190522144249346-485014602.png"></p><p>2、代码实现：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/nEFRK2YMa3l6Po8.png" alt="1232840-20190522144451993-596997079.png"></p><p>3、运行结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/3RtadnqYjbS1P9B.png" alt="1232840-20190522144512041-1863872617.png"></p><p>4、查询age变更到25了没有</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Ejtpi5W8fLsMvKR.png" alt="1232840-20190522144603004-1034685737.png"></p><p>5、参考代码</p><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-03-22@author: 北京-宏哥Project:学习和使用python操作MySQL数据库&#39;&#39;&#39;# 3.导入模块import pymysqlimport pymysql# 打开数据库连接conn = pymysql.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testdb&#39;)# 使用cursor()方法获取操作游标cursor = conn.cursor()# SQL语句，执行更新操作sql = &#39;UPDATE employee SET age = age + 5 WHERE sex = &quot;M&quot;&#39;# 异常处理try:    # 执行SQL语句    cursor.execute(sql)    # 提交到数据库执行    conn.commit()except:    # 发生错误时回滚    conn.rollback()# 关闭数据库连接conn.close()</code></pre><h5 id="5、删除操作"><a href="#5、删除操作" class="headerlink" title="5、删除操作"></a>5、删除操作</h5><p>删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据：</p><p>1、大于20的只有一条，删除了就没有记录了，输入</p><pre><code>1  select * from employee;</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/jEqueoOBHW4V2zJ.png" alt="1232840-20190522145115234-2051097733.png"></p><p>2、代码实现</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/WBhQeO8NfE3LoAI.png" alt="1232840-20190522145318688-692528367.png"> </p><p>3、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/OcFrXxuLvyQP1oC.png" alt="1232840-20190522145305518-1938594856.png"></p><p>4、查看数据库表，重复第一步</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/UnrDfKR8i5ghzyL.png" alt="1232840-20190522152659620-917907207.png"></p><p>5、参考代码</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-22 7 @author: 北京-宏哥 8 Project:学习和使用python操作MySQL数据库 9 &#39;&#39;&#39;10 # 3.导入模块11 import pymysql12 13 import pymysql14 15 # 打开数据库连接16 conn = pymysql.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testdb&#39;)17 18 # 使用cursor()方法获取操作游标19 cursor = conn.cursor()20 21 # SQL语句，执行删除操作22 sql = &#39;DELETE FROM employee WHERE age &gt;20&#39;23 24 # 异常处理25 try:26     # 执行SQL语句27     cursor.execute(sql)28     # 提交到数据库执行29     conn.commit()30 except:31     # 发生错误时回滚32     conn.rollback()33 34 # 关闭数据库连接35 conn.close()</code></pre><h4 id="11-执行事务"><a href="#11-执行事务" class="headerlink" title="11.执行事务"></a>11.执行事务</h4><p>事务机制可以确保数据一致性。</p><p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><p>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。<br>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。<br>Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。</p><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><pre><code> 1 # SQL删除记录语句 2 sql = &quot;DELETE FROM EMPLOYEE WHERE AGE &gt; %s&quot; % (20) 3 try: 4    # 执行SQL语句 5    cursor.execute(sql) 6    # 向数据库提交 7    db.commit() 8 except: 9    # 发生错误时回滚10    db.rollback()</code></pre><p>对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。</p><p>commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。</p><h4 id="12-错误处理"><a href="#12-错误处理" class="headerlink" title="12.错误处理"></a>12.错误处理</h4><p>DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常:</p><table><thead><tr><th align="center">异常</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Warning</td><td align="center">当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。</td></tr><tr><td align="center">Error</td><td align="center">警告以外所有其他错误类。必须是 StandardError 的子类。</td></tr><tr><td align="center">InterfaceError</td><td align="center">当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。</td></tr><tr><td align="center">DatabaseError</td><td align="center">和数据库有关的错误发生时触发。 必须是Error的子类。</td></tr><tr><td align="center">DataError</td><td align="center">当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。</td></tr><tr><td align="center">OperationalError</td><td align="center">指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。</td></tr><tr><td align="center">IntegrityError</td><td align="center">完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。</td></tr><tr><td align="center">InternalError</td><td align="center">数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。</td></tr><tr><td align="center">ProgrammingError</td><td align="center">程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。</td></tr><tr><td align="center">NotSupportedError</td><td align="center">不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。</td></tr></tbody></table><h4 id="13-小结"><a href="#13-小结" class="headerlink" title="13.小结"></a>13.小结</h4><p> 　　哈哈，终于搞完了、整完了，累死宝宝了，已到半夜，明天有时间分享！！！</p><p>　　小伙伴python操作MySQL数据库就是这么简单！！！最重要的自己要会、要有扎实的SQL基础。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化37</title>
      <link href="/2016/03/21/interface/"/>
      <url>/2016/03/21/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十七）-封装与调用–读取excel 数据（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>在进行软件接口测试或设计自动化测试框架时，一个不比可避免的过程就是: 参数化，在利用python进行自动化测试开发时，通常会使用excel来做数据管理，利用xlrd、xlwt开源包来读写excel。例如：当我们登录的账号有多个的时候，我们一般用excel 存放测试数据，本篇文章介绍，python 读取excel 方法，并保存为字典格式。</p><h4 id="2-官网"><a href="#2-官网" class="headerlink" title="2.官网"></a>2.官网</h4><p>　　通过官网来查看如何使用python读取Excel，python excel官网： <a href="http://www.python-excel.org/，" target="_blank" rel="noopener">http://www.python-excel.org/，</a></p><p>1、以下是翻译后的官网文档：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/cQjSwRGMJiquNld.png" alt="1232840-20190520100216229-654332433.png"></p><p>2、点击“文档”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/FHL19kngSvcr8AB.png" alt="1232840-20190520101235338-1741101075.png"></p><p>3、点击“安装说明”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/MQVIAw2stcWyXb6.png" alt="1232840-20190520101341406-591577215.png"> </p><p>4、根据以上安装说明，进行准备</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/cb7o3VRBUOClNgI.png" alt="1232840-20190520101128682-1547343429.png"></p><h4 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3.环境准备"></a>3.环境准备</h4><p>1、以下是小编环境是：</p><p>操作系统：win10</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Ej8z7fULKMsBHnX.png" alt="1232840-20190520100750779-682148014.png"> </p><p>python环境：python3.7</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/hvme3uIz9GL7Bgp.png" alt="1232840-20190520100827606-641939549.png"></p><p>2、根据官方文档先安装 xlrd 模块，打开 cmd，输入 pip install xlrd 在线安装</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/1ljV3S4L8Qs7iyb.png" alt="1232840-20190520101716394-1200765055.png"></p><p>3、出现红色圈的内容表示xlrd安装成功</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/1XsgLGMySrAE4Tm.png" alt="1232840-20190520101526671-146997712.png"></p><h4 id="4-python对Excel的基本操作"><a href="#4-python对Excel的基本操作" class="headerlink" title="4.python对Excel的基本操作"></a>4.python对Excel的基本操作</h4><p>1、打开电子表格文件以进行数据提取，官方文档API</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Q47MNVloZkEqKjA.png" alt="1232840-20190520104040097-1372698205.png"></p><p>2、通过工作表索引、名称获取内容</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/6srJ4pYBQCqjium.png" alt="1232840-20190520115206531-1538743374.png"></p><p>3、实例1</p><p>（1）Excel内容</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/lBKeZW1Dyhxk2Mz.png" alt="1232840-20190520114847460-1403913047.png"></p><p>（2）代码实现</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/kTWyYOfeh97Lr8n.png" alt="1232840-20190520115325724-1081420078.png"></p><p>（3）运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/RDdVvP6LytZ9fmp.png" alt="1232840-20190520115410974-1958472211.png"></p><p>（4）参考代码1</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-21 7 @author: 北京-宏哥 8 Project:学习和使用python读取Excel 9 &#39;&#39;&#39;10 # 3.导入模块11 import xlrd12 13 if __name__ == &#39;__main__&#39;:14 15     # excel文件全路径16     xlPath = &quot;C:\\Users\\DELL\\Desktop\\test.xlsx&quot;17     # 用于读取excel18     xlBook = xlrd.open_workbook(xlPath)19     # 获取excel工作簿数20     count = len(xlBook.sheets())21     print(u&quot;工作簿数为:  &quot;, count)22     # 获取 表 数据的行列数23     table = xlBook.sheets()[0]24     nrows = table.nrows25     ncols = table.ncols26     print(u&quot;表数据行列为(%d, %d)&quot; % (nrows, ncols))27     # 循环读取数据28     for i in range(0, nrows):29         rowValues = table.row_values(i)  # 按行读取数据30         # 输出读取的数据31         for data in rowValues:32             print(data, &quot; &quot;,)33         print(&quot;&quot;)</code></pre><p>4、参考代码2</p><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-21 7 @author: 北京-宏哥 8 Project:学习和使用python读取Excel 9 &#39;&#39;&#39;10 # 3.导入模块11 import xlrd12 13 if __name__ == &#39;__main__&#39;:14     # 打开 exlce 表格，参数是文件路径15     data = xlrd.open_workbook(&#39;C:\\Users\\DELL\\Desktop\\test.xlsx&#39;)16     # table = data.sheets()[0] # 通过索引顺序获取17     # table = data.sheet_by_index(0) # 通过索引顺序获取18     table = data.sheet_by_name(u&#39;Sheet1&#39;)  # 通过名称获取19     nrows = table.nrows  # 获取总行数20     ncols = table.ncols  # 获取总列数21     # 获取一行或一列的值，参数是第几行22     print(table.row_values(0)) # 获取第一行值23     print(table.col_values(0)) # 获取第一列值</code></pre><p>5、以上代码运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Ck5OEriyfuj4KJx.png" alt="1232840-20190520131225877-1308365306.png"></p><h4 id="5-Excel存放数据（参数）"><a href="#5-Excel存放数据（参数）" class="headerlink" title="5.Excel存放数据（参数）"></a>5.Excel存放数据（参数）</h4><p>1、在 excel 中存放数据，第一行为标题，也就是对应字典里面的 key 值，如登录的参数：username，password</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/39CucqmYRsVjGUf.png" alt="1232840-20190520131844228-1459931335.png"></p><h4 id="6-封装读取参数或者数据方法"><a href="#6-封装读取参数或者数据方法" class="headerlink" title="6.封装读取参数或者数据方法"></a>6.封装读取参数或者数据方法</h4><p>1、最终读取的数据是多个字典的 list 类型数据，第一行数据就是字典里的 key 值，从第二行开始一一对应 value 值</p><p>2、封装好的代码如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/uw2MvLyITWpO1rA.png" alt="1232840-20190520145620750-1184782622.png"></p><p>3、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/WA9nPeLcSV6dlvk.png" alt="1232840-20190520145648605-1397316611.png"></p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>1、在安装xlrd模块的时候后边，还有一些黄色的警告，小伙伴们不需要的担心，翻译看一下，是需要更新pip</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/FopZqnI7G1KOxQL.png" alt="1232840-20190520110017114-824605163.png"></p><p>2、将提示的命令选中后，回车，另起一行粘贴，运行即可将pip更新到最新版本</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/7T4LVjWtZ8c5upv.png" alt="1232840-20190520110228385-1871871858.png"></p><p>3、小伙伴们可能发现在运行结果的显示：只有出现数字就会有个.0，解决办法：</p><p>　　如果 excel 数据中有纯数字的一定要右键》设置单元格格式》文本格式，要不然读取的数据是浮点数（先设置单元格格式后编辑，编辑成功左上角有个小三角图标）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/lRxi1pQyjOdVCBg.png" alt="1232840-20190520150229108-1392186232.png"></p><p>　　修改单元格式，运行代码结果：可以清楚看到.0没有了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/KrtVPTNsFCpJ5qL.png" alt="1232840-20190520150333063-1584747590.png"></p><p>4、好了关于python读取Excel的内容，就先讲解到这个，有兴趣可以看其官方文档对表格进行合并、样式设置等等系列动作！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化36</title>
      <link href="/2016/03/20/interface/"/>
      <url>/2016/03/20/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十六）-封装与调用–流程类接口关联续集（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇已经给大家都介绍过了流程类接口关联，但是由于博客的登录机制改变，所以没有办法给小伙伴们实战演练一下，那么这篇就按照上一篇计划的用jenkins来给小伙伴们演示一下流程类接口的封装和调用，其实很简单，就是用上一篇和前边这篇传送门的代码稍稍修改即可。不知道你自己练习了么，如果练习了，可以看看和我有什么不同，没练习的看看自己思路和我有啥不一样。好了废话少说进入主题</p><h4 id="2-大致流程"><a href="#2-大致流程" class="headerlink" title="2.大致流程"></a>2.大致流程</h4><p>1、同样的道理，在接口测试中，有些接口经常会被用到比如登录的接口，这时候我们可以每个接口都封装成一个方法，如：登录、新建任务和保存新建任务、删除新建任务，这四个接口就可以写成四个方法</p><p>2、接口封装好了后，后面我们写用例那就直接调用封装好的接口就行了，有些参数，可以参数化，如保存任务的的name和 jname 两个参数是动态的。调用时直接将其传入方法中，就可以了</p><p>3、像这种流程类的接口，后面的会依赖前面的，我们就可以通过 session将其关联起来</p><p>4、将自动化测试脚本保存到 login.py文件中，这样就可以是脚本和业务分离</p><h4 id="3-jenkins实例实战"><a href="#3-jenkins实例实战" class="headerlink" title="3.jenkins实例实战"></a>3.jenkins实例实战</h4><p>第一步：在pycharm中左上角点击“file”，然后点击“New Project”，修改名字为“jiekou”，点击“Create”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/8CUbYlI3EJZKeRD.png" alt="1232840-20190516090122765-1161686223.png"></p><p>第二步：在jiekou文件夹下，分别创建python package分别命名为“jenkins”和“case”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/PWy7keS3gLOH8Zm.png" alt="1232840-20190516090245918-1920045812.png"> </p><p>第三步：都完成后，如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/x7CMIAqcEyjU8wH.png" alt="1232840-20190516090425686-1955518715.png"> </p><p>第四步：在login.py文件中编辑自动化测试脚本</p><p>1、登录jenkins方法封装</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ScEYFHDKu7gJABq.png" alt="1232840-20190516091425837-1834722378.png"></p><p>2、新建任务和保存新建任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/HUhwkTA7yOMbtGe.png" alt="1232840-20190516092026018-1174335683.png"></p><p>3、删除新建任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/NHEYUJenpmQVCXA.png" alt="1232840-20190516092455283-1634376716.png"></p><h4 id="4-用例导入接口"><a href="#4-用例导入接口" class="headerlink" title="4.用例导入接口"></a>4.用例导入接口</h4><p>1、导入上面 login.py 模块写的接口自动化测试脚本</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/UIRc1hzangq6PGN.png" alt="1232840-20190516092937058-231888050.png"></p><p>2、在test_01.py中编辑测试用例</p><p>（1）登录接口测试用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/t9iA35hsjvdo6Nx.png" alt="1232840-20190516093910664-2112530239.png"></p><p>（2）新建和保存任务接口测试用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/MWO1mlAruF7otiU.png" alt="1232840-20190516094948928-288687683.png"> </p><p>（3）删除新建任务接口测试用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/UCfviShcag2tEdX.png" alt="1232840-20190516095005966-2079269356.png"> </p><p>3、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/A2NiIXK8kpUDdHE.png" alt="1232840-20190515154916797-93334513.png"></p><h4 id="5-参考代码"><a href="#5-参考代码" class="headerlink" title="5.参考代码"></a>5.参考代码</h4><p>学到这里了参考代码留作悬念，自己先自己根据我给的截图将代码串联起来，看看能不能实现，如果实在想不出来的话，可以评论里留言，我将参考源码发给你。或者在QQ群里找我要！！！</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p> 　　好了，到这里jenkins的流程类接口关联封装与调用也接近了尾声，由于其登录，保存，删除任务的接口没返回success或者别的明确结果，所以可能有的小伙伴看到代码的运行结果也不是很直观明显。为了让小伙伴们看的更清楚直观，</p><p>我们还是老办法：打断点！！！这个想必大家学到这里不是很陌生了吧！陌生的话，再和我详细来一遍，不陌生的和我复习一遍。</p><p>1、登录接口成功我这里取得是页面元素：admin和注销，进行断言的</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/rzVUI3DGaRM9k6y.png" alt="1232840-20190516112637273-1212455360.png"></p><p>登录成功页面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ySfhknw1XLmvztR.png" alt="1232840-20190516112440718-1520570323.png"></p><p>2、新建和保存任务，接口通过断点来看一下</p><p>（1）在执行删除任务的接口用例前边方法双击出现一个大红点</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/1PhTaRuN5WBipkn.png" alt="1232840-20190516113317535-1681590869.png"> </p><p>（2）登录jenkins查看页面没有一个新建的任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/KcjVRveX8k9ANCQ.png" alt="1232840-20190516113432380-41805890.png"></p><p>（3）点击pycharm右上角的昆虫图标，debug运行代码，一步步执行代码，但是不要执行删除任务方法</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/mqhklRFMG9oWfEL.png" alt="1232840-20190516113532866-260100234.png"></p><p>（4）刷新jenkins查看页面创建和保存一个新建的任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/6mfNiyF17DPYSv8.png" alt="1232840-20190516113848403-1514551220.png"></p><p>（5）继续debug运行，执行删除任务方法，刷新jenkins页面如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/pQicgaDF3qClJ4K.png" alt="1232840-20190516114540176-590940068.png"></p><p>（6）小伙伴傻眼了，为啥没有删掉了呢？？？你再认真细心地看一下，到底删掉了吗？？？其实是删掉了，不骗你的。你看这个任务名称后边跟了一个1，这个是新建保存任务的接口留下的，而那个删除任务的名称后边是个2</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/pQicgaDF3qClJ4K.png" alt="1232840-20190516114540176-590940068.png"></p><p>哈哈，时间也不早了，早点休息吧，就到这里吧！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化35</title>
      <link href="/2016/03/19/interface/"/>
      <url>/2016/03/19/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十五）-封装与调用–流程类接口关联（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　流程相关的接口，主要用 session 关联，如果写成函数（如上篇），s 参数每个函数都要带，每个函数多个参数，这时候封装成类会更方便。在这里我们还是以博客园为例，带着小伙伴们实践一下。</p><h4 id="2-接口封装大致流程"><a href="#2-接口封装大致流程" class="headerlink" title="2.接口封装大致流程"></a>2.接口封装大致流程</h4><p>1、在接口测试中，有些接口经常会被用到比如登录的接口，这时候我们可以每个接口都封装成一个方法，如：登录、保存草稿、发布随笔、删除随笔，这四个接口就可以写成四个方法</p><p>2、接口封装好了后，后面我们写用例那就直接调用封装好的接口就行了，有些参数，可以参数化，如保存草稿的 title 和 body 两个参数是动态的。调用时直接将其传入方法中，就可以了</p><p>3、像这种流程类的接口，后面的会依赖前面的，我们就可以通过 session将其关联起来</p><p>4、将自动化测试脚本保存到 login.py文件中，这样就可以是脚本和业务分离</p><h4 id="3-实战实例"><a href="#3-实战实例" class="headerlink" title="3.实战实例"></a>3.实战实例</h4><p>第一步：在pycharm中左上角点击“file”，然后点击“New Project”，修改名字为“jiekou”，点击“Create”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/b9iCRegkyUjXM1l.png" alt="1232840-20190514103928018-1244794824.png"></p><p>第二步：在jiekou文件夹下，分别创建python package分别命名为“blog”和“case”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/98A6VX7Ckpm2RJc.png" alt="1232840-20190514104326199-981270842.png"></p><p>第三步：都完成后，如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/rGJY7s4K2Lydx5B.png" alt="1232840-20190514104722073-1586666121.png"> </p><p>第四步：在login.py文件中编辑自动化测试脚本</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/61jwyNgRtvD7Ibu.png" alt="1232840-20190514113432412-753092381.png"> </p><h4 id="4-用例导入接口"><a href="#4-用例导入接口" class="headerlink" title="4.用例导入接口"></a>4.用例导入接口</h4><p>1、导入上面 login.py 模块写的接口自动化测试脚本</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/vGEB2iZKVR7zOnP.png" alt="1232840-20190514114940669-1040742021.png"></p><p>2、在test_01.py中编辑测试用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/foBIVedkg3TPRlX.png" alt="1232840-20190514113853908-1880419913.png"></p><h4 id="5-参考代码"><a href="#5-参考代码" class="headerlink" title="5.参考代码"></a>5.参考代码</h4><h4 id="5-1login-py文件"><a href="#5-1login-py文件" class="headerlink" title="5.1login.py文件"></a>5.1login.py文件</h4><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-19 7 @author: 北京-宏哥 8 Project:学习和使用封装与调用--流程类接口关联 9 &#39;&#39;&#39;10 # 3.导入模块11 import requests12 # 禁用安全请求警告13 import urllib314 15 urllib3.disable_warnings()16 import warnings17 18 warnings.simplefilter(&quot;ignore&quot;, ResourceWarning)19 20 21 class Blog():22     def __init__(self, s):23         s = requests.session()  # 全局参数24         self.s = s25 26     def login(self):27         &#39;&#39;&#39;登录接口&#39;&#39;&#39;28         url = &quot;http://localhost:8080/jenkins/j_acegi_security_check&quot;29         headers = {30             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot;31         }  # get方法其它加个ser-Agent就可以了32         d = {&quot;j_username&quot;: &quot;admin&quot;,33              &quot;j_password&quot;: &quot;111111&quot;,34              &quot;from&quot;: &quot;&quot;,35              &quot;Submit&quot;: u&quot;登录&quot;,36              &quot;remember_me&quot;: &quot;on&quot;37              }38 39         s = requests.session()40         r = s.post(url, headers=headers, data=d)41         # print (r.content.decode(&#39;utf-8&#39;))42         # 正则表达式提取账号和登录按钮43         import re44         t = re.findall(r&#39;&lt;b&gt;(.+?)&lt;/b&gt;&#39;, r.content.decode(&#39;utf-8&#39;))  # 用python3的这里r.content需要解码45         print(t[0])46         print(t[1])47 48     def get_postid(self, r2_url):49         &#39;&#39;&#39;正则表达式提取&#39;&#39;&#39;50         import re51         postid = re.findall(r&quot;postid=(.+?)&amp;&quot;, r2_url)52         print(postid)  # 这里是 list []53         # 提取为字符串54         print(postid[0])55         return postid[0]56 57     def save(self, title, body):58         &#39;&#39;&#39;保存草稿箱：59         参数 1：title # 标题60         参数 2：body # 中文&#39;&#39;&#39;61         url2 = &quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot;62         d = {&quot;__VIEWSTATE&quot;: &quot;&quot;,63              &quot;__VIEWSTATEGENERATOR&quot;: &quot;FE27D343&quot;,64              &quot;Editor$Edit$txbTitle&quot;: title,65              &quot;Editor$Edit$EditorBody&quot;: &quot;&lt;p&gt;%s&lt;/p&gt;&quot; % body,66              &quot;Editor$Edit$Advanced$ckbPublished&quot;: &quot;on&quot;,67              &quot;Editor$Edit$Advanced$chkDisplayHomePage&quot;: &quot;on&quot;,68              &quot;Editor$Edit$Advanced$chkComments&quot;: &quot;on&quot;,69              &quot;Editor$Edit$Advanced$chkMainSyndication&quot;: &quot;on&quot;,70              &quot;Editor$Edit$lkbDraft&quot;: &quot;存为草稿&quot;,71              }72         r2 = self.s.post(url2, data=d, verify=False)  # 保存草稿箱73         print(r2.url)74         return r2.url75     76     def del_tie(self, postid):77         &#39;&#39;&#39;删除帖子&#39;&#39;&#39;78         del_json = {&quot;postId&quot;: postid}79         del_url = &quot;https://i.cnblogs.com/post/delete&quot;80         r3 = self.s.post(del_url, json=del_json, verify=False)81         print(r3.json()[&quot;isSuccess&quot;])82         return r3.json()83 84 85 if __name__ == &quot;__main__&quot;:86     s = requests.session()87     Blog(s).login()</code></pre><h4 id="5-2test-01-py"><a href="#5-2test-01-py" class="headerlink" title="5.2test_01.py"></a>5.2test_01.py</h4><pre><code> 1 # coding=utf-8 2 # 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 # 2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-19 7 @author: 北京-宏哥 8 Project:学习和使用封装与调用--流程类接口关联 9 &#39;&#39;&#39;10 # 3.导入模块11 import unittest12 import requests13 import warnings14 from blog.login import Blog15 16 17 class Test(unittest.TestCase):18     def setUp(self):19         warnings.simplefilter(&quot;ignore&quot;, ResourceWarning)20         s = requests.session()21         self.blog = Blog(s)22 23      def test_login_01(self):24     　　 self.blog.login()25     　　 print (result)26     　　 print (type(result))27      　　print (result[&quot;success&quot;] )# 登录，获取结果28     　　 self.assertEqual(result[&quot;success&quot;] , True) # 拿结果断言29     def test_del_02(self):30         # 第一步：登录31         self.blog.login()32         # 第二步：保存33         r2_url = self.blog.save(title=&quot;北京-宏哥，流程类接口关联&quot;, body=&quot;学习和使用封装与调用--流程类接口关联&quot;)34         pid = self.blog.get_postid(r2_url)35         # 第三步：删除36         result = self.blog.del_tie(pid)37         print(result)38         self.assertEqual(result[&quot;isSuccess&quot;], True)39 40 41 if __name__ == &quot;__main__&quot;:42     unittest.main()</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>　　 流程相关的接口的封装和调用给各位小伙伴暂且介绍到这里，因为博客园的登陆机制改变，小伙伴们可以用jenkins的仿照这一篇实战演练一下，下一篇我会带你们一起做一下。</p><p>欲知后事发展，请听下回分解！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化34</title>
      <link href="/2016/03/18/interface/"/>
      <url>/2016/03/18/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十四）-封装与调用–函数和参数化（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　前面虽然实现了参数的关联，但是那种只是记流水账的完成功能，不便于维护，也没什么可读性，随着水平和技能的提升，再返回头去看前边写的代码，简直是惨不忍睹那样的代码是初级入门的代码水平都达不到。接下来这篇由我带领小伙伴们把每一个鼠标点击动作写成一个函数，这样更方便维护了，而且可读性也高，后期其他维护人员在维护代码的时候看起来赏心悦目，就不会骂娘了。</p><p>　　参数化的思维只需记住一点：不要写死，这样就便于维护，否则就会牵一发而动全身，一处修改导致处处修改，不便于维护。</p><h4 id="2-登录函数"><a href="#2-登录函数" class="headerlink" title="2.登录函数"></a>2.登录函数</h4><p>1、s 参数是 session 的一个实例类，先放这里，方便写后面代码</p><p>2、登录函数传三个参数，s 是需要调用前面的 session 类，所以必传，可以传个登录的 url,然后 payload 是账号和密码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/RA52DEcXnmj4voz.png" alt="1232840-20190513114931058-1407169831.png"></p><h4 id="3-保存草稿"><a href="#3-保存草稿" class="headerlink" title="3.保存草稿"></a>3.保存草稿</h4><p>1、编辑内容的标题 title 和正文 body_data 参数化了，这样后面可以方便传不同值</p><p>2、这里返回了获取到新的 url 地址，因为后面的 postid 参数需要在这里提取</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/zpS5TXr6o93cb8v.png" alt="1232840-20190513115206721-41296126.png"></p><h4 id="4-提取-postid"><a href="#4-提取-postid" class="headerlink" title="4.提取 postid"></a>4.提取 postid</h4><p>1、这里用正则表达式提取 url 里面的 postid</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/e21WT3k5tc9sSAd.png" alt="1232840-20190513115557644-1634287280.png"></p><h4 id="5-删除草稿"><a href="#5-删除草稿" class="headerlink" title="5.删除草稿"></a>5.删除草稿</h4><p>1、传个 url 和 postid 就可以了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/q8DRmQw5Wn7OYxS.png" alt="1232840-20190513115704488-253526171.png"></p><h4 id="6-参考代码"><a href="#6-参考代码" class="headerlink" title="6.参考代码"></a>6.参考代码</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-18 7 @author: 北京-宏哥 8 Project:学习和使用封装与调用--函数和参数化 9 &#39;&#39;&#39;10 #3.导入模块11 import requests12 13 def login(s, url, payload):14  15  headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot;,16 17  &quot;Accept&quot;: &quot;application/json, text/javascript, */*; q=0.01&quot;,18  &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;,19  &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;,20  &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;,21  &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;,22  &quot;Content-Length&quot;: &quot;385&quot;,23  &quot;Cookie&quot;: &quot;xxx 已省略&quot;,24  &quot;Connection&quot;: &quot;keep-alive&quot;25  }26  r = s.post(url, json=payload, headers=headers, verify=False)27  result = r.json()28  print (result)29  return result[&#39;success&#39;] # 返回 True 或 False30  31 def save_box(s, url2, title, body_data):32  &#39;&#39;&#39;# 获取报存之后 url 地址&#39;&#39;&#39;33  body = {&quot;__VIEWSTATE&quot;: &quot;&quot;,34  &quot;__VIEWSTATEGENERATOR&quot;: &quot;FE27D343&quot;,35  &quot;Editor$Edit$txbTitle&quot;: title,36  &quot;Editor$Edit$EditorBody&quot;: &quot;&lt;p&gt;&quot;+body_data+&quot;&lt;/p&gt;&quot;,37  &quot;Editor$Edit$Advanced$ckbPublished&quot;: &quot;on&quot;,38  &quot;Editor$Edit$Advanced$chkDisplayHomePage&quot;: &quot;on&quot;,39  &quot;Editor$Edit$Advanced$chkComments&quot;: &quot;on&quot;,40  &quot;Editor$Edit$Advanced$chkMainSyndication&quot;: &quot;on&quot;,41  &quot;Editor$Edit$lkbDraft&quot;: &quot;存为草稿&quot;,42  }43  r2 = s.post(url2, data=body, verify=False)44  print(r2.url)45  return r2.url46 def get_postid(u):47  &#39;&#39;&#39;正则提取 postid&#39;&#39;&#39;48  import re49  postid = re.findall(r&quot;postid=(.+?)&amp;&quot;, u)50  print (postid) # 这里是 list51  if len(postid) &lt; 1:52   return &#39;&#39;53  else:54   return postid[0]55 def delete_box(s,url3, postid):56  &#39;&#39;&#39;删除草稿箱&#39;&#39;&#39;57  json3 = {&quot;postId&quot;: postid}58  r3 = s.post(url3, json=json3, verify=False)59  print (r3.json())60 if __name__ == &quot;__main__&quot;:61  #-------------由于博客园的登录机制改变这部分代码仅作为参考start-------62  &#39;&#39;&#39;63  #登录url64  url = &quot;https://passport.cnblogs.com/user/signin&quot;65  payload = {66  &quot;input1&quot;: &quot;xxx&quot;,67  &quot;input2&quot;: &quot;xxx&quot;,68  &quot;remember&quot;: True69  }70  s = requests.session()71  login(s, url, payload)72  &#39;&#39;&#39;73  # -------------由于博客园的登录机制改变这部分代码仅作为参考end-------74 75  #编辑随笔url76  url2 = &quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot;77  u = save_box(s, url2, &quot;北京-宏哥学习和使用封装与调用--函数和参数化&quot;, &quot;1、学习和使用封装与调用--函数和参数化&quot;)78  postid = get_postid(u)79  # 删除随笔url80  url3 = &quot;https://i.cnblogs.com/post/delete&quot;81  delete_box(s, url3, postid)</code></pre><p>由于博客园的登录机制改变，我们想要让代码跑起来还需要用老办法绕过验证码通过cookie登录替换登录这个动作</p><h4 id="7-改造代码如下"><a href="#7-改造代码如下" class="headerlink" title="7.改造代码如下"></a>7.改造代码如下</h4><p>第一步：将登录方法注释掉</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/OIh7XR8cfBnAeH2.png" alt="1232840-20190513130636751-1727500905.png"></p><p>第二步：将登录方法所传的参数和调用登录的方法注释掉</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/1OlUFGYDvLex6wV.png" alt="1232840-20190513130732743-1672247342.png"></p><p>第三步：通过cookie登录绕过验证码，实现登录</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/nxDqeMmIZEpNd8T.png" alt="1232840-20190513131012759-1737420003.png"></p><p>第四步：直接运行代码，查看结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/gmfiO7SoNMaLcIb.png" alt="1232840-20190513152918996-1717613603.png"></p><p>第五步：由于我们新增又删除，所以看到的界面看到的效果还是不太明显，为了让小伙伴们看到明显效果，我们这里还是通过老方法：打断点</p><p>第六步：在调用删除随笔的方法前打断点，双击方法前边出现一个大红点</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/zGvHgCwLlPZR2m3.png" alt="1232840-20190513131733317-285409792.png"></p><p>第七步：debug运行代码，点击右上角的昆虫</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/S4lGYIeLfTtJuCZ.png" alt="1232840-20190513131850842-1165025449.png"></p><p>第八步：浏览器登录查看随笔页面</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Y6Em72ZtC4jLBzP.png" alt="1232840-20190513132015301-623275556.png"></p><p>postid</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/eCbi23ruAZV5aMk.png" alt="1232840-20190513132405316-115333701.png"></p><p>第九步：继续运行。执行删除随笔的方法</p><p>代码运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/tsnVpuvwTjZ1cby.png" alt="1232840-20190513151502357-447736374.png"></p><p>第十步：刷新随笔页面，查看刚刚新增的那条随笔消失了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/3EqHyXlD5ZnALWU.png" alt="1232840-20190513151543412-2138688762.png"></p><h4 id="8-改造后参考代码"><a href="#8-改造后参考代码" class="headerlink" title="8.改造后参考代码"></a>8.改造后参考代码</h4><pre><code>  1 # coding=utf-8  2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行  3   4 #2.注释：包括记录创建时间，创建人，项目名称。  5 &#39;&#39;&#39;  6 Created on  2016-03-18  7 @author: 北京-宏哥  8 Project:学习和使用封装与调用--函数和参数化  9 &#39;&#39;&#39; 10 #3.导入模块 11 import requests 12 # # 先打开登录首页，获取部分cookie 13 # url = &quot;https://passport.cnblogs.com/user/signin&quot; 14 # # 登录成功后保存编辑内容 15 # url2= &quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; 16 # s = requests.session()     #s参数作为全局变量 17 #-------------由于博客园的登录机制改变这部分代码仅作为参考start------- 18 &#39;&#39;&#39; 19 def login(s, url, payload): 20   21  headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot;, 22  23  &quot;Accept&quot;: &quot;application/json, text/javascript, */*; q=0.01&quot;, 24  &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;, 25  &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;, 26  &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;, 27  &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, 28  &quot;Content-Length&quot;: &quot;385&quot;, 29  &quot;Cookie&quot;: &quot;xxx 已省略&quot;, 30  &quot;Connection&quot;: &quot;keep-alive&quot; 31  } 32  r = s.post(url, json=payload, headers=headers, verify=False) 33  result = r.json() 34  print (result) 35  return result[&#39;success&#39;] # 返回 True 或 False 36  &#39;&#39;&#39; 37  # -------------由于博客园的登录机制改变这部分代码仅作为参考end------- 38 def save_box(s, url2, title, body_data): 39  &#39;&#39;&#39;# 获取报存之后 url 地址&#39;&#39;&#39; 40  body = {&quot;__VIEWSTATE&quot;: &quot;&quot;, 41  &quot;__VIEWSTATEGENERATOR&quot;: &quot;FE27D343&quot;, 42  &quot;Editor$Edit$txbTitle&quot;: title, 43  &quot;Editor$Edit$EditorBody&quot;: &quot;&lt;p&gt;&quot;+body_data+&quot;&lt;/p&gt;&quot;, 44  &quot;Editor$Edit$Advanced$ckbPublished&quot;: &quot;on&quot;, 45  &quot;Editor$Edit$Advanced$chkDisplayHomePage&quot;: &quot;on&quot;, 46  &quot;Editor$Edit$Advanced$chkComments&quot;: &quot;on&quot;, 47  &quot;Editor$Edit$Advanced$chkMainSyndication&quot;: &quot;on&quot;, 48  &quot;Editor$Edit$lkbDraft&quot;: &quot;存为草稿&quot;, 49  } 50  r2 = s.post(url2, data=body, verify=False) 51  print(r2.url) 52  return r2.url 53 def get_postid(u): 54  &#39;&#39;&#39;正则提取 postid&#39;&#39;&#39; 55  import re 56  postid = re.findall(r&quot;postid=(.+?)&amp;&quot;, u) 57  print (postid) # 这里是 list 58  if len(postid) &lt; 1: 59   return &#39;&#39; 60  else: 61   return postid[0] 62 def delete_box(s,url3, postid): 63  &#39;&#39;&#39;删除草稿箱&#39;&#39;&#39; 64  json3 = {&quot;postId&quot;: postid} 65  r3 = s.post(url3, json=json3, verify=False) 66  print (r3.json()) 67 if __name__ == &quot;__main__&quot;: 68  #-------------由于博客园的登录机制改变这部分代码仅作为参考start------- 69  &#39;&#39;&#39; 70  #登录url 71  url = &quot;https://passport.cnblogs.com/user/signin&quot; 72  payload = { 73  &quot;input1&quot;: &quot;xxx&quot;, 74  &quot;input2&quot;: &quot;xxx&quot;, 75  &quot;remember&quot;: True 76  } 77  s = requests.session() 78  login(s, url, payload) 79  &#39;&#39;&#39; 80  # -------------由于博客园的登录机制改变这部分代码仅作为参考end------- 81  url = &quot;https://passport.cnblogs.com/user/signin&quot; 82  headers = { 83      &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 84  }  # get方法其它加个ser-Agent就可以了 85  s = requests.session() 86  r = s.get(url, headers=headers, verify=False) 87  print(s.cookies) 88  # 添加登录需要的两个cookie 89  c = requests.cookies.RequestsCookieJar() 90  c.set(&#39;.CNBlogsCookie&#39;, 91        &#39;XXX&#39;)  # 填上面抓包内容  具体查看前边的cookie登录，这里不赘述 92  c.set(&#39;.Cnblogs.AspNetCore.Cookies&#39;, 93        &#39;XXX&#39;)  # 填上面抓包内容   具体查看前边cookie登录，这里不赘述 94  c.set(&#39;AlwaysCreateItemsAsActive&#39;, &quot;True&quot;) 95  c.set(&#39;AdminCookieAlwaysExpandAdvanced&#39;, &quot;True&quot;) 96  s.cookies.update(c) 97  print(s.cookies) 98  result = r.content 99 100  #编辑随笔url101  url2 = &quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot;102  u = save_box(s, url2, &quot;北京-宏哥学习和使用封装与调用--函数和参数化&quot;, &quot;1、学习和使用封装与调用--函数和参数化&quot;)103  postid = get_postid(u)104  # 删除随笔url105  url3 = &quot;https://i.cnblogs.com/post/delete&quot;106  delete_box(s, url3, postid)</code></pre><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><h5 id="1、封装好处："><a href="#1、封装好处：" class="headerlink" title="1、封装好处："></a>1、封装好处：</h5><p>第一:重用;</p><p>第二:不必关心具体的实现;</p><p>第三:面向对象三大特征之一;</p><p>第四,具有安全性!</p><p>哈哈，各位小伙伴们，封装与调用–函数和参数化就是这么简单！！！小编能力有限欢迎各位批评指正。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化33</title>
      <link href="/2016/03/17/interface/"/>
      <url>/2016/03/17/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十三）-python自动发邮件总结及实例说明番外篇——下（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　发邮件前我们需要了解的是邮件是怎么一个形式去发送到对方手上的，通俗点来说就是你写好一封信，然后装进信封，写上地址，贴上邮票，然后就近找个邮局，把信仍进去，其他的就不关心了，只是关心时间，而电子邮件不像日常发送邮件的按天算，时间都是按</p><p>秒算的。</p><h5 id="电子邮件的发送流程："><a href="#电子邮件的发送流程：" class="headerlink" title="电子邮件的发送流程："></a>电子邮件的发送流程：</h5><p>1、你使用某款电子邮件软件MUA：mail user agent –邮件用户代理，填写完成点击发送</p><p>2、在你点击发送的时候电子邮件软件发出去，到MTA：mail transfer agent–邮件传输代理，即email服务提供商，如网易等</p><p>3、MTA–邮箱传输代理会把邮箱投递到邮件的最终目的地MDA：mail delivery agent—邮箱投递服务</p><p>4、email到达MDA后就会放在某个服务器上，存在数据库里，收件人必须通过MUA从MDA中把邮箱放到自己电脑上</p><p>发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA&lt;-MUA&lt;-收件人</p><p>python发邮件需要掌握两个模块的用法，smtplib和email，这俩模块是python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。</p><p>smtplib模块主要负责发送邮件：是一个发送邮件的动作，连接邮箱服务器，登录邮箱，发送邮件（有发件人，收信人，邮件内容）。</p><p>email模块主要负责构造邮件：指的是邮箱页面显示的一些构造，如发件人，收件人，主题，正文，附件等。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/yYdv4g2VeFwnEz1.png" alt="1232840-20190510090233349-828034619.png"></p><h4 id="2-smtplib模块"><a href="#2-smtplib模块" class="headerlink" title="2.smtplib模块"></a>2.smtplib模块</h4><p>smtplib使用较为简单。以下是最基本的语法。</p><p>导入及使用方法如下：</p><pre><code>1 import smtplib2 3 smtp = smtplib.SMTP() 4 smtp.connect(&#39;smtp.163.com,25&#39;) 5 smtp.login(username, password) 6 smtp.sendmail(sender, receiver, msg.as_string()) 7 smtp.quit()</code></pre><p>说明：</p><p>smtplib.SMTP()：实例化SMTP()</p><p>connect(host,port):</p><p>host:指定连接的邮箱服务器。常用邮箱的smtp服务器地址如下：</p><p>新浪邮箱：smtp.sina.com,新浪VIP：smtp.vip.sina.com,搜狐邮箱：smtp.sohu.com，126邮箱：smtp.126.com,139邮箱：smtp.139.com,163网易邮箱：smtp.163.com。</p><p>port：指定连接服务器的端口号，默认为25.</p><p>login(user,password):</p><p>user:登录邮箱的用户名。</p><p>password：登录邮箱的密码，像笔者用的是网易邮箱，网易邮箱一般是网页版，需要用到客户端密码，需要在网页版的网易邮箱中设置授权码，该授权码即为客户端密码。</p><p>sendmail(from_addr,to_addrs,msg,…):</p><p>from_addr:邮件发送者地址</p><p>to_addrs:邮件接收者地址。发送邮件，多人时用list，字符串列表[‘接收地址1’,’接收地址2’,’接收地址3’,…]或’接收地址’</p><p>msg：发送消息：邮件内容。邮件正文是一个str，一般是msg.as_string():as_string()是将msg(MIMEText对象或者MIMEMultipart对象)变为str。</p><p>quit(): 退出关闭邮箱，用于结束SMTP会话。</p><h4 id="3-email模块"><a href="#3-email模块" class="headerlink" title="3.email模块"></a>3.email模块</h4><p>email模块下有mime包，mime英文全称为“Multipurpose Internet Mail Extensions”，即多用途互联网邮件扩展，是目前互联网电子邮件普遍遵循的邮件技术规范。</p><p>该mime包下常用的有三个模块：text，image，multpart。</p><p>导入方法如下：</p><pre><code>from email.mime.multipart import MIMEMultipart    from email.mime.text import MIMEText    from email.mime.image import MIMEImage</code></pre><p>构造一个邮件对象就是一个Message对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下：</p><pre><code>Message+- MIMEBase   +- MIMEMultipart   +- MIMENonMultipart      +- MIMEMessage      +- MIMEText      +- MIMEImage</code></pre><h5 id="3-1-text说明"><a href="#3-1-text说明" class="headerlink" title="3.1 text说明"></a>3.1 text说明</h5><p>邮件发送程序为了防止有些邮件阅读软件不能显示处理HTML格式的数据，通常都会用两类型分别为”text/plain”和”text/html”</p><p>构造MIMEText对象时，第一个参数是邮件正文，第二个参数是MIME的subtype，最后一定要用utf-8编码保证多语言兼容性。</p><h6 id="3-1-1添加普通文本"><a href="#3-1-1添加普通文本" class="headerlink" title="3.1.1添加普通文本"></a>3.1.1添加普通文本</h6><p>方法很简单，在构造MIMEText对象时，把TEXT字符串传进去，再把第二个参数plain和第三个参数编码传进去即可。plain表示纯文本 ，后面的则是编译，保证多语言兼容 </p><pre><code>text = &quot;Hi!\nHow are you?\nHere is the link you wanted:\nhttps://www.cnblogs.com/du-hong&quot;    text_plain = MIMEText(text,&#39;plain&#39;, &#39;utf-8&#39;)    </code></pre><p>查看MIMEText属性：可以观察到MIMEText，MIMEImage和MIMEMultipart的属性都一样。</p><pre><code>print dir(text_plain)[&#39;__contains__&#39;, &#39;__delitem__&#39;, &#39;__doc__&#39;, &#39;__getitem__&#39;, &#39;__init__&#39;, &#39;__len__&#39;, &#39;__module__&#39;, &#39;__setitem__&#39;, &#39;__str__&#39;, &#39;_charset&#39;, &#39;_default_type&#39;, &#39;_get_params_preserve&#39;, &#39;_headers&#39;, &#39;_payload&#39;, &#39;_unixfrom&#39;, &#39;add_header&#39;, &#39;as_string&#39;, &#39;attach&#39;, &#39;defects&#39;, &#39;del_param&#39;, &#39;epilogue&#39;, &#39;get&#39;, &#39;get_all&#39;, &#39;get_boundary&#39;, &#39;get_charset&#39;, &#39;get_charsets&#39;, &#39;get_content_charset&#39;, &#39;get_content_maintype&#39;, &#39;get_content_subtype&#39;, &#39;get_content_type&#39;, &#39;get_default_type&#39;, &#39;get_filename&#39;, &#39;get_param&#39;, &#39;get_params&#39;, &#39;get_payload&#39;, &#39;get_unixfrom&#39;, &#39;has_key&#39;, &#39;is_multipart&#39;, &#39;items&#39;, &#39;keys&#39;, &#39;preamble&#39;, &#39;replace_header&#39;, &#39;set_boundary&#39;, &#39;set_charset&#39;, &#39;set_default_type&#39;, &#39;set_param&#39;, &#39;set_payload&#39;, &#39;set_type&#39;, &#39;set_unixfrom&#39;, &#39;values&#39;, &#39;walk&#39;]</code></pre><h6 id="3-1-2添加超文本-HTML"><a href="#3-1-2添加超文本-HTML" class="headerlink" title="3.1.2添加超文本(HTML)"></a>3.1.2添加超文本(HTML)</h6><p>方法也很简单，在构造MIMEText对象时，把HTML字符串传进去，再把第二个参数由plain变为html就可以了</p><pre><code> 1 html = &quot;&quot;&quot; 2 &lt;html&gt;   3   &lt;body&gt;   4     &lt;p&gt;  5        Here is the &lt;a href=&quot;https://www.cnblogs.com/du-hong&quot;&gt;link&lt;/a&gt; you wanted. 6     &lt;/p&gt;  7   &lt;/body&gt;   8 &lt;/html&gt;   9 &quot;&quot;&quot;    10 text_html = MIMEText(html,&#39;html&#39;, &#39;utf-8&#39;)  </code></pre><h6 id="3-1-3添加附件"><a href="#3-1-3添加附件" class="headerlink" title="3.1.3添加附件"></a>3.1.3添加附件</h6><p>首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送</p><pre><code>sendfile=open(r&#39;D:\pythontest\text.txt&#39;,&#39;rb&#39;).read()text_att = MIMEText(sendfile, &#39;base64&#39;, &#39;utf-8&#39;)    text_att[&quot;Content-Type&quot;] = &#39;application/octet-stream&#39;    text_att[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;显示的名字.txt&quot;&#39;  </code></pre><h5 id="3-2-image说明"><a href="#3-2-image说明" class="headerlink" title="3.2 image说明"></a>3.2 image说明</h5><p>添加图片：</p><pre><code>sendimagefile=open(r&#39;D:\pythontest\testimage.png&#39;,&#39;rb&#39;).read()image = MIMEImage(sendimagefile)image.add_header(&#39;Content-ID&#39;,&#39;&lt;image1&gt;&#39;)</code></pre><p>查看MIMEImage属性：</p><pre><code>print dir(image)[&#39;__contains__&#39;, &#39;__delitem__&#39;, &#39;__doc__&#39;, &#39;__getitem__&#39;, &#39;__init__&#39;, &#39;__len__&#39;, &#39;__module__&#39;, &#39;__setitem__&#39;, &#39;__str__&#39;, &#39;_charset&#39;, &#39;_default_type&#39;, &#39;_get_params_preserve&#39;, &#39;_headers&#39;, &#39;_payload&#39;, &#39;_unixfrom&#39;, &#39;add_header&#39;, &#39;as_string&#39;, &#39;attach&#39;, &#39;defects&#39;, &#39;del_param&#39;, &#39;epilogue&#39;, &#39;get&#39;, &#39;get_all&#39;, &#39;get_boundary&#39;, &#39;get_charset&#39;, &#39;get_charsets&#39;, &#39;get_content_charset&#39;, &#39;get_content_maintype&#39;, &#39;get_content_subtype&#39;, &#39;get_content_type&#39;, &#39;get_default_type&#39;, &#39;get_filename&#39;, &#39;get_param&#39;, &#39;get_params&#39;, &#39;get_payload&#39;, &#39;get_unixfrom&#39;, &#39;has_key&#39;, &#39;is_multipart&#39;, &#39;items&#39;, &#39;keys&#39;, &#39;preamble&#39;, &#39;replace_header&#39;, &#39;set_boundary&#39;, &#39;set_charset&#39;, &#39;set_default_type&#39;, &#39;set_param&#39;, &#39;set_payload&#39;, &#39;set_type&#39;, &#39;set_unixfrom&#39;, &#39;values&#39;, &#39;walk&#39;]</code></pre><h5 id="3-3-multpart说明"><a href="#3-3-multpart说明" class="headerlink" title="3.3 multpart说明"></a>3.3 multpart说明</h5><p>常见的multipart类型有三种：multipart/alternative, multipart/related和multipart/mixed。</p><p>邮件类型为”multipart/alternative”的邮件包括纯文本正文（text/plain）和超文本正文（text/html）。</p><p>邮件类型为”multipart/related”的邮件正文中包括图片，声音等内嵌资源。</p><p>邮件类型为”multipart/mixed”的邮件包含附件。向上兼容，如果一个邮件有纯文本正文，超文本正文，内嵌资源，附件，则选择mixed类型。</p><p>msg = MIMEMultipart(‘mixed’)<br>我们必须把Subject，From，To，Date添加到MIMEText对象或者MIMEMultipart对象中，邮件中才会显示主题，发件人，收件人，时间（若无时间，就默认一般为当前时间，该值一般不设置）。</p><pre><code>msg = MIMEMultipart(&#39;mixed&#39;) msg[&#39;Subject&#39;] = &#39;Python email test&#39;msg[&#39;From&#39;] = &#39;XXX@163.com &lt;XXX@163.com&gt;&#39;msg[&#39;To&#39;] = &#39;XXX@126.com&#39;msg[&#39;Date&#39;]=&#39;2016-3-17&#39;</code></pre><p>查看MIMEMultipart属性：</p><pre><code>msg = MIMEMultipart(&#39;mixed&#39;) print dir(msg) </code></pre><p>结果：</p><pre><code>[&#39;__contains__&#39;, &#39;__delitem__&#39;, &#39;__doc__&#39;, &#39;__getitem__&#39;, &#39;__init__&#39;, &#39;__len__&#39;, &#39;__module__&#39;, &#39;__setitem__&#39;, &#39;__str__&#39;, &#39;_charset&#39;, &#39;_default_type&#39;, &#39;_get_params_preserve&#39;, &#39;_headers&#39;, &#39;_payload&#39;, &#39;_unixfrom&#39;, &#39;add_header&#39;, &#39;as_string&#39;, &#39;attach&#39;, &#39;defects&#39;, &#39;del_param&#39;, &#39;epilogue&#39;, &#39;get&#39;, &#39;get_all&#39;, &#39;get_boundary&#39;, &#39;get_charset&#39;, &#39;get_charsets&#39;, &#39;get_content_charset&#39;, &#39;get_content_maintype&#39;, &#39;get_content_subtype&#39;, &#39;get_content_type&#39;, &#39;get_default_type&#39;, &#39;get_filename&#39;, &#39;get_param&#39;, &#39;get_params&#39;, &#39;get_payload&#39;, &#39;get_unixfrom&#39;, &#39;has_key&#39;, &#39;is_multipart&#39;, &#39;items&#39;, &#39;keys&#39;, &#39;preamble&#39;, &#39;replace_header&#39;, &#39;set_boundary&#39;, &#39;set_charset&#39;, &#39;set_default_type&#39;, &#39;set_param&#39;, &#39;set_payload&#39;, &#39;set_type&#39;, &#39;set_unixfrom&#39;, &#39;values&#39;, &#39;walk&#39;]</code></pre><p>说明：</p><pre><code>msg.add_header(_name,_value,**_params):添加邮件头字段。msg.as_string():是将msg(MIMEText对象或者MIMEMultipart对象)变为str,如果只有一个html超文本正文或者plain普通文本正文的话，一般msg的类型可以是MIMEText；如果是多个的话，就都添加到MIMEMultipart，msg类型就变为MIMEMultipart。msg.attach(MIMEText对象或MIMEImage对象):将MIMEText对象或MIMEImage对象添加到MIMEMultipart对象中。MIMEMultipart对象代表邮件本身，MIMEText对象或MIMEImage对象代表邮件正文。</code></pre><p>以上的构造的文本，超文本，附件，图片都何以添加到MIMEMultipart(‘mixed’)中：</p><pre><code>msg.attach(text_plain)    msg.attach(text_html)    msg.attach(text_att)    msg.attach(image)</code></pre><h4 id="4-文字，html，图片，附件实现实例"><a href="#4-文字，html，图片，附件实现实例" class="headerlink" title="4.文字，html，图片，附件实现实例"></a>4.文字，html，图片，附件实现实例</h4><h5 id="4-1实例"><a href="#4-1实例" class="headerlink" title="4.1实例"></a>4.1实例</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/gPuoUI9veSftwpX.png" alt="1232840-20190510112838820-1608628037.png"></p><h5 id="4-2运行结果"><a href="#4-2运行结果" class="headerlink" title="4.2运行结果"></a>4.2运行结果</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/b5Pnw6hdyiqRc8u.png" alt="1232840-20190510113010537-33392216.png"></p><h5 id="4-3参考代码"><a href="#4-3参考代码" class="headerlink" title="4.3参考代码"></a>4.3参考代码</h5><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-10 7 @author: 北京-宏哥 8 Project:学习和使用邮箱发文字，html，图片，附件实现实例邮件 9 &#39;&#39;&#39;10 #3.导入模块11 import smtplib12 from email.mime.multipart import MIMEMultipart13 from email.mime.text import MIMEText14 from email.mime.image import MIMEImage15 from email.header import Header16 17 # 设置smtplib所需的参数18 # 下面的发件人，收件人是用于邮件传输的。19 smtpserver = &#39;smtp.mxhichina.com&#39;20 username = &#39;noreply@xxx.cn&#39;21 password = &#39;xxxx@@xx3&#39;22 sender = &#39;noreply@xxx.cn&#39;23 # 收件人为一个收件人24 # receiver=&#39;XXX@126.com&#39;25 # 收件人为多个收件人26 receiver = [&quot;1918991791@qq.com&quot;,&quot;2014816656@qq.com&quot;,&quot;hongge@xxx.cn&quot;]27 28 subject = &#39;Python email test&#39;29 # 通过Header对象编码的文本，包含utf-8编码信息和Base64编码信息。以下中文名测试ok30 # subject = &#39;中文标题&#39;31 # subject=Header(subject, &#39;utf-8&#39;).encode()32 33 # 构造邮件对象MIMEMultipart对象34 # 下面的主题，发件人，收件人，日期是显示在邮件页面上的。35 msg = MIMEMultipart(&#39;mixed&#39;)36 msg[&#39;Subject&#39;] = subject37 msg[&#39;From&#39;] = &#39;北京-宏哥&lt;noreply@xxx.cn&gt;&#39;38 # msg[&#39;To&#39;] = &quot;1918991791@qq.com&quot;,&quot;2014816656@qq.com&quot;,&quot;hongge@xxx.cn&quot;39 # 收件人为多个收件人,通过join将列表转换为以;为间隔的字符串40 msg[&#39;To&#39;] = &quot;;&quot;.join(receiver)41 # msg[&#39;Date&#39;]=&#39;2019-5-10&#39;42 43 # 构造文字内容44 text = &quot;Hi!\nHow are you?\nHere is the link you wanted:\nhttps://www.cnblogs.com/du-hong&quot;45 text_plain = MIMEText(text, &#39;plain&#39;, &#39;utf-8&#39;)46 msg.attach(text_plain)47 48 # 构造图片链接49 sendimagefile = open(r&#39;E:\pythontest\testimage.png&#39;, &#39;rb&#39;).read()50 image = MIMEImage(sendimagefile)51 image.add_header(&#39;Content-ID&#39;, &#39;&lt;image1&gt;&#39;)52 image[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;honggeimage.png&quot;&#39;53 msg.attach(image)54 55 # 构造html56 # 发送正文中的图片:由于包含未被许可的信息，网易邮箱定义为垃圾邮件，报554 DT:SPM ：&lt;p&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;/p&gt;57 html = &quot;&quot;&quot;58 &lt;html&gt;  59   &lt;head&gt;&lt;/head&gt;  60   &lt;body&gt;  61     &lt;p&gt;Hi!&lt;br&gt;  62        How are you?&lt;br&gt;  63        Here is the &lt;a href=&quot;https://www.cnblogs.com/du-hong/&quot;&gt;link 北京-宏哥&lt;/a&gt; you wanted.&lt;br&gt; 64     &lt;/p&gt; 65   &lt;/body&gt;  66 &lt;/html&gt;  67 &quot;&quot;&quot;68 text_html = MIMEText(html, &#39;html&#39;, &#39;utf-8&#39;)69 text_html[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;texthtml.html&quot;&#39;70 msg.attach(text_html)71 72 # 构造附件73 sendfile = open(r&#39;E:\pythontest\text.txt&#39;, &#39;rb&#39;).read()74 text_att = MIMEText(sendfile, &#39;base64&#39;, &#39;utf-8&#39;)75 text_att[&quot;Content-Type&quot;] = &#39;application/octet-stream&#39;76 # 以下附件可以重命名成aaa.txt77 # text_att[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;aaa.txt&quot;&#39;78 # 另一种实现方式79 text_att.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;, filename=&#39;hongge.txt&#39;)80 # 以下中文测试不ok81 # text_att[&quot;Content-Disposition&quot;] = u&#39;attachment; filename=&quot;中文附件.txt&quot;&#39;.decode(&#39;utf-8&#39;)82 msg.attach(text_att)83 84 # 发送邮件85 smtp = smtplib.SMTP()86 smtp.connect(&#39;smtp.mxhichina.com&#39;)87 # 我们用set_debuglevel(1)就可以打印出和SMTP服务器交互的所有信息。88 # smtp.set_debuglevel(1)89 smtp.login(username, password)90 smtp.sendmail(sender, receiver, msg.as_string())91 smtp.quit()</code></pre><p>说明：</p><p>对有些 header 要特别留意，服务器会针对这些 header 做检查</p><p>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求</p><p>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。常见的取值有：</p><p>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用</p><p>application/json ： 在 JSON RPC 调用时使用</p><p>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用</p><p>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p> 　　好了，哈哈，到这里把python发邮件的十八辈祖宗都被我们挖出来了，自己都感觉到有点缺德，但是我们学习就是需要这种精神，但是也不要过于钻牛角筋，要适可而止。想必小伙伴们对python发邮件有了更深刻的认识了，以后遇到类似的问题，</p><p>往上套就可以了，但是要注意方式和方法，不要生搬硬套，生搬硬套又会出现问题，要灵活有技巧的套。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化32</title>
      <link href="/2016/03/16/interface/"/>
      <url>/2016/03/16/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十二）–Python发送邮件（常见四种邮件内容）番外篇——上（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　本篇文章与前边没有多大关联，就是对前边有关发邮件的总结和梳理。在写脚本时，放到后台运行，想知道执行情况，会通过邮件、SMS（短信）、飞信、微信等方式通知管理员，用的最多的是邮件。在linux下，Shell脚本发送邮件告警是件很简单的事，有现成的邮件服务软件或者调用运营商邮箱服务器。</p><p>　　对于Python来说，需要编写脚本调用邮件服务器来发送邮件，使用的协议是SMTP。接收邮件，使用的协议是POP3和IMAP。我想有必要说明下 ，POP3和IMAP的区别：POP3在客户端邮箱中所做的操作不会反馈到邮箱服务器，比如删除一封邮件，邮箱服务器并不会删除。IMAP则会反馈到邮箱服务器，会做相应的操作。</p><p>　　Python分别提供了收发邮件的库，smtplib、poplib和imaplib。</p><p>　　本章主要讲解如果使用smtplib库实现发送各种形式的邮件内容。在smtplib库中，主要主要用smtplib.SMTP()类，用于连接SMTP服务器，发送邮件。</p><p>这个类有几个常用的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SMTP.set_debuglevel(level)</td><td align="center">设置输出debug调试信息，默认不输出</td></tr><tr><td align="center">SMTP.docmd(cmd[, argstring])</td><td align="center">发送一个命令到SMTP服务器</td></tr><tr><td align="center">SMTP.connect([host[, port]])</td><td align="center">连接到指定的SMTP服务器</td></tr><tr><td align="center">SMTP.helo([hostname])</td><td align="center">使用helo指令向SMTP服务器确认你的身份</td></tr><tr><td align="center">SMTP.ehlo(hostname)</td><td align="center">使用ehlo指令像ESMTP（SMTP扩展）确认你的身份</td></tr><tr><td align="center">SMTP.ehlo_or_helo_if_needed()</td><td align="center">如果在以前的会话连接中没有提供ehlo或者helo指令，这个方法会调用ehlo()或helo()</td></tr><tr><td align="center">SMTP.has_extn(name)</td><td align="center">判断指定名称是否在SMTP服务器上</td></tr><tr><td align="center">SMTP.verify(address)</td><td align="center">判断邮件地址是否在SMTP服务器上</td></tr><tr><td align="center">SMTP.starttls([keyfile[, certfile]])</td><td align="center">使SMTP连接运行在TLS模式，所有的SMTP指令都会被加密</td></tr><tr><td align="center">SMTP.login(user, password)</td><td align="center">登录SMTP服务器</td></tr><tr><td align="center">SMTP.sendmail(from_addr, to_addrs, msg, mail_options=[], rcpt_options=[])</td><td align="center">发送邮件from_addr：邮件发件人to_addrs：邮件收件人</td></tr><tr><td align="center">SMTP.quit()</td><td align="center">关闭SMTP会话</td></tr><tr><td align="center">SMTP.close()</td><td align="center">关闭SMTP服务器连接</td></tr></tbody></table><h4 id="2-看下官方给的示例："><a href="#2-看下官方给的示例：" class="headerlink" title="2.看下官方给的示例："></a>2.看下官方给的示例：</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/28kqwLFZc5Hdvhr.png" alt="1232840-20190508153251751-2017271717.png"></p><p>我们根据示例给自己发一个邮件测试下：</p><p>我这里测试使用本地的SMTP服务器，也就是要装一个支持SMTP协议的服务，比如sendmail、postfix等。</p><p>CentOS安装sendmail：yum install sendmail</p><pre><code>1 &gt;&gt;&gt; import smtplib2 &gt;&gt;&gt; s = smtplib.SMTP(&quot;localhost&quot;)3 &gt;&gt;&gt; tolist = [&quot;xxx@qq.com&quot;, &quot;xxx@163.com&quot;]4 &gt;&gt;&gt; msg = &#39;&#39;&#39;\5 ... From: Me@my.org6 ... Subject: test7 ... This is a test &#39;&#39;&#39;8 &gt;&gt;&gt; s.sendmail(&quot;me@my.org&quot;, tolist, msg)9 {}</code></pre><p>进入腾讯和网易收件人邮箱，就能看到刚发的测试邮件，一般都被邮箱服务器过滤成垃圾邮件，所以收件箱没有，你要去垃圾箱看看。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/VPR64l3NUZD1iEL.png" alt="1232840-20200707145902192-1249892968.png"></p><p>可以看到，多个收件人可以放到一个列表中进行群发。msg对象里From表示发件人，Subject是邮件标题，换行后输入的是邮件内容。</p><h4 id="3-Python发送邮件并抄送"><a href="#3-Python发送邮件并抄送" class="headerlink" title="3.Python发送邮件并抄送"></a>3.Python发送邮件并抄送</h4><pre><code> 1 #!/usr/bin/python 2 # -*- coding: utf-8 -*- 3 import smtplib 4 def sendMail(body): 5     smtp_server = &#39;smtp.163.com&#39; 6     from_mail = &#39;hongge@163.com&#39; 7     mail_pass = &#39;xxx&#39; 8     to_mail = [&#39;xxx@qq.com&#39;, &#39;xxx@163.com&#39;] 9     cc_mail = [&#39;hongge@xxx.com&#39;]10     from_name = &#39;monitor&#39; 11     subject = u&#39;监控&#39;.encode(&#39;gbk&#39;)   # 以gbk编码发送，一般邮件客户端都能识别12 #     msg = &#39;&#39;&#39;\13 # From: %s &lt;%s&gt;14 # To: %s15 # Subject: %s16 # %s&#39;&#39;&#39; %(from_name, from_mail, to_mail_str, subject, body)  # 这种方式必须将邮件头信息靠左，也就是每行开头不能用空格，否则报SMTP 55417     mail = [18         &quot;From: %s &lt;%s&gt;&quot; % (from_name, from_mail),19         &quot;To: %s&quot; % &#39;,&#39;.join(to_mail),   # 转成字符串，以逗号分隔元素20         &quot;Subject: %s&quot; % subject,21         &quot;Cc: %s&quot; % &#39;,&#39;.join(cc_mail),22         &quot;&quot;,23         body24         ]25     msg = &#39;\n&#39;.join(mail)  # 这种方式先将头信息放到列表中，然后用join拼接，并以换行符分隔元素，结果就是和上面注释一样了26     try:27         s = smtplib.SMTP()28         s.connect(smtp_server, &#39;25&#39;)29         s.login(from_mail, mail_pass)30         s.sendmail(from_mail, to_mail+cc_mail, msg)   31         s.quit()32     except smtplib.SMTPException as e:33         print &quot;Error: %s&quot; %e34 if __name__ == &quot;__main__&quot;:35     sendMail(&quot;This is a test!&quot;)</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/nALgWDc9p8Pe75X.png" alt="1232840-20190509132331603-729145739.png"></p><p>s.sendmail(from_mail, to_mail+cc_mail, msg) 在这里注意下，收件人和抄送人为什么放一起发送呢？其实无论是收件人还是抄送人，它们收到的邮件都是一样的，SMTP都是认为收件人这样一封一封的发出。所以实际上并没有抄送这个概念，只是在邮件头加了抄送人的信息罢了！另外，如果不需要抄送人，直接把上面cc的信息去掉即可。</p><p>另外以上代码发送的邮件会出现主题中文乱码：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/UZKqEs85GwibXDk.png" alt="1232840-20190509132628995-1110170050.png"></p><p>解决方案：三行代码即可，修改成红色框代码即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/yxsTjn9B164QXNY.png" alt="1232840-20190509133325318-1775180628.png"></p><h4 id="4-Python发送邮件带附件"><a href="#4-Python发送邮件带附件" class="headerlink" title="4.Python发送邮件带附件"></a>4.Python发送邮件带附件</h4><p>由于SMTP.sendmail()方法不支持添加附件，所以可以使用email模块来满足需求。email模块是一个构造邮件和解析邮件的模块。</p><p>先看下如何用email库构造一个简单的邮件：</p><pre><code>message = Message()message[&#39;Subject&#39;] = &#39;邮件主题&#39;message[&#39;From&#39;] = from_mailmessage[&#39;To&#39;] = to_mailmessage[&#39;Cc&#39;] = cc_mailmessage.set_payload(&#39;邮件内容&#39;)</code></pre><p>基本的格式就是这样的！</p><p>继续回到主题，发送邮件带附件：</p><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-9 7 @author: 北京-宏哥 8 Project:学习和使用邮箱发带有附件邮件 9 &#39;&#39;&#39;10 #3.导入模块11 import smtplib12 from email.mime.text import MIMEText13 from email.mime.multipart import MIMEMultipart14 from email.header import Header15 from email import encoders16 from email.mime.base import MIMEBase17 18 def send_mail(file_new):19     #-----------1.跟发件相关的参数------20     smtpserver = &#39;smtp.mxhichina.com&#39;                #发件服务器21     port = 0                      #端口22     username = &#39;noreply@cxx.cn&#39;  #发件箱用户名23     password = &#39;xx@@123&#39;        #发件箱密码24     sender = &#39;noreply@cxx.cn&#39;    #发件人邮箱25     receiver = [&#39;hongge@cedex.cn&#39;,&#39;1918991791@qq.com&#39;] #收件人邮箱26     # ----------2.编辑邮件的内容------27     #读文件内容28     f = open(file_new, &#39;rb&#39;)29     mail_body = f.read()30     f.close()31     # 邮件正文是MIMEText32     body = MIMEText(mail_body, &#39;html&#39;, &#39;utf-8&#39;)33     # 邮件对象34     msg = MIMEMultipart()35     msg[&#39;Subject&#39;] = Header(&quot;自动化测试报告&quot;, &#39;utf-8&#39;).encode()#主题36     msg[&#39;From&#39;] = Header(u&#39;测试机 &lt;%s&gt;&#39;%sender)                #发件人37     msg[&#39;To&#39;] = Header(u&#39;测试负责人 &lt;%s&gt;&#39;%receiver)            #收件人38     msg[&#39;To&#39;] = &#39;;&#39;.join(receiver)39     msg.attach(body)40     # # MIMEBase表示附件的对象41     att = MIMEText(mail_body, &quot;base64&quot;, &quot;utf-8&quot;)42     att[&quot;Content-Type&quot;] = &quot;application/octet-stream&quot;43     # filename是显示附件名字44     att[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;test_report.html&quot;&#39;45     msg.attach(att)46     # ----------3.发送邮件------47     try:48         smtp = smtplib.SMTP()49         smtp.connect(smtpserver)  # 连服务器50         smtp.login(sender, password)51     except:52         smtp = smtplib.SMTP_SSL(smtpserver, port)53         smtp.login(sender, password)  # 登录54     smtp.sendmail(sender, receiver, msg.as_string())  # 发送55     smtp.quit()56 57 if __name__ == &quot;__main__&quot;:58     #本地文件的路径59     att_path= r&#39;E:\pythontest\text.txt&#39;60     send_mail(att_path)</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ViSmr37ogq4Hup2.png" alt="1232840-20190509154743960-1776799402.png"></p><h4 id="5-Python发送HTML邮件"><a href="#5-Python发送HTML邮件" class="headerlink" title="5.Python发送HTML邮件"></a>5.Python发送HTML邮件</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-9 7 @author: 北京-宏哥 8 Project:学习和使用邮箱发HTML邮件 9 &#39;&#39;&#39;10 #3.导入模块11 #&quot;-*- coding: utf-8 -*-&quot;12 import smtplib13 from email.mime.text import MIMEText14 15 mail_user=&quot;XXX@163.com&quot;16 mail_password=&quot;******q1125&quot;17 mailto_list=[&quot;1918991791&lt;1918991791@qq.com&gt;&quot;,&quot;2014816656@qq.com&quot;]18 mail_host=&quot;smtp.163.com&quot;19 mail_postfix=&quot;163.com&quot;20 21 def sendmail(to_list,sub,content):22     me=&quot;北京-宏哥&quot;+&quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;23     msg=MIMEText(&quot;&lt;a href=&#39;https://www.cnblogs.com/du-hong&#39;&gt;&lt;font color=&#39;red&#39;&gt;北京-宏哥&lt;/font&gt;&lt;/a&gt;&quot;,&quot;html&quot;,&quot;utf-8&quot;)24     msg[&#39;Subject&#39;]=sub25     msg[&#39;From&#39;]=me26     msg[&#39;To&#39;]=&quot;,&quot;.join(to_list)27     try:28         server=smtplib.SMTP()29         server.connect(mail_host)30         server.login(mail_user,mail_password)31         server.sendmail(me,to_list,msg.as_string())32         server.close()33         return True34     except Exception as e:35         print (str(e))36         return False37 if sendmail(mailto_list,&quot;标题:发送的是html格式&quot;,&quot;&lt;a href=&#39;https://www.cnblogs.com/du-hong&#39;&gt;北京-宏哥&lt;/a&gt;&quot;):38     print (&quot;done!&quot;)39 else:40     print (&quot;falsed!&quot;)![1232840-20190509153006765-689290673.png](https://i.loli.net/2020/08/06/l1xrNXbBFYOqPDm.png)1.4 Python发送图片邮件# coding=utf-8#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-5-9@author: 北京-宏哥Project:学习和使用1邮箱发HTML邮件&#39;&#39;&#39;#3.导入模块#&quot;-*- coding: utf-8 -*-&quot;import smtplibfrom email.mime.text import MIMETextmail_user=&quot;@@@@@163.com&quot;mail_password=&quot;@@@@&quot;mailto_list=[&quot;1918991791&lt;1918991791@qq.com&gt;&quot;,&quot;2014816656@qq.com&quot;]mail_host=&quot;smtp.163.com&quot;mail_postfix=&quot;163.com&quot;def sendmail(to_list,sub,content):    me=&quot;北京-宏哥&quot;+&quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;    msg=MIMEText(&#39;&lt;html&gt;&lt;body&gt;&lt;img hidefocus=&quot;true&quot; class=&quot;index-logo-src&quot; src=&quot;//www.baidu.com/img/bd_logo1.png&quot; width=&quot;270&quot; height=&quot;129&quot; usemap=&quot;#mp&quot;&gt;&lt;/body&gt;&lt;/html&gt;&#39;, &#39;html&#39;, &#39;utf-8&#39;)    msg[&#39;Subject&#39;]=sub    msg[&#39;From&#39;]=me    msg[&#39;To&#39;]=&quot;,&quot;.join(to_list)    try:        server=smtplib.SMTP()        server.connect(mail_host)        server.login(mail_user,mail_password)        server.sendmail(me,to_list,msg.as_string())        server.close()        return True    except Exception as e:        print (str(e))        return Falseif sendmail(mailto_list,&quot;标题:发送的是HTML格式&quot;,&quot;&lt;a href=&#39;https://www.cnblogs.com/du-hong&#39;&gt;北京-宏哥&lt;/a&gt;&quot;):    print (&quot;done!&quot;)else:    print (&quot;falsed!&quot;)</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/oceUqSThMZbs6IJ.png" alt="1232840-20190509154351367-21715505.png"></p><p>上面发邮件的几种常见的发邮件方法基本满足日常需求了。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、linux环境下提示AttributeError: module ‘smtplib’ has no attribute ‘SMTP’，Windows环境运行代码也报如下错误：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/UDSRFjzcTBAwdfr.png" alt="1232840-20190508162011243-816651460.png"></p><p>2、原因当然不是模块的问题，检查了一下拼写也没有出问题，最后在这个帖子（链接）的启发下发现，发现自己的文件命名为email.py，和模块中的函数有冲突，改名之后Linux环境邮件正常发送。</p><pre><code>为了方便大家在移动端也能看到我分享的</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化31</title>
      <link href="/2016/03/15/interface/"/>
      <url>/2016/03/15/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十一）–html测试报告通过邮件发出去——下（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　本篇总结了 QQ （SSL）邮箱和 163（非SSL） 邮箱发送邮件，专治各种不行，总之看完这篇以后麻麻再也不用担心我的邮件收不到了。以下代码兼容 python2 和 python3，运行无异常，放心大胆使用。</p><h4 id="2-常用邮件协议"><a href="#2-常用邮件协议" class="headerlink" title="2.常用邮件协议"></a>2.常用邮件协议</h4><p>发送邮件：SMTP</p><p>收取邮件：POP3、IMAP</p><h4 id="3-常用邮件配置项"><a href="#3-常用邮件配置项" class="headerlink" title="3.常用邮件配置项"></a>3.常用邮件配置项</h4><table><thead><tr><th align="center">配置项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mail.xxx.ssl.enable</td><td align="center">是否支持 SSL 连接</td></tr><tr><td align="center">mail.xxx.host</td><td align="center">邮件服务器主机名</td></tr><tr><td align="center">mail.xxx.port</td><td align="center">邮件服务器端口号</td></tr><tr><td align="center">mail.xxx.auth</td><td align="center">是否进行身份认证</td></tr></tbody></table><p>说明：xxx 表示协议名称，例如：smtp、pop3 等。</p><h4 id="4-默认端口号"><a href="#4-默认端口号" class="headerlink" title="4.默认端口号"></a>4.默认端口号</h4><table><thead><tr><th align="center"></th><th align="center">SMTP</th><th align="center">POP3</th><th align="center">IMAP</th></tr></thead><tbody><tr><td align="center">普通方式（非SSL）</td><td align="center">25</td><td align="center">110</td><td align="center">143</td></tr><tr><td align="center">SSL方式</td><td align="center">465</td><td align="center">995</td><td align="center">993</td></tr></tbody></table><h4 id="5-163邮箱（非SSL）"><a href="#5-163邮箱（非SSL）" class="headerlink" title="5.163邮箱（非SSL）"></a>5.163邮箱（非SSL）</h4><p>1、先导入 smtplib 库用来发送邮件，导入 MIMEText 库用来做纯文本的邮件模板</p><p>2、先准备几个跟发邮件相关的参数，每个邮箱的发件服务器都不一样，以 163为例，百度搜到发件服务器为：smtp.163.com</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/4qk5KPVyCQuxgd3.png" alt="1232840-20190507140739294-1754057195.png"></p><p>3、接下来就是写邮件的主题和正文内容，正文这里用 html 格式的</p><p>4、最后调用发件服务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/8iXTEMf4LRbxzjD.png" alt="1232840-20190507140815957-515961600.png"></p><p>5、参考代码</p><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-8 7 @author: 北京-宏哥 8 Project:学习和使用163邮箱发邮件 9 &#39;&#39;&#39;10 #3.导入模块11 import smtplib12 from email.mime.text import MIMEText13 # ----------1.跟发件相关的参数------14 smtpserver = &quot;smtp.163.com&quot; # 发件服务器15 port = 0 # 端口16 sender = &quot;hongge@163.com&quot; # 账号17 psw = &quot;**************&quot; # 密码18 receiver = &quot;1918991791@qq.com&quot; # 接收人19 # ----------2.编辑邮件的内容------20 subject = &quot;这个是主题 163&quot;21 body = &#39;&lt;p&gt;这个是发送的 163 邮件&lt;/p&gt;&#39; # 定义邮件正文为 html 格式22 msg = MIMEText(body, &quot;html&quot;, &quot;utf-8&quot;)23 msg[&#39;from&#39;] = sender24 msg[&#39;to&#39;] = &quot;19198991791@qq.com&quot;25 msg[&#39;subject&#39;] = subject26 # ----------3.发送邮件------27 smtp = smtplib.SMTP()28 smtp.connect(smtpserver) # 连服务器29 smtp.login(sender, psw) # 登录30 smtp.sendmail(sender, receiver, msg.as_string()) # 发送31 smtp.quit() # 关闭</code></pre><h4 id="6-QQ邮箱（SSL）"><a href="#6-QQ邮箱（SSL）" class="headerlink" title="6.QQ邮箱（SSL）"></a>6.QQ邮箱（SSL）</h4><p>1、QQ 邮箱是需要 SSL 认证的，这种邮箱跟上面的就有点不一样了（如果已经开启了，不知道授权码，就点温馨提示里面的‘生成授权码’）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/NU2OJWsnxSLhl78.png" alt="1232840-20190507145139543-134313177.png"></p><p>2、找到 QQ 邮箱授权码，打开 QQ 邮箱-设置-账号-POP3 开启服务-开启</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/OZAt6J1oTQacRm5.png" alt="1232840-20190507145336602-530953428.png"></p><p>3、根据相对应的验证方式，就会收到授权码了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/lDpAdPULsgBCV85.png" alt="1232840-20190507145528270-2138859758.png"></p><p>4、收到授权码后复制，保存下来，这个就可以当 QQ 邮箱的密码了</p><p>5、QQ 邮箱发送邮件代码，跟 163 有点不一样，如下图红色框框：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/dHoDqvaZXlO9sLm.png" alt="1232840-20190507153113523-1794063469.png"></p><p>6、参考代码</p><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-5-8 7 @author: 北京-宏哥 8 Project:学习和使用QQ邮箱发邮件 9 &#39;&#39;&#39;10 #3.导入模块11 import smtplib12 from email.mime.text import MIMEText13 # ----------1.跟发件相关的参数------14 # smtpserver = &quot;smtp.163.com&quot; # 发件服务器15 smtpserver = &quot;smtp.qq.com&quot;16 port = 465 # 端口17 sender = &quot;1918991791@qq.com&quot; # 账号18 psw = &quot;**************&quot; # 密码19 receiver = &quot;1918991791@qq.com&quot; # 接收人20 # ----------2.编辑邮件的内容------21 subject = &quot;这个是主题 QQ&quot;22 body = &#39;&lt;p&gt;这个是发送的 QQ 邮件&lt;/p&gt;&#39; # 定义邮件正文为 html 格式23 msg = MIMEText(body, &quot;html&quot;, &quot;utf-8&quot;)24 msg[&#39;from&#39;] = sender25 msg[&#39;to&#39;] = &quot;1918991791@qq.com&quot;26 msg[&#39;subject&#39;] = subject27 # ----------3.发送邮件------28 # smtp = smtplib.SMTP()29 # smtp.connect(smtpserver) # 连服务器30 smtp = smtplib.SMTP_SSL(smtpserver, port)31 smtp.login(sender, psw) # 登录32 smtp.sendmail(sender, receiver, msg.as_string()) # 发送33 smtp.quit() # 关闭</code></pre><h4 id="7-兼容-163（非SSL）-和-QQ-邮箱（SSL）"><a href="#7-兼容-163（非SSL）-和-QQ-邮箱（SSL）" class="headerlink" title="7.兼容 163（非SSL） 和 QQ 邮箱（SSL）"></a>7.兼容 163（非SSL） 和 QQ 邮箱（SSL）</h4><p>1、Python中检测处理异常是非常重要的，这可以增加代码的健壮性，我们在写python程序的时候，会可能会遇到一些不可预料的情况，一旦遇到这些情况，运行时程序便可能会崩溃。异常可以通过 try 语句来检测. 任何在 try 语句块里的代码都</p><p>会被监测, 检查有无异常发生。</p><p>　　try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你只能使用其中的一种 . 一个 try 语句可以对应一个或多个 except 子句 , 但只能对应一个finally 子句, 或是一个 try-except-finally 复合语句.</p><p>try-except 语句(以及其更复杂的形式)定义了进行异常监控的一段代码, 并且提供了处理异常的机制.</p><p>最常见的 try-except 语句语法如下所示，它由try块和except块 (try_suite 和 except_suite )组成, 也可以有一个可选的错误原因。首先尝试执行 try 子句, 如果没有错误, 忽略所有的 except 从句继续执行，如果发生异常, 解释器将在这一串处理器</p><p>(except 子句)中查找匹配的异常。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/QUWRc4dDafvMjs1.jpg" alt="u_3551840761,1138950460_fm_173_app_25_f_JPEG.jpg"></p><p>简单用法（except后面不跟特定异常，这会捕获所有异常）这种好处就是你不知道会发生什么异常，尽管用；坏处就是当异常发生时候，不能清楚了解到底发生哪种异常。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/zYoMWv6VZLcnFd2.jpg" alt="u_3440588802,3676325594_fm_173_app_25_f_JPEG.jpg"></p><p>我们可以发现，连接没有成功，但程序是正常运行的，会继续往下运行如果没有try，程序则会中断报错。我们发现第一个print并没有运行，这是因为try 语句块中异常发生点后的剩余语句永远不会到达(所以也永远不会执行)。</p><p>2、好了关于try的讲解就到这里，回归正题：如果想兼容上面两种方式发送邮件，只需把第三块内容稍微改下，如下所示</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/8KpIUcxzv2RiOHo.png" alt="1232840-20190508090351471-1815021821.png"></p><p>3、参考代码</p><pre><code> 1 # ----------3.发送邮件------ 2 try: 3     #非SSL 4     smtp = smtplib.SMTP() 5     smtp.connect(smtpserver) # 连服务器 6 except: 7     #SSL 8     smtp = smtplib.SMTP_SSL(smtpserver, port) 9     smtp.login(sender, psw) # 登录10 smtp.sendmail(sender, receiver, msg.as_string()) # 发送11 smtp.quit() # 关闭</code></pre><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h4><p>1、小伙伴们下次遇到这样的直接就用兼容SSL和非SSL的发送邮件代码即可。其实也是很简单！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化30</title>
      <link href="/2016/03/14/interface/"/>
      <url>/2016/03/14/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三十）–html测试报告通过邮件发出去——中（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇，我们虽然已经将生成的最新的测试报告发出去了，但是MIMEText 只能发送正文，无法带附件，因此我还需要继续改造我们的代码，实现可以发送带有附件的邮件。发送带附件的需要导入另外一个模块 MIMEMultipart。还有就是测试负责人不止一个人，需要将测试报告发给多个人，也就是多个收件人。这篇主要是围绕这两个主题进行讲解的。</p><h4 id="2-大致思路"><a href="#2-大致思路" class="headerlink" title="2.大致思路"></a>2.大致思路</h4><p>#####（一）带有附件发送邮件</p><p>1、导入模块 MIMEMultipart</p><pre><code>from email.mime.multipart import MIMEMultipart</code></pre><p>2、先读取要发送文件的内容，file_new 是测试报告路径的参数名</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/hXorDYENGeBlbZd.png" alt="1232840-20190506160752555-1355662005.png"> </p><p>3、下图红色框框 file_name 参数是发送的附件重新命名</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/B632LofqvQr197g.png" alt="1232840-20190506160925958-1146815231.png"> </p><p>4、file_new 是测试报告路径的参数名，发送邮件是将其传入</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/E47pVcsZinPuAKw.png" alt="1232840-20190506161110654-1468373080.png"></p><p>5、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/eFYuGClxEsc31TZ.png" alt="1232840-20190506161619508-1173696443.png"></p><p>6、查看收件箱</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/6YMij39QH8osWcr.png" alt="1232840-20190506161714682-1157232280.png"></p><p>#####（二）发送给多个收件人</p><p>上面都是发给一个收件人，那么如何一次发给多个收件人呢？其实是非常简单的，只需改两个小地方，即可，从这里就可以看出python的强大之处。</p><p>1、源码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/8qLiUwNP2kZleab.png" alt="1232840-20190506163526020-257940741.png"></p><p>2、仿造修改</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/RgvkrxBuQzFHDed.png" alt="1232840-20190507124059768-1224726427.png"></p><p>3、运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/MZoQrXwHhLIR1C9.png" alt="1232840-20190506164219402-840238446.png"></p><p>4、收件箱查看</p><p>公司邮箱</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/LVOsSec2MNqk4jh.png" alt="1232840-20190506170810811-140165208.png"></p><p>QQ邮箱</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/aJWBgAS5Vold4FO.png" alt="1232840-20190507124521965-1169634488.png"></p><h4 id="3-参考代码"><a href="#3-参考代码" class="headerlink" title="3.参考代码"></a>3.参考代码</h4><pre><code># coding=utf-8#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-03-14@author: 北京-宏哥Project:学习和使用将测试报告通过邮件发出去且邮件带有附件&#39;&#39;&#39;#3.导入unittest模块import unittestimport osfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Headerimport smtplib#4.编写测试用例和断言def all_case():    # 待执行用例的目录    #case_dir = &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&quot;    case_dir = os.path.join(os.getcwd(), &quot;case&quot;)    testcase = unittest.TestSuite()    discover = unittest.defaultTestLoader.discover(case_dir,                                                   pattern=&quot;test*.py&quot;,                                                   top_level_dir=None)    # #discover方法筛选出用例，循环添加到测试套件中    # for test_suit in discover:    #     for test_case in test_suit:    #         #添加用力到testcase    #         testcase.addTests(test_case)    # print(testcase)    testcase.addTests(discover)  # 直接加载 discover    可以兼容python2和3    print(testcase)    return testcase# ==============定义发送邮件==========def send_mail(file_new):    #-----------1.跟发件相关的参数------    smtpserver = &#39;smtp.mxhichina.com&#39;                #发件服务器    port = 0                      #端口    username = &#39;nXXX@ceXx.cn&#39;  #发件箱用户名    password = &#39;ceXXx@@123&#39;        #发件箱密码    sender = &#39;XXly@cedex.cn&#39;    #发件人邮箱    receiver = [&#39;hongge@com.cn&#39;,&#39;1918991791@qq.com&#39;] #收件人邮箱    # ----------2.编辑邮件的内容------    #读文件    f = open(file_new, &#39;rb&#39;)    mail_body = f.read()    f.close()    # 邮件正文是MIMEText    body = MIMEText(mail_body, &#39;html&#39;, &#39;utf-8&#39;)    # 邮件对象    msg = MIMEMultipart()    msg[&#39;Subject&#39;] = Header(&quot;自动化测试报告&quot;, &#39;utf-8&#39;).encode()#主题    msg[&#39;From&#39;] = Header(u&#39;测试机 &lt;%s&gt;&#39;%sender)                #发件人    msg[&#39;To&#39;] = Header(u&#39;测试负责人 &lt;%s&gt;&#39;%receiver)            #收件人    msg[&#39;To&#39;] = &#39;;&#39;.join(receiver)    msg[&#39;date&#39;] = time.strftime(&quot;%a,%d %b %Y %H:%M:%S %z&quot;)    msg.attach(body)    # 附件    att = MIMEText(mail_body, &quot;base64&quot;, &quot;utf-8&quot;)    att[&quot;Content-Type&quot;] = &quot;application/octet-stream&quot;    att[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;test_report.html&quot;&#39;    msg.attach(att)    # ----------3.发送邮件------    try:        smtp = smtplib.SMTP()        smtp.connect(smtpserver)  # 连服务器        smtp.login(sender, password)    except:        smtp = smtplib.SMTP_SSL(smtpserver, port)        smtp.login(sender, password)  # 登录    smtp.sendmail(sender, receiver, msg.as_string())  # 发送    smtp.quit()    # #发送邮件    # smtp = smtplib.SMTP()    # smtp.connect(&#39;smtp.mxhichina.com&#39;)  # 邮箱服务器    # smtp.login(username, password)  # 登录邮箱    # smtp.sendmail(sender, receiver, msg.as_string())  # 发送者和接收者    # smtp.quit()    print(&quot;邮件已发出！注意查收。&quot;)# ======查找测试目录，找到最新生成的测试报告文件======def new_report(test_report):    lists = os.listdir(test_report)  # 列出目录的下所有文件和文件夹保存到lists    lists.sort(key=lambda fn: os.path.getmtime(test_report + &quot;\\&quot; + fn))  # 按时间排序    file_new = os.path.join(test_report, lists[-1])  # 获取最新的文件保存到file_new    print(file_new)    return file_newif __name__ == &quot;__main__&quot;:    # 返回实例    runner = unittest.TextTestRunner()    #导入第三方模块HTMLTestRunner    import HTMLTestReportCN    import time    # 获取当前时间，这样便于下面的使用。    now = time.strftime(&quot;%Y-%m-%M-%H_%M_%S&quot;, time.localtime(time.time()))    #保存生成报告的路径    report_path =  &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&quot;+now+&quot;_result.html&quot;    fp = open(report_path,&#39;wb&#39;)    runner = HTMLTestReportCN.HTMLTestRunner(stream=fp,                                           title=u&quot;这是我的自动化测试用例&quot;,                                           description=u&quot;用例执行情况&quot;,                                           verbosity = 2                                           )    # run 所有用例    runner.run(all_case())    #关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。    fp.close()    #测试报告文件夹    test_path = &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&quot;    new_report = new_report(test_path)    send_mail(new_report)  # 发送测试报告</code></pre><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>1、第二处我注释掉也可以发出去，两个收件人可以收到邮件，但是如果这样的话，公司邮箱收件人只显示一个收件人，QQ邮箱显示两个收件人。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/RgvkrxBuQzFHDed.png" alt="1232840-20190507124059768-1224726427.png"></p><p>公司邮箱    PS：如果将红色框上边的注释掉，下边的不注释，就可以看到两个收件人的邮箱</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/F5MfPzLYykC41lv.png" alt="1232840-20190507124353004-2044140686.png"></p><p>以下是个人愚见，如果不对请指出</p><pre><code>from email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartimport smtplib</code></pre><p>以上是导入的包，通过email和smtplib实现发邮件。</p><p>折腾好久，发现是这样：email中收件人和sendmail中的收件人是没啥联系的。</p><pre><code>mail_to = [&#39;test1@exp.com&#39;,&#39;test2@exp.com&#39;]server = smtplib.SMTP()server.connect()server.sendmail(mail_from, mail_to, msg.as_string())server.quit()mail_to = &#39;test1@exp.com,test2@exp.com&#39;msg = MIMEMultipart(&#39;related&#39;) ##采用related定义内嵌资源的邮件体msgtext = MIMEText(content,_subtype=&#39;html&#39;,_charset=&#39;utf-8&#39;) ##_subtype有plain,html等格式，避免使用错误msg[&#39;Subject&#39;] = subjectmsg[&#39;From&#39;] = mail_frommsg[&#39;To&#39;] =mail_to</code></pre><p>sendmail中收件人，它的格式应该为list。这个为实际的收件人地址。</p><p>而msg[‘To’] 格式是字符串(str)。这个只是为了邮件中打印出来而已。</p><p>sendmail查源码，python/lib/smtplib.py大概690行左右，或者搜索tolist。</p><p>2、在使用python添加附件发送时报错：<code>Cannot attach additional subparts to non-multipart/*</code></p><p>查询得知，错误的原因在于缺少这行代码：</p><p><code>msg = MIMEMultipart()</code></p><p>将这行加上：<code>msg = MIMEMultipart()</code>即可</p><h5 id="邮件收不到的几种原因"><a href="#邮件收不到的几种原因" class="headerlink" title="邮件收不到的几种原因"></a>邮件收不到的几种原因</h5><p>1、Subject 和正文内容不要用 hello、hehe、test 等单词</p><p>2、from(发件人)和 to(收件人)不要为空，（要不然会被认为是垃圾邮件）</p><p>3、找不到的话，先看下垃圾信箱，是不是跑到垃圾箱了</p><p>4、如果前几次可以收到，后来收不到了，需改下 subject 内容（因为每次都是一个 subject，系统也会拒收的，把 subject 内容设置为动态的是最好的）</p><p>5、部分邮箱是 ssl 加密了的，所以无法发送，如:qq 邮箱（用授权码去登录）</p><p>6、要是按照上面的步骤来报错了，说明代码抄错了，多检查几次。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化29</title>
      <link href="/2016/03/13/interface/"/>
      <url>/2016/03/13/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十九）–html测试报告通过邮件发出去——上（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　前边几篇，已经教小伙伴们掌握了如何生成HTML的测试报告，那么生成测试报告，我们也不能放在那里不管了，这样即使你报告在漂亮，领导也看不到。因此如果想向领导汇报工作，不仅需要提供更直观的测试报告。而是我们需要将生成测试报告发个相关的负责人，需要他们看一下测试结果，把控一下项目的接口有风险，会不会影响项目进度等等一些事吧。</p><p>　　发邮件需要用到python两个模块，smtplib和email，这俩模块是python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。其中MIMEText()定义邮件正文，Header()定义邮件标题。MIMEMulipart模块构造带附件。</p><h4 id="2-大致思路流程"><a href="#2-大致思路流程" class="headerlink" title="2.大致思路流程"></a>2.大致思路流程</h4><p>1、通过unittest框架的discover()找到匹配的测试用例，由HTMLTestRunner的run()方法执行测试用例并生成最新的测试报告。</p><p>2、调用new_report()函数找到测试报告目录下最新生成的测试报告，返回测试报告的路径。</p><p>3、将得到的最新测试报告的完整路径传给send_mail()函数，实现发邮件功能。</p><p>4、第一步，前边几篇，我们都详细介绍了，所以这篇就不在赘述了，直接从第二步、第三步开始讲解。</p><h4 id="3-查找最新测试报告"><a href="#3-查找最新测试报告" class="headerlink" title="3.查找最新测试报告"></a>3.查找最新测试报告</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/AHv4VuFLgR5dC2N.png" alt="1232840-20190506110256734-588764790.png"></p><h4 id="4-定义发送邮件"><a href="#4-定义发送邮件" class="headerlink" title="4.定义发送邮件"></a>4.定义发送邮件</h4><p>1、查看一下，源码如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/miRq2lC3fHtB1Zc.png" alt="1232840-20190506134115515-1276667820.png"></p><p>2、仿照源码进行改造</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/useJVKy4rEPqalU.png" alt="1232840-20190506134252881-1879931191.png"></p><h4 id="5-参考代码"><a href="#5-参考代码" class="headerlink" title="5.参考代码"></a>5.参考代码</h4><pre><code># coding=utf-8#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-03-13@author: 北京-宏哥Project:学习和使用将测试报告通过邮件发出去&#39;&#39;&#39;#3.导入unittest模块import unittestimport osfrom email.mime.text import MIMETextfrom email.header import Headerimport smtplib#4.编写测试用例和断言def all_case():    # 待执行用例的目录    #case_dir = &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&quot;    case_dir = os.path.join(os.getcwd(), &quot;case&quot;)    testcase = unittest.TestSuite()    discover = unittest.defaultTestLoader.discover(case_dir,                                                   pattern=&quot;test*.py&quot;,                                                   top_level_dir=None)    # #discover方法筛选出用例，循环添加到测试套件中    # for test_suit in discover:    #     for test_case in test_suit:    #         #添加用力到testcase    #         testcase.addTests(test_case)    # print(testcase)    testcase.addTests(discover)  # 直接加载 discover    可以兼容python2和3    print(testcase)    return testcase# ==============定义发送邮件==========def send_mail(file_new):    f = open(file_new, &#39;rb&#39;)    mail_body = f.read()    f.close()    username = &#39;nXXply@ceXXx.cn&#39;  #发件箱用户名    password = &#39;XXX@@123&#39;        #发件箱密码    sender = &#39;noXXy@ceXXx.cn&#39;    #发件人邮箱    receiver = [&#39;hongge@XXX.cn&#39;]  #收件人邮箱    # 邮件正文是MIMEText    msg = MIMEText(mail_body, &#39;html&#39;, &#39;utf-8&#39;)    # 邮件对象    msg[&#39;Subject&#39;] = Header(&quot;自动化测试报告&quot;, &#39;utf-8&#39;).encode()    msg[&#39;From&#39;] = Header(u&#39;测试机 &lt;%s&gt;&#39;%sender)    msg[&#39;To&#39;] = Header(u&#39;测试负责人 &lt;%s&gt;&#39;%receiver)    msg[&#39;date&#39;] = time.strftime(&quot;%a,%d %b %Y %H:%M:%S %z&quot;)    #发送邮件    smtp = smtplib.SMTP()    smtp.connect(&#39;smtp.mxhichina.com&#39;)  # 邮箱服务器    smtp.login(username, password)  # 登录邮箱    smtp.sendmail(sender, receiver, msg.as_string())  # 发送者和接收者    smtp.quit()    print(&quot;邮件已发出！注意查收。&quot;)# ======查找测试目录，找到最新生成的测试报告文件======def new_report(test_report):    lists = os.listdir(test_report)  # 列出目录的下所有文件和文件夹保存到lists    lists.sort(key=lambda fn: os.path.getmtime(test_report + &quot;\\&quot; + fn))  # 按时间排序    file_new = os.path.join(test_report, lists[-1])  # 获取最新的文件保存到file_new    print(file_new)    return file_newif __name__ == &quot;__main__&quot;:    # 返回实例    runner = unittest.TextTestRunner()    #导入第三方模块HTMLTestRunner    import HTMLTestReportCN    import time    # 获取当前时间，这样便于下面的使用。    now = time.strftime(&quot;%Y-%m-%M-%H_%M_%S&quot;, time.localtime(time.time()))    #保存生成报告的路径    report_path =  &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&quot;+now+&quot;_result.html&quot;    fp = open(report_path,&#39;wb&#39;)    runner = HTMLTestReportCN.HTMLTestRunner(stream=fp,                                           title=u&quot;这是我的自动化测试用例&quot;,                                           description=u&quot;用例执行情况&quot;,                                           verbosity = 2                                           )    # run 所有用例    runner.run(all_case())    #关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。    fp.close()    #测试报告文件夹    test_path = &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&quot;    new_report = new_report(test_path)    send_mail(new_report)  # 发送测试报告</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、遇到的问题及解决方法</p><p>（1）将生成的测试报告的保存路径和查找测试报告的路径混淆会报如下错误</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/KN3tZ9TPXS2aCyo.png" alt="1232840-20190506103924189-992662445.png"></p><p>（2）解决方法</p><p>a、我们先来分析一下原因，刚开始我查了资料还觉得是不是数组越界，后来感觉不对，就复制粘贴到我的电脑报如下错误，确实找不到</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/sc9FZdI2gRLAjeW.png" alt="1232840-20190506104159395-1118007246.png"></p><p>b、接着Ctrl+R复制进去，运行出现如下这是才知道查找最新的测试报告遍历的根本不是一个目录而是一个文件</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/KDZvsJYekaw1n53.png" alt="1232840-20190506104500599-1767031482.png"></p><p>c、解决办法不是文件夹修改成测试报告的文件夹是不是就可以，做如下简单地修改就可以了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/EKbA3MoejkcF28O.png" alt="1232840-20190506104808209-915136186.png"></p><p>d、完了把test_path拷贝在我电脑和运行处，两个界面一样分别定位到测试报告。这样就可以遍历，这是不用试 一定可以成功分别如下：</p><p>我的电脑</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/tDai9wOzmHjQS3K.png" alt="1232840-20190506105114358-260779565.png"></p><p>运行</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/Xsma59ZyQEtVTW8.png" alt="1232840-20190506105215294-1464883342.png"></p><p>e、代码运行结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/YPZrNLMTdWRq1sF.png" alt="1232840-20190506105410258-2132774264.png"></p><p>f、到收件箱可以看到测试报告</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/ljLJMnyedAo4YB8.png" alt="1232840-20190506105509077-1235636861.png"></p><p>2、发送的邮件看不到发件人和收件人，如图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/W9L7ZBamvigtSk6.png" alt="1232840-20190506120144481-1992485559.png"></p><p> a、解决办法：</p><p>加两行代码即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/DwZoJEYHdlau7Bi.png" alt="1232840-20190506134816260-603909728.png"></p><p>b、再次运行收到邮件</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/06/GmEhVUvRu45AZeF.png" alt="1232840-20190506134912693-521929684.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化28</title>
      <link href="/2016/03/12/interface/"/>
      <url>/2016/03/12/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十八）–html测试 报告——下（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　五一小长假已经结束了，想必大家都吃饱喝足玩好了，那就继续学习吧。一天不学习，自己知道；两天不学习，对手知道；三天不学习，大家知道；一周不学习，智商输给猪。好了开个玩笑都逗大家一乐，但是想想还是有道理的。那就进入正题：上一篇我们批量执行完用例后，已经生成的测试报告是生成 HTML 格式的。但是我们可以看出那个官方的测试报告既不美观也不大方，我们这里需要优化一下，优化的让人赏心悦目，就和看到一个美女一样看了一眼，忍不住回头再多看一眼  - _ - 并且把上一篇遇到的问题列举解决一下。</p><h4 id="2-python3如何改动下载的HTMLTestRunner"><a href="#2-python3如何改动下载的HTMLTestRunner" class="headerlink" title="2.python3如何改动下载的HTMLTestRunner"></a>2.python3如何改动下载的HTMLTestRunner</h4><h5 id="HTMLTestRunner-py-的python3-版本"><a href="#HTMLTestRunner-py-的python3-版本" class="headerlink" title="HTMLTestRunner.py 的python3 版本"></a>HTMLTestRunner.py 的python3 版本</h5><p>由于 HTMLTestRunner.py 原本就是python2版本，目前还没找到python3版本，所以需要我们自己修改 HTMLTestRunner.py 文件。</p><h6 id="1-修改的地方"><a href="#1-修改的地方" class="headerlink" title="1. 修改的地方"></a>1. 修改的地方</h6><p>问题一：No module named StringIO</p><p>原因：python 3 中 没有 StringIO 这个模块。这里我们需要使用io 这个模块来代替。</p><p>解决方法：</p><p>第94行引入的名称要改，从 import StringIO 改成import io。</p><p>相应的，539行 self.outputBuffer = StringIO.StringIO() 要改成self.outputBuffer = io.BytesIO()</p><p>问题二：AttributeError: ‘dict’ object has no attribute ‘has_key’</p><p>原因：python 3 字典类型的object 已经不支持 has_key函数，我们需要使用in 来进行遍历。</p><p>解决方法：</p><p>定位到642行，if not rmap.has_key(cls): 需要换成 if not cls in rmap:</p><p>问题三：’str’ object has no attribute ‘decode’</p><p>原因：python3 里面对字符的操作中，decode已经拿掉了。</p><p>解决方法：</p><p>定位到772行，把 ue = e.decode(‘latin-1’) 直接改成 ue = e 。</p><p>另外766还有类似的uo = o.decode(‘latin-1’)，改成 uo=o ；</p><p>问题四 ：TypeError: can’t concat bytes to str</p><p>原因：定位一下，报在了778行的内容escape(uo+ue) 。这是因为我们上面给uo赋值的时候，走的是else流程，uo被赋值的是bytes类型的值。 而bytes类型不能直接转化为str类型。所以我们需要在前面给uo赋值的时候先将bytes类型转换为 str类型。</p><p>解决方法：</p><p>修改768行的 uo = o ，直接改成 uo = o.decode(‘utf-8’) 。</p><p>另外 774还有类似的  ue = e， 改成 ue = e.decode(‘utf-8’)。</p><p>问题五：TypeError: unsupported operand type(s) for &gt;&gt;: ‘builtin_function_or_method’ and ‘RPCProxy’</p><p>原因： python3  不支持 print &gt;&gt; sys.stderr 这种写法，这里定义输出流的话，采用print(“This is print str”,file=sys.stderr) 这种方式。</p><p>解决方法：</p><p>定位到631行，把print的语句修改掉，原来是print &gt;&gt;sys.stderr, ‘\nTime Elapsed: %s’ % (self.stopTime-self.startTime)， 可改成 print(‘\nTime Elapsed: %s’ % (self.stopTime-self.startTime),file=sys.stderr)</p><p>问题六：TypeError: ‘str’ does not support the buffer interface</p><p>原因：定位一下，问题出在118行，这里s是str类型，我们需要把传过来的s转化为bytes类型。</p><p>解决方法：</p><p>定位到118行，把 self.fp.write(s) 修改为 self.fp.write(bytes(s,’UTF-8’)) 即可。</p><h6 id="2-保存"><a href="#2-保存" class="headerlink" title="2. 保存"></a>2. 保存</h6><p>修改后对HTMLTestRunner.py 保存一下。</p><h6 id="3-调用语句更改"><a href="#3-调用语句更改" class="headerlink" title="3. 调用语句更改"></a>3. 调用语句更改</h6><p>python3 里面打开文件使用 open，不要再去用file了。</p><p>即 fp = file(filename,’wb’)替换成 fp = open(filename,’wb’)；</p><p>关闭该文件可用fp.close()</p><p>备注： 改动之后，中文也不会乱码。</p><h4 id="3-中文乱码"><a href="#3-中文乱码" class="headerlink" title="3.中文乱码"></a>3.中文乱码</h4><p>1、测试报告中，msg 自定义异常内容有中文情况会出现乱码，如图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/v2UAxtI13eMkwVs.png" alt="1232840-20190430135233864-848932277 _1_.png"></p><p>2、找到 HTMLTestRunner.py 文件，搜索:uo =</p><p>3、找到红色区域设置编码的两个地方</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/5JPe347kvdt2mBx.png" alt="1232840-20190430134430216-1843435441.png"></p><p>4、注释掉红色区域这两个设置，重新添加编码格式为：uo = o.decode(‘utf-8’) ue = e.decode(‘utf-8’)，或者在此基础上直接修给成uo = o.decode(‘utf-8’) ue = e.decode(‘utf-8’)，建议初学者还是用第一种方法。这样出错了，可以很快还原，否则</p><p>在碰到更复杂的代码直接修改就可能会遇到问题</p><p>5、修改好之后记得保存，重新运行，乱码问题就解决了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/Ub3ouNqFrjQ5pBn.png" alt="1232840-20190430135508632-850240072.png"></p><h4 id="4-python3-报告问题"><a href="#4-python3-报告问题" class="headerlink" title="4.python3 报告问题"></a>4.python3 报告问题</h4><p>1、各位小伙伴可以按照我前边的方法进行自己修改，或者找我要也是可以，注意在修改的时候空格和Tab的问题，否则运行会报这样的错误</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/HgPqxceyoipa4tL.png" alt="1232840-20190430135930506-1946234772.png"></p><h4 id="5-报告问题样式优化"><a href="#5-报告问题样式优化" class="headerlink" title="5.报告问题样式优化"></a>5.报告问题样式优化</h4><p>1、优化是一些前端和CSS知识，在这里就不做详细介绍了，有兴趣的可以找我探讨一下，也可以和我要一下那个优化后的报告文件，优化后报告展示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/iwnINQ1f7Pr8suc.png" alt="1232840-20190430140451648-1262963364.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、关于生成报告，优化报告就是这么简单，小伙伴们练起来吧！</p><p>2、为了新的报告不会覆盖掉老的测试报告，可以按图中的红色部分圈起来的方法实现</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/nWqliwtZPgTz6XU.png" alt="1232840-20190430141802039-838368915.png"></p><p>3、参考代码（增加一行代码，测试报告的路径修改一下）</p><pre><code>1 # 获取当前时间，这样便于下面的使用。2 now = time.strftime(&quot;%Y-%m-%M-%H_%M_%S&quot;, time.localtime(time.time()))3 #保存生成报告的路径4 report_path =  &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\result&quot;+now+&quot;.html&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化27</title>
      <link href="/2016/03/11/interface/"/>
      <url>/2016/03/11/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十七）–html 测试报告——上（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇我们批量执行完用例后，生成的测试报告是文本形式的，不够直观，而且报告一般都是发给leader的，所以最好是直观一目了然，为了更好的展示测试报告，最好是生成 HTML 格式的。unittest 里面是不能生成 html 格式报告的，需要导入一个第三方的模块：HTMLTestRunner。</p><h4 id="2-导入-HTMLTestRunner"><a href="#2-导入-HTMLTestRunner" class="headerlink" title="2.导入 HTMLTestRunner"></a>2.导入 HTMLTestRunner</h4><p>1.、这 个 模 块 下 载 不 能 通 过 pip 安装了，只能下载后手动导入，下载地址：<a href="http://tungwaiyip.info/software/HTMLTestRunner.html" target="_blank" rel="noopener">http://tungwaiyip.info/software/HTMLTestRunner.html</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/QweUoOpbmt4u3Ks.png" alt="1232840-20190429152046444-1406129484.png"></p><p>2、Download 下 HTMLTestRunner.py 文件就是我们需要下载的包。注意点击后会进入其源码，可以通过另存为将其下载下来或者直接Ctrl+A加Ctrl+C，Ctrl+V,推荐另存为</p><p>3、下载后手动拖到 python 安装文件的 Lib 目录下</p><p>demo 解析<br>1、下载 Download 下的第二个文件 test_HTMLTestRunner.py,这个就是官方给的一个测试demo 了，从这个文件可以找到该模块的用法。</p><p>2、找到下图这段，就是官方给的一个 demo 了，test_main()里上半部分就是加载测试 case,我们不需要搞这么复杂。</p><p>3、最核心的代码是下面的红色区域，这个就是本篇的重点啦。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/ZBlvut96fKoV8zC.png" alt="1232840-20190429152917024-1676365984.png"> </p><h4 id="3-生成-html-报告"><a href="#3-生成-html-报告" class="headerlink" title="3.生成 html 报告"></a>3.生成 html 报告</h4><p>1、我们只需把上面红色区域代码 copy 到上一篇的基础上稍做修改就可以了，这里主要有三个参数:　</p><p>　　–stream:测试报告写入文件的存储区域</p><p>　　–title:测试报告的主题</p><p>　　–description：测试报告的描述</p><p>2、report_path 是存放测试报告的地址</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/1kmaBbLR36xCpFK.png" alt="1232840-20190430090152883-1583104116.png"></p><h4 id="4-测试报告详情"><a href="#4-测试报告详情" class="headerlink" title="4.测试报告详情"></a>4.测试报告详情</h4><p>1、找到测试报告文件，用浏览器打开，点开 View 里的 Detail 可以查看详情描述。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/HwBFfKpdYr5l7aJ.png" alt="1232840-20190430100128178-955501387.png"></p><p>2、为了生成带中文描述的测试用例，可以在 case 中添加注释，如在 test_01 的脚本添加如下注释：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/hJ81sPAM6DZkBxU.png" alt="1232840-20190430100609877-46899857.png"></p><p>3、重新运行后查看测试报告</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/yYq1Au2lXNoEOxP.png" alt="1232840-20190430100523313-1526469244.png"> </p><h4 id="5-参考代码"><a href="#5-参考代码" class="headerlink" title="5.参考代码"></a>5.参考代码</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-29 7 @author: 北京-宏哥 8 Project:学习和使用discover批量执行测试用例 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 import os13 #4.编写测试用例和断言14 def all_case():15     # 待执行用例的目录16     #case_dir = &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&quot;17     case_dir = os.path.join(os.getcwd(), &quot;case&quot;)18     testcase = unittest.TestSuite()19     discover = unittest.defaultTestLoader.discover(case_dir,20                                                    pattern=&quot;test*.py&quot;,21                                                    top_level_dir=None)22     # #discover方法筛选出用例，循环添加到测试套件中23     # for test_suit in discover:24     #     for test_case in test_suit:25     #         #添加用力到testcase26     #         testcase.addTests(test_case)27     # print(testcase)28 29     testcase.addTests(discover)  # 直接加载 discover    可以兼容python2和330     print(testcase)31     return testcase32 if __name__ == &quot;__main__&quot;:33     # 返回实例34     runner = unittest.TextTestRunner()35     #导入第三方模块HTMLTestRunner36     import HTMLTestRunner37     #保存生成报告的路径38     report_path =  &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\result.html&quot;39     fp = open(report_path,&#39;wb&#39;)40     runner = HTMLTestRunner.HTMLTestRunner(stream=fp,41                                            title=u&quot;这是我的自动化测试用例&quot;,42                                            description=u&quot;用例执行情况&quot;43                                            )44     # run 所有用例45     runner.run(all_case())46     #关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。47     fp.close()</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、fp.close()  #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError</p><p>2、问题： 执行测试用例的过程中，不会打印任何东西，导致上个厕所或第二天回来时，根本不知道执行到哪了，或者执行多少测试用例了。</p><p>解决思路： 每次执行一个测试用例时，就打印该测试用例的名称。</p><p>解决方案： 调用HTMLTestRunner时，定义 verbosity 为大于1的整数，比如说 2：</p><pre><code>runner=HTMLTestRunner.HTMLTestRunner(fp,title=&quot;xxxx&quot;,description=&quot;xxx&quot;,verbosity=2)</code></pre><p>在控制台console 就可以看到每执行一条用例，就会有如下输出：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/GCxVk5UXNmvgK86.png" alt="1232840-20190430110722822-1596324694.png"></p><p>3、HTMLTestRunner 脚本源码分析与解释</p><pre><code> 1 class OutputRedirector(object) 2 # 将输出进行重定向 3  4 class Template_mixin(object) 5 # 定义生成HTML结果文件所需要的模板。 6 # 如果我们想改变HTML的格式等待，可以在这里进行改动 7  8 class _TestResult(TestResult) 9 # 定义继承自 unittest.TestResult 的 类。10 # 这里重写了 unittest.TestResult 的多个方法，比如 startTest(self, test) 等等11 12 class HTMLTestRunner(Template_mixin)13 # 这里可以说是使用 HTMLTestRunner.py 的入口。定义了多个我们可以看到的方法，比如 run(self, test)14 15 class TestProgram(unittest.TestProgram)16 # 这里继承自 unittest.TestProgram 类，重写了 runTests 方法。17 # 用于命令行执行测试</code></pre><p>4、缺点：使用HTMLTestRunner的执行测试用例的过程中，如果中间中断执行，则已经执行完的用例结果也不会打印到html文件</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化26</title>
      <link href="/2016/03/10/interface/"/>
      <url>/2016/03/10/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十六）–批量执行用例 discover（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>我们在写用例的时候，单个脚本的用例好执行，那么多个脚本的时候，如何批量执行呢？这时候就需要用到 unittest 里面的 discover 方法来加载用例了。加载用例后，用 unittest 里面的 TextTestRunner 这里类的 run 方法去一次执行多个脚本的用例。那么前边介绍那么多都是半道开始，半道出家，这篇就带大家从头到尾，一步一步给小伙伴们详细介绍一下。</p><h4 id="2-新建测试项目"><a href="#2-新建测试项目" class="headerlink" title="2.新建测试项目"></a>2.新建测试项目</h4><p>1、pycharm 左上角 File&gt;New Projetc&gt;Pure Python,在 location 位置命名一个测试工程的名称：honggetest</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/aN3rT5EwzpYHOgP.png" alt="1232840-20190428104928484-555485728.png"></p><p>2、然后点击“Create”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/2y58tpPnAcsNFQx.png" alt="1232840-20190428105956092-158453222.png"></p><p>3、选中刚才新建的工程右键&gt;New&gt;Python Package&gt;新建一个 case 文件夹</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/WVehHPCbXvnw1cY.png" alt="1232840-20190428110758160-1941501394.png"></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/BoGriQMxkCILKTu.png" alt="1232840-20190428111223483-2032822580.png"></p><p>4、重复第 3 步的操作，新建一个 case 的文件夹，在里面添加一个 baidu 和一个 blog 的文件夹，里面分别有两个用例的脚本，如下图所示。test_01,test_02,test_03,test_04 是我们写用例的脚本</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/Oa5I39JrNxvWKdT.png" alt="1232840-20190428111458423-1835842880.png"> </p><p>5、test_01创建完后，打开脚本，写入用例，其他的可以复制即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/DRnNmqevTr53l7E.png" alt="1232840-20190429114152419-1064506012.png"></p><p>6、参考代码</p><pre><code> 1 # coding:utf-8 2 import unittest 3 import time 4  5 class Test(unittest.TestCase): 6     def setUp(self): 7         print (&quot;start!&quot;) 8     def tearDown(self): 9         time.sleep(1)10         print (&quot;end!&quot;)11     def test01(self):12         print (&quot;执行测试用例 01&quot;)13     def test02(self):14         print (&quot;执行测试用例 02&quot;)15     def test03(self):16         print (&quot;执行测试用例 03&quot;)17 18 if __name__ == &quot;__main__&quot;:19     unittest.main()</code></pre><p>7、在 honggetest 这个项目下面创建一个脚本 run_all_case.py，接下来用这个脚本去批量执行所有的用例。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/hnOzlru2EJtTVeM.png" alt="1232840-20190428112517671-850262157.png"></p><h4 id="3-discover-加载测试用例"><a href="#3-discover-加载测试用例" class="headerlink" title="3.discover 加载测试用例"></a>3.discover 加载测试用例</h4><p>1、discover 方法里面有三个参数：</p><p>　　-case_dir:这个是待执行用例的目录。</p><p>　　-pattern：这个是匹配脚本名称的规则，test*.py 意思是匹配 test 开头的所有脚本。</p><p>　　-top_level_dir：这个是顶层目录的名称，一般默认等于 None 就行了。</p><p>2、discover 加载到的用例是一个 list 集合，需要重新写入到一个 list 对象 testcase 里，这样就可以用 unittest 里面的 TextTestRunner 这里类的 run 方法去执行。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/wOZr7lCE2jTuUmX.png" alt="1232840-20190429104836547-458807808.png"></p><p>3、运行后结果入下，就是加载到的所有测试用例了：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/gvrNdGXu7YoaKfs.png" alt="1232840-20190429104918665-1225555269.png"></p><h4 id="4-参考代码"><a href="#4-参考代码" class="headerlink" title="4.参考代码"></a>4.参考代码</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-10 7 @author: 北京-宏哥 8 Project:学习和使用discover批量执行测试用例 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 #4.编写测试用例和断言13 def all_case():14     # 待执行用例的目录15     case_dir = &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&quot;16     testcase = unittest.TestSuite()17     discover = unittest.defaultTestLoader.discover(case_dir,18                                                    pattern=&quot;test*.py&quot;,19                                                    top_level_dir=None)20     #discover方法筛选出用例，循环添加到测试套件中21     for test_suit in discover:22         for test_case in test_suit:23             #添加用力到testcase24             testcase.addTests(test_case)25     print(testcase)26     return testcase27 if __name__ == &quot;__main__&quot;:28     # 返回实例29     runner = unittest.TextTestRunner()30     # run 所有用例31     runner.run(all_case())</code></pre><h4 id="5-run-测试用例"><a href="#5-run-测试用例" class="headerlink" title="5.run 测试用例"></a>5.run 测试用例</h4><p>1、为了更方便的理解，可以把上面 discover 加载用例的方法封装下，写成一个函数</p><p>2、先返回 TextTestRunner()类的实例</p><p>3、调用 run 方法去执行 all_case()这个函数</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/1F4fbRJHEAopPGg.png" alt="1232840-20190429105119136-832251450.png"> </p><h4 id="6-参考代码"><a href="#6-参考代码" class="headerlink" title="6.参考代码"></a>6.参考代码</h4><pre><code># coding=utf-8#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-03-10@author: 北京-宏哥Project:学习和使用discover批量执行测试用例&#39;&#39;&#39;#3.导入unittest模块import unittest#4.编写测试用例和断言def all_case():    # 待执行用例的目录    case_dir = &quot;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&quot;    testcase = unittest.TestSuite()    discover = unittest.defaultTestLoader.discover(case_dir,                                                   pattern=&quot;test*.py&quot;,                                                   top_level_dir=None)    testcase.addTests(discover)  # 直接加载 discover    可以兼容python2和3    print(testcase)    return testcaseif __name__ == &quot;__main__&quot;:    # 返回实例    runner = unittest.TextTestRunner()    # run 所有用例    runner.run(all_case())</code></pre><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>1、unittest模块中的TestLoader类有一个discover方法（Python2.7之后）discover(start_dir, pattern=’test*.py’,top_level_dir=None)递归查找指定目录（start_dir）及其子目录下的全部测试模块，将这些测试模块放入一个TestSuite 对象并返</p><p>回。只有匹配pattern的测试文件才会被加载到TestSuite中。如果一个测试文件的名称符合pattern，将检查该文件是否包含 load_tests() 函数，如果 load_tests() 函数存在，则由该函数负责加载本文件中的测试用例。如果不存在，就会执行</p><p>loadTestsFromModule()，查找该文件中派生自TestCase 的类包含的 test 开头的方法。</p><p>2、用例路径另一种写法</p><pre><code>1 case_dir = os.path.join(os.getcwd(), &quot;case&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化25</title>
      <link href="/2016/03/09/interface/"/>
      <url>/2016/03/09/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十五）–unittest断言——下（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　本篇还是回归到我们最初始的话题，想必大家都忘记了，没关系看这里：传送门  没错最初的话题就是登录，由于博客园的登录机制改变了，本篇以我找到的开源免费的登录API为案例，结合 unittest 框架写 2 个用例。同样我们先来看一下接口文档。</p><h4 id="2-接口文档"><a href="#2-接口文档" class="headerlink" title="2.接口文档"></a>2.接口文档</h4><h5 id="2-1登录接口"><a href="#2-1登录接口" class="headerlink" title="2.1登录接口"></a>2.1登录接口</h5><p>请求方式：POST</p><p>请求地址：<a href="https://api.apiopen.top/developerLogin" target="_blank" rel="noopener">https://api.apiopen.top/developerLogin</a></p><table><thead><tr><th align="center">Query参数名</th><th align="center">类型</th><th align="center">必需</th><th align="center">描述</th><th align="center">示例e.g.</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">string</td><td align="center">是</td><td align="center">用户名</td><td align="center">peakchao</td></tr><tr><td align="center">passwd</td><td align="center">string</td><td align="center">是</td><td align="center">密码</td><td align="center">123456</td></tr></tbody></table><p>返回示例：</p><pre><code>                                {    &quot;code&quot;: 200,    &quot;message&quot;: &quot;成功!&quot;,    &quot;result&quot;: {        &quot;apikey&quot;: &quot;b9b3a96f7554e3bead2eccf16506c13e&quot;    }}</code></pre><h4 id="3-设计测试用例"><a href="#3-设计测试用例" class="headerlink" title="3.设计测试用例"></a>3.设计测试用例</h4><p>1、针对以上接口文档，设计这个登录接口的测试用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/M7DvKEbq3C9jHQY.png" alt="1232840-20190428084340657-2049868223.png"></p><p>2、参考代码</p><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-28 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架设计登录测试用例和断言-下篇 9 &#39;&#39;&#39;10 #3.导入requests和unittest模块11 import requests12 import unittest13 #4.编写测试用例和断言14 class Blog_login(unittest.TestCase):15     def login(self, username, psw):16         &#39;&#39;&#39;两个个参数：账号：username，密码：psw&#39;&#39;&#39;17         url = &quot;https://api.apiopen.top/developerLogin&quot;18         par = {&quot;name&quot;: username,19                &quot;passwd&quot;: psw20         }21         res = requests.post(url, params=par)22 #        result1 = res.text  # 字节输出23 #        print(result1)24         return res.json()25 26     def test_login1(self):27         &#39;&#39;&#39;测试登录：正确账号，正确密码&#39;&#39;&#39;28         username = &quot;peakchao&quot;,  # 正确账号，抓包获得的加密字符串29         psw = &quot;123456&quot;,  # 正确密码，抓包获得的加密字符串30         result = self.login(username, psw)31         self.assertEqual(200,result[&#39;code&#39;])32         print(result[&#39;message&#39;])33 34     def test_login2(self):35         &#39;&#39;&#39;测试登录：正确账号，错误密码；反之也可以设计用例&#39;&#39;&#39;36         username = &quot;peakchao&quot;,#正确账号37         psw = &quot;122222&quot;,#错误密码38         result = self.login(username, psw)39         self.assertEqual(result[&#39;code&#39;], 400)40         print(result[&#39;message&#39;])41     def test_login3(self):42         &#39;&#39;&#39;测试登录：账号为空，正确密码；反之也可以设计用例&#39;&#39;&#39;43         username = &quot;&quot;,  # 错误账号44         psw = &quot;123456&quot;,  # 正确密码45         result = self.login(username, psw)46         self.assertEqual(result[&#39;code&#39;], 400)47         print(result[&#39;message&#39;])48 if __name__ == &quot;__main__&quot;:49  unittest.main()</code></pre><h4 id="4-无接口文档"><a href="#4-无接口文档" class="headerlink" title="4.无接口文档"></a>4.无接口文档</h4><p>1、在实际工作中由于某些原因开发人员不能按时给出接口文档，但是接口已经开发好了，需要测试人员提前介入，此时你又不能等接口文档写好了再开始测试，那样黄花菜都凉了，还有就是接口文档有是有，但是没有人更新和维护，如果你按</p><p>照旧文档保证是会出错，或者接口不通。所以我们必须采用另一种方式开始测试接口。</p><p>2、那就是我们自己通过fiddler抓包获取url和接口的参数以及返回结果等等，还是由于博客园的登录机制的改变，我在这了一jenkins登录接口为例给小伙伴们演示一下。</p><p>3、大致流程：web页面jenkins点击登录—&gt;fiddler抓包获取登录接口URL和参数—&gt;从fiddler查看登录接口返回的结果—&gt;代码模拟登录接口并获取接口登录返回结果—&gt;设计登录接口测试用例—&gt;断言并执行用例</p><p>4、web页面jenkins点击登录</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/cmxLOzN8S7KkJaP.png" alt="1232840-20190428093018035-710689636.png"></p><p>5、fiddler抓包获取登录接口URL和参数</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/cVuoC9qazk7txvN.png" alt="1232840-20190428093253185-1945823672.png"></p><p>6、从fiddler查看登录接口返回的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/JYbKQIThFutp28g.png" alt="1232840-20190428093340762-1848257507.png"></p><p>7、代码模拟登录接口并获取接口登录返回结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/1cbXzjuGw4ryOWN.png" alt="1232840-20190428101738005-1279406397.png"> </p><p>8、设计登录接口测试用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/kO6lGyV3WYven9c.png" alt="1232840-20190428101806892-1174445873.png"> </p><p>9、断言并执行用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/mSTk1l5CgRVte4E.png" alt="1232840-20190428101840995-1238924574.png"> </p><p>10、参考代码</p><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-28 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架设计jenkins登录测试用例和断言-下篇 9 &#39;&#39;&#39;10 #3.导入requests和unittest模块11 import requests12 import unittest13 #4.编写测试用例和断言14 class Jenkins_login(unittest.TestCase):15     def login(self, username, psw):16         &#39;&#39;&#39;从fiddler抓包看到事个参数：17         账号：j_username，密码：j_password，from，Submit，remember_me18         &#39;&#39;&#39;19         url = &quot;http://localhost.:8080/jenkins/j_acegi_security_check&quot;20         headers = {21             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot;22         }  # get方法其它加个ser-Agent就可以了23         par = {&quot;j_username&quot;: username,24              &quot;j_password&quot;: psw,25              &quot;from&quot;: &quot;&quot;,26              &quot;Submit&quot;: u&quot;登录&quot;,27              &quot;remember_me&quot;: &quot;on&quot;28         }29         res = requests.post(url, headers=headers, data=par)30         result = res.url  # 字节输出31         print(result)32         result1 = res.status_code33         print(result1)34         return res.status_code35 36     def test_login1(self):37         &#39;&#39;&#39;测试登录：正确账号，正确密码&#39;&#39;&#39;38         username = &quot;admin&quot;,  # 正确账号，抓包获得的加密字符串39         psw = &quot;111111&quot;,  # 正确密码，抓包获得的加密字符串40         result = self.login(username, psw)41         self.assertEqual(200,result)42 43     def test_login2(self):44         &#39;&#39;&#39;测试登录：正确账号，错误密码；反之也可以设计用例&#39;&#39;&#39;45         username = &quot;admin&quot;,#正确账号46         psw = &quot;122222&quot;,#错误密码47         result = self.login(username, psw)48         self.assertEqual(result, 404)49 50     def test_login3(self):51         &#39;&#39;&#39;测试登录：账号为空，正确密码；反之也可以设计用例&#39;&#39;&#39;52         username = &quot;&quot;,  # 错误账号53         psw = &quot;111111&quot;,  # 正确密码54         result = self.login(username, psw)55         self.assertEqual(result, 404)56 57 if __name__ == &quot;__main__&quot;:58  unittest.main()</code></pre><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>1、fiddler抓取本地部署的jenkins登录请求时，抓取不到，但是百度可以抓取到，解决方法：</p><p>（1）使用<a href="http://localhost.fiddler" target="_blank" rel="noopener">http://localhost.fiddler</a> 代替<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></p><p>（2）使用用 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a>. 在locahost后面加一个点号</p><p>（3）使用 <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>.  在127.0.0.1后面加一个点号</p><p>（4）使用 <a href="http://machinename" target="_blank" rel="noopener">http://machinename</a>  使用机器名</p><p>（5）打开Fiddler，菜单&gt;Fiddler Options&gt;General&gt;Enable IPv6(if avaible)去掉该选项。</p><p>（6）在hosts文件中加入127.0.0.1  localsite这样也可以被捕获到。</p><p>2、一些免费开源的接口，可以提供给大家进行练习</p><p>随机推荐热门段子（包含文字、图片、GIF、视频）：</p><p><a href="https://www.apiopen.top/satinApi?type=1&amp;page=1" target="_blank" rel="noopener">https://www.apiopen.top/satinApi?type=1&amp;page=1</a></p><p>随机推荐热门段子【神评版本】（包含文字、图片、GIF、视频）： </p><p><a href="https://www.apiopen.top/satinGodApi?type=1&amp;page=1" target="_blank" rel="noopener">https://www.apiopen.top/satinGodApi?type=1&amp;page=1</a></p><p>随机推荐热门段子【神评版本】评论列表： </p><p><a href="https://www.apiopen.top/satinCommentApi?id=27610708&amp;page=1" target="_blank" rel="noopener">https://www.apiopen.top/satinCommentApi?id=27610708&amp;page=1</a></p><p>热门小说推荐列表 </p><p><a href="https://www.apiopen.top/novelApi" target="_blank" rel="noopener">https://www.apiopen.top/novelApi</a></p><p>小说搜索接口 </p><p><a href="https://www.apiopen.top/novelSearchApi?name=盗墓笔记" target="_blank" rel="noopener">https://www.apiopen.top/novelSearchApi?name=盗墓笔记</a></p><p>小说详情接口 </p><p><a href="https://www.apiopen.top/novelInfoApi?name=盗墓笔记" target="_blank" rel="noopener">https://www.apiopen.top/novelInfoApi?name=盗墓笔记</a></p><p>天气获取接口 </p><p><a href="https://www.apiopen.top/weatherApi?city=成都" target="_blank" rel="noopener">https://www.apiopen.top/weatherApi?city=成都</a></p><p>美图获取接口 </p><p><a href="https://www.apiopen.top/meituApi?page=1" target="_blank" rel="noopener">https://www.apiopen.top/meituApi?page=1</a></p><p>个性网名获取接口 </p><p><a href="https://www.apiopen.top/femaleNameApi?page=1" target="_blank" rel="noopener">https://www.apiopen.top/femaleNameApi?page=1</a></p><p>创建应用接口 </p><p><a href="https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&amp;passwd=123456" target="_blank" rel="noopener">https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&amp;passwd=123456</a></p><p>增加统计信息接口 </p><p><a href="https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&amp;type=点击统计&amp;typeId=1&amp;count=2" target="_blank" rel="noopener">https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&amp;type=点击统计&amp;typeId=1&amp;count=2</a></p><p>查询统计信息接口 </p><p><a href="https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5" target="_blank" rel="noopener">https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5</a></p><p>用户注册接口</p><p><a href="https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123654" target="_blank" rel="noopener">https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123654</a></p><p>用户登陆接口 </p><p><a href="https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123456" target="_blank" rel="noopener">https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123456</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化24</title>
      <link href="/2016/03/08/interface/"/>
      <url>/2016/03/08/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十四）–unittest断言——中（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇通过简单的案例给小伙伴们介绍了一下unittest断言，这篇我们将通过结合和围绕实际的工作来进行unittest的断言。这里以获取城市天气预报的接口为例，设计了 2 个用例，一个是查询北京的天气，一个是查询南京为例，你也可以查询别的城市的天气预报。</p><h4 id="2-接口文档"><a href="#2-接口文档" class="headerlink" title="2.接口文档"></a>2.接口文档</h4><p>1、在实际工作中，开发人员都会给你接口文档方便QA测试，和其他系统的开发人员对接。接口文档如下：</p><h5 id="2-1天气预报"><a href="#2-1天气预报" class="headerlink" title="2.1天气预报"></a>2.1天气预报</h5><h6 id="获取实时天气"><a href="#获取实时天气" class="headerlink" title="获取实时天气"></a>获取实时天气</h6><p>请求方式：POST</p><p>请求地址：<a href="https://www.apiopen.top/weatherApi" target="_blank" rel="noopener">https://www.apiopen.top/weatherApi</a></p><table><thead><tr><th align="center">Query参数名</th><th align="center">类型</th><th align="center">必需</th><th align="center">描述</th><th align="center">示例e.g.</th></tr></thead><tbody><tr><td align="center">city</td><td align="center">string</td><td align="center">是</td><td align="center">城市名称</td><td align="center">成都</td></tr></tbody></table><p>返回示例：</p><pre><code>                                {    &quot;code&quot;: 200,    &quot;msg&quot;: &quot;成功!&quot;,    &quot;data&quot;: {        &quot;yesterday&quot;: {            &quot;date&quot;: &quot;14日星期五&quot;,            &quot;high&quot;: &quot;高温 7℃&quot;,            &quot;fx&quot;: &quot;无持续风向&quot;,            &quot;low&quot;: &quot;低温 4℃&quot;,            &quot;fl&quot;: &quot;&quot;,            &quot;type&quot;: &quot;阴&quot;        },        &quot;city&quot;: &quot;成都&quot;,        &quot;aqi&quot;: &quot;89&quot;,        &quot;forecast&quot;: [            {                &quot;date&quot;: &quot;15日星期六&quot;,                &quot;high&quot;: &quot;高温 10℃&quot;,                &quot;fengli&quot;: &quot;&quot;,                &quot;low&quot;: &quot;低温 2℃&quot;,                &quot;fengxiang&quot;: &quot;无持续风向&quot;,                &quot;type&quot;: &quot;多云&quot;            },            {                &quot;date&quot;: &quot;16日星期天&quot;,                &quot;high&quot;: &quot;高温 15℃&quot;,                &quot;fengli&quot;: &quot;&quot;,                &quot;low&quot;: &quot;低温 3℃&quot;,                &quot;fengxiang&quot;: &quot;无持续风向&quot;,                &quot;type&quot;: &quot;晴&quot;            },            {                &quot;date&quot;: &quot;17日星期一&quot;,                &quot;high&quot;: &quot;高温 14℃&quot;,                &quot;fengli&quot;: &quot;&quot;,                &quot;low&quot;: &quot;低温 5℃&quot;,                &quot;fengxiang&quot;: &quot;无持续风向&quot;,                &quot;type&quot;: &quot;晴&quot;            },            {                &quot;date&quot;: &quot;18日星期二&quot;,                &quot;high&quot;: &quot;高温 11℃&quot;,                &quot;fengli&quot;: &quot;&quot;,                &quot;low&quot;: &quot;低温 6℃&quot;,                &quot;fengxiang&quot;: &quot;无持续风向&quot;,                &quot;type&quot;: &quot;多云&quot;            },            {                &quot;date&quot;: &quot;19日星期三&quot;,                &quot;high&quot;: &quot;高温 12℃&quot;,                &quot;fengli&quot;: &quot;&quot;,                &quot;low&quot;: &quot;低温 6℃&quot;,                &quot;fengxiang&quot;: &quot;无持续风向&quot;,                &quot;type&quot;: &quot;多云&quot;            }        ],        &quot;ganmao&quot;: &quot;昼夜温差较大，较易发生感冒，请适当增减衣服。体质较弱的朋友请注意防护。&quot;,        &quot;wendu&quot;: &quot;9&quot;    }}</code></pre><p>2、如果没有你可以自己通过fiddler抓包获取参数和接口URL，以及请求方式 。</p><h4 id="3-设计测试用例"><a href="#3-设计测试用例" class="headerlink" title="3.设计测试用例"></a>3.设计测试用例</h4><p>1、针对以上接口，设计两个城市接口测试用例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/2zd6mPKLyvFsxik.png" alt="1232840-20190426100241426-2110286960.png"></p><p>2、运行接口用例结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/UIrOiJ2lw4pSbWB.png" alt="1232840-20190426100444189-1299940646.png"></p><p>3、参考代码</p><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2016-3-08 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写断言-中篇 9 &#39;&#39;&#39;10 #3.导入requests和unittest模块11 import requests12 import unittest13 #4.编写测试用例和断言14 class TestWeather(unittest.TestCase):15     &#39;&#39;&#39;测试天气预报接口&#39;&#39;&#39;       # 此注释将展示到测试报告的测试组类16     def test_beijin_weather(self):17         &#39;&#39;&#39;查询北京天气预报&#39;&#39;&#39;         # 此注释将展示到测试报告的用例标题18         url = &quot;https://www.apiopen.top/weatherApi&quot;19 20         par = {21                 &quot;city&quot;: &quot;北京&quot;,  # 城市名22         }23         r = requests.post(url, params=par)24         print(r.text)     # 获取返回的结果25         result = r.json()[&#39;code&#39;] #获取状态码26         print(result)27         # 断言28         self.assertEqual(200, result)29         self.assertIn(&#39;msg&#39;, r.text)30         self.assertTrue(&#39;北京&#39;in r.text)31     def test_nanjin_weather(self):32         &#39;&#39;&#39;查询南京天气预报&#39;&#39;&#39;  # 此注释将展示到测试报告的用例标题33         url = &quot;https://www.apiopen.top/weatherApi&quot;34         par = {35             &quot;city&quot;: &quot;南京&quot;,  # 城市名36         }37         r = requests.post(url, params=par)38         print(r.text)  # 获取返回的结果39         result = r.json()[&#39;code&#39;]#获取状态码40         print(result)41         # 断言42         self.assertEqual(200, result)43         self.assertIn(&#39;msg&#39;, r.text)44         self.assertTrue(&#39;南京&#39; in r.text)45 46 if __name__ == &quot;__main__&quot;:47     unittest.main()</code></pre><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>1、实际中的接口和这个也差不多，你可以增加没有这个城市的等等测试用例，可根据实际需要增加多个测试用例全面的断言。</p><p>2、实际开发或者测试工作中经常用到json数据，那么就会有这样一个需求：在谷歌浏览器中访问URL地址返回的json数据能否按照json格式展现出来。</p><p>比如，在谷歌浏览器中访问：<a href="http://jsonview.com/example.json" target="_blank" rel="noopener">http://jsonview.com/example.json</a></p><p>展现效果如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/v71sCSJDeMbnQKF.png" alt="20180115124435579.png"></p><p>那么安装了JsonView扩展程序后的展现效果如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/pgYCZVfa7KA6dsG.png" alt="20180115124442216.png"></p><p>很明显，后者的效果更好。实现步骤如下：</p><p>1、下载JsonView扩展程序压缩包<br>下载地址：<a href="https://github.com/gildas-lormeau/JSONView-for-Chrome" target="_blank" rel="noopener">https://github.com/gildas-lormeau/JSONView-for-Chrome</a></p><p>点击【Clone or download】——【Download Zip】</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/OrcvXwWxe3VLN8I.png" alt="1232840-20190508110604368-1016556683.png"></p><p>2、解压这个压缩包</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/bz1gYmVG4TuaeKW.png" alt="20180115124456285.png"></p><p>3、打开谷歌浏览器的扩展程序界面<br>方式一：在谷歌浏览器地址栏中输入：chrome://extensions/</p><p>方式二：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/3jfPDwqRelzBYCM.png" alt="1232840-20190508110713626-482863159.png"></p><p>4、加载JsonView扩展程序</p><p>选中开发者模式，点击【加载正在开发的扩展程序…】，选择插件目录（D:\JSONView-for-Chrome-master\WebContent）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/3elCW4XMri1uxOh.png" alt="1232840-20190508110815998-373787722.png"></p><p>点击确定后，就安装上了。安装后界面如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/M75YJnPUxiXHuov.png" alt="1232840-20190508110948482-125861095.png"></p><p>安装完成，重新加载 (Ctrl+R)。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化23</title>
      <link href="/2016/03/07/interface/"/>
      <url>/2016/03/07/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十三）–unittest断言——上（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　在测试用例中，执行完测试用例后，最后一步是判断测试结果是 pass 还是 fail，自动化测试脚本里面一般把这种生成测试结果的方法称为断言（assert）。用 unittest 组件测试用例的时候，断言的方法还是很多的，下面介绍几种常用的断言方法：assertEqual、assertIn、assertTrue。想了解更多可以点击 传送门 看一下最后的小结有大致介绍。</p><p>　　unittest断言计划是分上、中、下三篇有简单到复杂的给小伙伴们介绍一下，填补一下这部分的空白。</p><h4 id="2-基本断言方法"><a href="#2-基本断言方法" class="headerlink" title="2.基本断言方法"></a>2.基本断言方法</h4><p>基本的断言方法提供了测试结果是True还是False。所有的断言方法都有一个msg参数，如果指定msg参数的值，则将该信息作为失败的错误信息返回。</p><table><thead><tr><th align="center">序号</th><th align="center">断言方法</th><th align="center">断言描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">assertEqual(arg1, arg2, msg=None)</td><td align="center">验证arg1=arg2，不等则fail</td></tr><tr><td align="center">2</td><td align="center">assertNotEqual(arg1, arg2, msg=None)</td><td align="center">验证arg1 != arg2, 相等则fail</td></tr><tr><td align="center">3</td><td align="center">assertTrue(expr, msg=None)</td><td align="center">验证expr是true，如果为false，则fail</td></tr><tr><td align="center">4</td><td align="center">assertFalse(expr,msg=None)</td><td align="center">验证expr是false，如果为true，则fail</td></tr><tr><td align="center">5</td><td align="center">assertIs(arg1, arg2, msg=None)</td><td align="center">验证arg1、arg2是同一个对象，不是则fail</td></tr><tr><td align="center">6</td><td align="center">assertIsNot(arg1, arg2, msg=None)</td><td align="center">验证arg1、arg2不是同一个对象，是则fail</td></tr><tr><td align="center">7</td><td align="center">assertIsNone(expr, msg=None)</td><td align="center">验证expr是None，不是则fail</td></tr><tr><td align="center">8</td><td align="center">assertIsNotNone(expr, msg=None)</td><td align="center">验证expr不是None，是则fail</td></tr><tr><td align="center">9</td><td align="center">assertIn(arg1, arg2, msg=None)</td><td align="center">验证arg1是arg2的子串，不是则fail</td></tr><tr><td align="center">10</td><td align="center">assertNotIn(arg1, arg2, msg=None)</td><td align="center">验证arg1不是arg2的子串，是则fail</td></tr><tr><td align="center">11</td><td align="center">assertIsInstance(obj, cls, msg=None)</td><td align="center">验证obj是cls的实例，不是则fail</td></tr><tr><td align="center">12</td><td align="center">assertNotIsInstance(obj, cls, msg=None)</td><td align="center">验证obj不是cls的实例，是则fail</td></tr></tbody></table><p>1、实例，写了四个测试用例，其中第四个是失败的</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/Ir6iYe9jPnZxv4B.png" alt="1232840-20190425094035734-758759196.png"></p><p>2、运行结果（python3）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/WGRk9s3uTCEFgzH.png" alt="1232840-20190425094004331-501418205.png"> </p><p>python2</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/41cYfGvleuUtdZD.png" alt="1232840-20190425152302748-26245934.png"></p><p>3、在python2中执行的结果，中文编码不对，没正常显示中文，遇到这种情况，可以自定义异常输出，python3正常。有时候也可以根据实际需要采用自定义异常输出，要灵活掌握。</p><h4 id="4-参考代码"><a href="#4-参考代码" class="headerlink" title="4.参考代码"></a>4.参考代码</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on  2016-03-07 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写断言 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 #4.编写测试用例和断言13 14 class Test(unittest.TestCase):15     def test01(self):16         &#39;&#39;&#39;判断 a == b &#39;&#39;&#39;17         a = 118         b = 119         self.assertEqual(a, b)20     def test02(self):21         &#39;&#39;&#39;判断 a in b &#39;&#39;&#39;22         a = &quot;hello hongge&quot;23         b = &quot;hello hongge and world!&quot;24         self.assertIn(a, b)25 26     def test03(self):27         &#39;&#39;&#39;判断 a is True &#39;&#39;&#39;28         a = True29         self.assertTrue(a)30 31     def test04(self):32         &#39;&#39;&#39;失败案例&#39;&#39;&#39;33         a = &quot;北京-宏哥&quot;34         b = &quot;hongge&quot;35         self.assertEqual(a, b)36 37 if __name__ == &quot;__main__&quot;:38     unittest.main()</code></pre><h4 id="5-自定义异常输出"><a href="#5-自定义异常输出" class="headerlink" title="5.自定义异常输出"></a>5.自定义异常输出</h4><p>1、以 assertEqual 为例分析，在pycharm中通过ctrl（command）+🖱️左键我们可以定位到方法的位置：</p><p>python3</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/q9s8xKcWBgYQ4wz.png" alt="1232840-20190425135159452-1599240793.png"></p><p>python2</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/Am5F8slkLDOQCyJ.png" alt="1232840-20190425152349327-676285006.png"></p><p>2、python2翻译：如果两个对象不能相等，就返回失败，相当于 return: first==second</p><p>   python3如果你断言的 语句正确 则什么反应都没有，但是如果你出错之后 就会报出    AssertionError 并且错误可以自己填写。</p><p>3、这里除了相比较的两个参数 first 和 second，还有第三个参数 msg=None,这个 msg 参数就是遇到异常后自定义输出信息</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/8Wkyz3l9aJYMmou.png" alt="1232840-20190425152903796-1149254712.png"></p><p>4、参考代码</p><pre><code># coding=utf-8#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on  2016-03-07@author: 北京-宏哥Project:学习和使用unittest框架编写断言&#39;&#39;&#39;#3.导入unittest模块import unittest#4.编写测试用例和断言class Test(unittest.TestCase):    def test01(self):        &#39;&#39;&#39;判断 a == b &#39;&#39;&#39;        a = 1        b = 1        self.assertEqual(a, b)    def test02(self):        &#39;&#39;&#39;判断 a in b &#39;&#39;&#39;        a = &quot;hello hongge&quot;        b = &quot;hello hongge and world!&quot;        self.assertIn(a, b)    def test03(self):        &#39;&#39;&#39;判断 a is True &#39;&#39;&#39;        a = True        self.assertTrue(a)    def test04(self):        &#39;&#39;&#39;失败案例&#39;&#39;&#39;        a = &quot;北京-宏哥&quot;        b = &quot;hongge&quot;        self.assertEqual(a, b,msg=&#39;失败原因: %s!=%s&#39;%(a,b))if __name__ == &quot;__main__&quot;:    unittest.main()</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>　　unittest断言开篇就介绍这里，另外大家也不要纠结python2或者python3，建议小伙伴们使用python3，因为python2到2020年官方就好像不会维护了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化22</title>
      <link href="/2016/03/06/interface/"/>
      <url>/2016/03/06/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十二）–unittest执行顺序隐藏的坑（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　大多数的初学者在使用 unittest 框架时候，不清楚用例的执行顺序到底是怎样的。对测试类里面的类和方法分不清楚，不知道什么时候执行，什么时候不执行。虽然或许通过代码实现了，也是稀里糊涂的一知半解，这样还好，好歹自己鼓捣出了，但是时间和效率并不是很高，下次遇到还是老样子。那么本篇通过最简单案例来给给为小伙伴详细讲解、演示一下 unittest 执行顺序。</p><h4 id="2-实例代码"><a href="#2-实例代码" class="headerlink" title="2.实例代码"></a>2.实例代码</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/nQ2e6I8WYtwxZVf.png" alt="1232840-20190424083353030-1129366547.png"></p><h4 id="3-参考代码"><a href="#3-参考代码" class="headerlink" title="3.参考代码"></a>3.参考代码</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-23 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写测试用例执行顺序 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 #4.执行顺序和运行测试13 import unittest14 15 class TestLogin(unittest.TestCase):16 17     def test_login_blog(self):18         &quot;&quot;&quot;登录博客园19 20         :return:21         &quot;&quot;&quot;22 23     def test_add_essay(self):24         &quot;&quot;&quot; 添加随笔25 26         :return:27         &quot;&quot;&quot;28 29     def test_release_essay(self):30         &quot;&quot;&quot; 发布随笔31 32         :return:33         &quot;&quot;&quot;34 35     def test_quit_blog(self):36         &quot;&quot;&quot;退出博客园37 38         :return:39         &quot;&quot;&quot;40 if __name__ == &quot;__main__()&quot;:41     unittest.main()</code></pre><p>这是一个标准的使用unittest进行测试的例子，写完后心里美滋滋，嗯，就按照一贯思路代码会按照这个顺序测就可以了。结果一运行。就傻眼了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/vlZc9x36gPXiubD.png" alt="1232840-20190424083919359-1934783132.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/SxBCjaDdK92NmrL.png" alt="1232840-20190424144647874-1636973817.png"></p><p>　　这时候自己心里犯嘀咕，这是什么鬼，怎么回事呢。执行的顺序乱了。第一个执行的测试用例并不是登录博客园，而是添加随笔，此时用户还没登录博客园，进行添加随笔的话会直接报错，导致用例失败。</p><p>到这里有些小伙伴可能会说，为什么要让测试用例之间有所依赖呢？</p><p>　　的确，如果完全没依赖，测试用例的执行顺序是不需要关注的。但是这样对于用例的设计和实现，要求就高了许多。而对博客园来说，一个系统内的操作，是有很大的关联性的。以添加随笔为例，随笔内的每个操作都有一个前提，你需要</p><p>登录博客园才能添加随笔。所以要实现用例之间的完全解耦，需要每个用例开始之前，检测用户的登录状态。</p><p>　　如果可以控制测试用例的执行顺序，按照功能流程一遍走下来，节省的代码量是非常可观的，阅读测试用例也会清晰明了许多。</p><h4 id="4-如何控制unittest用例执行的顺序呢？"><a href="#4-如何控制unittest用例执行的顺序呢？" class="headerlink" title="4.如何控制unittest用例执行的顺序呢？"></a>4.如何控制unittest用例执行的顺序呢？</h4><p>1、带大家先看看源码，unittest是怎么样对用例进行排序的。在loader.py的loadTestsFromTestCase方法里边，调用了getTestCaseNames方法来获取测试用例的名称</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/KHvBzT2aSMJIi35.png" alt="1232840-20190424111758350-210516870.png"></p><p>2、从源码可以清楚地看到，getTestCaseNames方法对测试用例的名称进行了排序</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/hk4vJyepEsrbmHD.png" alt="1232840-20190424111938233-1864966866.png"></p><p>3、一步一步跟进去，查看其排序方法</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/C9MOT3sjk1fvaIA.png" alt="1232840-20190424112402962-614080194.png"></p><p>4、根据排序规则，unittest执行测试用例，默认是根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。</p><p>5、做个小demo，看看是不是我们所说的那种排序规则</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/yITO3wHq1AStDL9.png" alt="1232840-20190424112753576-29735455.png"></p><p>6、从上边的运行结果，我们可以看出是：unittest执行测试用例，默认是根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。</p><p>7、基于unittest的机制，如何控制用例执行顺序呢？查了一些网上的资料，主要介绍了两种方式：</p><h5 id="方式1，通过TestSuite类的addTest方法，按顺序加载测试用例"><a href="#方式1，通过TestSuite类的addTest方法，按顺序加载测试用例" class="headerlink" title="方式1，通过TestSuite类的addTest方法，按顺序加载测试用例"></a>方式1，通过TestSuite类的addTest方法，按顺序加载测试用例</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/aNxZO17Hw8LoABT.png" alt="1232840-20190424144432296-1513536059.png"></p><h6 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-23 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写测试用例执行顺序 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 #4.执行顺序和运行测试13 import unittest14 15 class TestLogin(unittest.TestCase):16 17     def setUp(self):18         pass19     def test_login_blog(self):20         &quot;&quot;&quot;登录博客园21 22         :return:23         &quot;&quot;&quot;24         print(&quot;登录博客园&quot;)25     def test_add_essay(self):26         &quot;&quot;&quot; 添加随笔27 28         :return:29         &quot;&quot;&quot;30         print(&quot;添加随笔&quot;)31     def test_release_essay(self):32         &quot;&quot;&quot; 发布随笔33 34         :return:35         &quot;&quot;&quot;36         print(&quot;发布随笔&quot;)37     def test_quit_blog(self):38         &quot;&quot;&quot;退出博客园39 40         :return:41         &quot;&quot;&quot;42         print(&quot;退出博客园&quot;)43 44     def tearDown(self):45         pass46 if __name__ == &#39;__main__&#39;:47     # 启动单元测试48     # unittest.main()49 50     # 获取TestSuite的实例对象51     suite = unittest.TestSuite()52 53     # 将测试用例添加到测试容器中54     suite.addTest(TestLogin(&#39;test_login_blog&#39;))55     suite.addTest(TestLogin(&#39;test_add_essay&#39;))56     suite.addTest(TestLogin(&#39;test_release_essay&#39;))57     suite.addTest(TestLogin(&#39;test_quit_blog&#39;))58 59     # 创建TextTestRunner类的实例对象60     runner = unittest.TextTestRunner()61     runner.run(suite)62     #unittest.TextTestRunner(verbosity=3).run(suite)</code></pre><h5 id="方式2，通过修改函数名的方式"><a href="#方式2，通过修改函数名的方式" class="headerlink" title="方式2，通过修改函数名的方式"></a>方式2，通过修改函数名的方式</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/dTaSAnK9somkIH8.png" alt="1232840-20190424145005526-1651743407.png"></p><h6 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-23 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写测试用例执行顺序 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 #4.执行顺序和运行测试13 import unittest14 15 class TestLogin(unittest.TestCase):16 17     def setUp(self):18         pass19     def test_1_login_blog(self):20         &quot;&quot;&quot;登录博客园21 22         :return:23         &quot;&quot;&quot;24         print(&quot;登录博客园&quot;)25     def test_2_add_essay(self):26         &quot;&quot;&quot; 添加随笔27 28         :return:29         &quot;&quot;&quot;30         print(&quot;添加随笔&quot;)31     def test_3_release_essay(self):32         &quot;&quot;&quot; 发布随笔33 34         :return:35         &quot;&quot;&quot;36         print(&quot;发布随笔&quot;)37     def test_4_quit_blog(self):38         &quot;&quot;&quot;退出博客园39 40         :return:41         &quot;&quot;&quot;42         print(&quot;退出博客园&quot;)43 44     def tearDown(self):45         pass46 if __name__ == &#39;__main__&#39;:47     # 启动单元测试48     unittest.main()</code></pre><h4 id="5-拓展练习"><a href="#5-拓展练习" class="headerlink" title="5.拓展练习"></a>5.拓展练习</h4><h5 id="1、实例"><a href="#1、实例" class="headerlink" title="1、实例"></a>1、实例</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/VWtgMSv2BlCLFXU.png" alt="1232840-20190423130704591-2042375124.png"></p><h5 id="2、运行结果"><a href="#2、运行结果" class="headerlink" title="2、运行结果"></a>2、运行结果</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/9p2kwLWr6UfvROE.png" alt="1232840-20190423131122823-559985546.png"></p><h5 id="3、运行结果分析"><a href="#3、运行结果分析" class="headerlink" title="3、运行结果分析"></a>3、运行结果分析</h5><p>1、从运行结果可以看出执行顺序：</p><p>　　start!-执行测试用例 01-end!</p><p>　　start!-执行测试用例 02-end!</p><p>　　start!-执行测试用例 03-end!</p><p>2、从执行结果可以看出几点</p><p>　　–先执行的前置 setUp，然后执行的用例(test*)，最后执行的后置 tearDown</p><p>　　–测试用例（test*）的执行顺序是根据 01-02-03 执行的，也就是说根据用例名称来顺序执行的</p><p>　　–addtest（self）这个方法没执行,说明只执行 test 开头的用例</p><h5 id="4、参考代码"><a href="#4、参考代码" class="headerlink" title="4、参考代码"></a>4、参考代码</h5><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-23 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写测试用例思路 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 13 #4.执行顺序和运行测试14 import time15 class Test(unittest.TestCase):16     def setUp(self):17         print (&quot;start!&quot;)18     def tearDown(self):19         time.sleep(1)20         print (&quot;end!&quot;)21     def test01(self):22         print (&quot;执行测试用例 01&quot;)23     def test03(self):24         print (&quot;执行测试用例 03&quot;)25     def test02(self):26         print (&quot;执行测试用例 02&quot;)27     def addtest(self):28         print (&quot;add 方法&quot;)29 if __name__ == &quot;__main__&quot;:30     unittest.main()</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、这个执行顺序，看似简单，实则不简单，只有掌握最简单的才可以应付最复杂的。</p><p>2、setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化21</title>
      <link href="/2016/03/05/interface/"/>
      <url>/2016/03/05/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十一）–unittest简介（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　前边的随笔主要介绍的requests模块的有关知识个内容，接下来看一下python的单元测试框架unittest。熟悉 或者了解java 的小伙伴应该都清楚常见的单元测试框架 Junit 和 TestNG，这个招聘的需求上也是经常见到的。python 里面也有单元测试框架-unittest,相当于是一个 python 版的 junit。python 里面的单元测试框架除了 unittest,还有一个 pytest 框架，这个实际上用的比较少，后面有空再继续介绍和分享。unittest单元测试框架不仅可以适用于单元测试，还可以适用WEB自动化测试用例的开发与执行，该测试框架可组织执行测试用例，并且提供了丰富的断言方法，判断测试用例是否通过，最终生成测试结果。</p><h4 id="2-学习和了解unittest"><a href="#2-学习和了解unittest" class="headerlink" title="2.学习和了解unittest"></a>2.学习和了解unittest</h4><p>1、查看其中文官网：<a href="https://docs.python.org/zh-cn/3/library/unittest.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/unittest.html</a> 英文官网：<a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">https://docs.python.org/3/library/unittest.html</a></p><p>2、先导入 unittest用 help 函数查看源码解析查看描述：</p><p>Python unit testing framework, based on Erich Gamma’s JUnit and Kent Beck’s Smalltalk testing framework.</p><p>翻译：python 的单元测试框架，是基于 java 的 junit 测试框架</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/HhB8J2ZlYRefrqx.png" alt="1232840-20190423104643235-1412685778.png"></p><h4 id="3-简单的用法"><a href="#3-简单的用法" class="headerlink" title="3.简单的用法"></a>3.简单的用法</h4><p>1、从官网源码或者print的help里查找unittest用法</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/GQZhNYKgSuHxVyj.png" alt="1232840-20190423104835891-1472604445.png"></p><p>2、我们将上图的这段代码 copy 出来，单独运行，看看测试和运行结果，抱着怀疑的心态自己体验一下，因为所有人都不可能是不犯错的，官网和源码也不例外。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/h1rs4JMxnReKWqQ.png" alt="1232840-20190423110458205-1861147940.png"></p><h4 id="4-代码分析和说明："><a href="#4-代码分析和说明：" class="headerlink" title="4.代码分析和说明："></a>4.代码分析和说明：</h4><p>1、第一行是导入 unittest 这个模块</p><p>2、class 这一行是定义一个测试的类，并继承 unittest.TestCase 这个类</p><p>定义测试类，父类为unittest.TestCase。 #可继承unittest.TestCase的方法，如setUp和tearDown方法，不过此方法可以在子类重写，覆盖父类方法。 #可继承unittest.TestCase的各种断言方法。</p><p>3、接下来是定义了两个测试 case 名称:testAdd 和 testMultiply4、注释里面有句话很重要：<strong>## test method names begin ‘test*’–翻译：测试用例的名称要以 test 开头</strong></p><p>4、然后是断言 assert，这里的断言方法是 assertEqual-判断两个是否相等，这个断言可以是一个也可以是多个</p><p>5、if 下面的这个 unittest.main()是运行主函数，运行后会看到测试结果（跑了两个用例耗时 0.000 秒,两个用例都通过）</p><h4 id="5-模仿和实践"><a href="#5-模仿和实践" class="headerlink" title="5.模仿和实践"></a>5.模仿和实践</h4><p>1、既然都了解的差不多了，还等什么呢，开始模仿和敲起了来吧。</p><p>2、上面的两个案例是加法和乘法，我们可以写个 case 试下减法和除法。</p><p>3、有很多小伙伴不知道断言怎么写，断言其实就是拿实际结果和期望结果去对比，对比的方法很多，这里只是举的最简单的一个判断相等的方法</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/hu9AEdTwRGeZM2N.png" alt="1232840-20190423112540709-2096718861.png"></p><h4 id="6-参考代码"><a href="#6-参考代码" class="headerlink" title="6.参考代码"></a>6.参考代码</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-23 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写测试用例思路 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 13 #4.copy 和运行测试14 class IntegerArithmeticTestCase(unittest.TestCase):15     def testSubtract(self):  # test method names begin with &#39;test&#39;16         result = 6-5   #实际结果17         hope = 1       #期望结果18         self.assertEqual(result, hope)19 20     def testDivide(self):21         result = 7 / 2  # 实际结果22         hope = 3.5  # 期望结果23         self.assertEqual(result, hope)24 25 if __name__ == &#39;__main__&#39;:26     unittest.main()</code></pre><h4 id="7-前置条件和后置条件"><a href="#7-前置条件和后置条件" class="headerlink" title="7.前置条件和后置条件"></a>7.前置条件和后置条件</h4><p>1、setUp：在写测试用例的时候，每次操作其实都是基于打开浏览器输入对应网址这些操作，这个就是执行用例的前置条件。</p><p>2、tearDown：执行完用例后，为了不影响下一次用例的执行，一般有个数据还原的过程，这就是执行用例的后置条件。</p><p>3、很多小伙伴执行完用例，都不去做数据还原，以致于下一个用例执行失败，这就是典型的自己给自己挖坑埋自己，自己坑自己，习惯不好。</p><p>4、前置和后置都是非必要的条件，如果没有也可以写 pass</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/hUrGC6NTvcBxSFY.png" alt="1232840-20190423114608018-1476226533.png"></p><h4 id="8-参考代码"><a href="#8-参考代码" class="headerlink" title="8.参考代码"></a>8.参考代码</h4><pre><code> 1 # coding=utf-8 2 #1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 3  4 #2.注释：包括记录创建时间，创建人，项目名称。 5 &#39;&#39;&#39; 6 Created on 2019-4-23 7 @author: 北京-宏哥 8 Project:学习和使用unittest框架编写测试用例思路 9 &#39;&#39;&#39;10 #3.导入unittest模块11 import unittest12 13 #4.前置、后置 和运行测试14 class Test(unittest.TestCase):15 16     def setUp(self):17         pass                  #如果没有可以不写或者pass代替18 19     def tearDown(self):20         pass21 22     def testSubtract(self):  # test method names begin with &#39;test&#39;23         result = 6-5   #实际结果24         hope = 1       #期望结果25         self.assertEqual(result, hope)26 27     def testDivide(self):28         result = 7 / 2  # 实际结果29         hope = 3.5  # 期望结果30         self.assertEqual(result, hope)31 32 if __name__ == &#39;__main__&#39;:33     unittest.main()</code></pre><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><h5 id="一、unittest模块的各个属性说明"><a href="#一、unittest模块的各个属性说明" class="headerlink" title="一、unittest模块的各个属性说明"></a>一、unittest模块的各个属性说明</h5><pre><code>先来聊一聊unittest模块的各个属性，所谓知己知彼方能百战百胜，了解unittest的各个属性，对于后续编写用例有很大的帮助。</code></pre><h6 id="1-unittest的属性如下："><a href="#1-unittest的属性如下：" class="headerlink" title="1.unittest的属性如下："></a>1.unittest的属性如下：</h6><pre><code>[&#39;BaseTestSuite&#39;, &#39;FunctionTestCase&#39;, &#39;SkipTest&#39;, &#39;TestCase&#39;, &#39;TestLoader&#39;, &#39;TestProgram&#39;, &#39;TestResult&#39;, &#39;TestSuite&#39;, &#39;TextTestResult&#39;, &#39;TextTestRunner&#39;, &#39;_TextTestResult&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__unittest&#39;, &#39;case&#39;, &#39;defaultTestLoader&#39;, &#39;expectedFailure&#39;, &#39;findTestCases&#39;, &#39;getTestCaseNames&#39;, &#39;installHandler&#39;, &#39;loader&#39;, &#39;main&#39;, &#39;makeSuite&#39;, &#39;registerResult&#39;, &#39;removeHandler&#39;, &#39;removeResult&#39;, &#39;result&#39;, &#39;runner&#39;, &#39;signals&#39;, &#39;skip&#39;, &#39;skipIf&#39;, &#39;skipUnless&#39;, &#39;suite&#39;, &#39;util&#39;]</code></pre><p>说明：</p><pre><code>unittest.TestCase：TestCase类，所有测试用例类继承的基本类。class BaiduTest(unittest.TestCase):unittest.main():使用她可以方便的将一个单元测试模块变为可直接运行的测试脚本，main()方法使用TestLoader类来搜索所有包含在该模块中以“test”命名开头的测试方法，并自动执行他们。执行方法的默认顺序是：根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。所以以A开头的测试用例方法会优先执行，以a开头会后执行。unittest.TestSuite()：unittest框架的TestSuite()类是用来创建测试套件的。unittest.TextTextRunner():unittest框架的TextTextRunner()类，通过该类下面的run()方法来运行suite所组装的测试用例，入参为suite测试套件。unittest.defaultTestLoader(): defaultTestLoader()类，通过该类下面的discover()方法可自动更具测试目录start_dir匹配查找测试用例文件（test*.py），并将查找到的测试用例组装到测试套件，因此可以直接通过run()方法执行discover。用法如下：discover=unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;)unittest.skip():装饰器，当运行用例时，有些用例可能不想执行等，可用装饰器暂时屏蔽该条测试用例。一种常见的用法就是比如说想调试某一个测试用例，想先屏蔽其他用例就可以用装饰器屏蔽。@unittest.skip(reason): skip(reason)装饰器：无条件跳过装饰的测试，并说明跳过测试的原因。@unittest.skipIf(reason): skipIf(condition,reason)装饰器：条件为真时，跳过装饰的测试，并说明跳过测试的原因。@unittest.skipUnless(reason): skipUnless(condition,reason)装饰器：条件为假时，跳过装饰的测试，并说明跳过测试的原因。@unittest.expectedFailure(): expectedFailure()测试标记为失败。</code></pre><h6 id="2-TestCase类的属性如下："><a href="#2-TestCase类的属性如下：" class="headerlink" title="2.TestCase类的属性如下："></a>2.TestCase类的属性如下：</h6><pre><code>[&#39;__call__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_addSkip&#39;, &#39;_baseAssertEqual&#39;, &#39;_classSetupFailed&#39;, &#39;_deprecate&#39;, &#39;_diffThreshold&#39;, &#39;_formatMessage&#39;, &#39;_getAssertEqualityFunc&#39;, &#39;_truncateMessage&#39;, &#39;addCleanup&#39;, &#39;addTypeEqualityFunc&#39;, &#39;assertAlmostEqual&#39;, &#39;assertAlmostEquals&#39;, &#39;assertDictContainsSubset&#39;, &#39;assertDictEqual&#39;, &#39;assertEqual&#39;, &#39;assertEquals&#39;, &#39;assertFalse&#39;, &#39;assertGreater&#39;, &#39;assertGreaterEqual&#39;, &#39;assertIn&#39;, &#39;assertIs&#39;, &#39;assertIsInstance&#39;, &#39;assertIsNone&#39;, &#39;assertIsNot&#39;, &#39;assertIsNotNone&#39;, &#39;assertItemsEqual&#39;, &#39;assertLess&#39;, &#39;assertLessEqual&#39;, &#39;assertListEqual&#39;, &#39;assertMultiLineEqual&#39;, &#39;assertNotAlmostEqual&#39;, &#39;assertNotAlmostEquals&#39;, &#39;assertNotEqual&#39;, &#39;assertNotEquals&#39;, &#39;assertNotIn&#39;, &#39;assertNotIsInstance&#39;, &#39;assertNotRegexpMatches&#39;, &#39;assertRaises&#39;, &#39;assertRaisesRegexp&#39;, &#39;assertRegexpMatches&#39;, &#39;assertSequenceEqual&#39;, &#39;assertSetEqual&#39;, &#39;assertTrue&#39;, &#39;assertTupleEqual&#39;, &#39;assert_&#39;, &#39;countTestCases&#39;, &#39;debug&#39;, &#39;defaultTestResult&#39;, &#39;doCleanups&#39;, &#39;fail&#39;, &#39;failIf&#39;, &#39;failIfAlmostEqual&#39;, &#39;failIfEqual&#39;, &#39;failUnless&#39;, &#39;failUnlessAlmostEqual&#39;, &#39;failUnlessEqual&#39;, &#39;failUnlessRaises&#39;, &#39;failureException&#39;, &#39;id&#39;, &#39;longMessage&#39;, &#39;maxDiff&#39;, &#39;run&#39;, &#39;setUp&#39;, &#39;setUpClass&#39;, &#39;shortDescription&#39;, &#39;skipTest&#39;, &#39;tearDown&#39;, &#39;tearDownClass&#39;]</code></pre><p>说明：</p><pre><code>setUp():setUp()方法用于测试用例执行前的初始化工作。如测试用例中需要访问数据库，可以在setUp中建立数据库连接并进行初始化。如测试用例需要登录web，可以先实例化浏览器。tearDown():tearDown()方法用于测试用例执行之后的善后工作。如关闭数据库连接。关闭浏览器。assert*():一些断言方法：在执行测试用例的过程中，最终用例是否执行通过，是通过判断测试得到的实际结果和预期结果是否相等决定的。assertEqual(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a和b是否相等，相等则测试用例通过。assertNotEqual(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a和b是否相等，不相等则测试用例通过。assertTrue(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否True，是True则测试用例通过。assertFalse(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否False，是False则测试用例通过。assertIs(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a是否是b，是则测试用例通过。assertNotIs(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a是否是b，不是则测试用例通过。assertIsNone(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否None，是None则测试用例通过。assertIsNotNone(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否None，不是None则测试用例通过。assertIn(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是否在b中，在b中则测试用例通过。assertNotIn(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是否在b中，不在b中则测试用例通过。assertIsInstance(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是是b的一个实例，是则测试用例通过。assertNotIsInstance(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是是b的一个实例，不是则测试用例通过。</code></pre><h6 id="3-TestSuite类的属性如下：（组织用例时需要用到）"><a href="#3-TestSuite类的属性如下：（组织用例时需要用到）" class="headerlink" title="3.TestSuite类的属性如下：（组织用例时需要用到）"></a>3.TestSuite类的属性如下：（组织用例时需要用到）</h6><pre><code>[&#39;__call__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_addClassOrModuleLevelException&#39;, &#39;_get_previous_module&#39;, &#39;_handleClassSetUp&#39;, &#39;_handleModuleFixture&#39;, &#39;_handleModuleTearDown&#39;, &#39;_tearDownPreviousClass&#39;, &#39;_tests&#39;, &#39;addTest&#39;, &#39;addTests&#39;, &#39;countTestCases&#39;, &#39;debug&#39;, &#39;run&#39;]</code></pre><p>说明：</p><pre><code>addTest(): addTest()方法是将测试用例添加到测试套件中，如下方，是将test_baidu模块下的BaiduTest类下的test_baidu测试用例添加到测试套件。suite = unittest.TestSuite()suite.addTest(test_baidu.BaiduTest(&#39;test_baidu&#39;)) </code></pre><h6 id="4-TextTextRunner的属性如下：（组织用例时需要用到）"><a href="#4-TextTextRunner的属性如下：（组织用例时需要用到）" class="headerlink" title="4.TextTextRunner的属性如下：（组织用例时需要用到）"></a>4.TextTextRunner的属性如下：（组织用例时需要用到）</h6><pre><code>[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_makeResult&#39;, &#39;buffer&#39;, &#39;descriptions&#39;, &#39;failfast&#39;, &#39;resultclass&#39;, &#39;run&#39;, &#39;stream&#39;, &#39;verbosity&#39;]</code></pre><p>说明：</p><pre><code>run(): run()方法是运行测试套件的测试用例，入参为suite测试套件。runner = unittest.TextTestRunner()runner.run(suite)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化20</title>
      <link href="/2016/03/04/interface/"/>
      <url>/2016/03/04/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二十）–token登录（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　为了验证用户登录情况以及减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。有些登录不是用 cookie 来验证的，是用 token 参数来判断是否登录。token 传参有两种一种是放在请求头里，本质上是跟 cookie 是一样的，只是换个单词而已；另外一种是在 url 请求参数里，这种更直观。</p><h4 id="2-登录返回token"><a href="#2-登录返回token" class="headerlink" title="2.登录返回token"></a>2.登录返回token</h4><p>1、如下图的这个登录接口，就是没有 cookies的登录接口。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/UyP3iZGxn86vfSo.png" alt="1232840-20190422133002808-130457134.png"> </p><p>2、但是这个登录接口，登录成功后有返回token，如下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/A5Mw67WGvZg4LOF.png" alt="1232840-20190422133242480-1026765827.png"></p><h4 id="3-请求头带token"><a href="#3-请求头带token" class="headerlink" title="3.请求头带token"></a>3.请求头带token</h4><p>1、登录成功后继续操作其它页面，发现post请求的请求头，都会带有token参数</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/A5Mw67WGvZg4LOF.png" alt="1232840-20190422133242480-1026765827.png"> </p><p>2、这种请求其实比cookie更简单，直接把登录后的token放到头部即可</p><h4 id="4-token关联"><a href="#4-token关联" class="headerlink" title="4.token关联"></a>4.token关联</h4><p>1、用脚本实现登录，获取token参数，获取后传参到请求头就可以了</p><p>2、如果登录有验证码，前面的脚本登录步骤就省略了，自己手动登录后获取token</p><h4 id="5-参考代码"><a href="#5-参考代码" class="headerlink" title="5.参考代码"></a>5.参考代码</h4><pre><code> 1 # coding:utf-8 2 import requests 3 header = {   # 登录抓包获取的头部 4         &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot;, 5         &quot;Accept&quot;: &quot;*/*&quot;, 6         &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;, 7         &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 8         &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, 9         &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;,10         &quot;Content-Length&quot;: &quot;423&quot;,11         &quot;Connection&quot;: &quot;keep-alive&quot;12         }13 body = {&quot;key1&quot;: &quot;value1&quot;,14         &quot;key2&quot;: &quot;value2&quot;}  # 这里账号密码就是抓包的数据15 s = requests.session()16 login_url = &quot;http://xxx.login&quot;   #　自己找带token网址17 login_ret = s.post(login_url, headers=header, data=body)18 # 这里token在返回的json里，可以直接提取19 token = login_ret.json()[&quot;token&quot;]20 # 这是登录后发的一个post请求21 post_url = &quot;http://xxx&quot;22 # 添加token到请求头23 header[&quot;token&quot;] = token24 # 如果这个post请求的头部其它参数变了，也可以直接更新25 header[&quot;Content-Length&quot;]=&quot;9&quot;26 body1 = {27          &quot;key&quot;: &quot;value&quot;28          }29 post_ret = s.post(post_url, headers=header, data=body1)30 print post_ret.content</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><h5 id="Token的意义及用法"><a href="#Token的意义及用法" class="headerlink" title="Token的意义及用法"></a>Token的意义及用法</h5><h6 id="一-Token的来源："><a href="#一-Token的来源：" class="headerlink" title="一.Token的来源："></a>一.Token的来源：</h6><pre><code>   当客户端多次向服务端请求数据时，服务端就需要多次从数据库中查询用户名和密码并进行对比，判断用户名和密码是否正确，并作出相应提示。但这样无疑会增加服务器端的运行压力，是否可以有一种方式只需要验证用户就是之前的用</code></pre><p>户而不需要每次在客户端请求数据时都需要查询数据库判断用户名和密码是否正确。在这种请求下，引入了token来解决服务器端多次访问数据库问题。</p><p>1、什么是Token： </p><pre><code>   Token是服务端端生成的一串字符串，作为客户端进行请求时辨别客户身份的的一个令牌。当用户第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</code></pre><p>2、使用Token的目的： </p><p>Token的目的是为了验证用户登录情况以及减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><h6 id="二-Token的运用流程："><a href="#二-Token的运用流程：" class="headerlink" title="二. Token的运用流程："></a>二. Token的运用流程：</h6><p>1、当用户首次登录成功之后, 服务器端就会生成一个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端；</p><p>2、客户端拿到 token 值之后，进行保存 （保存位置由服务器端设置）；</p><p>3、以后客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器.；</p><p>4、服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值进行比较；</p><p>5、如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态；</p><p>6、如果没有这个 token 值, 没有登录成功；</p><p>7、如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录；</p><p>8、Django Rest framework中JWT的使用稍有差异，这里不做详细说明。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化19</title>
      <link href="/2016/03/03/interface/"/>
      <url>/2016/03/03/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十九）–Json 数据处理—实战（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇说了关于json数据处理，是为了断言方便，这篇就带各位小伙伴实战一下。首先捋一下思路，然后根据思路一步一步的去实现和实战，不要一开始就盲目的动手和无头苍蝇一样到处乱撞，撞得头破血流后而放弃了。不仅什么没学习到，自己的自信心都受到打击了，自己都怀疑自己。其实你是最棒的，天生我材必有用，好了废话不说，进入实战——以查看快递物流接口为例。</p><p>　　大致流程步骤：web页面操作—&gt;抓包看参数和url—&gt;代码模拟接口请求—&gt;取到接口返回结果—&gt;断言</p><h4 id="2-web页面操作"><a href="#2-web页面操作" class="headerlink" title="2.web页面操作"></a>2.web页面操作</h4><p>1、浏览器输入快递物流查询url，输入快递单号，点击“查询”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/KcFDyLb2IBYk1W6.png" alt="1232840-20190419141511965-1753386553.png"></p><h4 id="3-抓包看参数和url"><a href="#3-抓包看参数和url" class="headerlink" title="3.抓包看参数和url"></a>3.抓包看参数和url</h4><p>1、点击“查询”，fiddler抓包，查看url和参数</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/uLqWXlAKhRUkdz6.png" alt="1232840-20190419140316034-2114919797.png"></p><h4 id="4-代码模拟接口请求"><a href="#4-代码模拟接口请求" class="headerlink" title="4.代码模拟接口请求"></a>4.代码模拟接口请求</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/rF9BNHwod6bpyVz.png" alt="1232840-20190419141802721-1381488165.png"></p><h4 id="5-取到接口返回结果"><a href="#5-取到接口返回结果" class="headerlink" title="5.取到接口返回结果"></a>5.取到接口返回结果</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/QMm4NzZSwvbfksL.png" alt="1232840-20190419141832962-1187277977.png"> </p><h4 id="6-断言"><a href="#6-断言" class="headerlink" title="6.断言"></a>6.断言</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/p9KLR1il8v2WqNM.png" alt="1232840-20190419141854588-1768672082.png"></p><h4 id="7-代码及运行结果"><a href="#7-代码及运行结果" class="headerlink" title="7.代码及运行结果"></a>7.代码及运行结果</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/SCgEQfHcVuWyv1O.png" alt="1232840-20190419142011078-567748148.png"></p><h4 id="8-参考代码"><a href="#8-参考代码" class="headerlink" title="8.参考代码"></a>8.参考代码</h4><pre><code> 1 # coding:utf-8 2 import requests 3 url =&quot;http://www.kuaidi100.com/query?type=annengwuliu&amp;postid=300240694004&amp;temp=0.5964149534969456&amp;phone=&quot; 4 headers = { 5     &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&quot; 6 } # get 方法加个 User-Agent 就可以了 7 s = requests.session() 8 r = s.get(url, headers=headers,verify=False) 9 result = r.json()10 print(result)11 data = result[&#39;data&#39;] # 获取 data 里面内容12 print (data)13 print (data[0]) # 获取 data 里最上面有个14 get_result = data[0][&#39;context&#39;] # 获取已签收状态15 print (get_result)16 17 #进行断言18 if u&quot;已签收&quot; in get_result:19  print (&quot;快递单已签收成功&quot;)20 else:21  print (&quot;未签收&quot;)</code></pre><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>　　各位小伙伴，看到了，断言就是这么简单，其实和你写的测试用例差不多，将预期与实际结果进行对比，只不过是用代码体现出来。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化18</title>
      <link href="/2016/03/02/interface/"/>
      <url>/2016/03/02/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十八）–重定向（Location）（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　在实际工作中，有些接口请求完以后会重定向到别的url，而你却需要重定向前的url。URL主要是针对虚拟空间而言，因为不是自己独立管理的服务器，所以无法正常进行常规的操作。但是自己又不希望通过主域名的二级目录进行访问，而是希望通过主域名的二级域名进行访问。所以这个时候就会用到URL重定向。<br>    重定向过程好比有个绰号叫“浏览器”的人写信找张三借钱，张三回信说没有钱，让“浏览器”去找李四借，并将李四现在的通信地址告诉给了“浏览器 ”。于是，“浏览器”又按张三提供通信地址给李四写信借钱，李四收到信后就把钱汇给了“浏览器”。可见，“浏览器”一共发出了两封信和收到了两次回复，“ 浏览器”也知道他借到的钱出自李四之手。具体可以通过 HttpServletResponse.sendRedirect  实现。<br>　　RequestDispatcher.forward 方法在服务器端内部将请求转发给另外一个资源，浏览器只知道发出了请求并得到了响应结果，并不知道在服务器程序内部发生了转发行为。这个过程好比绰号叫“ 浏览器”的人写信找张三借钱，张三没有钱，于是张三找李四借了一些钱，甚至还可以加上自己的一些钱，然后再将这些钱汇给了“浏览器”。可见，“浏览器”只 发出了一封信和收到了一次回复，他只知道从张三那里借到了钱，并不知道有一部分钱出自李四之手。</p><h6 id="1、请求转发（requestDispatcher）"><a href="#1、请求转发（requestDispatcher）" class="headerlink" title="1、请求转发（requestDispatcher）"></a>1、请求转发（requestDispatcher）</h6><p>该动作是服务器行为，在web容器中进行的，客户端对于跳转是不知道的，地址栏中显示的URL是不会变化的，因为请求转发中是一次请求，相同的request，可以在请求中设置属性对象（setAttribute()）来实现数据共享</p><pre><code>request.getRequestDispatcher(URL).forward(request,response);</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/daAmDxvyLrSPN6M.png" alt="1232840-20190418140151504-1990029865.png"></p><h6 id="2、请求重定向（sendRedirect，也称为间接的请求转发）"><a href="#2、请求重定向（sendRedirect，也称为间接的请求转发）" class="headerlink" title="2、请求重定向（sendRedirect，也称为间接的请求转发）"></a>2、请求重定向（sendRedirect，也称为间接的请求转发）</h6><p>该动作是客户端行为，服务器会向客户端返回一个301状态码并携带一个Location属性表名应请求的地址，然后客户端按照服务器返回的地址重新发送请求，地址栏中显示的URL是会变化的因为请求重定向中是两次不同的请求request，无法实现数据共享</p><pre><code>response.sendRedirect(URL);</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/IA7EXaSPhJoc68u.png" alt="1232840-20190418140123454-1172592501.png"></p><h4 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2.重定向"></a>2.重定向</h4><p>　　URL重定向主要是指主域名主域名<a href="http://www.xusseo.com下的二级目录，如www.xusseo.com/wap，但是由于wap是一个新的站点，所以正确的域名应该是应该是wap.xusseo.com。但是访问的文件夹却是www.xusseo.com/wap，这种访问则被称之为重定向。" target="_blank" rel="noopener">www.xusseo.com下的二级目录，如www.xusseo.com/wap，但是由于wap是一个新的站点，所以正确的域名应该是应该是wap.xusseo.com。但是访问的文件夹却是www.xusseo.com/wap，这种访问则被称之为重定向。</a></p><p>常见的重定向分为301重定向和302重定向。重定向是一种比较特别的优化方式，因为需要通过代码来实现，从而变相提高权重值。所以在特殊情况下，如果使用重定向过于严重，则会被搜索引擎判定为不是正当的优化。</p><p>1、301重定向代表永久性转移(Permanently Moved)</p><p>301重定向被称之为永久性重定向，主要是针对一些永久性更改的网站，而且这种重定向一旦做好，将会对网站的优化大有好处。</p><p>2、302重定向代表暂时性转移(Temporarily Moved )</p><p>302重定向的使用并不多见，它通常被称之为暂时性的转移。302重定向的使用常见于meta重定向和JavaScript重定向。而这种重定向是典型的不正当行为，很容易被搜索引擎发现，并将其重定向的网址定义为不合法网站，做出惩罚。</p><p>3、以博客园举个简单的场景案例，先登录博客园打开我的博客首页，进入任意一个页面都可以，在这里进我的随笔编辑界面，记住这个地址：<a href="https://i.cnblogs.com/EditPosts.aspx?opt=1" target="_blank" rel="noopener">https://i.cnblogs.com/EditPosts.aspx?opt=1</a></p><p>4.退出博客园登录，把刚才我的随笔这个地址<a href="https://i.cnblogs.com/EditPosts.aspx?opt=1输入浏览器回车，抓包会看到这个请求状态码是" target="_blank" rel="noopener">https://i.cnblogs.com/EditPosts.aspx?opt=1输入浏览器回车，抓包会看到这个请求状态码是</a> 302，浏览器地址栏瞬间刷新跳到登录首页去了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/hVNBzWlwYOtaxm2.png" alt="1232840-20190418131928361-1987747083.png"></p><h4 id="3-禁止重定向（allow-redirects）"><a href="#3-禁止重定向（allow-redirects）" class="headerlink" title="3.禁止重定向（allow_redirects）"></a>3.禁止重定向（allow_redirects）</h4><p>1、用 get 方法请求：<a href="https://i.cnblogs.com/EditPosts.aspx?opt=1" target="_blank" rel="noopener">https://i.cnblogs.com/EditPosts.aspx?opt=1</a></p><p>2、打印状态码是 200，这是因为 requets 库自动处理了重定向请求了，这里留作疑问。聪明的你一定或许猜到了，不知道的后边带你去解密，笔者就喜欢抽丝剥茧的那种感觉，带你一层一层揭开它神秘的面纱</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/brn2tkcFPS1WzAa.png" alt="1232840-20190418134231385-1387243876.png"></p><p>3、自动处理重定向地址后，我们就获取不到重定向后的 url 了，就无法走下一步，这里我们可以设置一个参数禁止重定向：allow_redirects=False（allow_redirects=True 是启动重定向），然后就可以看到 status_code 是 302 了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/l5xSXdNv1R9hGi7.png" alt="1232840-20190418134845768-1575320002.png"></p><h4 id="4-获取重定向后地址"><a href="#4-获取重定向后地址" class="headerlink" title="4.获取重定向后地址"></a>4.获取重定向后地址</h4><p>1、在第一个请求后，服务器会下发一个新的请求链接，在 response 的 headers 里，如下抓包：Location</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/9QOw1xDK6JfPGRe.png" alt="1232840-20190418135307836-1627929577.png"></p><p>2、代码实现获取Location 地址</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/7g6YulB1UirvFwy.png" alt="1232840-20190418135615930-1381445911.png"></p><p>3、参考代码</p><pre><code> 1 # coding:utf-8 2 import requests 3 # 请求头 4 headers = { 5     &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&quot; 6 } 7 s = requests.session() 8 # 打开我的随笔 9 r = s.get(&#39;https://i.cnblogs.com/EditPosts.aspx?opt=1&#39;,10 headers=headers,11 allow_redirects=False,12 verify=False)13 # 打印状态码，自动处理重定向请求14 print (r.status_code)15 new_url = r.headers[&quot;Location&quot;]16 print (new_url)</code></pre><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>　　在工作和学习中，我们不仅需要知其然，还必须知其所以然。前边留的疑问或许你已经查资料知道其原因了。我这里还是用老办法，看源码！看源码！看源码！重要的事说三遍。</p><h6 id="1、从get方法入手"><a href="#1、从get方法入手" class="headerlink" title="1、从get方法入手"></a>1、从get方法入手</h6><p>我们知道使用requests的get方法传入url就可以访问此网站，但是这个过程是怎么做的呢，今天就带着这个疑问对其进行进一步探究。</p><p>打开pycharm，在pycharm中通过ctrl（command）+🖱️左键我们可以定位到方法的位置。</p><p>我们首先进入sessions.py文件，看到get方法如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/yZraI1gmNloGAB6.png" alt="1232840-20190418141625564-1079600140.png"></p><p>可以发现该方法就两句话</p><p>先看第一句，<code>kwargs.setdefault(&#39;allow_redirects&#39;, True)</code>,下面我们来说说kwargs在这里的用处</p><h6 id="2、kwargs"><a href="#2、kwargs" class="headerlink" title="2、kwargs"></a>2、kwargs</h6><p>kwargs是字典类型，setdefault的作用是给字典键名allow_redirects赋值，如果该键不存在，赋给其默认值，也就是第二参数True。</p><p>好了到此为止，就解决大家的疑问了，有兴趣的小伙伴可以继续往下分析。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化17</title>
      <link href="/2016/03/01/interface/"/>
      <url>/2016/03/01/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十七）–Json 数据处理—一次爬坑记（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　有些 post 的请求参数是 json 格式的，这个前面发送post 请求里面提到过，需要导入 json模块处理。现在企业公司一般常见的接口因为json数据容易处理，所以绝大多数返回数据也是 json 格式的，我们在做判断时候，往往只需要提取其中几个关键的参数就行，这时候我们就需要 json 来解析返回的数据了。首先来说一下笔者为何要单独写这么一篇，原因是：python 里面 bool 值是 True 和 False,json 里面 bool 值是 true和 false,并且区分大小写，这就尴尬了，明明都是 bool 值。在python里面写的代码，传到json里，不用说肯定识别不了，所以需要把python的代码经过encode后成为 json 可识别的数据类型，反之json数据就需要decode后成为python代码可识别的数据类型。这个也是需要初学者注意，也算是个细微差和一个坑人的地方吧，如果不注意很容易掉坑里啊。笔者就掉进去过，还好自救能力强，爬出来了，所以为了警醒后来者，就有了这篇随笔。</p><h4 id="2-json-模块简介"><a href="#2-json-模块简介" class="headerlink" title="2.json 模块简介"></a>2.json 模块简介</h4><p>1、Json 简介：Json，全名 JavaScript Object Notation,JSON(JavaScript Object Notation(记号、标记)) 是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。 JSON采用完全独立</p><p>于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。JSON易于人阅读和编写，同时也易于机器解析和生成。常用于 http 请求中，接口</p><p>返回的数据中。</p><p>2、可以用 help(json),查看对应的源码注释内容</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/G4egkvBwSjV5mHo.png" alt="1232840-20190411133157487-874557478.png"></p><h4 id="3-编码Encode（python-gt-json）"><a href="#3-编码Encode（python-gt-json）" class="headerlink" title="3.编码Encode（python-&gt;json）"></a>3.编码Encode（python-&gt;json）</h4><p>1、为什么要 encode，笔者在开头就给各位小伙伴开门见山的说出来了，让各位带着问题来探索、来学习、来思考</p><p>2、举个简单例子，下图的实例中 dict 类型经过 json.dumps（）后变成 str，True 变成了 true,False变成了 fasle</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/dsgo2xlcpv3XWKG.png" alt="1232840-20190416082302709-1179828254.png"> </p><p>3、从json模块的对应源码中可以查看到，python  数据转化成 json可识别的数据，对应的表关系如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/grLeuBD7Cf2JSiw.png" alt="1232840-20190415112953365-1602994067.png"></p><h4 id="4-解码-decode-json-gt-python"><a href="#4-解码-decode-json-gt-python" class="headerlink" title="4.解码 decode(json-&gt;python)"></a>4.解码 decode(json-&gt;python)</h4><p>1、以博客园的登录成功结果：{“success”:True}为例，我们其实最想知道的是 success 这个字段返回的是 True 还是 False，以便于我们对接口进行断言，以下是fiddler抓包博客园登录成功的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/erD5vOzF1c8ShM2.png" alt="1232840-20190416085338912-1801480568.png"></p><p>2、如果以 content 字节输出，返回的是一个字符串：{“success”:true}，这样获取后面那个结果就不方便了，导致断言也不方便</p><p>3、如果经过 json 解码后，返回的就是一个字典：{u’success’: True}，这样获取后面那个结果，就用字典的方式去取值：result2[“success”]，这样不言而喻断言也就简单方便了</p><p>4、由于博客园的登录机制的改变，我们这里接着上一篇的删除随笔的返回结果，给小伙伴们实战演练一下</p><p>5、用fiddler抓包，抓到删除新建随笔的请求，从抓包结果可以看出，返回结果是一个字符串：{“isSuccess”:True}，按照上边的步骤用代码实现</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/flLhsj4maUR9QXi.png" alt="1232840-20190416114809493-773371217.png"></p><p>6、代码及结果（看到了吧，就是这么轻松被我们取到其value了，接下来就可以进行断言了）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/rTIqK2uxghAHjYo.png" alt="1232840-20190417165233712-1381693182.png"></p><p>7、从json模块的对应源码中可以查看到， json 数据转化成 python 可识别的数据，对应的表关系如下</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/6HcqiSpVsrP2nBz.png" alt="1232840-20190415112525536-391469404.png"> </p><p>8、参考代码</p><pre><code> 1 # coding:utf-8 2 import requests 3 # 先打开登录首页，获取部分cookie 4 url = &quot;https://passport.cnblogs.com/user/signin&quot; 5 headers = { 6             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 7            }  # get方法其它加个ser-Agent就可以了 8 s = requests.session() 9 r = s.get(url, headers=headers,verify=False)10 print (s.cookies)11 # 添加登录需要的两个cookie12 c = requests.cookies.RequestsCookieJar()13 c.set(&#39;.CNBlogsCookie&#39;, &#39;XXX&#39;)  # 填上面抓包内容14 c.set(&#39;.Cnblogs.AspNetCore.Cookies&#39;,&#39;XXX&#39;)  # 填上面抓包内容15 c.set(&#39;AlwaysCreateItemsAsActive&#39;,&quot;True&quot;)16 c.set(&#39;AdminCookieAlwaysExpandAdvanced&#39;,&quot;True&quot;)17 s.cookies.update(c)18 print (s.cookies)19 result = r.content20 print(result.decode(&#39;utf-8&#39;))21 # 登录成功后保存编辑内容22 url2= &quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot;23 body = {&quot;__VIEWSTATE&quot;: &quot;&quot;,24         &quot;__VIEWSTATEGENERATOR&quot;:&quot;FE27D343&quot;,25         &quot;Editor$Edit$txbTitle&quot;:&quot;这是绕过登录的标题：北京-宏哥&quot;,26         &quot;Editor$Edit$EditorBody&quot;:&quot;&lt;p&gt;这里是中文内容：http://www.cnblogs.com/duhong/&lt;/p&gt;&quot;,27         &quot;Editor$Edit$Advanced$ckbPublished&quot;:&quot;on&quot;,28         &quot;Editor$Edit$Advanced$chkDisplayHomePage&quot;:&quot;on&quot;,29         &quot;Editor$Edit$Advanced$chkComments&quot;:&quot;on&quot;,30         &quot;Editor$Edit$Advanced$chkMainSyndication&quot;:&quot;on&quot;,31         &quot;Editor$Edit$lkbDraft&quot;:&quot;存为草稿&quot;,32          }33 r2 = s.post(url2, data=body, verify=False)34 print (r.content.decode(&#39;utf-8&#39;))35 36 # 第三步：正则提取需要的参数值37 import re38 postid = re.findall(r&quot;postid=(.+?)&amp;&quot;, r2.url)39 print(type(postid))40 print (postid) # 这里是 list41 # 提取为字符串42 print (postid[0])43 # 第四步：删除草稿箱44 url3 = &quot;https://i.cnblogs.com/post/delete&quot;45 json3 = {&quot;postId&quot;: postid[0]}46 r3 = s.post(url3, json=json3, verify=False)47 result = r3.content #content数据是字节输出48 print(type(result))49 print(result)50 #json是经过加码encode成对应python的数据类型51 result1 = r3.json()52 print (type(result1))53 print(result1[&#39;isSuccess&#39;])</code></pre><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>　　在实际工作中遇到问题要学会查资料，看其对应的官方文档以及源码，不仅可以起到事半功倍的作用，也可以锻炼自己解决问题的能力。这一点笔者深有体会！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化16</title>
      <link href="/2016/02/29/interface/"/>
      <url>/2016/02/29/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十六）–参数关联接口后传（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　大家对前边的自动化新建任务之后，接着对这个新建任务操作了解之后，希望带小伙伴进一步巩固胜利的果实，夯实基础。因此再在沙场实例演练一下博客园的相关接口。我们用自动化发随笔之后，要想接着对这篇随笔操作，不用说就需</p><p>要用参数关联了，发随笔之后会有一个随笔的 id，获取到这个 id，继续操作传这个随笔 id 就可以了（博客园的登录机制已经变了，不能用账号和密码登录了，这里用 cookie 登录）</p><p>大致流程步骤：web界面操作登录抓包查看cookie—&gt;代码模拟cookie登录—&gt;web界面操作新建随笔和保存随笔—&gt;抓包查看新建随笔和保存随笔的url和参数等—&gt;代码模拟新建随笔并保存编辑内容—&gt;web界面操作删除随笔—&gt;抓取删除操作请求—&gt;提取参数—&gt;传参—&gt;代码实现。</p><h4 id="2-删除随笔"><a href="#2-删除随笔" class="headerlink" title="2.删除随笔"></a>2.删除随笔</h4><p>1、我们前面讲过登录后新建随笔和保存随笔后，不记得可以点击传送门那可以继续接着操作：删除刚才新建的随笔</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/Kl4VQPvTULDZ156.png" alt="1232840-20190416112854202-1863970122.png"> </p><p>2、用fiddler抓包，抓到删除新建随笔的请求，从抓包结果可以看出，传的json参数是postId</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/flLhsj4maUR9QXi.png" alt="1232840-20190416114809493-773371217.png"></p><p>3.这个postId哪里来的呢？可以看上个请求的url地址</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/JVGbsYjEgaQU2dM.png" alt="1232840-20190416114627706-1999908725.png"></p><p>4、也就是说保存草稿箱成功之后，重定向一个 url 地址，里面带有 postId 这个参数。那我们想办法将这个参数提取出来就可以了</p><h4 id="3-提取参数"><a href="#3-提取参数" class="headerlink" title="3.提取参数"></a>3.提取参数</h4><p>1、我们需要的参数 postId 是在保存成功后 url 地址，这时候从 url 地址提出对应的参数值就行了，先获取保存成功后 url</p><p>2、通过正则表达式从保存的url提取需要的字符串，这个参数值前面（postid=）和后面（&amp;）字符串都是固定的</p><p>3、这里正则提出来的是 list 类型，取第一个值就可以是字符串了（注意：每次保存需要修改内容，不能重复）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/o1IOeJt5wXl9kxi.png" alt="1232840-20190416132226901-2016326895.png"></p><h4 id="4-传参"><a href="#4-传参" class="headerlink" title="4.传参"></a>4.传参</h4><p>1、删除草稿箱的 json 参数传上面取到的参数：{“postId”: postid[0]}</p><p>2、json 数据类型 post 里面填 json 就行，会自动转 json</p><p>3、接着前面的保存随笔的操作，就可以删除成功了</p><p>注意：同理和jenkins一样，如果想看清楚，可以在删除新建随笔出打断点，看到新建的随笔后，再次执行下边的代码 看看是不是可以删掉新建随笔</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/92TbOkPqmGwH5JX.png" alt="1232840-20190416132335249-1213273111.png"></p><h4 id="5-参考代码"><a href="#5-参考代码" class="headerlink" title="5.参考代码"></a>5.参考代码</h4><pre><code> 1 # coding:utf-8 2 import requests 3 # 先打开登录首页，获取部分cookie 4 url = &quot;https://passport.cnblogs.com/user/signin&quot; 5 headers = { 6             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 7            }  # get方法其它加个ser-Agent就可以了 8 s = requests.session() 9 r = s.get(url, headers=headers,verify=False)10 print (s.cookies)11 # 添加登录需要的两个cookie12 c = requests.cookies.RequestsCookieJar()13 c.set(&#39;.CNBlogsCookie&#39;, &#39;XXX&#39;)  # 填上面抓包内容14 c.set(&#39;.Cnblogs.AspNetCore.Cookies&#39;,&#39;XXX&#39;)  # 填上面抓包内容15 c.set(&#39;AlwaysCreateItemsAsActive&#39;,&quot;True&quot;)16 c.set(&#39;AdminCookieAlwaysExpandAdvanced&#39;,&quot;True&quot;)17 s.cookies.update(c)18 print (s.cookies)19 # 登录成功后保存编辑内容20 url2= &quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot;21 body = {&quot;__VIEWSTATE&quot;: &quot;&quot;,22         &quot;__VIEWSTATEGENERATOR&quot;:&quot;FE27D343&quot;,23         &quot;Editor$Edit$txbTitle&quot;:&quot;这是绕过登录的标题：北京-宏哥&quot;,24         &quot;Editor$Edit$EditorBody&quot;:&quot;&lt;p&gt;这里是中文内容：http://www.cnblogs.com/duhong/&lt;/p&gt;&quot;,25         &quot;Editor$Edit$Advanced$ckbPublished&quot;:&quot;on&quot;,26         &quot;Editor$Edit$Advanced$chkDisplayHomePage&quot;:&quot;on&quot;,27         &quot;Editor$Edit$Advanced$chkComments&quot;:&quot;on&quot;,28         &quot;Editor$Edit$Advanced$chkMainSyndication&quot;:&quot;on&quot;,29         &quot;Editor$Edit$lkbDraft&quot;:&quot;存为草稿&quot;,30          }31 r2 = s.post(url2, data=body, verify=False)32 #print (r.content.decode(&#39;utf-8&#39;))33 34 # 第三步：正则提取需要的参数值35 import re36 postid = re.findall(r&quot;postid=(.+?)&amp;&quot;, r2.url)37 print(type(postid))38 print (postid) # 这里是 list39 # 提取为字符串40 print (postid[0])41 # 第四步：删除草稿箱42 url3 = &quot;https://i.cnblogs.com/post/delete&quot;43 json3 = {&quot;postId&quot;: postid[0]}44 r3 = s.post(url3, json=json3, verify=False)45 print (r3.json())</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、好了，参数关联接口就是这么简单，相信各位小伙伴下回遇到此种类似的问题，不会慌了，应该是十拿九稳的把它KO掉。</p><p>2、有兴趣的自己可以向上一篇一样，自己练习一下打断点，自己可以体验一下其中的乐趣和神奇。</p><p>最后欢迎各位小伙伴探讨和留言！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化15</title>
      <link href="/2016/02/28/interface/"/>
      <url>/2016/02/28/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十五）–参数关联接口（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　我们用自动化新建任务之后，要想接着对这个新建任务操作，那就需要用参数关联了，新建任务之后会有一个任务的Jenkins-Crumb，获取到这个Jenkins-Crumb，就可以通过传这个任务Jenkins-Crumb继续操作这个新建的任务。</p><p>大致流程步骤：登录—&gt;新建任务—&gt;web界面操作删除—&gt;抓取删除操作请求—&gt;提取参数—&gt;传参—&gt;代码实现。</p><h4 id="2-删除新建任务"><a href="#2-删除新建任务" class="headerlink" title="2.删除新建任务"></a>2.删除新建任务</h4><p>1、我们前面讲过登录后新建任务后，那可以继续接着操作：删除刚才新建的任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/2z4AmT6wPotfuUY.png" alt="1232840-20190410100142473-890749140.png"> </p><p>2、用fiddler抓包，抓到删除新建任务的请求，从抓包结果可以看出，传的data参数是Jenkins-Crumb</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/1DFjHhAWeg43QX2.png" alt="1232840-20190410100833406-1133193107.png"> </p><p>3.这个Jenkins-Crumb哪里来的呢？可以看上个请求的body</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/HM9y5fd831RSsIY.png" alt="1232840-20190410101314596-1293215964.png"></p><p>4、也就是说在新建任务的时候，系统随机生成一个Jenkins-Crumb参数的值，body里面带有Jenkins-Crumb这个参数。那接下来我们提取出来就可以了 </p><h4 id="3-提取参数"><a href="#3-提取参数" class="headerlink" title="3.提取参数"></a>3.提取参数</h4><p>1、我们需要的参数Jenkins-Crumb是在新建任务是body里Jenkins-Crumb的值，这时候从body里提出对应的参数值就行了（注意：每次保存需要修改内容，不能重复）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/o4kXQaqpnyju8Ve.png" alt="1232840-20190410102243835-275675165.png"></p><h4 id="4-传参"><a href="#4-传参" class="headerlink" title="4.传参"></a>4.传参</h4><p>1、删除新建任务的data参数传上面取到的参数：{“Jenkins-Crumb”: Jenkins_Crumb}</p><p>2、data数据类型post里面填data就行</p><p>3、接着前面的新建任务操作，就可以删除成功了</p><p>注意：如果想看清楚，可以在删除新建任务出打断点，看到新建的任务后，再次执行下边的代码 看看是不是可以删掉新建任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/SuawDTAt874CEbZ.png" alt="1232840-20190410103226878-1130583889.png"></p><p>4、302重定向</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/qsLVQ38Sfo1thKW.png" alt="1232840-20190410103106417-321307515.png"></p><p>5、content内容复制到记事本，修改后缀以后，浏览器查看有“欢迎来到Jenkins”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/GnD54YRTp2KjEhf.png" alt="1232840-20190410103459932-438816878.png"></p><h4 id="5-参考代码"><a href="#5-参考代码" class="headerlink" title="5.参考代码"></a>5.参考代码</h4><pre><code> 1 # coding:utf-8 2 import requests 3 # 先打开登录首页，获取部分session 4 url = &quot;http://localhost:8080/jenkins/j_acegi_security_check&quot; 5 headers = { 6             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 7            }  # get方法其它加个ser-Agent就可以了 8 d = {&quot;j_username&quot;: &quot;admin&quot;, 9      &quot;j_password&quot;: &quot;111111&quot;,10      &quot;from&quot;: &quot;&quot;,11      &quot;Submit&quot;: u&quot;登录&quot;,12      &quot;remember_me&quot;: &quot;on&quot;13      }14 15 s = requests.session()16 r = s.post(url, headers=headers, data=d)17 #print (r.content.decode(&#39;utf-8&#39;))18 # 正则表达式提取账号和登录按钮19 import re20 t = re.findall(r&#39;&lt;b&gt;(.+?)&lt;/b&gt;&#39;, r.content.decode(&#39;utf-8&#39;))   # 用python3的这里r.content需要解码21 print (t[0])22 print (t[1])23 #新建任务24 url1 = &quot;http://localhost:8080/jenkins/createItem&quot;25 body = {&quot;name&quot;:&quot;6666&quot;,26         &quot;mode&quot;: &quot;hudson.model.FreeStyleProject&quot;,27         &quot;Jenkins-Crumb&quot;:&quot;51a97fc7fbf3792823230d9bdd7ec906&quot;,28         &quot;json&quot;:{&quot;name&quot;:&quot;6666&quot;,29                 &quot;mode&quot;: &quot;hudson.model.FreeStyleProject&quot;,30                 &quot;Jenkins-Crumb&quot;:&quot;51a97fc7fbf3792823230d9bdd7ec906&quot;31 32         }33 }34 print(type (body))35 import urllib36 import sys37 #获取name的值38 name = body[&#39;name&#39;]39 print(&#39;name:&#39;+name)40 #获取body的值41 Jenkins_Crumb = body[&#39;Jenkins-Crumb&#39;]42 print(&#39;body的值是：&#39;,body[&#39;Jenkins-Crumb&#39;])43 r2 = s.post(url1, data=body, verify=False)44 #print (r2.content.decode(&#39;utf-8&#39;))45 #删除新建任务46 url2 = &quot;http://localhost:8080/jenkins/job/&quot;+name+&quot;/doDelete&quot;47 body1 = {48             &quot;Jenkins-Crumb&quot;: Jenkins_Crumb49 }50 51 r3 = s.post(url2, data=body1, verify=False)52 print (r3.content.decode(&#39;utf-8&#39;))53 #删除成功重定向到主界面（由于抓包没有看到response的结果，只知道重定向主界面）54 print(r3.url)</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p> 1、细心地、认真的小伙伴一定会发现我代码请求的name的值是6666，或者英文，而不是“北京-宏哥”的中文，原因是中文出现的url中有时候会报错。解决办法：</p><pre><code>1 from urllib.parse import quote2 import urllib.request3 name = quote(name)4 url2 = &quot;http://localhost:8080/jenkins/job/&quot;+name+&quot;/doDelete&quot;</code></pre><p>2、给小伙伴们演示一下，打断点</p><p>（1）在删除新建任务出打上断点,双击前边即可出现一个红色的大圆点</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/XN7yWrupABwjk3Q.png" alt="1232840-20190410151411971-729052573.png"></p><p>（2）查看jenkins主界面，没有新建任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/jzBEN7vXfQJcU8b.png" alt="1232840-20190410151819124-1886457889.png"> </p><p>（3）点击右上方的昆虫图标</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/Fy43odrzgXLvUBu.png" alt="1232840-20190410151619234-957694967.png"></p><p>（4）进入debug模式，代码运行到断点处停止运行</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/VbPu6v3jXrEFUmk.png" alt="1232840-20190410151903262-329092371.png"> </p><p>（5）刷新主界面，再次查看jenkins主界面，有新建任务-北京-宏哥</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/pjlytHCT6b8axMg.png" alt="1232840-20190410152051748-1639698550.png"></p><p>（6）点击右边的绿色图标一次性执行完后边的代码，或者是上边拐弯蓝色图标，一步一步执行完后边的代码</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/o8Yi2vV5NhrbJzA.png" alt="1232840-20190410152454855-780685709.png"> </p><p>（7）刷新主界面，再次查看jenkins主界面，你会看到：新建任务-北京-宏哥  神奇的消失了，他就这样被你神不知鬼不觉的干掉了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/PH46qLwXc3DlbeT.png" alt="1232840-20190410152953831-1349312086.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化14</title>
      <link href="/2016/02/27/interface/"/>
      <url>/2016/02/27/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十四）–session关联接口（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇cookie绕过验证码模拟登录博客园，但这只是第一步，一般登录后，还会有其它的操作，如发帖，评论等等，这时候如何保持会话呢？这里我以jenkins平台为例，给小伙伴们在沙场演练一下。</p><h4 id="2-session简介"><a href="#2-session简介" class="headerlink" title="2.session简介"></a>2.session简介</h4><p>1、通过help方法查看帮助文档,截图一部分，后面省略了，有兴趣的自己可以敲一下看看</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/sdn14afOhyTKilR.png" alt="1232840-20190403162623701-1650488720.png"></p><p>2、参考代码</p><pre><code>1 # coding:utf-82 import requests3 help(requests.session())</code></pre><h4 id="3-使用session登录"><a href="#3-使用session登录" class="headerlink" title="3.使用session登录"></a>3.使用session登录</h4><p>1、使用session登录只需在登录的基础上稍做修改，即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/P9U3fC7xRkj1Qns.png" alt="1232840-20190409113139413-1149291392.png"> </p><p>2、参考代码</p><pre><code># coding:utf-8import requests# 先打开登录首页，获取部分sessionurl = &quot;http://localhost:8080/jenkins/j_acegi_security_check&quot;headers = {            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot;           }  # get方法其它加个ser-Agent就可以了d = {&quot;j_username&quot;: &quot;admin&quot;,     &quot;j_password&quot;: &quot;111111&quot;,     &quot;from&quot;: &quot;&quot;,     &quot;Submit&quot;: u&quot;登录&quot;,     &quot;remember_me&quot;: &quot;on&quot;     }s = requests.session()r = s.post(url, headers=headers, data=d)#print (r.content.decode(&#39;utf-8&#39;))</code></pre><h4 id="4-保存编辑"><a href="#4-保存编辑" class="headerlink" title="4.保存编辑"></a>4.保存编辑</h4><p>1、先打开新建任务，手动输入任务名称和选择下边选项后，打开fiddler抓包，然后点击“确定”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/ArRs7xjVBGMtyue.png" alt="1232840-20190409112640867-1436217274.png"></p><p>fiddler抓包</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/hJ8nGBzAdZrDtOk.png" alt="1232840-20190409112939013-755978808.png"></p><p>2、把body的参数内容写成字典格式</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/fvQsbGYZK5T1zHF.png" alt="1232840-20190409132923437-1230626099.png"> </p><p>参考代码：</p><pre><code>1 body = {&quot;name&quot;:&quot;北京-宏哥1&quot;,2         &quot;mode&quot;: &quot;hudson.model.FreeStyleProject&quot;,3         &quot;Jenkins-Crumb&quot;:&quot;51a97fc7fbf3792823230d9bdd7ec906&quot;,4         &quot;json&quot;:{&quot;name&quot;:&quot;北京-宏哥1&quot;,5                 &quot;mode&quot;: &quot;hudson.model.FreeStyleProject&quot;,6                 &quot;Jenkins-Crumb&quot;:&quot;51a97fc7fbf3792823230d9bdd7ec906&quot;7 8         }9 }</code></pre><p>3、用上面登录保存的session继续发送post请求，来新建任务</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/9EifdWGaHjYFoUc.png" alt="1232840-20190409133031677-6251901.png"> </p><p>4、执行后，查看所有任务就多了一条新增的了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/DZjVKuXBiHqC58b.png" alt="1232840-20190409132752754-1308665219.png"> </p><p>5、运行结果部分截图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/qS8oyFUHukbiKvz.png" alt="1232840-20190409135811981-1266307704.png"></p><p>6、粘贴到记事本修改后缀查看：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/TWuNFDmlp9oR31S.png" alt="1232840-20190409135849947-1352095135.png"></p><h4 id="7-参考代码"><a href="#7-参考代码" class="headerlink" title="7.参考代码"></a>7.参考代码</h4><pre><code> 1 # coding:utf-8 2 import requests 3 # 先打开登录首页，获取部分session 4 url = &quot;http://localhost:8080/jenkins/j_acegi_security_check&quot; 5 headers = { 6             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 7            }  # get方法其它加个ser-Agent就可以了 8 d = {&quot;j_username&quot;: &quot;admin&quot;, 9      &quot;j_password&quot;: &quot;111111&quot;,10      &quot;from&quot;: &quot;&quot;,11      &quot;Submit&quot;: u&quot;登录&quot;,12      &quot;remember_me&quot;: &quot;on&quot;13      }14 15 s = requests.session()16 r = s.post(url, headers=headers, data=d)17 #print (r.content.decode(&#39;utf-8&#39;))18 # 正则表达式提取账号和登录按钮19 import re20 t = re.findall(r&#39;&lt;b&gt;(.+?)&lt;/b&gt;&#39;, r.content.decode(&#39;utf-8&#39;))   # 用python3的这里r.content需要解码21 print (t[0])22 print (t[1])23 #新建任务24 url1 = &quot;http://localhost:8080/jenkins/createItem&quot;25 body = {&quot;name&quot;:&quot;北京-宏哥1&quot;,26         &quot;mode&quot;: &quot;hudson.model.FreeStyleProject&quot;,27         &quot;Jenkins-Crumb&quot;:&quot;51a97fc7fbf3792823230d9bdd7ec906&quot;,28         &quot;json&quot;:{&quot;name&quot;:&quot;北京-宏哥1&quot;,29                 &quot;mode&quot;: &quot;hudson.model.FreeStyleProject&quot;,30                 &quot;Jenkins-Crumb&quot;:&quot;51a97fc7fbf3792823230d9bdd7ec906&quot;31 32         }33 }34 35 r2 = s.post(url1, data=body, verify=False)36 print (r2.content.decode(&#39;utf-8&#39;))</code></pre><p>这里我是用新建任务写的案例，小伙伴可以试下Jenkins里边其他的关联接口</p><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h4><p>小伙伴都看到了吧，session关联接口就是这么简单！！！赶快动起来吧。想要学习的小伙伴可以用博客园来练习一下，遇到问题欢迎打扰和沟通！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化13</title>
      <link href="/2016/02/26/interface/"/>
      <url>/2016/02/26/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十三）–cookie绕过验证码登录（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　有些登录的接口会有验证码：短信验证码，图形验证码等，这种登录的话验证码参数可以从后台获取的（或者查数据库最直接）。获取不到也没关系，可以通过添加cookie的方式绕过验证码。（注意：并不是所有的登录都是用cookie来保持登录的，有些是用token登录）</p><h4 id="2-抓登录cookie"><a href="#2-抓登录cookie" class="headerlink" title="2.抓登录cookie"></a>2.抓登录cookie</h4><p>1、如博客园登录后会生成一个已登录状态的cookie，那么只需要直接把这个值添加到cookies里面就可以了。</p><p>2、可以先手动登录一次，然后抓取这个cookie，这里就需要用抓包工具fiddler了</p><p>3、先打开博客园登录界面，手动输入账号和密码（勾选下次自动登录）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/PbU3VBQZJ4pkLt2.png" alt="1232840-20190401154817598-2029649734.png"></p><p>4、打开fiddler抓包工具，刷新下登录首页，就是登录前的cookie了</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/LnNRMCdqhvbgjFH.png" alt="1232840-20190416090612960-199035741.png"></p><p>5、登录成功后，再查看cookie变化，发现多了两组参数，多的这两组参数就是我们想要的，copy出来，一会有用</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/92XGCINvmfwPRBK.png" alt="1232840-20190416091134168-1983444868.png"></p><h4 id="3-cookie组成结构"><a href="#3-cookie组成结构" class="headerlink" title="3.cookie组成结构"></a>3.cookie组成结构</h4><p>1、用抓包工具fidller只能看到cookie的name和value两个参数，实际上cookie还有其它参数</p><p>2、以下是一个完整的cookie组成结构</p><pre><code>1 cookie ={u&#39;domain&#39;: u&#39;.cnblogs.com&#39;,2            u&#39;name&#39;: u&#39;.CNBlogsCookie&#39;,3            u&#39;value&#39;: u&#39;xxxx&#39;,4           u&#39;expiry&#39;: 1491887887,5            u&#39;path&#39;: u&#39;/&#39;,6            u&#39;httpOnly&#39;: True,7           u&#39;secure&#39;: False}</code></pre><p>name：cookie的名称</p><p>value：cookie对应的值，动态生成的</p><p>domain：服务器域名</p><p>expiry：Cookie有效终止日期</p><p>path：Path属性定义了Web服务器上哪些路径下的页面可获取服务器设置的Cookie</p><p>httpOnly：防脚本攻击</p><p>secure:在Cookie中标记该变量，表明只有当浏览器和Web Server之间的通信协议为加密认证协议时，</p><p>浏览器才向服务器提交相应的Cookie。当前这种协议只有一种，即为HTTPS。</p><h4 id="5-添加cookie"><a href="#5-添加cookie" class="headerlink" title="5.添加cookie"></a>5.添加cookie</h4><p>1、往session里面添加cookie可以用以下方式</p><p>2、set里面参数按括号里面的参数格式</p><pre><code>1 coo = requests.cookies.RequestsCookieJar() 2 coo.set(&#39;cookie-name&#39;, &#39;cookie-value&#39;, path=&#39;/&#39;, domain=&#39;.xxx.com&#39;) 3 s.cookies.update(c)</code></pre><p>3、于是添加登录的cookie，把第一步fiddler抓到的内容填进去就可以了</p><pre><code>1 c = requests.cookies.RequestsCookieJar()2 c.set(&#39;.CNBlogsCookie&#39;, &#39;xxx&#39;)3 c.set(&#39;.Cnblogs.AspNetCore.Cookies&#39;,&#39;xxx&#39;)4 s.cookies.update(c)5 print(s.cookies)</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/BUfiZ9t2qKbmPIW.png" alt="1232840-20190401155020777-888861529.png"></p><h4 id="6-代码运行，刷新随笔"><a href="#6-代码运行，刷新随笔" class="headerlink" title="6.代码运行，刷新随笔"></a>6.代码运行，刷新随笔</h4><p>1、看到刚刚添加的随笔</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/OVjdfp8Q3xIR1Yo.png" alt="1232840-20190416101553901-426176631.png"></p><h4 id="7-参考代码"><a href="#7-参考代码" class="headerlink" title="7.参考代码"></a>7.参考代码</h4><p>1、由于登录时候是多加2个cookie，我们可以先用get方法打开登录首页，获取部分cookie</p><p>2、再把登录需要的cookie添加到session里</p><p>3、添加成功后，随便编辑正文和标题保存到草稿箱</p><pre><code> 1 # coding:utf-8 2 import requests 3 # 先打开登录首页，获取部分cookie 4 url = &quot;https://passport.cnblogs.com/user/signin&quot; 5 headers = { 6             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 7            }  # get方法其它加个ser-Agent就可以了 8 s = requests.session() 9 r = s.get(url, headers=headers,verify=False)10 print s.cookies11 # 添加登录需要的两个cookie12 c = requests.cookies.RequestsCookieJar()13 c.set(&#39;.CNBlogsCookie&#39;, &#39;xxx&#39;)  # 填上面抓包内容14 c.set(&#39;.Cnblogs.AspNetCore.Cookies&#39;,&#39;xxx&#39;)  # 填上面抓包内容15 s.cookies.update(c)16 print s.cookies17 # 登录成功后保存编辑内容18 url2= &quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot;19 body = {&quot;__VIEWSTATE&quot;: &quot;&quot;,20         &quot;__VIEWSTATEGENERATOR&quot;:&quot;FE27D343&quot;,21         &quot;Editor$Edit$txbTitle&quot;:&quot;这是绕过登录的标题：北京-宏哥&quot;,22         &quot;Editor$Edit$EditorBody&quot;:&quot;&lt;p&gt;这里是中文内容：http://www.cnblogs.com/duhong/&lt;/p&gt;&quot;,23         &quot;Editor$Edit$Advanced$ckbPublished&quot;:&quot;on&quot;,24         &quot;Editor$Edit$Advanced$chkDisplayHomePage&quot;:&quot;on&quot;,25         &quot;Editor$Edit$Advanced$chkComments&quot;:&quot;on&quot;,26         &quot;Editor$Edit$Advanced$chkMainSyndication&quot;:&quot;on&quot;,27         &quot;Editor$Edit$lkbDraft&quot;:&quot;存为草稿&quot;,28          }29 r2 = s.post(url2, data=body, verify=False)30 print r.content</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化12</title>
      <link href="/2016/02/25/interface/"/>
      <url>/2016/02/25/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十二）–https请求（SSL）（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　本来最新的requests库V2.13.0是支持https请求的，但是一般写脚本时候，我们会用抓包工具fiddler，这时候会 报：requests.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)</p><h4 id="2-小编环境"><a href="#2-小编环境" class="headerlink" title="2.小编环境"></a>2.小编环境</h4><p>python：3.7</p><p>requests：2.21.0</p><p>fiddler：v5.0.20</p><p>python &amp; requests:</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/wgeNd8srChMxqIz.png" alt="1232840-20190326160238512-197745863.png"> </p><p>Fiddler:</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/OxR8KUBMtve4Ddm.png" alt="1232840-20190326160435033-311365508.png"></p><h4 id="3-SSL问题"><a href="#3-SSL问题" class="headerlink" title="3.SSL问题"></a>3.SSL问题</h4><p>1、在你不启用fiddler时，python代码直接发送https请求，不会有SSL问题（也就是说不想看到SSL问题，关掉fiddler就行）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/s1hKtE2qXDNYwPB.png" alt="614655-20170904221144272-1517438496.png"></p><p>2、启动fiddler抓包，会出现这个错误：</p><pre><code>requests.exceptions.SSLError: HTTPSConnectionPool(host=&#39;passport.cnblogs.com&#39;, port=443): Max retries exceeded with url: /user/signin (Caused by SSLError(SSLError(&quot;bad handshake: Error([(&#39;SSL routines&#39;, &#39;tls_process_server_certificate&#39;, &#39;certificate verify failed&#39;)])&quot;)))</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/IaB7rbANDL41PVp.png" alt="1232840-20190326161745213-1774559635.png"></p><h4 id="4-verify参数设置"><a href="#4-verify参数设置" class="headerlink" title="4.verify参数设置"></a>4.verify参数设置</h4><p>1、Requests的请求默认verify=True</p><p>2、如果你将 verify设置为 False，Requests 也能忽略对 SSL 证书的验证</p><p>3、但是依然会出现两行Warning,可以不用管</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/AKvZNsgraWCD7lc.png" alt="614655-20170904221204210-796418385.png"></p><h4 id="5-忽略Warning"><a href="#5-忽略Warning" class="headerlink" title="5.忽略Warning"></a>5.忽略Warning</h4><p>　　有些小伙伴有强迫症看到红色的心里就发慌，这里加两行代码可以忽略掉警告，眼不见为净！</p><p> Python2添加如下代码即可解决：</p><pre><code>1 from requests.packages.urllib3.exceptions import InsecureRequestWarning2 # 禁用安全请求警告3 requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</code></pre><p>Python3添加如下三种任意一种代码即可解决：</p><pre><code>1 1、requests.packages.urllib3.disable_warnings()2 3 2、import warnings4 　  warnings.filterwarnings(&quot;ignore&quot;)5 6 3、import urllib37 　　urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/2I18dvUzSVAYlMG.png" alt="1232840-20190326163022014-1212806683.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化11</title>
      <link href="/2016/02/24/interface/"/>
      <url>/2016/02/24/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十一）–发送post【data】（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　前面登录博客园的是传 json 参数，由于其登录机制的改变没办法演示，然而在工作中有些登录不是传 json 的，如 jenkins 的登录，这里小编就以jenkins 登录为案例，传 data 参数，给各位童鞋详细演练一下。</p><h4 id="2-登录jenkins抓包"><a href="#2-登录jenkins抓包" class="headerlink" title="2.登录jenkins抓包"></a>2.登录jenkins抓包</h4><p>1、浏览器上登录jenkins，输入账号和密码，点击登录</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/4hWvVAFIzXSunkT.png" alt="1232840-20190409104912554-2057818411.png"> </p><p>2、fiddler抓包工具抓取jenkins登录的过程</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/4sJqKzDIu8GR7jf.png" alt="1232840-20190409104957864-1906678021.png"></p><p>3、可以清楚地看到这个body参数并不是json格式，是key=value格式，也就是前面介绍post请求四种数据类型里面的第一种</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/TLNejRviOBM7KzC.png" alt="1232840-20190326153546758-1080778198.png"></p><h4 id="3-请求头部"><a href="#3-请求头部" class="headerlink" title="3.请求头部"></a>3.请求头部</h4><p>1.上面抓包已经知道body的数据类型了，那么头部里面Content-Type类型也需要填写对应的参数类型</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/aUb7ARCr6IE89H4.png" alt="614655-20170904220738929-1796950581.png"></p><h4 id="4-实现登录"><a href="#4-实现登录" class="headerlink" title="4.实现登录"></a>4.实现登录</h4><p>1、登录实例代码如下：</p><p>注意：此处的登录URL是fiddler抓包抓到的，而并非是浏览器的URL地址，如果你复制的是浏览器的地址，就会报错了</p><pre><code> 1 # coding:utf-8 2 import requests 3 # 先打开登录首页，获取部分session 4 url = &quot;http://localhost:8080/jenkins/j_acegi_security_check&quot; 5 headers = { 6             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 7            }  # get方法其它加个ser-Agent就可以了 8 d = {&quot;j_username&quot;: &quot;admin&quot;, 9      &quot;j_password&quot;: &quot;111111&quot;,10      &quot;from&quot;: &quot;&quot;,11      &quot;Submit&quot;: u&quot;登录&quot;,12      &quot;remember_me&quot;: &quot;on&quot;13      }14 s = requests.session()15 r = s.post(url, headers=headers, data=d)16 print (r.content.decode(&#39;utf-8&#39;))</code></pre><p>2、运行后的结果如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/BbDUyXsdoNMjEuS.png" alt="1232840-20190409110231035-1632164720.png"></p><p>3、为了更好地查看你可以将其拷贝到记事本，保存，然后将文件后缀名修改成.html或者.htm，用浏览器打开查看</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/HTatYKpSfDhGuqn.png" alt="1232840-20190409111957961-1617125551.png"></p><h4 id="5-判断登录是否成功"><a href="#5-判断登录是否成功" class="headerlink" title="5.判断登录是否成功"></a>5.判断登录是否成功</h4><p>1.首先这个登录接口有重定向，看左边会话框302，那登录成功的结果看最后一个200就行</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/InjqYdM1WpFx4gH.png" alt="614655-20170904220819194-218604847.png"></p><p>2.返回的结果并不是跟博客园一样的json格式，返回的是一个html页面 </p><h4 id="6-判断登录成功"><a href="#6-判断登录成功" class="headerlink" title="6.判断登录成功"></a>6.判断登录成功</h4><p>1.判断登录成功，可以抓取页面上的关键元素，比如：账号名称admin，注销按钮</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/t9wkcpHgZMmd84f.png" alt="1232840-20190326155254663-1114019940.png"></p><p>2.通过正则表达式提出这2个关键字</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/MB3U4wSO2Xpsznu.png" alt="1232840-20190409110411277-2010459.png"></p><h4 id="7-参考代码"><a href="#7-参考代码" class="headerlink" title="7.参考代码"></a>7.参考代码</h4><pre><code> 1 # coding:utf-8 2 import requests 3 # 先打开登录首页，获取部分session 4 url = &quot;http://localhost:8080/jenkins/j_acegi_security_check&quot; 5 headers = { 6             &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&quot; 7            }  # get方法其它加个ser-Agent就可以了 8 d = {&quot;j_username&quot;: &quot;admin&quot;, 9      &quot;j_password&quot;: &quot;111111&quot;,10      &quot;from&quot;: &quot;&quot;,11      &quot;Submit&quot;: u&quot;登录&quot;,12      &quot;remember_me&quot;: &quot;on&quot;13      }14 s = requests.session()15 r = s.post(url, headers=headers, data=d)16 #print (r.content.decode(&#39;utf-8&#39;))17 # 正则表达式提取账号和登录按钮18 import re19 t = re.findall(r&#39;&lt;b&gt;(.+?)&lt;/b&gt;&#39;, r.content.decode(&#39;utf-8&#39;))   # 用python3的这里r.content需要解码20 print (t[0])21 print (t[1])</code></pre><h4 id="8-遇到问题可解决方法"><a href="#8-遇到问题可解决方法" class="headerlink" title="8.遇到问题可解决方法"></a>8.遇到问题可解决方法</h4><p>注意这里边遇到的问题python3遇到的问题，或许python2没有这些问题，笔者没有实践，有兴趣的自己可以试一下<br>1、如果打印content，没有加后边的.decode(‘utf-8’)，会出现乱码，解决方法加上即可。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/V2icILTuw6YeO5B.png" alt="1232840-20190409111050605-2065451392.png"></p><p>2、如果正则提取没有加.decode(‘utf-8’)，会报如下错误，解决方案也是加上即可</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/05/xVmzNuehAZIOpwt.png" alt="1232840-20190409110820571-1290410890.png"></p><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>　　jenkins 代码模拟登陆到这里就结束，实际工作中的登录接口也就是这些，记住万变不离其宗，举一反三。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化10</title>
      <link href="/2016/02/23/interface/"/>
      <url>/2016/02/23/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（十）–post请求四种传送正文方式（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　post请求我在python接口自动化（八）–发送post请求的接口（详解）已经讲过一部分了，主要是发送一些较长的数据，还有就是数据比较安全等。我们要知道post请求四种传送正文方式首先需要先了解一下常见的四种编码方式：<br>HTTP 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。</p><h4 id="2-浏览器行为：Form表单提交"><a href="#2-浏览器行为：Form表单提交" class="headerlink" title="2.浏览器行为：Form表单提交"></a>2.浏览器行为：Form表单提交</h4><h5 id="1、form表单常用属性"><a href="#1、form表单常用属性" class="headerlink" title="1、form表单常用属性"></a>1、form表单常用属性</h5><p>1 action：url 地址，服务器接收表单数据的地址<br>2 method：提交服务器的http方法，一般为post和get<br>3 name：最好好吃name属性的唯一性<br>4 enctype: 表单数据提交时使用的编码类型，默认使用”pplication/x-www-form-urlencoded”，如果是使用POST请求，则请求头中的content-type指定值就是该值。如果表单中有上传文件，编码类型需要使用”multipart/form-data”，类型，才能完成传递文件数据。<br>enctype为form表单数据的编码格式，Content-type为Http传输的数据的编码格式。分清两者</p><h5 id="2、浏览器提交表单时，会执行如下步骤"><a href="#2、浏览器提交表单时，会执行如下步骤" class="headerlink" title="2、浏览器提交表单时，会执行如下步骤"></a>2、浏览器提交表单时，会执行如下步骤</h5><p>1 识别出表单中表单元素的有效项，作为提交项<br>2 构建一个表单数据集<br>3 根据form表单中的enctype属性的值作为content-type对数据进行编码<br>4 根据form表单中的action属性和method属性向指定的地址发送数据</p><h5 id="3、提交方式"><a href="#3、提交方式" class="headerlink" title="3、提交方式"></a>3、提交方式</h5><p>1 get:表单数据会被encodeURIComponent后以参数的形式:name1=value1&amp;name2=value2 附带在url?后面，再发送给服务器，并在url中显示出来。<br>2 post：enctype 默认”application/x-www-form-urlencoded”对表单数据进行编码，数据以键值对在http请求体重发送给服务器；如果enctype 属性为”multipart/form-data”，则以消息的形式发送给服务器。<br>Http协议行为：Http1.1协议</p><p>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p><pre><code>1 &lt;method&gt; &lt;request-URL&gt; &lt;version&gt; &lt;headers&gt; &lt;entity-body&gt;　　</code></pre><p>　　协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p><p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主</p><p>体是用何种方式编码，再对主体进行解析。</p><p>所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分</p><h4 id="3-常见的四种编码方式如下"><a href="#3-常见的四种编码方式如下" class="headerlink" title="3.常见的四种编码方式如下"></a>3.常见的四种编码方式如下</h4><h5 id="1、application-x-www-form-urlencoded"><a href="#1、application-x-www-form-urlencoded" class="headerlink" title="1、application/x-www-form-urlencoded"></a>1、application/x-www-form-urlencoded</h5><p>　　这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p><pre><code>POST http://www.example.com HTTP/1.1    Content-Type:application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</code></pre><p>　　首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，</p><p>$_POST[‘title’] 可以获取到 title 的值，$_POST[‘sub’] 可以得到 sub 数组。</p><p>　　很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。</p><h5 id="2、multipart-form-data"><a href="#2、multipart-form-data" class="headerlink" title="2、multipart/form-data"></a>2、multipart/form-data</h5><p>　　除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。</p><p>　　这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值，下面是示例</p><p>form表单：</p><pre><code>1 &lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;2     Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;3     Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;4     File: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;5     &lt;input type=&quot;submit&quot;&gt;6 &lt;/form&gt;</code></pre><p>Http协议请求：</p><pre><code>POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</code></pre><p>　　这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里</p><p>按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary-</p><ul><li>标示结束。关于 multipart/form-data 的详细定义，请前往 rfc1867 查看。</li></ul><p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p><p>　　上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也只支持这两种方式（通过 <form> 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支</form></form></p><p>持 text/plain，不过用得非常少）。</p><p>　　随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p><h5 id="3、application-json"><a href="#3、application-json" class="headerlink" title="3、application/json"></a>3、application/json</h5><p>　　application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持</p><p>JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p><p>　　JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-</p><p>www-form-urlencoded 方式提交。</p><p>　　Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：</p><pre><code>1 var data = {&#39;title&#39;:&#39;test&#39;, &#39;sub&#39; : [1,2,3]};2 $http.post(url, data).success(function(result) {3     ...4 });</code></pre><p>最终发送的请求是：</p><pre><code>1 POST http://www.example.com HTTP/1.12 Content-Type: application/json;charset=utf-83  4 {&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]}</code></pre><p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 </p><p>php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。<br>　　当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。如有需要，可以参考这篇文章。</p><h5 id="4、text-xml"><a href="#4、text-xml" class="headerlink" title="4、text/xml"></a>4、text/xml</h5><p>　　它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：</p><pre><code> 1 POST http://www.example.com HTTP/1.1 2 Content-Type: text/xml 3   4 &lt;?xml version=&quot;1.0&quot;?&gt; 5 &lt;methodCall&gt; 6     &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; 7     &lt;params&gt; 8         &lt;param&gt; 9             &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;10         &lt;/param&gt;11     &lt;/params&gt;12 &lt;/methodCall&gt;</code></pre><p>　　XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服</p><p>务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。</p><p>　　相比之下，get方式的数据提交方式（编码方式）只有一种，就是application/x-www-form-urlencoding</p><h4 id="3-post请求四种传送正文方式"><a href="#3-post请求四种传送正文方式" class="headerlink" title="3.post请求四种传送正文方式"></a>3.post请求四种传送正文方式</h4><p>　　（1）请求正文是application/x-www-form-urlencoded</p><p>　　（2）请求正文是multipart/form-data</p><p>　　（3）请求正文是raw</p><p>　　（4）请求正文是binary</p><p>（1）请求正文是application/x-www-form-urlencoded</p><p>形式：</p><pre><code>1 requests.post(url=&#39;&#39;,data={&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;},headers={&#39;Content-Type&#39;:&#39;application/x-www-form-urlencoded&#39;})</code></pre><p>　　Reqeusts支持以form表单形式发送post请求，只需要将请求的参数构造成一个字典，然后传给requests.post()的data参数即可。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/xXGKFLBpv5yl96r.png" alt="1232840-20190325150705328-1109426382.png"></p><p>　　可以看到，请求头中的Content-Type字段已设置为application/x-www-form-urlencoded，且d = {‘key1’: ‘value1’, ‘key2’: ‘value2’}以form表单的形式提交到服务端，服务端返回的form字段即是提交的数据。</p><p>（2）请求正文是multipart/form-data</p><p>　　除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。</p><p>形式：</p><pre><code>1 requests.post(url=&#39;&#39;,data={&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;},headers={&#39;Content-Type&#39;:&#39;multipart/form-data&#39;})</code></pre><p> 　　发送文件中的数据需要（安装requests_toolbelt）</p><pre><code>from requests_toolbelt import MultipartEncoderimport requestsm = MultipartEncoder(    fields={&#39;field0&#39;: &#39;value&#39;, &#39;field1&#39;: &#39;value&#39;,            &#39;field2&#39;: (&#39;filename&#39;, open(&#39;file.py&#39;, &#39;rb&#39;), &#39;text/plain&#39;)}    )r = requests.post(&#39;http://httpbin.org/post&#39;, data=m,                  headers={&#39;Content-Type&#39;: m.content_type})　　不需要文件from requests_toolbelt import MultipartEncoderimport requestsm = MultipartEncoder(fields={&#39;field0&#39;: &#39;value&#39;, &#39;field1&#39;: &#39;value&#39;})r = requests.post(&#39;http://httpbin.org/post&#39;, data=m,                  headers={&#39;Content-Type&#39;: m.content_type})</code></pre><p>（3）请求正文是raw</p><p>形式：</p><p>♦传入xml格式文本</p><pre><code>1 requests.post(url=&#39;&#39;,data=&#39;&lt;?xml  ?&gt;&#39;,headers={&#39;Content-Type&#39;:&#39;text/xml&#39;})</code></pre><p>♦传入json格式文本</p><pre><code>1 requests.post(url=&#39;&#39;,data=json.dumps({&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;}),headers={&#39;Content-Type&#39;:&#39;application/json&#39;})</code></pre><p>或者：</p><pre><code>1  requests.post(url=&#39;&#39;,json={{'key1':'value1','key2':'value2'}},headers={&#39;Content-Type&#39;:&#39;application/json&#39;})</code></pre><p>　　可以将一json串传给requests.post()的data参数，</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/DOP9YU6ajBLIZlJ.png" alt="1232840-20190325151237599-1481247332.png"></p><p>（4）请求正文是binary</p><p>形式：</p><pre><code>1 requests.post(url=&#39;&#39;,files={&#39;file&#39;:open(&#39;test.xls&#39;,&#39;rb&#39;)},headers={&#39;Content-Type&#39;:&#39;binary&#39;})　　Requests也支持以multipart形式发送post请求，只需将一文件传给requests.post()的files参数即可。</code></pre><p>输入：</p><pre><code>url = &#39;http://httpbin.org/post&#39;files = {&#39;file&#39;: open(&#39;report.txt&#39;, &#39;rb&#39;)}r = requests.post(url, files=files)print r.text输出：{ “args”: {}, “data”: “”, “files”: { “file”: “Hello world!” }, “form”: {}, “headers”: {…… “Content-Type”: “multipart/form-data; boundary=467e443f4c3d403c8559e2ebd009bf4a”, …… }, “json”: null, …… }</code></pre><p> 　　文本文件report.txt的内容只有一行：Hello world!，从请求的响应结果可以看到数据已上传到服务端中。注意：一定要注意headers的类型。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化9</title>
      <link href="/2016/02/22/interface/"/>
      <url>/2016/02/22/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（九）–python中字典和json的区别（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　这篇文章的由来是由于上一篇发送post请求的接口时候，参数传字典（dict）和json的缘故，因为python中，json和dict非常类似，都是key-value的形式，为啥还要这么传参，在群里问了一些人，也说不出个所以然了，还是自己动手丰衣足食，所以才有这篇和编辑分类格格不入的文章。来先看一下它们各自的定义。</p><h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h4><p>　　python中，json和dict非常类似，都是key-value的形式，而且json、dict也可以非常方便的通过dumps、loads互转。既然都是key-value格式，为啥还需要进行格式转换？</p><p>　　json（JavaScript Object Notation）</p><p>　　json：是一种数据格式，是纯字符串。可以被解析成Python的dict或者其他形式。</p><p>　　dict：是一个完整的数据结构，是对Hash Table这一数据结构的一种实现，是一套从存储到提取都封装好了的方案。它使用内置的哈希函数来规划key对应value的存储位置，从而获得O（1）的数据读取速度。</p><h4 id="3-json和dict对比"><a href="#3-json和dict对比" class="headerlink" title="3.json和dict对比"></a>3.json和dict对比</h4><p> 　 1、json的key只能是字符串，python的dict可以是任何可hash对象（hashtable type）；                           </p><p>　　2、json的key可以是有序、重复的；dict的key不可以重复。</p><p>　　3、json的value只能是字符串、浮点数、布尔值或者null，或者它们构成的数组或者对象。</p><p>　　4、json任意key存在默认值undefined，dict默认没有默认值；</p><p>　　5、json访问方式可以是[],也可以是.，遍历方式分in、of；dict的value仅可以下标访问。</p><p>　　6、json的字符串强制双引号，dict字符串可以单引号、双引号；</p><p>　　7、dict可以嵌套tuple，json里只有数组。</p><p>　　8、json:true、false、null</p><p>　　9、python：True、False、None</p><p>　　10、json中文必须是unicode编码，如”\u6211”.</p><p>　　11、json的类型是字符串，字典的类型是字典。</p><h4 id="4-hashtable"><a href="#4-hashtable" class="headerlink" title="4.hashtable"></a>4.hashtable</h4><p>1、post 的 body 是 json 类型，也可以用 json 参数传入。</p><p>2、先导入 json 模块，用 dumps 方法转化成 json 格式。</p><p>3、返回结果，传到 data 里</p><p>4、只有当tuple内的所有项都是hashtable的时候，tuple才是hashtable；</p><h4 id="5-代码示例对比"><a href="#5-代码示例对比" class="headerlink" title="5.代码示例对比"></a>5.代码示例对比</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/rtpli7JvEwdSsIb.png" alt="1232840-20190322115207639-1052252685.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><pre><code>实际上JSON就是Python字典的字符串表示，但是字典作为一个复杂对象是无法直接转换成定义它的代码的字符串，字典是一个数据的结构，而json只是一个具有一定规则的字符串，方便在不同平台上处理其中包含的数据。</code></pre><p>但本质上来讲，字典是一种数据结构，json是一种格式；字典有很多内置函数，有多种调用方法，而json是数据打包的一种格式，并不像字典具备操作性，并且是格式就会有一些形式上的限制，比如json的格式要求必须且只能使用双引号作为</p><p>key或者值的边界符号，不能使用单引号，而且“key”必须使用边界符（双引号），但字典就无所谓了。</p><p>形式上的相近也让python提供了json.loads()转换函数，方便json数据的调用。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化8</title>
      <link href="/2016/02/21/interface/"/>
      <url>/2016/02/21/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（八）–发送post请求的接口（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上篇介绍完发送get请求的接口，大家必然联想到发送post请求的接口也不会太难，被聪明的你又猜到了。答案是对的，虽然发送post请求的参考例子很简单，但是实际遇到的情况却是很复杂的，因为所有系统或者软件、网站都是从登录开始的，进入这扇门才可以发现里边的奥秘，所以首先介绍的第一个post请求肯定是登录了，但登录是最难处理的。如果把登录问题这只拦路虎解决了，那么后面问题都迎刃而解。</p><h4 id="2-help函数"><a href="#2-help函数" class="headerlink" title="2.help函数"></a>2.help函数</h4><p>　　上篇介绍发送get请求的接口时，学习requests模块，是让大家去访问官方网站，查看官方文档；其实学习一个新的模块捷径，不用去百度什么的，直接用 help 函数就能查看相关注释和案例内容。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/v78Xpd4ez1FKSyg.png" alt="1232840-20190320111307039-970602898.png"></p><h5 id="2-1python发送get请求接口案例："><a href="#2-1python发送get请求接口案例：" class="headerlink" title="2.1python发送get请求接口案例："></a>2.1python发送get请求接口案例：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/nCFyjwU6hHm4Tar.png" alt="1232840-20190320111408383-1120332403.png"> </p><h5 id="2-2python发送post请求接口案例："><a href="#2-2python发送post请求接口案例：" class="headerlink" title="2.2python发送post请求接口案例："></a>2.2python发送post请求接口案例：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/Su4ZaQjxTvyRgsI.png" alt="1232840-20190320111450197-719250803.png"></p><h4 id="3-发送post请求的接口（dict参数）"><a href="#3-发送post请求的接口（dict参数）" class="headerlink" title="3.发送post请求的接口（dict参数）"></a>3.发送post请求的接口（dict参数）</h4><p> 　　上一篇，我们就见识过requests的强大功能和威力。寥寥几行代码就可以实现get和post的请求。介绍到这里想必大伙都迫不及待了，好，那我们来牛刀小试一下。</p><p>1、用上面给的python发送post请求接口案例，稍稍地做个简单修改，就可以发个简单的post 请求</p><p>2、便可以像官方文档给出的案例将payload 参数是字典类型（dict），传到如下图的 form 里</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/Sc97u3hG2Zx5bLP.png" alt="1232840-20190321110241440-1728421370.png"> </p><h4 id="4-发送post请求的接口（json参数）"><a href="#4-发送post请求的接口（json参数）" class="headerlink" title="4.发送post请求的接口（json参数）"></a>4.发送post请求的接口（json参数）</h4><p>1、post 的 body 是 json 类型，也可以用 json 参数传入。</p><p>2、先导入 json 模块，用 dumps 方法转化成 json 格式。</p><p>3、返回结果，传到 data 里</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/RYu5MSm8idXKF6J.png" alt="1232840-20190321114337942-847994179.png"></p><h4 id="5-请求头header"><a href="#5-请求头header" class="headerlink" title="5.请求头header"></a>5.请求头header</h4><p>　　现在由于对接口安全性的要求，使得模拟登录越来越复杂，比上边介绍的基本内容要复杂很多。一般来说登陆只要涉及安全性方面考虑，那么登陆就会比较复杂。</p><p>1、以博客园为例，几年前模拟登陆，没有涉及安全性考虑相对简单。发展到现在其登录涉及安全性考虑，所以实际的情况要比上面讲的几个复杂很多，</p><p>2、我们在请求数据时也可以加上自定义的headers（通过headers关键字参数传递）有时候有的特殊的请求必须加上headers头信息，才回返回响应结果。例如：博客园登录时，将请求头 headers添加上,这里不是说博客园登录必须登录才能返回</p><p>响应结果，而是以其为例子来说明将请求头header参数加入到登录请求接口中。这里可以用抓包工具来看其登录时的请求头。如下是fiddler工具抓包时登录的请求头。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/O8PaQfh3Cr6S5YX.png" alt="1232840-20190322170733298-290744009.png"></p><p>3、由于博客园的登录方式改变了，我们换一个例子演示。还是以官方文档给的网址演示如下</p><p>（1）抓包，查看其请求头，浏览器F12查看</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/GklSRvoqV9aHOX7.png" alt="1232840-20190325091555997-1268316817.png"></p><p>　　Fiddler抓包查看请求头，结果如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/N6UngjcbAo3HimL.png" alt="1232840-20190325091840428-664121257.png"></p><p>　　实例代码和其结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/yCt2BDwX5fUWMjR.png" alt="1232840-20190325092751603-711297740.png"> </p><p>　　遇到问题报错和解决办法：</p><pre><code>raise SSLError(e, request=request)requests.exceptions.SSLError: HTTPSConnectionPool(host=&#39;httpbin.org&#39;, port=443): Max retries exceeded with url: /post (Caused by SSLError(SSLError(&quot;bad handshake: Error([(&#39;SSL routines&#39;, &#39;tls_process_server_certificate&#39;, &#39;certificate verify failed&#39;)])&quot;)))</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>1、由于这里是 https 请求，直接发送请求会报错误:</p><pre><code>SSLError: HTTPSConnectionPool(host=&#39;httpbin.org&#39;, port=443): Max retries exceeded with url: /post (Caused by SSLError(SSLError(&quot;bad handshake: Error([(&#39;SSL routines&#39;, &#39;tls_process_server_certificate&#39;, &#39;certificate verify failed&#39;)])&quot;)))</code></pre><p>2、可以加个参数：verify=False，表示忽略对 SSL 证书的验证，但是此时仍然会有警告：</p><pre><code>InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warningsInsecureRequestWarning)</code></pre><p>3、这里请求参数 payload 是 json 格式的，用 json 参数传。将请求头写成字典格式，进行传参。</p><p>4、最后结果是 json 格式，可以直接用 r.json 返回 json 数据：</p><pre><code>{&#39;args&#39;: {}, &#39;data&#39;: &#39;&#39;, &#39;files&#39;: {}, &#39;form&#39;: {}, &#39;headers&#39;: {&#39;Accept&#39;: &#39;*/*&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Content-Length&#39;: &#39;0&#39;, &#39;Host&#39;: &#39;httpbin.org&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&#39;}, &#39;json&#39;: None, &#39;origin&#39;: &#39;222.128.10.95, 222.128.10.95&#39;, &#39;url&#39;: &#39;https://httpbin.org/post&#39;}</code></pre><p>5、json参数和dict的参数非常类似，都是key-value的形式，它们有何区别，欲知后事如何，且听下回分解。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化7</title>
      <link href="/2016/02/20/interface/"/>
      <url>/2016/02/20/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（七）–状态码详解对照表（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　我们为啥要了解状态码，从它的作用，就不言而喻了。如果不了解，我们就会像个无头苍蝇，横冲直撞。遇到问题也不知道从何处入手，就是想找别人帮忙，也不知道是找前端还是后端的工程师。</p><p>　　状态码的作用是：web服务器用来告诉客户端，发生了什么事。·</p><p>　　状态码位于HTTP Response 的第一行中，会返回一个”三位数字的状态码“和一个“状态消息”。 ”三位数字的状态码“便于程序进行处理， “状态消息”更便于人理解。</p><h4 id="2-简略状态码对照表"><a href="#2-简略状态码对照表" class="headerlink" title="2.简略状态码对照表"></a>2.简略状态码对照表</h4><p>　　这部分主要是给大家练就一双火眼金睛，看到状态码一眼定位到问题所在，该找谁，就找谁，大大提高效率。</p><p>　　PS：小技巧：  假如你看到一个状态码518， 你并不知道具体518是什么意思。 这时候你只要知道518是属于（5XX，服务器错误就可以了）</p><table><thead><tr><th></th><th>已定义范围</th><th>分类</th></tr></thead><tbody><tr><td>1XX</td><td>100-199</td><td>信息提示，用于指定客户端相应的某些动作</td></tr><tr><td>2XX</td><td>200-299</td><td>成功，用于表示请求成功</td></tr><tr><td>3XX</td><td>300-399</td><td>重定向，用于移动的文件并且常被包含在定位头信息中制定新的地址信息</td></tr><tr><td>4XX</td><td>400-499</td><td>客户端错误，用于指出客户端的错误</td></tr><tr><td>5XX</td><td>500-599</td><td>服务器错误，用于指出服务器的错误</td></tr></tbody></table><h4 id="3-常见的状态码"><a href="#3-常见的状态码" class="headerlink" title="3.常见的状态码"></a>3.常见的状态码</h4><p>　　这部分主要是希望大家不要那么折磨自己，常用的记住就可以一般人只需要了解以下常见的状态码就够了， （当然了受虐和自虐的除外）如果你想了解更多， 请继续往下看。</p><table><thead><tr><th>200 OK 服务器成功处理了请求（这个是我们见到最多的）</th></tr></thead><tbody><tr><td>301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个LocationURL, 说明资源现在所处的位置</td></tr><tr><td>304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存</td></tr><tr><td>404 Not Found 未找到资源</td></tr><tr><td>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</td></tr></tbody></table><h4 id="4-状态码详解对照表"><a href="#4-状态码详解对照表" class="headerlink" title="4.状态码详解对照表"></a>4.状态码详解对照表</h4><p>　　这部分主要是给一些需要深入了解和学习的童鞋准备的饕餮盛宴（状态码详细对照表）</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td>101</td><td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td>200</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td>201</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td></tr><tr><td>202</td><td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td>203</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td>204</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td>207</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>300</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td>301</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td>302</td><td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td>303</td><td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td>304</td><td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td>305</td><td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td>307</td><td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>400</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</td></tr><tr><td>401</td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td>402</td><td>该状态码是为了将来可能的需求而预留的。</td></tr><tr><td>403</td><td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td></tr><tr><td>408</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td>410</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td>411</td><td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td>417</td><td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td>421</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td>424</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td>425</td><td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td>426</td><td>客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td>449</td><td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td>500</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td>501</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td>502</td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td></tr><tr><td>504</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td>505</td><td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>　　状态码对照也是这么简单，只要把常用的记住、简略的了解即可，大可不必纠结详细的！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化6</title>
      <link href="/2016/02/19/interface/"/>
      <url>/2016/02/19/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（六）–发送get请求接口（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>如果想用python做接口测试，我们首先有不得不了解和学习的模块。它就是第三方模块：Requests。 虽然Python内置的urllib模块，用于访问网络资源。但是，它用起来比较麻烦，而且，缺少很多实用的高级功能。更好的方案是使用requests。它是一个Python第三方库，处理URL资源特别方便。查看其中文官网：<a href="http://cn.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="noopener">http://cn.python-requests.org/zh_CN/latest/index.html</a> 英文官网：<a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">http://www.python-requests.org/en/master/</a>     可以看一下它的很多实用的高级功能。</p><h4 id="2-功能特性"><a href="#2-功能特性" class="headerlink" title="2.功能特性"></a>2.功能特性</h4><p>　　Requests 完全满足今日 web 的需求。</p><p>Keep-Alive &amp; 连接池<br>国际化域名和 URL<br>带持久 Cookie 的会话<br>浏览器式的 SSL 认证<br>自动内容解码<br>基本/摘要式的身份认证<br>优雅的 key/value Cookie<br>自动解压<br>Unicode 响应体<br>HTTP(S) 代理支持<br>文件分块上传<br>流下载<br>连接超时<br>分块请求<br>支持 .netrc</p><h4 id="3-环境安装（安装requests）"><a href="#3-环境安装（安装requests）" class="headerlink" title="3.环境安装（安装requests）"></a>3.环境安装（安装requests）</h4><p>　　您如果安装了Anaconda，requests就已经可用了。否则，需要在命令行下通过pip安装：</p><pre><code>pip install requests</code></pre><p>　　注意：pip很容易就会版本升级，</p><p>　　方法1：检测并更新</p><pre><code>pip list –outdated</code></pre><p>　　方法2：</p><p>　　　　♦先卸载：</p><pre><code>pip uninstall packagename</code></pre><p>　　　　♦在用：easy_install.exe安装</p><pre><code>easy_install.exe pip</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/WXYmVnoLNHJtwDh.png" alt="1232840-20190319102135614-37325132.png"> </p><p>　　出现Installing collected packages: idna, chardet, certifi, requests</p><p>　　　　Successfully installed certifi-2019.3.9 chardet-3.0.4 idna-2.8 requests-2.21.0 说明requests模块安装成功！</p><p>使用requests（get请求无参数param）<br>1、将安装好的requests模块导入后，通过GET访问一个URL地址的网页页面，如：<a href="https://www/douban.com" target="_blank" rel="noopener">https://www/douban.com</a></p><p>2、这里的 r 也就是 response，请求后的返回值，可以调用 response 里的 status_code 方法查看状态码</p><p>3、状态码 200 只能说明这个接口访问的服务器地址是对的，并不能说明功能 OK，一般要查看响应的内容，r.text 是返回文本信息</p><p>看吧！这个就是requests的威力，看起来是不是很神奇很牛逼：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/VBy9uq75SvohCZX.png" alt="1232840-20190319105208667-1972695820 _1_.png"> </p><p>使用requests（get请求有参数param）<br>1、再发一个带参数的 get 请求，如在豆瓣网搜索：西游记,url 地址为：<a href="https://www.douban.com/search?q=西游记" target="_blank" rel="noopener">https://www.douban.com/search?q=西游记</a></p><p>2、请求参数：q=西游记，可以以字典的形式传参:{“q”: “西游记”}</p><p>3、多个参数格式：{“key1”: “value1”, “key2”: “value2”, “key3”: “value3”}</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/c4sbiamRp8wQeLg.png" alt="1232840-20190319111831536-1097467522.png"></p><p> 这部分最容易犯错的部分，就是1、豆瓣网址后没有+/search；2、params错误的写成param</p><p>使用request（get获取响应文本content）<br>1、豆瓣网首页如果用 r.text 会发现获取到的内容有乱码，因为豆瓣网首页响应内容是 gzip 压缩的（非 text 文本）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/w4KpZkvFAma9uhI.png" alt="1232840-20190319144239193-1311256864.png"></p><p>2、如果是在 fiddler 工具乱码，是可以点击后解码的，在代码里面可以用 r.content 这个方法，content 会自动解码 gzip 和 deflate 压缩（这个就是开始介绍requests的高级功能：自动解码和自动解压）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/VBy9uq75SvohCZX.png" alt="1232840-20190319105208667-1972695820 _1_.png"></p><h4 id="4-附录response返回的其他信息"><a href="#4-附录response返回的其他信息" class="headerlink" title="4.附录response返回的其他信息"></a>4.附录response返回的其他信息</h4><p>1.response 的返回内容（content）还有其它更多信息</p><p>– r.status_code #响应状态码</p><p>– r.content #字节方式的响应体，会自动为你解码 gzip 和deflate 压缩</p><p>– r.headers #以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回 None</p><p>– r.json() #Requests 中内置的 JSON 解码器，requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取</p><p>– r.url # 获取 url</p><p>– r.encoding # 编码格式，requests自动检测编码</p><p>– r.cookies # 获取 cookie</p><p>– r.raw #返回原始响应体– r.text #字符串方式的响应体，会自动根据响应头部的字符编码进行解码</p><p>– r.raise_for_status() #失败请求(非 200 响应)抛出异常</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>用requests发送get请求的接口，就是这么简单！想要学的赶快行动起来，键盘敲起来，你可以用自己的博客园练习一下。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化5</title>
      <link href="/2016/02/18/interface/"/>
      <url>/2016/02/18/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（五）–接口测试用例和接口测试报告模板（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>当今社会在测试领域，接口测试已经越来越多的被提及，被重视，而且现在好多招聘信息要对接口测试提出要求。区别于传统意义上的系统级别测试，很多测试人员在接触到接口测试的时候，也许对测试执行还可以比较顺利的上手，但一提到相关的文档，比如测试用例和报告，就有些不知所措了。这类问题在我加入的几个测试的群里，经常看到一些人在不断提问。<br>今天就用这篇文章来说说接口测试用例和报告。</p><h4 id="2-接口功能测试用例模板"><a href="#2-接口功能测试用例模板" class="headerlink" title="2.接口功能测试用例模板"></a>2.接口功能测试用例模板</h4><p>　　提到功能测试用例，我们知道，其中最重要的两个要素就是：</p><p>　　测试步骤</p><p>　　预期结果</p><p>　　其实对于接口功能测试也同样如此；接口测试的步骤中，最重要的是将实现向接口发送预设请求，结果则要关注响应信息及后续处理。</p><p>　　所以接口功能测试用例编排可以考虑下列两种形式：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/1rcOIyMhHWBDUTn.png" alt="1232840-20190311154749001-1803008343.png"></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/RkMUOeLc8ZA6y1t.png" alt="1232840-20190311143216663-314645977.png"></p><p>接口其他方面测试用例模板：</p><p>　　<img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/d5LbxpUScmajDPl.png" alt="1232840-20190311151949428-310494332.png"></p><p> 　　要特别注意的是，实际工作场景中我们可能还会对接口之间的串联和混合场景进行测试。就是上一个接口返回的数据有可能作为后边的接口的参数传入后边的接口。</p><h4 id="3-测试报告模板"><a href="#3-测试报告模板" class="headerlink" title="3.测试报告模板"></a>3.测试报告模板</h4><p>　　测试报告是指把测试的过程和结果写成文档，对发现的问题和缺陷进行分析，为纠正软件的存在的质量问题提供依据，同时为软件验收和交付打下基础。测试报告是测试阶段最后的文档产出物。优秀的测试经理或测试人员应该具备良好的文档编写能力。</p><p>　　接口测试报告很多时候会和接口性能测试报告一起，如果要单独报告的话，可以考虑以下内容：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/VMLBXD8kfvPlwpz.png" alt="1232840-20190311155422033-262095564.png"></p><h5 id="3-1系统接口概况"><a href="#3-1系统接口概况" class="headerlink" title="3.1系统接口概况"></a>3.1系统接口概况</h5><p>　　简要描述与测试项目相关的一些背景资料，如被测系统简介，项目上线计划等。</p><p>　　对于系统接口的定义和设计做出介绍。</p><p>　　比如系统一共有多少个接口？采用哪种协议？都涉及到哪些发送方法？采用怎样的请求格式？使用怎样的返回标准？可用表格说明。</p><h5 id="3-2测试目的与范围"><a href="#3-2测试目的与范围" class="headerlink" title="3.2测试目的与范围"></a>3.2测试目的与范围</h5><p>　　描述本次接口测试的目的、范围与目标，内容应与本次接口测试的《接口测试实施方案》中的对应内容保持一致。</p><p> 测试目的<br>　　本测试报告的具体编写目的，指出预期的读者范围。</p><p>　　实例：本测试报告为XXX项目的测试报告，目的在于总结测试阶段的测试以及分析测试结果，描述系统是否符合需求（或达到XXX功能目标）。预期参考人员包括用户、测试人员、、开发人员、项目管理者、其他质量管理人员和需要阅读</p><p>本报告的高层经理。<br>　　本次测试的目的在于确保系统接口功能和逻辑处理已验证，符合《接口定义说明书》的定义和要求，满足系统需要。</p><p> 测试对象范围（测试用例设计）<br>　　简要介绍测试用例的设计方法。例如：等价类划分、边界值、因果图，以及用这类方法(3-4句)。</p><p>　　提示：如果能够具体对设计进行说明，在其他开发人员、测试经理阅读的时候就容易对你的用例设计有个整体的概念，顺便说一句，在这里写上一些非常规的设计方法也是有利的，至少在没有看到测试结论之前就可以了解到测试经理的设</p><p>计技术，重点测试部分一定要保证有两种以上不同的用例设计方法。<br>　　说明测试的对象是哪些</p><p>单场景接口功能测试</p><p>混合场景接口功能测试</p><p>　　详见《项目接口测试用例》可考虑贴出x-mind图</p><p>测试指标范围<br>被测接口接收请求和返回报文</p><p>被测接口返回状态</p><p>被测接口对应业务逻辑处理</p><p>涉及数据沉淀的处理</p><p>复杂场景下多接口串联交互</p><h5 id="3-3测试工具及资源"><a href="#3-3测试工具及资源" class="headerlink" title="3.3测试工具及资源"></a>3.3测试工具及资源</h5><p>　　简要介绍测试中采用的方法(和工具)。<br>　　<br>　　提示：主要是黑盒测试，测试方法可以写上测试的重点和采用的测试模式，这样可以一目了然的知道是否遗漏了重要的测试点和关键块。工具为可选项，当使用到测试工具和相关工具时，要说明。注意要注明是自产还是厂商，版本号多</p><p>少，在测试报告发布后要避免大多工具的版权问题。</p><h6 id="3-3-1测试工具"><a href="#3-3-1测试工具" class="headerlink" title="3.3.1测试工具"></a>3.3.1测试工具</h6><p>　　说明本次测试使用到的测试工具和辅助工具</p><p>　　测试工具：该测试将使用Postman（例）</p><p>　　Postman是谷歌的一款接口测试插件，它使用简单，支持用例管理，支持get、 post、文件上传、响应验证、变量管理、环境参数管理等功能，可以批量运 行，并支持用例导出、导入。</p><h6 id="3-3-2辅助工具：略"><a href="#3-3-2辅助工具：略" class="headerlink" title="3.3.2辅助工具：略"></a>3.3.2辅助工具：略</h6><p>测试资源</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/tceBdMA6xLYCKn8.png" alt="1232840-20190311155810574-845307390.png"></p><h5 id="3-4测试记录及结果分析"><a href="#3-4测试记录及结果分析" class="headerlink" title="3.4测试记录及结果分析"></a>3.4测试记录及结果分析</h5><p>​     单场景接口测试</p><p>​     测试结果数据</p><p>　　  给出本次单场景接口测试的测试结果数据</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/ilJOp7dbXTrAtPs.png" alt="1232840-20190311155843541-2138306925.png"> </p><h5 id="3-5测试问题及结果分析"><a href="#3-5测试问题及结果分析" class="headerlink" title="3.5测试问题及结果分析"></a>3.5测试问题及结果分析</h5><p>　　结合测试中发现的问题对于整体测试结果进行分析，做出判断。</p><p>接口业务功能错误类缺陷情况</p><p>接口异常处理类缺陷情况</p><p>接口处理数据沉淀缺陷类情况</p><p>接口安全性缺陷情况</p><h4 id="4-混合场景接口测试"><a href="#4-混合场景接口测试" class="headerlink" title="4.混合场景接口测试"></a>4.混合场景接口测试</h4><h5 id="4-1测试结果数据"><a href="#4-1测试结果数据" class="headerlink" title="4.1测试结果数据"></a>4.1测试结果数据</h5><p>给出本次混合场景接口测试的测试结果数据</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/2FXUzRJc8S6CIx7.png" alt="1232840-20190311155922443-194550287.png"></p><h5 id="4-2测试问题及结果分析"><a href="#4-2测试问题及结果分析" class="headerlink" title="4.2测试问题及结果分析"></a>4.2测试问题及结果分析</h5><p>　　结合测试中发现的问题对于整体测试结果进行分析，做出判断。</p><p>混合接口业务功能错误类缺陷情况</p><p>混合接口业务数据传递类缺陷情况</p><h4 id="5-测试结论"><a href="#5-测试结论" class="headerlink" title="5.测试结论"></a>5.测试结论</h4><p>　　给出本次性能测试的测试总结论，一般以测试结果与测试目标的比较结果作为测试结论。</p><p>　　1． 测试执行是否充分（可以增加对安全性、可靠性、可维护性和功能性描述）</p><p>　　2． 对测试风险的控制措施和成效</p><p>　　3． 测试目标是否完成</p><p>　　4． 测试是否通过</p><p>　　5． 是否可以进入下一阶段项目目标</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化4</title>
      <link href="/2016/02/17/interface/"/>
      <url>/2016/02/17/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（四）–接口测试工具介绍（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　“工欲善其事必先利其器”，通过前边几篇文章的介绍，大家大致对接口有了进一步的认识。那么接下来让我们看看接口测试的工具有哪些。 目前，市场上有很多支持接口测试的工具。利用工具进行接口测试，能够提供测试效率。例如，假</p><p>入让你一天完成100个接口测试任务，你觉得你加班能完成，那么1000个、10000个……..。如果有工具，可以大大提高你的效率，可以达到事半功倍，但是不是所有工具都能够支持你完成这个任务。下面我们就来挑选几个常用和常见的工具，</p><p>简单介绍一下。如果需要或者有兴趣可以在网上查看各种工具对应的资料进行深入人的学习，这里带领大家了解一下，碰到这些工具会用、了解、知道这些工具就达到目的了，不要到时候说到测试工具，一问三不知，一脸懵逼，那样就尴尬</p><p>了。</p><h4 id="2-接口测试工具"><a href="#2-接口测试工具" class="headerlink" title="2.接口测试工具"></a>2.接口测试工具</h4><p>　　接口测试工具如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/EvR8oZDGfTyHxSd.png" alt="1232840-20190313103659147-746111331.png"></p><h5 id="2-1Fiddler"><a href="#2-1Fiddler" class="headerlink" title="2.1Fiddler"></a>2.1Fiddler</h5><p>   首先，这是一个HTTP协议调试代理工具，说白了就是一个抓http包的工具。web测试和手机测试都能用到这个工具。既然是http协议，这个工具也能支持接口测试。稍后文章，我会专门介绍fiddler这个工具。Fiddler工具介绍：传送门</p><h5 id="2-2PostMan"><a href="#2-2PostMan" class="headerlink" title="2.2PostMan"></a>2.2PostMan</h5><p>   Postman一款非常流行的API调试工具。其实，开发人员用的更多。因为测试人员做接口测试会有更多选择，例如Jmeter、soapUI等。不过，对于开发过程中去调试接口，Postman确实足够的简单方便，而且功能强大。这是一款google工程师开发的一个插件，可以安装到chrome浏览器上。支持不同接口测试请求，能够管理测试套件和自动化运行，弱点在于，自动化断言功能不强大。不能和jenkins和代码管理库进行持续集成测试。但是，绝对是一个很好的半手工，半自动化测试工具，我一般在写自动化接口测试用例，会打开postman进行辅助测试和debug。这个工具也会稍后在文章介绍。PostMan工具介绍：传送门</p><p>　　Postman视频教程：</p><p>　　链接：<a href="https://pan.baidu.com/s/1X-ruUvzPXKOiHgddY5TTeg" target="_blank" rel="noopener">https://pan.baidu.com/s/1X-ruUvzPXKOiHgddY5TTeg</a><br>　　提取码：dj9h</p><p>   这个是一款计算机上抓包工具，支持抓各种包，TCP,UDP,HTTP都支持。如果做底层网络数据测试，一般都需要用到它。作为接口测试，这个软件有点不友好。因为刷新数据太快，不好定位每个操作对应的接口。所以，我们不会进行过多介绍这个工具。</p><h5 id="2-3SoupUI"><a href="#2-3SoupUI" class="headerlink" title="2.3SoupUI"></a>2.3SoupUI</h5><p>　　SoapUI是一个开源测试工具，通过soap/http来检查、调用、实现Web Service的功能/负载/符合性测试。该工具既可作为一个单独的测试软件使用，也可利用插件集成到Eclipse，maven2.X，Netbeans 和intellij中使用。</p><p>　　SoapUI是一个自由和开放源码的跨平台功能测试解决方案。通过一个易于使用的图形界面和企业级功能，SoapUI让您轻松， 快速创建和执行自动化功能、回归、合规和负载测试。在一个测试环境，SoapUI提供完整的测试覆盖，并支持所</p><p>有的标准协议和技术。</p><p>　　SoapUI 基于Java 开发，支持多个平台，安装非常简单。</p><p>　　这个是一个开源免费和，企业版收费的软件。在国外的接口测试，使用非常多。这个工具能够支持接口自动化测试和接口性能测试，也能支持和jenkins做持续集成测试。了解一下就可以，自己可以下载一个社区免费版，做一个demo试试。</p><h5 id="2-4Java代码做接口测试"><a href="#2-4Java代码做接口测试" class="headerlink" title="2.4Java代码做接口测试"></a>2.4Java代码做接口测试</h5><p>   代码是万能，笔记工具也是代码开发出来的。为什么要用代码做接口自动化测试呢。因为，有些工具功能是有限制，很多公司，需要一些特定的功能，工具不支持，只好用代码进行开发。一般用Java做自动化测试，主要是利用httpclient.jar</p><p>这个包，然后利用junit或者testng这样的单元测试工具，进行测试用例的开发，然后在jenkins上创建一个job，进行持续集成测试。</p><h5 id="2-5Python代码做接口测试"><a href="#2-5Python代码做接口测试" class="headerlink" title="2.5Python代码做接口测试"></a>2.5Python代码做接口测试</h5><p>  和Java一样，Python中利用一个很好，功能强大的第三方库requests，能够方便都创建接口自动化用例。python下单元测试框架，一般采用unittest。生成测试报告，一般选择HTMLTestRunner.py。同样，可以和jenkins做持续集成测试。</p><h5 id="2-6LoadRunner"><a href="#2-6LoadRunner" class="headerlink" title="2.6LoadRunner"></a>2.6LoadRunner</h5><p>   不要以为LR只能做性能测试，loadrunner同样可以做接口自动化和接口压力测试。只是我们很多人，不会利用LR的函数，进行开发接口测试用例。</p><h5 id="2-7JMeter"><a href="#2-7JMeter" class="headerlink" title="2.7JMeter"></a>2.7JMeter</h5><p>  JMeter同loadrunner一样，都是以性能测试出名，一般用JMeter也是做接口性能测试。例如java+Jmeter+ant+jenkins做接口性能监听测试。</p><p>  以上介绍了这么多工具，基本覆盖了接口功能测试，接口自动化测试，接口性能测试。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化3</title>
      <link href="/2016/02/16/interface/"/>
      <url>/2016/02/16/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（三）–如何设计接口测试用例（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　上篇我们已经介绍了什么是接口测试和接口测试的意义。在开始接口测试之前，我们来想一下，如何进行接口测试的准备工作。或者说，接口测试的流程是什么？有些人就很好奇，接口测试要流程干嘛？不就是拿着接口文档直接利用接口测试工具测试嘛。其实，如果只是三五个接口，你可以这么做一个临时的接口测试。但是，如果是上百个接口，或者，你们公司的这个项目，第一次做接口测试，那么，我们还是很有必要严格遵守接口测试的流程。</p><h4 id="2-接口测试的流程"><a href="#2-接口测试的流程" class="headerlink" title="2.接口测试的流程"></a>2.接口测试的流程</h4><p>　　接口测试也是属于功能测试，所以跟我们以往的功能测试流程并没有太大区别，测试流程依旧是：1.测试接口文档（需求文档） 2.根据接口文档编写测试用例（用例编写完全可以按照以往规则来编写，例如等价类划分，边界值等设计方法） 3. 执行测试，查看不同的参数请求，接口的返回的数据是否达到预期。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/bj9YHaxvgdEfVKp.png" alt="1232840-20190311095818573-1857403938.png"></p><p>接口测试和功能测试一样，流程也大致遵守V模型，请看下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/AMzeiT5wofkjr9G.png" alt="1232840-20190312162820493-2116592138.png"></p><pre><code>一般来说，接口测试左边的每个阶段，每个公司可能都侧重点不同，例如有些公司就没有需求讨论和需求评审这个阶段。不管如何，用例设计，这个是少不了，而且是重点，要花时间的阶段。只有覆盖全面的接口测试用例，才能有比较好的测试接口覆盖率，才会找出更多的接口的Bug，后期接口才能越稳定。</code></pre><h4 id="3-为什么要写用例"><a href="#3-为什么要写用例" class="headerlink" title="3.为什么要写用例"></a>3.为什么要写用例</h4><pre><code>功能测试用例，大家都写过。接口测试用例，很多人没有写过。在后边后又专门一章关于接口用例和接口报告的模板。在写之前，我们来讨论下，为什么要写接口用例。</code></pre><p>理清思路，避免漏测和重复测<br>提高测试效率<br>跟进测试进度<br>告诉领导做过<br>跟进重复性工作<br>更好的记录问题，发现问题，复现问题<br>同时这也是是接口测试流程中的一个产物（测试用例）<br>　　上面七点，结合自己测试实际经验，应该来说是很好理解和认同的。有用例，自己做到心中有数，不要一个测试点重复测好多次，就有思路，避免漏掉测试点。跟着用例测试，避免随机测试那种没有目的性的测试，提高测试效率。有用</p><p>例，上级问你完成的进度，你好用数据回答。有用例，用来标记你执行的结果，证明你做过测试。避免将来发生问题，人家说你没有测试，有数据和证据说话。有用例，测出问题你可以根据用例将问题轻而易举的浮现出来，不至于等你反馈或</p><p>者复现的问题时，你忘记是如何操作才回出现问题。接口测试也需要重复跑，跑几轮，或者用自动化天天跑。这样的重复性工作，用例可以保证每次重复做的是一样的情况。</p><h4 id="4-接口用例设计要点"><a href="#4-接口用例设计要点" class="headerlink" title="4.接口用例设计要点"></a>4.接口用例设计要点</h4><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/FykjVIauJDlTn87.png" alt="1232840-20190311114933454-1292109063.png"> </p><p>主要从四个方面来设计接口用例：功能，逻辑业务，异常，安全</p><p>功能：</p><p>1）功能是否正常；</p><p>2）功能是否按照接口文档实现</p><pre><code>   举例：比如博客园添加随笔，需要登录才能添加。也就是业务要求不支持游客添加随笔功能，如果设计一个没有登录的用户，然后去测试添加随笔接口，结果接口能添加到随笔，说明功能不正常，不符合需求和接口文档描述。</code></pre><p>逻辑业务：是否依赖业务；<br>      举例：该接口调用之前，需要调用登录接口，如果不登录也能请求数据，不符合业务规则。</p><p>异常：参数异常和数据异常<br>参数异常：关键字参数，参数为空，多，少参数，错误参数</p><p>数据异常：关键字数据，数据为空，长度不一致，错误数据<br>         举例：不管数据异常还是参数异常，测试点差不多，一个参数有key和value，key表示参数，value表示数据。第一，看看参数和数据能不能支持关键字，例如Java中的保留关键字等等。第二个就是参数和数据都为空，看看是否做了判断。第三个，参数多和少，例如有两个参数的接口，你需要设计一个三个参数的用例，一个只有一个参数的用例。数据那边长度不一致，例如设计很长的字符串是否支持，因为数据库创建表过程都设置好了每个字段的长度。输入错误的参数和数据，例如故意输出单词等等。</p><p>安全测试用例设计：<br>1)cookie：有cookie才能获取数据，如果不带cookie还有信息返回，说明有问题<br>2)header：正常接口带header信息，删除header看是否能够返回数据。<br>3)唯一识别码：app手机识别码，一般是唯一的。</p><p>安全测试主要从上面三点检查。第三个是唯一识别码，主要是指app上手机的识别码，一般很少用到，除非很严格的接口测试，例如银行app登录，需要指纹，而指纹来源手机，一般有一个手机识别码判断过程。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化2</title>
      <link href="/2016/02/15/interface/"/>
      <url>/2016/02/15/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（二）–什么是接口测试、为什么要做接口测试（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　上一篇和大家一起科普扫盲接口后，知道什么是接口，接口类型等，对其有了大致了解之后，我们就回到主题-接口测试。</p><h4 id="2-什么是接口测试"><a href="#2-什么是接口测试" class="headerlink" title="2.什么是接口测试"></a>2.什么是接口测试</h4><p>　　接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。　<br>　　一般来说，测试接口，就是指测试接口的功能，性能和稳定性测试，当然可能还有安全性测试。这个入门系列会让你掌握接口的功能测试。一般，来说我们听说到的接口基本上都是指HTTP或者HTTPS协议的接口测试，也就是一些web服务请求。一个软件项目中，<br>有很多接口，少的有几十个，多的有几百上千个接口。这个时候，我们没有软件界面，没有具体的测试场景，只有一个接口描述文档。我们需要把接口这样抽象的东西，通过软件测试的理论和方法去测试接口，找出接口的功能和安全性的缺陷。接口有内部接口和外部<br>接口。内部接口就是开发人员自己开发的接口。外部接口，好比网站调用微信支付和支付宝支付接口。还有一些模块与模块之间的接口。学习过Java或者用过selenium的人，应该对接口有了解。你的自动化脚本调用了很多selenium的接口。</p><h4 id="3-为什么要做接口测试"><a href="#3-为什么要做接口测试" class="headerlink" title="3.为什么要做接口测试"></a>3.为什么要做接口测试</h4><p>1、现在很多系统前后端架构是分离的，因为不同端（前段，后端）的工作进度不一样，所以我们要针对最开始出来的接口，以及需要调用其他公司的（银行，支付宝，微信，qq等）一些接口进行接口测试及验证数据，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前端太容易了）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。在这种情况下就需要从接口层面进行验证。前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。</p><p>2、如今系统越来越复杂，传统的靠前端测试已经大大降低了效率，而且现在我们都推崇测试前移也叫测试左移，希望测试能更早的介入测试，那接口测试就是一种及早介入的方式。例如传统测试，你是不是得等前后端都完成你才能进行测试，才能进行自动化代码编写。 而如果是接口测试，只需要前后端定义好接口，那这时自动化就可以介入编写接口自动化测试代码，手工测试只需要后端代码完成就可以介入测试后端逻辑而不用等待前端工作完成。<br>　　测试左移这个是一次偶然的机会在群里看到的，孤陋寡闻的我，第一次看到，也是一知半解，后来查了一些资料供大家参考。<br>　　测试左移的原则支持测试团队在软件开发周期早期和所有干系人合作。因此他们能清晰地理解需求以及设计测试用例去帮助软件“快速失败”，促使团队更早的修改所有的bug。　　<br>　　测试左移并没有什么独特的，只是让测试人员在软件开发生命周期内更早的参与进来，同时让他们去理解需求、软件设计、软件架构以及软件功能，也让他们去向客户、商业分析师和开发人员问问题，寻找答案，提供反馈结果已达到支持团队的工作得可能性。参与和理解会使测试人员获取产品完整的知识，彻底想清楚各种场景，根据软件行为设计实时的场景，这些都会帮助团队在编码完成之前识别出一些缺陷。这样也可以更好的的体现我们作为一个QA的价值体                                                                </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/jmKF6hX5nJS4skf.png" alt="1232840-20190312085202817-981337531.png"></p><p>​                                                                         金字塔模型<br>通过之前对金字塔结构的学习，大概了解到了金字塔模型想告诉我们的几个道理：</p><p>　　1.越底层，越稳定。</p><p>　　金字塔主要观点认为单元测试的稳定性高，需要多投入。</p><p>　　2.越底层，越高效。</p><p>　　程序的问题，最终还得落在具体的代码上，所以底层的测试更容易发现问题。</p><p>　　3.越底层，越低成本。</p><p>　　越底层测试能越早发现问题，越早发现问题，修复的成本自然越低。</p><p>　　4.越底层，越难实施。</p><p>　　越底层的实现对技术专业性要求越高，这点跟第三点有点矛盾，往往越专业的人才也意味着人力成本越高。</p><p>　　综合下金字塔模型，随着前后端分离越来越清晰，我个人愚见提出了灯笼模型，拿接口测试和UI层测试以及单元测试做了比较，从图中各部分所占有的比重，可以一目了然的看出并最终认定接口（API）测试可以获得较高的投资回报。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/keSiMygwFYq2BZH.png" alt="1232840-20190312084032485-331187664.png"></p><p>​                                                                            灯笼模型<br>　　个人愚见，如有过错，请批评指正：<br>　　接口将前端和后端进行很好的分离，帮前后端实现数据交互，这样在项目初期就可以和前端工程师讨论需要的后端数据，然后后端根据需求开发后接口，将数据返回给前端，测试人员提前进入测试接口，前后端然后在各自开发自己模块。</p><p> 项目迁移，以及后期维护，接口带来的便利性，试想一下，如果没有项目交付以后，后端人员将数据库的某个字段的长度、类型修改后发版，而由于某些原因没有及时通知前端工程师，而此时前端的获取的这个字段的类型、长度是以前的，那么就可能引发线上事故。如</p><p>果前端技术牛叉，存储获取字段是一个变量，工作量还小点。只需要改变变量类型、长度即可，如果是一个差一点的没有用变量，而前端又是好几百个页面都用到这个字段，这样就造成后果无法想象的，但是用到接口就有不一样了，如果出现类似的情况，后端人员只需</p><p>要将这个字段通过接口做处理是返回的字段保持一致即可，也就是分分钟的事，可能用户都没有察觉就修复了。而且前端、后端、测试也很好排查问题，跑一下接口，查看接口文档返回数据有差异，修给接口就可以，这样处理问题效率也会大大提高。</p><p>　　简单概括：</p><p>①.越底层发现bug，它的修复成本是越低的。</p><p>②.前端随便变，接口测好了，后端不用变，前后端是两拨人开发的。</p><p>③.检查系统的安全性、稳定性，前端传参不可信，比如京东购物，前端价格不可能传入-1元，但是通过接口可以传入-1元。</p><p>④.如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，接口测试可以提供这种情况下的解决方案。</p><p>⑤. 接口测试相对容易实现自动化持续集成，且相对UI自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。</p><p>⑥.   现在很多系统前后端架构是分离的，从安全层面来说：</p><p>(1)、只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。</p><p>(2)、前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python接口自动化1</title>
      <link href="/2016/02/14/interface/"/>
      <url>/2016/02/14/interface/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥 python接口自动化（一）–什么是接口、接口优势、类型（详解）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　经常听别人说接口测试，接口测试自动化，但是你对接口，有多少了解和认识，知道什么是接口吗？它是用来做什么的，测试时候要注意什么？坦白的说，笔者之前也不是很清楚。接下来先看一下接口的定义。</p><h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h4><p>　　接口泛指实体把自己提供给外界的一种抽象化物（可以为另一实体），用以由内部操作分离出外部沟通方法，使其能被内部修改而不影响外界其他实体与其交互的方式。</p><p>　　人类与电脑等信息机器或人类与程序之间的接口称为用户界面。电脑等信息机器硬件组件间的接口叫硬件接口。电脑等信息机器软件组件间的接口叫软件接口。</p><p>　　在计算机中，接口是计算机系统中两个独立的部件进行信息交换的共享边界。这种交换可以发生在计算机软、硬件，外部设备或进行操作的人之间，也可以是它们的结合。</p><h4 id="3-接口的优势"><a href="#3-接口的优势" class="headerlink" title="3.接口的优势"></a>3.接口的优势</h4><p>　　一、规范性</p><p>　　接口就是规范，在整个系统设计中，涉及到很多层，为了使各个层之间调用透明话，你只需要知道接口，按照这个接口做你具体做的事情，就可以融合到整个系统中了。</p><p>　　生活中的例子很多，例如：插头、插座，有标准的规范告诉你插头应该是几个脚，插座是几个孔等等，做插头、插座的公司就是根据这个规范来做插头、插座，而不需要做完一个插头就跑遍全世界去试用一下这个插头做的对不对。</p><p>　　二、扩展性</p><p>　　在项目开发过程中，由于客户的需求经常变化，如果不采用接口，那么我们必须不停改写现有的业务代码。改写代码可能产生新的BUG，而且改写代码还会影响到调用该业务的类，可能全都需要修改，影响系统本身的稳定性。到最后，可能会出现代码凌乱，不易读懂，</p><p>　　后接手的人无法读懂代码，系统的维护工作越来越重，最终可能导致项目失败。</p><p>　　三、接口在项目就是一个业务逻辑，面向接口编程就是先把客户的业务提取出来，作为接口。业务具体实现通过该接口的实现类来完成。当客户需求变化时，只需编写该业务逻辑的新的实现类，不需要改写现有代码，减少对系统的影响。从而让项目具有更大的扩展性。</p><h4 id="4-常见的接口类型"><a href="#4-常见的接口类型" class="headerlink" title="4.常见的接口类型"></a>4.常见的接口类型</h4><p>　　接口是指外部系统与系统之间以及内部各子系统之间的交互点。包括外部接口、内部接口，内部接口又包括：上层服务与下层服务接口、同级接口。</p><p>　　常见web接口：一类是http协议的接口，另一类是web service接口（如soup、rmi、rpc协议）。本文主要介绍http请求接口。</p><p>　　常见的http请求方式包括：get（查）、post（增），除此之外还有put（改）、delete（删）等。日常工作中见到的最多的是get和post两种。</p><p> 　　GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。</p><p>　　 POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。它用来向指定资源提交数据进行处理请求（例如：提交表单和上传文件），数据包被包含在请求体中，post请求可能导致新的资源的建立或者已有的资源的修改。</p><p>　　 PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。客户端向服务器传送的数据取代指定文档的内容。</p><p>　　 举个例子：如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。</p><p>　　DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p><h5 id="1）get型接口"><a href="#1）get型接口" class="headerlink" title="1）get型接口"></a>1）get型接口</h5><p>格式：请求数参数写在网址后面，用”?”连接，多个参数之间用”&amp;”连接。如：<a href="https://api.douban.com/v2/book/search?q=&#39;&#39;,这是一个豆瓣查询图书信息的开发api，q=&#39;&#39;，单引号里就是查询的参数，如查询《小王子》这本书的信息，则q=&#39;小王子&#39;，使用postman工具来试验一下，如下图：" target="_blank" rel="noopener">https://api.douban.com/v2/book/search?q=&#39;&#39;,这是一个豆瓣查询图书信息的开发api，q=&#39;&#39;，单引号里就是查询的参数，如查询《小王子》这本书的信息，则q=&#39;小王子&#39;，使用postman工具来试验一下，如下图：</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/eMco3dwbqEkOKx5.png" alt="1232840-20190307155704927-1228173401.png"></p><p>场景：get型接口用于获取信息，多用于查询数据，如列表查询功能，点击查询按钮就调用一个get接口，然后把信息返回出来</p><p>特点：1）请求数据量小，2）参数暴露于url地址中，故存在安全隐患</p><h5 id="2）post型接口"><a href="#2）post型接口" class="headerlink" title="2）post型接口"></a>2）post型接口</h5><p>说明：向指定资源位置提交数据（如提交表单、上传文件）来进行请求，post请求可能会导致新资源的建立</p><p>场景：如注册、上传、发帖等功能，如用户在豆瓣网站对某本书进行收藏、写笔记、发表评论</p><p>特点：请求数据量大，安全性高</p><p>如豆瓣的发表评论的开放api，见下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/TXKlw5hJRULQNWr.png" alt="1232840-20190307155722927-1016151054.png"></p><h5 id="3）put型接口"><a href="#3）put型接口" class="headerlink" title="3）put型接口"></a>3）put型接口</h5><p>说明：put请求用于向指定资源位置上传最新内容</p><p>场景：如用户在豆瓣网站修改对某本书的收藏、修改某篇笔记或修改评论</p><p>如豆瓣的修改评论的开放api，见下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/Lg7Duw8tq3OBHrX.png" alt="1232840-20190307155734127-617712613.png"></p><h5 id="4）delete型接口"><a href="#4）delete型接口" class="headerlink" title="4）delete型接口"></a>4）delete型接口</h5><p>说明：请求服务器删除请求里url所标识的资源</p><p>场景：如用户在豆瓣网站取消对某本书的收藏、删除某篇笔记或删除评论</p><p>如豆瓣的删除评论的开放api，见下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/hfXgMDK4UwA7JE6.png" alt="1232840-20190307155748988-302529172.png"></p><h4 id="5-不常见的接口类型（了解即可）"><a href="#5-不常见的接口类型（了解即可）" class="headerlink" title="5.不常见的接口类型（了解即可）"></a>5.不常见的接口类型（了解即可）</h4><p>  　　不常见的http请求方式包括：head、connect、options和trace。</p><p>　　  head：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。换句话说，就是返回响应中没有具体内容，只获取报头。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p><p>　　  connect：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p>　　  options：这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。允许客户端查看服务器的性能。</p><p>　　  trace：回显服务器收到的请求，主要用于测试和诊断。</p><h4 id="6-附录（get和post的区别）"><a href="#6-附录（get和post的区别）" class="headerlink" title="6.附录（get和post的区别）"></a>6.附录（get和post的区别）</h4><p>这个问题，面试中经常被提到。简单来说，可以从三个方面去回到这个区别:方式、大小、安全</p><p>1）.方式</p><p>方式指的是参数的传入方式，GET方法一般是指获取服务器上的数据，参数直接跟着URL后边，直接可以放到浏览器地址栏里，例如登录就是采用GET方法。而POST方法是指客户端给服务器上提交表单数据，所以POST是通过表单提交的，例如你网页上的新用户的注册、调查问卷和答题就是采用POST方法。</p><p>2）.大小</p><p>上面已经知道GET是直接在浏览器地址栏输入，由于浏览器有限制，一般整个URL的长度可以很长，但是不能超过2049KB的大小限制，而这个POST就没有大小限制。</p><p>3）.安全性</p><p>由于GET的参数是在浏览器地址栏直接拼接，暴露在互联网中，肯定不安全。POST是通过表单数据提交，相对比GET方法更安全。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Interface </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试26</title>
      <link href="/2016/02/13/selenium/"/>
      <url>/2016/02/13/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇9-最新的chromedriver与chrome的对应关系表</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　看到网上基本没有最新的chromedriver与chrome的对应关系表，便兴起整理了一份如下，希望对大家有用。小伙伴们就不用下载低版本的谷歌浏览器而发愁了，还有就是由于谷歌浏览器和驱动的版本不匹配，造成测试过程中的各种报错。</p><h4 id="2-chromedriver版本支持的Chrome版本"><a href="#2-chromedriver版本支持的Chrome版本" class="headerlink" title="2.chromedriver版本支持的Chrome版本"></a>2.chromedriver版本支持的Chrome版本</h4><p>　　如下表所示：</p><table><thead><tr><th align="center">chromedriver版本</th><th align="center">支持的Chrome版本</th></tr></thead><tbody><tr><td align="center">v2.43</td><td align="center">v69-71</td></tr><tr><td align="center">v2.42</td><td align="center">v68-70</td></tr><tr><td align="center">v2.41</td><td align="center">v67-69</td></tr><tr><td align="center">v2.40</td><td align="center">v66-68</td></tr><tr><td align="center">v2.39</td><td align="center">v66-68</td></tr><tr><td align="center">v2.38</td><td align="center">v65-67</td></tr><tr><td align="center">v2.37</td><td align="center">v64-66</td></tr><tr><td align="center">v2.36</td><td align="center">v63-65</td></tr><tr><td align="center">v2.35</td><td align="center">v62-64</td></tr><tr><td align="center">v2.34</td><td align="center">v61-63</td></tr><tr><td align="center">v2.33</td><td align="center">v60-62</td></tr><tr><td align="center">v2.32</td><td align="center">v59-61</td></tr><tr><td align="center">v2.31</td><td align="center">v58-60</td></tr><tr><td align="center">v2.30</td><td align="center">v58-60</td></tr><tr><td align="center">v2.29</td><td align="center">v56-58</td></tr><tr><td align="center">v2.28</td><td align="center">v55-57</td></tr><tr><td align="center">v2.27</td><td align="center">v54-56</td></tr><tr><td align="center">v2.26</td><td align="center">v53-55</td></tr><tr><td align="center">v2.25</td><td align="center">v53-55</td></tr><tr><td align="center">v2.24</td><td align="center">v52-54</td></tr><tr><td align="center">v2.23</td><td align="center">v51-53</td></tr><tr><td align="center">v2.22</td><td align="center">v49-52</td></tr><tr><td align="center">v2.21</td><td align="center">v46-50</td></tr><tr><td align="center">v2.20</td><td align="center">v43-48</td></tr><tr><td align="center">v2.19</td><td align="center">v43-47</td></tr><tr><td align="center">v2.18</td><td align="center">v43-46</td></tr><tr><td align="center">v2.17</td><td align="center">v42-43</td></tr><tr><td align="center">v2.13</td><td align="center">v42-45</td></tr><tr><td align="center">v2.15</td><td align="center">v40-43</td></tr><tr><td align="center">v2.14</td><td align="center">v39-42</td></tr><tr><td align="center">v2.13</td><td align="center">v38-41</td></tr><tr><td align="center">v2.12</td><td align="center">v36-40</td></tr><tr><td align="center">v2.11</td><td align="center">v36-40</td></tr><tr><td align="center">v2.10</td><td align="center">v33-36</td></tr><tr><td align="center">v2.9</td><td align="center">v31-34</td></tr><tr><td align="center">v2.8</td><td align="center">v30-33</td></tr><tr><td align="center">v2.7</td><td align="center">v30-33</td></tr><tr><td align="center">v2.6</td><td align="center">v29-32</td></tr><tr><td align="center">v2.5</td><td align="center">v29-32</td></tr><tr><td align="center">v2.4</td><td align="center">v29-32</td></tr></tbody></table><h4 id="3-chromedriver各个版本下载地址"><a href="#3-chromedriver各个版本下载地址" class="headerlink" title="3.chromedriver各个版本下载地址"></a>3.chromedriver各个版本下载地址</h4><p>附：<br>所有chromedriver均可在下面链接中下载到：</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>有些同学说下不了，到taobao下也是可以的：</p><p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试25</title>
      <link href="/2016/02/12/selenium/"/>
      <url>/2016/02/12/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇8-年底升职加薪，年终奖就差最后这一步你知道不？？？</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　到上一篇为止，测试报告已经完美的生成，但是你此时不要沾沾自喜，因为还差点意思，你才能升职加薪、拿年终奖。差点啥了？？？听宏哥给你慢慢道来。那就是把你生成的高端大气上档次的测试报告给领导展示一番，吹嘘一番。不把测试报告发出去好好地在领导面前表现一番，你留着生娃过年吗？这马上就新年了，你还真的留着它生娃啊？？？辛苦了这么久升职加薪，拿年终奖就靠这一把了。今天这篇文章宏哥就给小伙伴和童鞋们来答疑解惑了，当然了方式方法多种多样的，你可以通过邮件、QQ、微信将测试报告附件手动写邮件发送给相关负责人。这里宏哥讲解如何将测试报告自动发送给相关的负责人。</p><h4 id="2-框架结构"><a href="#2-框架结构" class="headerlink" title="2.框架结构"></a>2.框架结构</h4><p>　　先一睹为快，看看宏哥把邮件模块放在那里了，宏哥认为这个也是固定的只要封装好，在需要用到的地方进行导入和调用就可以了。因为宏哥将它放在了framework文件夹下，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/91Ozt6BWSKahfCo.png" alt="1232840-20191226101542466-436823471.png"></p><h4 id="3-邮件模块封装"><a href="#3-邮件模块封装" class="headerlink" title="3.邮件模块封装"></a>3.邮件模块封装</h4><p>　　上边都说了，我们需要封装，因此这里给小伙伴或童鞋们分享一下邮件模块的封装，封装将最新的测试报告发送给测试负责人或者是领导，让他们看看你的成果，这个是你升职加薪，年终奖的砝码。相关代码如下：</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/BWrT1c6KACbPpe9.png" alt="1232840-20191226103229084-1376317205.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-12@author:北京-宏哥QQ交流群：705269076Project:《一头扎进》系列之Python+Selenium自动化测试框架实战篇8-年底了还没升职加薪，年终奖全靠它了！！！&#39;&#39;&#39;#3.导入模块importos,sysimportsmtplibimporttimefromemail.mime.textimportMIMETextfromemail.mime.multipartimportMIMEMultipart#reportPath=os.path.join(os.getcwd(),&#39;test_report&#39;)#测试报告的路径reportPath=os.path.dirname(os.path.abspath(&#39;.&#39;))+&#39;/test_report/&#39;#reportPath=&quot;E:\\untitled\\automation_framework_demo\\test_report&quot;#测试报告的路径print(&quot;打印路径：&quot;)print(reportPath)classSendMail(object):defget_report(self):#该函数的作用是为了在测试报告的路径下找到最新的测试报告dirs=os.listdir(reportPath)dirs.sort()newreportname=dirs[-1]print(&#39;Thenewreportname:{0}&#39;.format(newreportname))returnnewreportname#返回的是测试报告的名字deftake_messages(self):#该函数的目的是为了准备发送邮件的的消息内容newreport=self.get_report()self.msg=MIMEMultipart()self.msg[&#39;Subject&#39;]=&#39;BBAJIT自动化测试报告&#39;#邮件的标题self.msg[&#39;date&#39;]=time.strftime(&#39;%a,%d%b%Y%H:%M:%S%z&#39;)withopen(os.path.join(reportPath,newreport),&#39;rb&#39;)asf:mailbody=f.read()#读取测试报告的内容html=MIMEText(mailbody,_subtype=&#39;html&#39;,_charset=&#39;utf-8&#39;)#将测试报告的内容放在邮件的正文当中self.msg.attach(html)#将html附加在msg里#html附件下面是将测试报告放在附件中发送att1=MIMEText(mailbody,&#39;base64&#39;,&#39;utf-8&#39;)att1[&quot;Content-Type&quot;]=&#39;application/octet-stream&#39;att1[&quot;Content-Disposition&quot;]=&#39;attachment;filename=&quot;TestReport.html&quot;&#39;#这里的filename可以任意写，写什么名字，附件的名字就是什么self.msg.attach(att1)defsend(self):#recipients=[&#39;xxxx@xxxx.com&#39;,&#39;xxxx@qq.com&#39;,&#39;xxx@xxxxx.com&#39;]#发送给多个人recipients=[&#39;hgxxx@nnnx.cn&#39;]#发送给一个人self.take_messages()self.msg[&#39;from&#39;]=&#39;hg@xxx.cn&#39;#发送邮件的人，这种是公司邮箱转发#self.msg[&#39;to&#39;]=recipients#收件人和发送人必须这里定义一下，执行才不会报错。toaddrs=recipientssmtp=smtplib.SMTP()smtp.connect(&#39;smtp.mxhichina.com&#39;)smtp.ehlo()smtp.login(&#39;hg@xxx.cn&#39;,&#39;*******xxxx&#39;)smtp.sendmail(self.msg[&#39;from&#39;],toaddrs,self.msg.as_string())#发送邮件smtp.close()print(&#39;sendmailsuccess&#39;)if__name__==&#39;__main__&#39;:sendMail=SendMail()sendMail.send()</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/vYXhzRk8gKCL4V3.png" alt="1232840-20191226103344161-1629913332.png"></p><h5 id="3-4验证是否是最新测试报告"><a href="#3-4验证是否是最新测试报告" class="headerlink" title="3.4验证是否是最新测试报告"></a>3.4验证是否是最新测试报告</h5><p>从3.3中控制台运行结果宏哥打印的结果看出最新的测试报告是：</p><p>Thenewreportname:2019-12-25-11_03_42HTMLtemplate.html<br>我们去存储测试报告文件的test_report文件夹看一下是不是这个：是不是最新的测试报告</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/vULwTA8DcrsE7py.png" alt="1232840-20191226132033906-829957124.png"></p><p>综上所述：从控制台打印结果和测试报告文件夹的测试报告文件比较，我们可以清楚地看出二者一致，证明达到了预期的结果。</p><h4 id="4-查看收件箱"><a href="#4-查看收件箱" class="headerlink" title="4.查看收件箱"></a>4.查看收件箱</h4><h5 id="4-1查看收件箱"><a href="#4-1查看收件箱" class="headerlink" title="4.1查看收件箱"></a>4.1查看收件箱</h5><p>在邮件的收件箱中查看到，我们刚刚发送的邮件如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/yvYOBb1E3jTifDd.png" alt="1232840-20191226104343594-1833421715.png"></p><h5 id="4-2查看邮件内容"><a href="#4-2查看邮件内容" class="headerlink" title="4.2查看邮件内容"></a>4.2查看邮件内容</h5><p>点击查看邮件内容如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/k6aSNEDl4fQseZM.png" alt="1232840-20191226104053288-1978326421.png"></p><h5 id="4-3查看邮件附件"><a href="#4-3查看邮件附件" class="headerlink" title="4.3查看邮件附件"></a>4.3查看邮件附件</h5><p>用浏览器打开附件预览查看如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/SBKpTJkQqifU6m4.png" alt="1232840-20191226104227906-294137950.png"></p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>Q：最后说明一下，有的小伙伴或者童鞋们私下会问，那个测试报告能不能在邮件里像在浏览器里一样可以点击？<br>A：不可以的生成的文件是HTML文件，邮件客户端解析不了，可以通过附件用浏览器打开查看，可以发一个最新测试报告ur地址，点击在浏览器上访问查看测试报告</p><p>　　好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。有问题加群交流讨论！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试24</title>
      <link href="/2016/02/11/selenium/"/>
      <url>/2016/02/11/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇7-年底升职加薪，年终奖全靠它！</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><pre><code>截止到上一篇文章为止，框架基本完全搭建完成。那么今天我们要做什么呢？？？？聪明如你的小伙伴或者是童鞋一定已经猜到了，都测试完了，当然是要生成一份高端大气上档次的测试报告了。没错的，今天宏哥就带领你们将这部分内容也集成到这个框架中。本文来介绍如何生成自动化测试报告，前面文章尾部提到了利用HTMLTestRunner.py来生成自动化测试报告。关于HTMLTestRunner不过多介绍，只需要知道是一个能生成一个HTML格式的网页报告就可以，其他的如果你特别感兴趣可以自己去搜索查询资料。我们需要在宏哥前边介绍的自动化框架里面继承一个报告输出，直接来看看效果。</code></pre><h4 id="2-测试报告效果"><a href="#2-测试报告效果" class="headerlink" title="2.测试报告效果"></a>2.测试报告效果</h4><h5 id="2-1测试报告文件"><a href="#2-1测试报告文件" class="headerlink" title="2.1测试报告文件"></a>2.1测试报告文件</h5><p>　　我们从下图中，可以清楚地看到在test_report文件夹下生成的测试报告</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/BwSHpgm9yCNcUFT.png" alt="1232840-20191225101738291-455174797.png"></p><h5 id="2-2浏览器预览效果"><a href="#2-2浏览器预览效果" class="headerlink" title="2.2浏览器预览效果"></a>2.2浏览器预览效果</h5><p>　　因为生成的是.html文件，所以这里用浏览器打开我们看一下效果如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/ovIEXbL5SYzwNhx.png" alt="1232840-20191225104053939-876176632.png"></p><h4 id="2-3实现"><a href="#2-3实现" class="headerlink" title="2.3实现"></a>2.3实现</h4><p>　　这里我们报告输出代码写到了，负责执行测试套件TestRunner.py这个文件。相关代码如下：</p><p>TestRunner.py</p><h5 id="2-3-1代码实现"><a href="#2-3-1代码实现" class="headerlink" title="2.3.1代码实现"></a>2.3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/YiCOXdWl3nDuvet.png" alt="1232840-20191225104707272-1698353446.png"></p><h5 id="2-3-2参考代码"><a href="#2-3-2参考代码" class="headerlink" title="2.3.2参考代码"></a>2.3.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-25@author:北京-宏哥QQ交流群：705269076Project:《一头扎进》系列之Python+Selenium自动化测试框架实战篇7-年底了还没升职加薪，年终奖全靠它了！！！&#39;&#39;&#39;#3.导入模块fromautomation_framework_demo.testsuitsimportHTMLTestReportCNimportosimportunittestimporttimefromautomation_framework_demo.framework.SendEmailimportSendMail#设置报告文件保存路径report_path=os.path.dirname(os.path.abspath(&#39;.&#39;))+&#39;/test_report/&#39;print(&#39;report_path&#39;+report_path)#获取系统当前时间now=time.strftime(&quot;%Y-%m-%d-%H_%M_%S&quot;,time.localtime(time.time()))#设置报告名称格式HtmlFile=report_path+now+&quot;HTMLtemplate.html&quot;#fp=file(HtmlFile,&quot;wb&quot;)fp=open(HtmlFile,&quot;wb&quot;)#用例路径case_path=os.path.join(os.getcwd(),&#39;&#39;)print(&#39;case_path&#39;,case_path)#构建suite#suite=unittest.TestLoader().discover(case_path,&quot;test_baidu_search.py&quot;,top_level_dir=None)suite=unittest.TestLoader().discover(case_path,&quot;baidu_search1.py&quot;,top_level_dir=None)if__name__==&#39;__main__&#39;:#初始化一个HTMLTestRunner实例对象，用来生成报告runner=HTMLTestReportCN.HTMLTestRunner(stream=fp,title=u&quot;Python+Selenium自动化测试框架实战篇7项目演示测试报告&quot;,description=u&quot;用例测试情况&quot;)#开始执行测试套件runner.run(suite)#runner=unittest.TextTestRunner()#runner.run(suite)fp.close()</code></pre><h5 id="2-3-3运行结果"><a href="#2-3-3运行结果" class="headerlink" title="2.3.3运行结果"></a>2.3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/WN7ORKugJ6FTpME.png" alt="1232840-20191225110559083-366348877.png"></p><h5 id="2-3-4测试报告预览"><a href="#2-3-4测试报告预览" class="headerlink" title="2.3.4测试报告预览"></a>2.3.4测试报告预览</h5><p>测试报告用浏览器打开截图，在你项目文件路径下，找到这个HTML的报告，用本地浏览器打开。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/JLGuH4a1RSpBOio.png" alt="1232840-20191225110745632-240361636.png"></p><p>如何生成自动化测试报告就介绍到这里。</p><h4 id="3-测试报告模板插件"><a href="#3-测试报告模板插件" class="headerlink" title="3.测试报告模板插件"></a>3.测试报告模板插件</h4><p>　　宏哥这里为了方便，直接将测试报告的模板插件，直接放在了testsuits的文件下，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/JlwyRHDcOk3Z24P.png" alt="1232840-20191225112002675-1812521548.png"></p><p>　　如果有洁癖的小伙伴或者童鞋们，可以自己建一个文件夹专门来存储这个模板插件也可以的，但是不要忘记了最重要的一条就是将其导入，否则可能会报找不到的错误哦！</p><h4 id="4-导入测试报告模板插件"><a href="#4-导入测试报告模板插件" class="headerlink" title="4.导入测试报告模板插件"></a>4.导入测试报告模板插件</h4><p>　　如何导入？其实很简单的，就像python导入其他模块一样。例如宏哥这里的导入方法如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/m2s1LUW5KlRAJrQ.png" alt="1232840-20191225112251075-1997478372.png"></p><p>　　宏哥总结如下：</p><p>from文件夹路径import插件名字.py</p><h4 id="5-执行所有测试用例"><a href="#5-执行所有测试用例" class="headerlink" title="5.执行所有测试用例"></a>5.执行所有测试用例</h4><p>　　除了上一篇那种找到文件夹，执行所有测试用例，我们还有别的方法执行所有测试用例吗？当然有，但是对测试用例的名字的命名有要求，其实也不是硬性要求，只不过是为了后边我们的正则表达式好写，这里命名就规范一些。</p><h5 id="5-1命名规则"><a href="#5-1命名规则" class="headerlink" title="5.1命名规则"></a>5.1命名规则</h5><p>　　所有测试用例的名字都以test开头，例如：test_login.py。</p><h5 id="5-2正则表达式"><a href="#5-2正则表达式" class="headerlink" title="5.2正则表达式"></a>5.2正则表达式</h5><p>　　正则表达式：test*.py</p><h5 id="5-3代码实现"><a href="#5-3代码实现" class="headerlink" title="5.3代码实现"></a>5.3代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/NGDYkuqCjKEtdiS.png" alt="1232840-20191225114324614-417827525.png"></p><h5 id="5-4参考代码"><a href="#5-4参考代码" class="headerlink" title="5.4参考代码"></a>5.4参考代码</h5><pre><code>#构建suite#suite=unittest.TestLoader().discover(case_path,&quot;test_baidu_search.py&quot;,top_level_dir=None)suite=unittest.TestLoader().discover(case_path,&quot;test*.py&quot;,top_level_dir=None)</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>　　好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。有问题加群交流讨论！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试23</title>
      <link href="/2016/02/10/selenium/"/>
      <url>/2016/02/10/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium自动化测试框架实战篇6 - 价值好几K的框架，呦！这个框架还真牛叉哦！！！</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　本文开始介绍如何通过unittest来管理和执行测试用例，这一篇主要是介绍unittest下addTest()方法来加载测试用例到测试套件中去、用addTest()方法来加载我们测试用例到suite中去和利用discover（）方法去加载一个路径下所有的测试用例。</p><h4 id="2-addTest-方法"><a href="#2-addTest-方法" class="headerlink" title="2.addTest()方法"></a>2.addTest()方法</h4><p>　　这里首先介绍unittest下addTest()方法来加载测试用例到测试套件中去。为了演示效果，我在前面文章的脚本基础上，新建了一个测试脚本，这个测试脚本有一个测试用例，加上前面的测试脚本，一共就是三个测试用例，前面那个测试类里面包括两个测试用例。</p><p>新建的测试脚本，test_get_page_title.py代码如下：</p><h5 id="2-1代码实现"><a href="#2-1代码实现" class="headerlink" title="2.1代码实现"></a>2.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/V36X4LOqKlpa2Dd.png" alt="1232840-20191224132149966-1764717942.png"></p><h5 id="2-2参考代码"><a href="#2-2参考代码" class="headerlink" title="2.2参考代码"></a>2.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-10@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，呦！这个框架还真牛叉哦！！！&#39;&#39;&#39;#3.导入模块importunittestfromautomation_framework_demo.framework.browser_engineimportBrowserEnginefromautomation_framework_demo.pageobjects.baidu_homepageimportHomePageclassGetPageTitle(unittest.TestCase):@classmethoddefsetUpClass(cls):browser=BrowserEngine(cls)cls.driver=browser.open_browser(cls)@classmethoddeftearDownClass(cls):cls.driver.quit()deftest_get_title(self):homepage=HomePage(self.driver)print(homepage.get_page_title())</code></pre><h5 id="2-3运行结果"><a href="#2-3运行结果" class="headerlink" title="2.3运行结果"></a>2.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/6IYCgkdpRoetVjW.png" alt="1232840-20191224132536084-1785300706.png"></p><pre><code>今天来学习下，如果加载这两个测试类文件里面的3个测试脚本。在unittest下有一个管理测试套件的叫TestSuit(),我们要使用这个测试套件，需要先初始化一个suite实例，然后这个实例有一个addTest()的方法，可以加载不同类里面的不同测试函数，格式这样的addTest(测试类的类名（‘测试函数名称，就是test开头的函数’）)，我们在testsuites这个包下新建一个TestRunner.py文件用来管理我们的用例启动方式。</code></pre><p>来看看这个TestRunner.py的内容</p><h5 id="2-4代码实现"><a href="#2-4代码实现" class="headerlink" title="2.4代码实现"></a>2.4代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/toTOAysxpML1wvB.png" alt="1232840-20191224134212835-1023501406.png"></p><h5 id="2-5参考代码"><a href="#2-5参考代码" class="headerlink" title="2.5参考代码"></a>2.5参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-10@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，呦！这个框架还真牛叉哦！！！&#39;&#39;&#39;#3.导入模块importunittest#fromautomation_framework_demo.testsuitsimporttestsuitsfromautomation_framework_demo.testsuits.baidu_search2importBaiduSearchfromautomation_framework_demo.testsuits.test_get_page_titleimportGetPageTitlesuite=unittest.TestSuite()suite.addTest(BaiduSearch(&#39;test_baidu_search&#39;))suite.addTest(BaiduSearch(&#39;test_search2&#39;))suite.addTest(GetPageTitle(&#39;test_get_title&#39;))if__name__==&#39;__main__&#39;:#执行用例runner=unittest.TextTestRunner()runner.run(suite)</code></pre><h5 id="2-6运行结果"><a href="#2-6运行结果" class="headerlink" title="2.6运行结果"></a>2.6运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/Lu3mKhn12BwAMZV.png" alt="1232840-20191224134524734-1802923986.png"></p><p>这个方法有没有局限性呢？当然有，加入你有几百个测试类，你是不是也一直这样手动去添加？有没有其他更好的方法去加载我们的测试脚本，关于这个问题，请紧跟宏哥的脚步继续往下看、往下走。</p><h4 id="3-makeSuite-方法"><a href="#3-makeSuite-方法" class="headerlink" title="3.makeSuite()方法"></a>3.makeSuite()方法</h4><p>前面文章介绍了如何用addTest()方法来加载我们测试用例到suite中去，本文介绍利用makeSuite()方法，一次性加载一个类文件下所有测试用例到suite中去。还是利用前面一篇文章中的测试脚本，来看看TestRunner.py如何写。</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/9BoX53xdQ2Rus7F.png" alt="1232840-20191224135340443-804441975.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-10@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，呦！这个框架还真牛叉哦！！！&#39;&#39;&#39;#3.导入模块importunittest#fromautomation_framework_demo.testsuitsimporttestsuitsfromautomation_framework_demo.testsuits.baidu_search2importBaiduSearchfromautomation_framework_demo.testsuits.test_get_page_titleimportGetPageTitle&#39;&#39;&#39;suite=unittest.TestSuite()suite.addTest(BaiduSearch(&#39;test_baidu_search&#39;))suite.addTest(BaiduSearch(&#39;test_search2&#39;))suite.addTest(GetPageTitle(&#39;test_get_title&#39;))&#39;&#39;&#39;suite=unittest.TestSuite(unittest.makeSuite(BaiduSearch))if__name__==&#39;__main__&#39;:#执行用例runner=unittest.TextTestRunner()runner.run(suite)</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/nM7YQskqCN1GBD6.png" alt="1232840-20191224135557765-2076744157.png"></p><p>缺陷:makeSuite()方法虽然比前面文章的addTest()方法有了一定的效率提升，在添加测试用例到测试套件过程。但是这个方法也有很多缺点，我不可能把所有项目脚本都放一个测试类文件吧。在unittest中还是有很多方法可以用来添加测试用例到suite中，makeSuite（类名称），只是一种，你可以多看看unittest的文档介绍。接下来我们介绍如何一次性加载一个文件目录下所有测试用例。</p><h4 id="4-discover-方法"><a href="#4-discover-方法" class="headerlink" title="4.discover()方法"></a>4.discover()方法</h4><p>　　继续接着介绍，如何利用unittest管理和执行测试用例的问题，这里我们还是利用之前已经有的三条测试用例，如果你跳过了前面文章，请回到框架设计篇的第八篇和第七篇，里面有相关测试类的文件。本文来介绍，如果利用discover（）方法去加载一个路径下所有的测试用例。这个方法是不是太适合我们现在的需求，例如我只需要跑testsuite包下所有测试用例，不管在里面有多少个包和多少个测试类，只需要用discover()搞定，来看看这个场景下TestRunner.py如何写。</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/okHawOrVQ1bSh9i.png" alt="1232840-20191224143400767-253767707.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-10@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，呦！这个框架还真牛叉哦！！！&#39;&#39;&#39;#3.导入模块importunittestsuite=unittest.TestLoader().discover(&quot;testsuits&quot;)if__name__==&#39;__main__&#39;:#执行用例runner=unittest.TextTestRunner()runner.run(suite)</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/nM7YQskqCN1GBD6.png" alt="1232840-20191224135557765-2076744157.png"></p><p>上面的testsuits是可以包名，也可以是一个文件夹名称，在实际脚本开发过程中，最后都采用这个方法来批量管理和执行几百上千的测试用例。下一篇内容，大概会介绍如何利用HTMLTestRunner.py这个开源的插件，生成测试报告，这个测试报告是一个HTML的格式。介绍完了生成报告文章，框架设计系列教程就会结束，不打算过多介绍其他技能点。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><h5 id="5-1报错提示：ImportError-Startdirectoryisnotimportable-’D-PyCharm-Workspace-testcases’"><a href="#5-1报错提示：ImportError-Startdirectoryisnotimportable-’D-PyCharm-Workspace-testcases’" class="headerlink" title="5.1报错提示：ImportError:Startdirectoryisnotimportable:’D:\PyCharm-Workspace\testcases’"></a>5.1报错提示：ImportError:Startdirectoryisnotimportable:’D:\PyCharm-Workspace\testcases’</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/qXy5HKSxJ3ZlRCm.png" alt="1675308-20191001111620992-2127202116.png"></p><p>以下两种路径实现代码存放在path.py中，查看区别：</p><pre><code>base_dir=os.path.dirname(os.getcwd())#第一种，当前目录#os.getcwd()定位路径为common#os.path.dirname(os.getcwd())定位路径为API_workbase_dir=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))#第二种，该代码存放的根目录#os.path.abspath(__file__)定位路径为path.py#os.path.dirname(os.path.abspath(__file__))定位路径为common#os.path.dirname(os.path.dirname(os.path.abspath(__file__)))定位路径为API_work</code></pre><p>以上两种方式，在path.py中执行，print输出均为：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/5nlBJzyp81fEPU9.png" alt="1675308-20191001113424453-318728047.png"></p><p>但第一种方式，在run.py中调用path.py中的base_dir属性，查找”test_*.py”的根目录就会出现下以报错：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/m9WJoCwYjiFDtOB.png" alt="1675308-20191001113706311-2074251121.png"></p><p>原因：</p><p>1、在run.py中调用path.py中的os.getcwd()代码，就是定位run.py的根目录；即：</p><pre><code>os.getcwd()定位路径为API_workos.path.dirname(os.getcwd())定位路径为API_work的上一层目录，因找不到上一层目录，所以报错；</code></pre><p>2、在run.py中调用第二种方式，是查找path.py的根目录，所以可执行正常；</p><p>总结：</p><p>　　其他模块会调用固定路径时，不要使用os.getcwd()当前定位方式来实现；使用os.path.abspath(<strong>file</strong>)实现。</p><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。有问题加群交流讨论</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试22</title>
      <link href="/2016/02/09/selenium/"/>
      <url>/2016/02/09/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架设计篇5 - 价值好几K的框架，哎呦！这个框架还真有点料啊！！！</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　其实，到前面这一篇文章，简单的Python+Selenium自动化测试框架就已经算实现了。接下来的主要是介绍，unittest管理脚本，如何如何加载执行脚本，再就是采用第三方插件，实现输出html的测试报告。本文来介绍下，在同一个类中，多个测试函数时候，测试固件如何写和进一步实现POM和可能遇到问题解决办法。</p><h4 id="2-一个类文件多个测试方法情况下测试固件的写法"><a href="#2-一个类文件多个测试方法情况下测试固件的写法" class="headerlink" title="2.一个类文件多个测试方法情况下测试固件的写法"></a>2.一个类文件多个测试方法情况下测试固件的写法</h4><p>为了说明这个问题，我们在之前的测试类基础上，再写一个test_search2()的测试用例，看看会发生什么。</p><h5 id="2-1代码实现"><a href="#2-1代码实现" class="headerlink" title="2.1代码实现"></a>2.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/LBxOzdb85Zwkvy9.png" alt="1232840-20191223084803867-1288555755.png"></p><h5 id="2-2参考代码"><a href="#2-2参考代码" class="headerlink" title="2.2参考代码"></a>2.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-23@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimeimportunittestfromautomation_framework_demo.framework.browser_engineimportBrowserEnginefromautomation_framework_demo.pageobjects.baidu_homepageimportHomePageclassBaiduSearch(unittest.TestCase):defsetUp(self):&quot;&quot;&quot;测试固件的setUp()的代码，主要是测试的前提准备工作:return:&quot;&quot;&quot;browse=BrowserEngine(self)self.driver=browse.open_browser(self)deftearDown(self):&quot;&quot;&quot;测试结束后的操作，这里基本上都是关闭浏览器:return:&quot;&quot;&quot;self.driver.quit()deftest_baidu_search(self):&quot;&quot;&quot;这里一定要test开头，把测试逻辑代码封装到一个test开头的方法里。:return:&quot;&quot;&quot;homepage=HomePage(self.driver)homepage.type_search(&#39;selenium&#39;)#调用页面对象中的方法homepage.send_submit_btn()#调用页面对象类中的点击搜索按钮方法time.sleep(2)homepage.get_windows_img()#调用基类截图方法try:assert&#39;selenium&#39;inhomepage.get_page_title()#调用页面对象继承基类中的获取页面标题方法print(&#39;TestPass.&#39;)exceptExceptionase:print(&#39;TestFail.&#39;,format(e))deftest_search2(self):homepage=HomePage(self.driver)homepage.type_search(&#39;python&#39;)#调用页面对象中的方法homepage.send_submit_btn()#调用页面对象类中的点击搜索按钮方法time.sleep(2)homepage.get_windows_img()#调用基类截图方法if__name__==&#39;__main__&#39;:unittest.main()</code></pre><h5 id="2-3运行结果"><a href="#2-3运行结果" class="headerlink" title="2.3运行结果"></a>2.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/qyuWI2iRdKbcTS6.png" alt="1232840-20191223084939432-1004526342.png"></p><p>问题发现了没，我们的浏览器启动和关闭了两次，是不是这个问题？其实细心地小伙伴或者童鞋们在上一篇文章里就可能发现这个问题了，由于时间的关系宏哥在这里把它单独拿出来分享讲解一下，希望可以加深小伙伴或者童鞋们的印象。问题是原来每执行一次</p><p>test开头的函数，都要执行一次测试固件，也就是说执行setUp()和()一次，如果有N个test开头的函数，测试固件就执行N次，我们到底有没有，只需要执行一次测试固件，支持执行多次测试函数。</p><p>我们测试中，肯定需要，打开一个页面，然后测试这个页面的多个用例，才关闭这个页面，去测试其他页面，在unittest是有相关测试固件方法去支持这种行为。请看下面调整，自己对比下，能不能找出不同。</p><h5 id="2-4代码实现"><a href="#2-4代码实现" class="headerlink" title="2.4代码实现"></a>2.4代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/w2M1LsNudFfkm4B.png" alt="1232840-20191223090926176-1529736228.png"></p><h5 id="2-5参考代码"><a href="#2-5参考代码" class="headerlink" title="2.5参考代码"></a>2.5参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-20@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇4-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimeimportunittestfromautomation_framework_demo.framework.browser_engineimportBrowserEnginefromautomation_framework_demo.pageobjects.baidu_homepageimportHomePageclassBaiduSearch(unittest.TestCase):@classmethoddefsetUpClass(cls):&quot;&quot;&quot;测试固件的setUp()的代码，主要是测试的前提准备工作:return:&quot;&quot;&quot;browse=BrowserEngine(cls)cls.driver=browse.open_browser(cls)@classmethoddeftearDownClass(cls):&quot;&quot;&quot;测试结束后的操作，这里基本上都是关闭浏览器:return:&quot;&quot;&quot;cls.driver.quit()deftest_baidu_search(self):&quot;&quot;&quot;这里一定要test开头，把测试逻辑代码封装到一个test开头的方法里。:return:&quot;&quot;&quot;#self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;selenium&#39;)#time.sleep(1)homepage=HomePage(self.driver)homepage.type_search(&#39;selenium&#39;)#调用页面对象中的方法time.sleep(12)homepage.send_submit_btn()#调用页面对象类中的点击搜索按钮方法time.sleep(12)homepage.get_windows_img()#调用基类截图方法print(self.driver.title)try:assert(&#39;selenium&#39;inHomePage.get_page_title(self))print(&#39;TestPass.&#39;)exceptExceptionase:print(&#39;TestFail.&#39;,format(e))deftest_search2(self):homepage=HomePage(self.driver)homepage.type_search(&#39;python&#39;)#调用页面对象中的方法homepage.send_submit_btn()#调用页面对象类中的点击搜索按钮方法time.sleep(2)homepage.get_windows_img()#调用基类截图方法if__name__==&#39;__main__&#39;:unittest.main()</code></pre><h5 id="2-6运行结果"><a href="#2-6运行结果" class="headerlink" title="2.6运行结果"></a>2.6运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/qyuWI2iRdKbcTS6.png" alt="1232840-20191223084939432-1004526342.png"></p><p>运行一下，是不是，只需要打开和关闭浏览器一次，就执行了2个搜索用例？以后，项目中基本采用这种方法来执行同一个功能不同测试用例的编写。</p><h4 id="3-进一步实现POM"><a href="#3-进一步实现POM" class="headerlink" title="3.进一步实现POM"></a>3.进一步实现POM</h4><p>本小节宏哥将会进一步演示POM的具体实现，前面POM只是一个页面，一个测试脚本，现在我们要实现三个页面，两个测试脚本。在pageobjects包下，我新建了2个页面对象：百度新闻首页，百度体育新闻首页，具体文件结构如下图，其他和之前项目层级结构保持不变。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/52wsKZE4C9bmGAY.png" alt="1232840-20191223091102154-1661448869.png"></p><p>1.百度首页页面类代码（baidu_homepage.py），定义了百度新闻的入口</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/szDnhNkQ7WcHKSE.png" alt="1232840-20191223091545333-1058928502.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-23@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块fromautomation_framework_demo.framework.base_pageimportBasePageclassHomePage(BasePage):input_box=&quot;id=&gt;kw&quot;search_submit_btn=&quot;xpath=&gt;//*[@id=&#39;su&#39;]&quot;#百度新闻入口#news_link=&quot;xpath=&gt;//*[@id=&#39;u1&#39;]/a[@name=&#39;tj_trnews&#39;]&quot;news_link=&quot;xpath=&gt;//*[@id=&#39;u1&#39;]/a[@name=&#39;tj_trnews&#39;]&quot;deftype_search(self,text):self.type(self.input_box,text)defsend_submit_btn(self):self.click(self.search_submit_btn)defclick_news(self,):self.click(self.news_link)self.sleep(2)</code></pre><p>2.百度新闻首页的页面类代码（baidu_news_home.py）,定义了体育新闻入口</p><h5 id="3-3代码实现"><a href="#3-3代码实现" class="headerlink" title="3.3代码实现"></a>3.3代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/m7LdEypirb14K5g.png" alt="1232840-20191223092520983-129412898.png"></p><h5 id="3-4参考代码"><a href="#3-4参考代码" class="headerlink" title="3.4参考代码"></a>3.4参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-23@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块fromautomation_framework_demo.framework.base_pageimportBasePageclassNewsHomePage(BasePage):#点击体育新闻入口sports_link=&quot;xpath=&gt;//*[@id=&#39;channle-all&#39;]/div/ul/li[7]/a&quot;defclick_sports(self):self.click(self.sports_link)self.sleep(2)</code></pre><p>3.百度体育新闻页面类代码（news_sports_home.py）</p><h5 id="3-5代码实现"><a href="#3-5代码实现" class="headerlink" title="3.5代码实现"></a>3.5代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/OUlyij1Wte2KB6P.png" alt="1232840-20191223092710385-492968738.png"></p><h5 id="3-6参考代码"><a href="#3-6参考代码" class="headerlink" title="3.6参考代码"></a>3.6参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-23@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块fromautomation_framework_demo.framework.base_pageimportBasePageclassSportsNewsHomePage(BasePage):#NBA入口nba_link=&quot;xpath=&gt;.//*[@id=&#39;col_focus&#39;]/div[1]/div[2]/div/div[2]/div/ul/li[1]/a&quot;defclick_nba_link(self):self.click(self.nba_link)self.sleep(2)</code></pre><h4 id="4-测试类代码（test-nba-news-view-py）"><a href="#4-测试类代码（test-nba-news-view-py）" class="headerlink" title="4.测试类代码（test_nba_news_view.py）"></a>4.测试类代码（test_nba_news_view.py）</h4><p>　　测试步骤大概是：百度首页点击新闻链接-进入新闻主页，点击体育-进入体育新闻主页，点击NBA-进入NBA页面-其他后续脚本操作。为什么要采用这样的步骤呢，干嘛不直接driver.get(‘nba的链接’)？因为我们就是要利用POM的思想去写我们测试脚本，才有上面的测试步骤。</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/VZhx496Hi5kJoAb.png" alt="1232840-20191223110303250-288301792.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-23@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimeimportunittestfromautomation_framework_demo.framework.browser_engineimportBrowserEnginefromautomation_framework_demo.pageobjects.baidu_homepageimportHomePagefromautomation_framework_demo.pageobjects.baidu_news_homeimportNewsHomePagefromautomation_framework_demo.pageobjects.news_sport_homeimportSportsNewsHomePageclassViewNBANews(unittest.TestCase):defsetUp(self):browse=BrowserEngine(self)self.driver=browse.open_browser(self)deftearDown(self):self.driver.quit()deftest_view_nba_views(self):#初始化百度首页，并点击新闻链接baiduhome=HomePage(self.driver)baiduhome.click_news()#初始化一个百度新闻主页对象，点击体育newshome=NewsHomePage(self.driver)newshome.click_sports()#初始化一个体育新闻主页，点击NBAsportnewhome=SportsNewsHomePage(self.driver)sportnewhome.click_nba_link()sportnewhome.get_windows_img()if__name__==&#39;__main__&#39;:unittest.main()</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/ughm3F847RkKezw.png" alt="1232840-20191223110553202-949686044.png"></p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><h5 id="5-1遇到问题"><a href="#5-1遇到问题" class="headerlink" title="5.1遇到问题"></a>5.1遇到问题</h5><p>　　人品好的小伙伴或者童鞋们或许不会遇到下面的问题，反之则会遇到下面的问题。通过上面的脚本，进入一个新的页面，就要初始化这个页面的对象，然后才能调用这个页面相关的方法，driver这个实例对象在不同页面之间切换，这个就是POM的核心内容。我们来测试运行这个类看看，结果报错。</p><p>StaleElementReferenceException:Message:staleelementreference:elementisnotattachedtothepagedocument</p><h5 id="5-2原因分析"><a href="#5-2原因分析" class="headerlink" title="5.2原因分析"></a>5.2原因分析</h5><p>字面意思是说，页面元素不在当前页面对象没有加载到页面，就不能找到元素，不能进行点击，这个报错发生在，百度新闻首页点击体育这行代码里。</p><p>由于我们的driver这个实例对象在不同的页面里切换，可能造成了这个报错，这个问题在python+selenium遇到过，java+selenium没有遇到，国外网站，有人建议，既然找不到这个元素，那么在脚本里，就直接driver.find_elemen(xpath)再找一次。也就是说，可能我们</p><p>利用页面对象方法，点击不了这个体育链接，那么我们直接在脚本里通过find_element方法去定位体育这个元素，然后再点击。这个也算是一个bug，目前暂时没有更好办法解决，不知道以后chromedriver.exe升级会不会解决这个问题不好说。</p><p>我们调整下我们测试类代码，添加find_element（）语句</p><h5 id="5-3参考代码"><a href="#5-3参考代码" class="headerlink" title="5.3参考代码"></a>5.3参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-23@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇5-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimeimportunittestfromautomation_framework_demo.framework.browser_engineimportBrowserEnginefromautomation_framework_demo.pageobjects.baidu_homepageimportHomePagefromautomation_framework_demo.pageobjects.baidu_news_homeimportNewsHomePagefromautomation_framework_demo.pageobjects.news_sport_homeimportSportsNewsHomePageclassViewNBANews(unittest.TestCase):defsetUp(self):browse=BrowserEngine(self)self.driver=browse.open_browser(self)deftearDown(self):self.driver.quit()deftest_view_nba_views(self):#初始化百度首页，并点击新闻链接baiduhome=HomePage(self.driver)#baiduhome.click_news()self.driver.find_element_by_xpath(&quot;//*[@id=&#39;u1&#39;]/a[@name=&#39;tj_trnews&#39;]&quot;).click()#初始化一个百度新闻主页对象，点击体育newshome=NewsHomePage(self.driver)#newshome.click_sports()self.driver.find_element_by_xpath(&quot;//*[@id=&#39;channel-all&#39;]/div/ul/li[7]/a&quot;).click()#初始化一个体育新闻主页，点击NBAsportnewhome=SportsNewsHomePage(self.driver)#sportnewhome.click_nba_link()self.driver.find_element_by_xpath(&quot;.//*[@id=&#39;col_focus&#39;]/div[1]/div[2]/div/div[2]/div/ul/li[1]/a&quot;).click()sportnewhome.get_windows_img()if__name__==&#39;__main__&#39;:unittest.main()</code></pre><p>其实，我们之前页面对象调用点击相关元素进入下一个页面，在回放脚本是看起作用了，但是就是报错，所以这里，只好在三个地方点击进入下一个页面的时候，采用self.driver.find_element()方法。这个和我们POM的思想，页面对象只写元素定位和相关方法，脚本类一般不写页面元素定位相矛盾，是吧。也许未来能解决这个问题，或者你接受当前这个方法，或者，你单独写一个进入到NBA的类，例如直接driver.get()然后封装静态类，当做其他NBA页面脚本的测试固件引入，这样也可以。<br>实际项目脚本开发也应该有一些公共方法封装成模块或者静态类，例如，把登录事件写成静态类，第二个用例是收藏一篇文章，收藏的测试前提就是登录，所以在收藏类的测试固件中的setUp()里就调用登录的模块脚本。同样，你写登录的事件，可能封装了浏览器的调用。具体问题要具体分析，实际脚本开发过程要随机应变，一种方法实现起来困难，就想办法绕过去，这个是自动化测试工程师要一直面临的挑战。</p><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。有问题加群交流讨论</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试21</title>
      <link href="/2016/02/08/selenium/"/>
      <url>/2016/02/08/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架实战篇4-价值好几K的框架，呵！这个框架有点意思啊！！！</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>前面文章，我们实现了框架的一部分功能，包括日志类和浏览器引擎类的封装，今天我们继续封装一个基类和介绍如何实现POM。关于基类，是这样定义的：把一些常见的页面操作的selenium封装到base_page.py这个类文件，以后每个POM中的页面类，都继承这个基类，这样每个页面类都有基类的方法，这个我们会在这篇文章由宏哥实现。</p><h4 id="2-项目层级结构"><a href="#2-项目层级结构" class="headerlink" title="2.项目层级结构"></a>2.项目层级结构</h4><p>1.上一篇中我们已经创建好了项目层级结构，具体项目层级结构如下图。这里不再赘述，相关文件也如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/DduxtyFwr7GhUPm.png" alt="1232840-20191219113551572-1602006466.png"></p><h4 id="3-定位和截图类封装"><a href="#3-定位和截图类封装" class="headerlink" title="3.定位和截图类封装"></a>3.定位和截图类封装</h4><p>1.在实现封装基类里，我们实现了元素八大方式的定位和截图类封装。</p><p>2.基类base_page.py的具体实现代码，这里就封装了几个常用方法，其他方法，你自己去练习封装下。</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/L8WF7cntl1AaST2.png" alt="1232840-20191220142652608-958817746.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-08@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇4-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimefromselenium.common.exceptionsimportNoSuchElementExceptionimportos.pathfromautomation_framework_demo.framework.loggerimportLogger#createaloggerinstancelogger=Logger(logger=&quot;BasePage&quot;).getlog()classBasePage(object):&quot;&quot;&quot;定义一个页面基类，让所有页面都继承这个类，封装一些常用的页面操作方法到这个类&quot;&quot;&quot;def__init__(self,driver):self.driver=driver#quitbrowserandendtestingdefquit_browser(self):self.driver.quit()#浏览器前进操作defforward(self):self.driver.forward()logger.info(&quot;Clickforwardoncurrentpage.&quot;)#浏览器后退操作defback(self):self.driver.back()logger.info(&quot;Clickbackoncurrentpage.&quot;)#隐式等待defwait(self,seconds):self.driver.implicitly_wait(seconds)logger.info(&quot;waitfor%dseconds.&quot;%seconds)#点击关闭当前窗口defclose(self):try:self.driver.close()logger.info(&quot;Closingandquitthebrowser.&quot;)exceptNameErrorase:logger.error(&quot;Failedtoquitthebrowserwith%s&quot;%e)#保存图片defget_windows_img(self):&quot;&quot;&quot;在这里我们把file_path这个参数写死，直接保存到我们项目根目录的一个文件夹.\Screenshots下&quot;&quot;&quot;file_path=os.path.dirname(os.path.abspath(&#39;.&#39;))+&#39;/screenshots/&#39;rq=time.strftime(&#39;%Y%m%d%H%M&#39;,time.localtime(time.time()))screen_name=file_path+rq+&#39;.png&#39;try:self.driver.get_screenshot_as_file(screen_name)logger.info(&quot;Hadtakescreenshotandsavetofolder:/screenshots&quot;)exceptNameErrorase:logger.error(&quot;Failedtotakescreenshot!%s&quot;%e)self.get_windows_img()#定位元素方法deffind_element(self,selector):&quot;&quot;&quot;这个地方为什么是根据=&gt;来切割字符串，请看页面里定位元素的方法submit_btn=&quot;id=&gt;su&quot;login_lnk=&quot;xpath=&gt;//*[@id=&#39;u1&#39;]/a[7]&quot;#百度首页登录链接定位如果采用等号，结果很多xpath表达式中包含一个=，这样会造成切割不准确，影响元素定位:paramselector::return:element&quot;&quot;&quot;element=&#39;&#39;if&#39;=&gt;&#39;notinselector:returnself.driver.find_element_by_id(selector)selector_by=selector.split(&#39;=&gt;&#39;)[0]selector_value=selector.split(&#39;=&gt;&#39;)[1]print(selector_value)ifselector_by==&quot;i&quot;orselector_by==&#39;id&#39;:try:element=self.driver.find_element_by_id(selector_value)logger.info(&quot;Hadfindtheelement\&#39;%s\&#39;successful&quot;&quot;by%sviavalue:%s&quot;%(element.text,selector_by,selector_value))exceptNoSuchElementExceptionase:logger.error(&quot;NoSuchElementException:%s&quot;%e)self.get_windows_img()#takescreenshotelifselector_by==&quot;n&quot;orselector_by==&#39;name&#39;:element=self.driver.find_element_by_name(selector_value)elifselector_by==&quot;c&quot;orselector_by==&#39;class_name&#39;:element=self.driver.find_element_by_class_name(selector_value)elifselector_by==&quot;l&quot;orselector_by==&#39;link_text&#39;:element=self.driver.find_element_by_link_text(selector_value)elifselector_by==&quot;p&quot;orselector_by==&#39;partial_link_text&#39;:element=self.driver.find_element_by_partial_link_text(selector_value)elifselector_by==&quot;t&quot;orselector_by==&#39;tag_name&#39;:element=self.driver.find_element_by_tag_name(selector_value)elifselector_by==&quot;x&quot;orselector_by==&#39;xpath&#39;:try:element=self.driver.find_element_by_xpath(selector_value)logger.info(&quot;Hadfindtheelement\&#39;%s\&#39;successful&quot;&quot;by%sviavalue:%s&quot;%(element.text,selector_by,selector_value))exceptNoSuchElementExceptionase:logger.error(&quot;NoSuchElementException:%s&quot;%e)self.get_windows_img()elifselector_by==&quot;s&quot;orselector_by==&#39;selector_selector&#39;:element=self.driver.find_element_by_css_selector(selector_value)else:raiseNameError(&quot;Pleaseenteravalidtypeoftargetingelements.&quot;)print(element)returnelement#输入deftype(self,selector,text):el=self.find_element(selector)el.clear()try:el.send_keys(text)logger.info(&quot;Hadtype\&#39;%s\&#39;ininputBox&quot;%text)exceptNameErrorase:logger.error(&quot;Failedtotypeininputboxwith%s&quot;%e)self.get_windows_img()#清除文本框defclear(self,selector):el=self.find_element(selector)try:el.clear()logger.info(&quot;Cleartextininputboxbeforetyping.&quot;)exceptNameErrorase:logger.error(&quot;Failedtoclearininputboxwith%s&quot;%e)self.get_windows_img()#点击元素defclick(self,selector):el=self.find_element(selector)try:el.click()logger.info(&quot;Theelement\&#39;%s\&#39;wasclicked.&quot;%el)exceptNameErrorase:logger.error(&quot;Failedtoclicktheelementwith%s&quot;%e)#或者网页标题defget_page_title(self):logger.info(&quot;Currentpagetitleis%s&quot;%self.driver.title)returnself.driver.title@staticmethoddefsleep(seconds):time.sleep(seconds)logger.info(&quot;Sleepfor%dseconds&quot;%seconds)</code></pre><h4 id="4-pageObjects文件夹下相关代码"><a href="#4-pageObjects文件夹下相关代码" class="headerlink" title="4.pageObjects文件夹下相关代码"></a>4.pageObjects文件夹下相关代码</h4><p>1.页面对象中，百度主页的元素定位和简单的操作函数，页面类主要是元素定位和页面操作写成函数，供测试类调用。</p><p>baidu_homepage.py</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/aKUq8dLCwthu9jA.png" alt="1232840-20191220141229591-491080604.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-08@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇4-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块fromautomation_framework_demo.framework.base_pageimportBasePageclassHomePage(BasePage):input_box=&quot;id=&gt;kw&quot;search_submit_btn=&quot;xpath=&gt;//*[@id=&#39;su&#39;]&quot;#百度新闻入口#news_link=&quot;xpath=&gt;//*[@id=&#39;u1&#39;]/a[@name=&#39;tj_trnews&#39;]&quot;news_link=&quot;xpath=&gt;//*[@id=&#39;u1&#39;]/a[@name=&#39;tj_trnews&#39;]&quot;deftype_search(self,text):self.type(self.input_box,text)defsend_submit_btn(self):self.click(self.search_submit_btn)defclick_news(self,):self.click(self.news_link)self.sleep(2)</code></pre><p>这里注意下元素定位写法，=&gt;和base_page.py中find_element()方法元素定位切割有关系，网上有些人写根据逗号切割或者等号切割，在实际使用xpath定位，发现单独逗号或者单独等号切割都不精确，造成元素定位失败。</p><h4 id="5-测试类的写法举例"><a href="#5-测试类的写法举例" class="headerlink" title="5.测试类的写法举例"></a>5.测试类的写法举例</h4><p>1.新建一个测试类baidu_search1.py。</p><p>baidu_search1.py</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/L8WF7cntl1AaST2.png" alt="1232840-20191220142652608-958817746.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-08@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇4-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimeimportunittestfromautomation_framework_demo.framework.browser_engineimportBrowserEnginefromautomation_framework_demo.pageobjects.baidu_homepageimportHomePageclassBaiduSearch(unittest.TestCase):defsetUpClass(cls):&quot;&quot;&quot;测试固件的setUp()的代码，主要是测试的前提准备工作:return:&quot;&quot;&quot;browse=BrowserEngine(cls)cls.driver=browse.open_browser(cls)deftearDownClass(cls):&quot;&quot;&quot;测试结束后的操作，这里基本上都是关闭浏览器:return:&quot;&quot;&quot;cls.driver.quit()deftest_baidu_search(self):&quot;&quot;&quot;这里一定要test开头，把测试逻辑代码封装到一个test开头的方法里。:return:&quot;&quot;&quot;#self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;selenium&#39;)#time.sleep(1)homepage=HomePage(self.driver)homepage.type_search(&#39;selenium&#39;)#调用页面对象中的方法homepage.send_submit_btn()#调用页面对象类中的点击搜索按钮方法time.sleep(2)homepage.get_windows_img()#调用基类截图方法print(self.driver.title)try:assert(&#39;selenium&#39;inHomePage.get_page_title(self))print(&#39;TestPass.&#39;)exceptExceptionase:print(&#39;TestFail.&#39;,format(e))deftest_search2(self):homepage=HomePage(self.driver)homepage.type_search(&#39;python&#39;)#调用页面对象中的方法homepage.send_submit_btn()#调用页面对象类中的点击搜索按钮方法time.sleep(2)homepage.get_windows_img()#调用基类截图方法if__name__==&#39;__main__&#39;:unittest.main()</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/TDq6fe3YwpltJxn.png" alt="1232840-20191220142933132-1251851631.png"></p><h5 id="5-4代码说明"><a href="#5-4代码说明" class="headerlink" title="5.4代码说明"></a>5.4代码说明</h5><pre><code>homepage=HomePage(self.driver)</code></pre><p>上面这行代码要注意，意思是：到一个页面，第一件事情是初始化这个页面的一个页面对象实例。注意，一定要带self.driver，不然会报错，这个self.driver，可以这样理解：在当前测试类里面，self.driver是来自浏览器引擎类中方法得到的，在初始化一个页面对象的时候，也把这个来自浏览器引擎类的driver给赋值给当前的页面对象，这样，才能执行页面对象或者基类里面的相关driver方法。写多了selenium的自动化脚本，你会明白，最重要的是保持前后driver的唯一性。</p><h5 id="5-5生成图片"><a href="#5-5生成图片" class="headerlink" title="5.5生成图片"></a>5.5生成图片</h5><p>1.测试结果：会在logs文件夹生成一个日志文件，也会在screenshots文件夹生成一个png图片。日志看过了，这里我们看一下图片</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/6RWveUzHnNQaci3.png" alt="1232840-20191220143116447-1767610017.png"></p><p>2.图片内容如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/AhzwHYZ1JSKLmMV.png" alt="1232840-20191220143153511-1340853207.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。有问题加群交流讨论</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试20</title>
      <link href="/2016/02/07/selenium/"/>
      <url>/2016/02/07/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架设计篇3-价值好几K的框架，狼来了，狼来了….，狼没来，框架真的来了</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　前边宏哥一边一边的喊框架，就如同一边一边的喊狼来了！狼来了！…..这回是狼没有来，框架真的来了。从本文开始宏哥将会一步一步介绍，如何从无到有地创建自己的第一个自动化测试框架。这一篇，我们介绍，如何封装自己的日志类和浏览器引擎类。</p><h4 id="2-创建项目层级结构"><a href="#2-创建项目层级结构" class="headerlink" title="2.创建项目层级结构"></a>2.创建项目层级结构</h4><p>　　如何创建，怎么创建。这个就需要我们前边介绍的框架概要设计以及框架的详细设计的思维导图，宏哥就是根据那个图，轻松地、清楚的、思路清晰地一步一步创建项目层级结构。</p><p>相关步骤：</p><p>1.打开PyCharm，创建如下格式的项目层级结构，为了避免不必要的麻烦文件名称建议和宏哥保持一样；</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/ncK5EgroB1Qf4Tv.png" alt="1232840-20191219102824469-1792054724.png"></p><h4 id="3-相关文件代码"><a href="#3-相关文件代码" class="headerlink" title="3.相关文件代码"></a>3.相关文件代码</h4><h5 id="3-1config-ini配置文件"><a href="#3-1config-ini配置文件" class="headerlink" title="3.1config.ini配置文件"></a>3.1config.ini配置文件</h5><p>配置文件config.ini相关设计如下：</p><h6 id="3-1-1代码实现"><a href="#3-1-1代码实现" class="headerlink" title="3.1.1代码实现"></a>3.1.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/kH4Cp9wu6eMdfq3.png" alt="1232840-20191219104228731-1983638055.png"></p><h6 id="3-1-2参考代码"><a href="#3-1-2参考代码" class="headerlink" title="3.1.2参考代码"></a>3.1.2参考代码</h6><pre><code>#thisisconfigfile,onlystorebrowsertypeandserverURL[browserType]#browserName=FirefoxbrowserName=Chrome#browserName=IE[testServer]URL=https://www.baidu.com#URL=www.google.com</code></pre><h4 id="3-2封装浏览器驱动（引擎）类"><a href="#3-2封装浏览器驱动（引擎）类" class="headerlink" title="3.2封装浏览器驱动（引擎）类"></a>3.2封装浏览器驱动（引擎）类</h4><h5 id="3-2-1browser-engine-py文件"><a href="#3-2-1browser-engine-py文件" class="headerlink" title="3.2.1browser_engine.py文件"></a>3.2.1browser_engine.py文件</h5><p>主要目前常用的Chrome、Firefox和IE三大浏览器引擎的封装。</p><p>浏览器引擎类browser_engine.py相关脚本代码如下：</p><h5 id="3-2-2代码实现"><a href="#3-2-2代码实现" class="headerlink" title="3.2.2代码实现"></a>3.2.2代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/94wJpBrYSnhc6zo.png" alt="1232840-20191219104449264-1698872308.png"></p><h5 id="3-2-3参考代码"><a href="#3-2-3参考代码" class="headerlink" title="3.2.3参考代码"></a>3.2.3参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-07@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇3-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importconfigparserimportos.pathfromseleniumimportwebdriverfromautomation_framework_demo.framework.loggerimportLoggerlogger=Logger(logger=&quot;BrowserEngine&quot;).getlog()classBrowserEngine(object):dir=os.path.dirname(os.path.abspath(&#39;.&#39;))#注意相对路径获取方法chrome_driver_path=dir+&#39;/tools/chromedriver.exe&#39;ie_driver_path=dir+&#39;/tools/IEDriverServer.exe&#39;def__init__(self,driver):self.driver=driver#readthebrowsertypefromconfig.inifile,returnthedriverdefopen_browser(self,driver):config=configparser.ConfigParser()#file_path=os.path.dirname(os.getcwd())+&#39;/config/config.ini&#39;file_path=os.path.dirname(os.path.abspath(&#39;.&#39;))+&#39;/config/config.ini&#39;config.read(file_path)browser=config.get(&quot;browserType&quot;,&quot;browserName&quot;)#获取浏览器类型、名字logger.info(&quot;Youhadselect%sbrowser.&quot;%browser)#日志打印你选择的浏览器url=config.get(&quot;testServer&quot;,&quot;URL&quot;)#获取测试的URL地址logger.info(&quot;Thetestserverurlis:%s&quot;%url)#日志打印测试的URL地址#判断你所选择的浏览器ifbrowser==&quot;Firefox&quot;:driver=webdriver.Firefox()logger.info(&quot;Startingfirefoxbrowser.&quot;)elifbrowser==&quot;Chrome&quot;:driver=webdriver.Chrome(self.chrome_driver_path)#初始化一个实例logger.info(&quot;StartingChromebrowser.&quot;)elifbrowser==&quot;IE&quot;:driver=webdriver.Ie(self.ie_driver_path)logger.info(&quot;StartingIEbrowser.&quot;)driver.get(url)#访问URLlogger.info(&quot;Openurl:%s&quot;%url)driver.maximize_window()#将窗口放大logger.info(&quot;Maximizethecurrentwindow.&quot;)driver.implicitly_wait(10)logger.info(&quot;Setimplicitlywait10seconds.&quot;)print(driver)returndriver#关闭浏览器defquit_browser(self):logger.info(&quot;Now,Closeandquitthebrowser.&quot;)self.driver.quit()</code></pre><h5 id="3-3封装日志类"><a href="#3-3封装日志类" class="headerlink" title="3.3封装日志类"></a>3.3封装日志类</h5><h6 id="3-3-1logger-py文件"><a href="#3-3-1logger-py文件" class="headerlink" title="3.3.1logger.py文件"></a>3.3.1logger.py文件</h6><p>日志类logger.py相关脚本代码如下：</p><h6 id="3-3-2代码实现"><a href="#3-3-2代码实现" class="headerlink" title="3.3.2代码实现"></a>3.3.2代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/cw6IN1pFzDmTCGt.png" alt="1232840-20191219104704839-1087953088.png"></p><h6 id="3-3-3参考代码"><a href="#3-3-3参考代码" class="headerlink" title="3.3.3参考代码"></a>3.3.3参考代码</h6><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-07@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇3-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importloggingimportlogging.handlersimportos.pathimporttimeclassLogger(object):def__init__(self,logger):&#39;&#39;&#39;&#39;&#39;指定保存日志的文件路径，日志级别，以及调用文件将日志存入到指定的文件中&#39;&#39;&#39;#创建一个日志器logger，并设置其日志级别为DEBUGself.logger=logging.getLogger(logger)self.logger.setLevel(logging.DEBUG)#创建一个handler，用于写入日志文件rq=time.strftime(&#39;%Y%m%d%H%M&#39;,time.localtime(time.time()))#log_path=os.path.dirname(os.getcwd())+&#39;/Logs/&#39;#项目根目录下/Logs保存日志log_path=os.path.dirname(os.path.abspath(&#39;.&#39;))+&#39;/logs/&#39;#如果case组织结构式/testsuit/featuremodel/xxx.py，那么得到的相对路径的父路径就是项目根目录log_name=log_path+rq+&#39;.log&#39;#创建一个文件处理器handler并设置其日志级别为INFO#fh=logging.FileHandler(log_name,maxBytes=1024*1024,backupCount=5,#encoding=&#39;utf-8&#39;)fh=logging.handlers.RotatingFileHandler(log_name,maxBytes=1024*1024,backupCount=5,encoding=&#39;utf-8&#39;)#实例化handler#fh=logging.FileHandler(log_name)fh.setLevel(logging.INFO)#再创建一个handler，用于输出到控制台&#39;&#39;&#39;创建一个流处理器handler并设置其日志级别为INFO&#39;&#39;&#39;ch=logging.StreamHandler()ch.setLevel(logging.INFO)#定义handler的输出格式#handler=logging.handlers.RotatingFileHandler(fh,maxBytes=1024*1024,backupCount=5,#encoding=&#39;utf-8&#39;)#实例化handler&#39;&#39;&#39;创建一个格式器formatter并将&#39;&#39;&#39;formatter=logging.Formatter(&#39;%(asctime)s-%(name)s-%(levelname)s-%(message)s&#39;)fh.setFormatter(formatter)ch.setFormatter(formatter)#给日志处理器logger添加上面创建的handlerself.logger.addHandler(fh)self.logger.addHandler(ch)defgetlog(self):returnself.logger</code></pre><p>页面对象pageobject这里暂不用，其实上一篇微博那个小例子已经介绍过了，计划下一篇宏哥再做详细地介绍。</p><h4 id="4-新建测试脚本"><a href="#4-新建测试脚本" class="headerlink" title="4.新建测试脚本"></a>4.新建测试脚本</h4><h5 id="4-1测试脚本baidu-search-py"><a href="#4-1测试脚本baidu-search-py" class="headerlink" title="4.1测试脚本baidu_search.py"></a>4.1测试脚本baidu_search.py</h5><p>测试脚本baidu_search.py相关脚本如下：</p><h5 id="4-2代码实现"><a href="#4-2代码实现" class="headerlink" title="4.2代码实现"></a>4.2代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/QKsIDL4zXA9UCpx.png" alt="1232840-20191219110010059-1235020726.png"></p><h5 id="4-3参考代码"><a href="#4-3参考代码" class="headerlink" title="4.3参考代码"></a>4.3参考代码</h5><pre><code>#-*-coding:utf-8-*-#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-07@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇3-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimeimportunittestfromautomation_framework_demo.framework.browser_engineimportBrowserEngineclassBaiduSearch(unittest.TestCase):defsetUp(self):&quot;&quot;&quot;测试固件的setUp()的代码，主要是测试的前提准备工作:return:&quot;&quot;&quot;browse=BrowserEngine(self)self.driver=browse.open_browser(self)deftearDown(self):&quot;&quot;&quot;测试结束后的操作，这里基本上都是关闭浏览器:return:&quot;&quot;&quot;self.driver.quit()deftest_baidu_search(self):&quot;&quot;&quot;这里一定要test开头，把测试逻辑代码封装到一个test开头的方法里。:return:&quot;&quot;&quot;self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;selenium&#39;)time.sleep(1)self.driver.find_element_by_id(&#39;su&#39;).click()time.sleep(5)try:assert&#39;selenium&#39;inself.driver.titleprint(&#39;TestPass.&#39;)exceptExceptionase:print(&#39;TestFail.&#39;,format(e))if__name__==&#39;__main__&#39;:unittest.main()</code></pre><h5 id="4-4运行结果"><a href="#4-4运行结果" class="headerlink" title="4.4运行结果"></a>4.4运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/kxnh9u65VbdyjA3.png" alt="1232840-20191219110117708-1479082179.png"></p><p>工具包，这里把三个浏览器的driver文件都放根目录一个文件夹里，这样别人拷贝这个项目也不需要去下载这些文件。</p><p>运行测试脚本baidu_search.py，会在根目录下的logs文件生成日志文件，例如宏哥的文件内容：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/gAW5mcIjXMJeKY7.png" alt="1232840-20191219110245337-169792140.png"></p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><h5 id="5-1遇到的一个小问题"><a href="#5-1遇到的一个小问题" class="headerlink" title="5.1遇到的一个小问题"></a>5.1遇到的一个小问题</h5><p>问题描述：主要是在断言的时候fail的了，原因是输入selenium后，没有点击查询，于是宏哥加上这段代码</p><pre><code>self.driver.find_element_by_id(&#39;su&#39;).click()</code></pre><p>运行后仍然fail的，宏哥猜测是点击后没有出现元素，就去断言，因此又加上了等待的出现的代码，结果pass了</p><pre><code>time.sleep(5)</code></pre><p>在实践和写代码，运行的过程中，遇到问题就出现在下边的代码里。有兴趣的小伙伴或者童鞋们可以自己注释掉实验一下</p><pre><code>deftest_baidu_search(self):&quot;&quot;&quot;这里一定要test开头，把测试逻辑代码封装到一个test开头的方法里。:return:&quot;&quot;&quot;self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;selenium&#39;)time.sleep(1)self.driver.find_element_by_id(&#39;su&#39;).click()time.sleep(5)try:assert&#39;selenium&#39;inself.driver.titleprint(&#39;TestPass.&#39;)exceptExceptionase:print(&#39;TestFail.&#39;,format(e))</code></pre><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。有问题加群交流讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试19</title>
      <link href="/2016/02/06/selenium/"/>
      <url>/2016/02/06/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架设计篇2- 价值好几K的框架，不看白不看，看了还想看</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　上一篇介绍了自动化框架的架构，今天宏哥就带领小伙伴或者童鞋们开始开工往这个框架里开始添砖加瓦。主要是介绍一个框架unittest单元测试框架和一种设计思想POM。</p><h4 id="2-unittest单元测试框架"><a href="#2-unittest单元测试框架" class="headerlink" title="2.unittest单元测试框架"></a>2.unittest单元测试框架</h4><p>前面文章已经简单介绍了一些关于自动化测试框架的介绍，知道了什么是自动化测试框架，主要有哪些特点，基本组成部分等。在继续介绍框架设计之前，我们先来学习一个工具，叫unittest。</p><p>unittest是一个单元测试框架，是Python编程的单元测试框架。有时候，也做叫做“PyUnit”,是Junit的Python语言版本。这里了解下,Junit是Java语言的单元测试框架，Java还有一个很好用的单元测试框架叫TestNG,本系列只学习Python，所以只需要unittest是</p><p>Python里的一个单元测试框架就可以了。</p><p>unittest支持测试自动化，共享测试用例中的初始化和关闭退出代码，在unittest中最小单元是test，也就是一个测试用例。要了解unittest单元测试框架，先来了解以下几个重要的概念。</p><h5 id="2-1测试固件（testfixture）"><a href="#2-1测试固件（testfixture）" class="headerlink" title="2.1测试固件（testfixture）"></a>2.1测试固件（testfixture）</h5><p>一个测试固件包括两部分，执行测试代码之前的准备部分和测试结束之后的清扫代码。这两部分一般用函数setUp()和tearDown()表示。这里举例以下，例如要测试百度搜索selenium这个场景，我们的测试固件可以这样写，setUp()里写打开浏览器，浏览器最大</p><p>化，和打开百度首页等脚本代码；在tearDown（）里写结束搜索后，退出并关闭浏览器的代码。</p><h5 id="2-2测试用例（testcase）"><a href="#2-2测试用例（testcase）" class="headerlink" title="2.2测试用例（testcase）"></a>2.2测试用例（testcase）</h5><p>unittest中管理的最小单元是测试用例，一个测试用例，包括测试固件，和具体测试业务的函数或者方法。一个测试用例中，测试固件可以不写，但是至少有一个已test开头的函数。unittest会自动化识别test开头的函数是测试代码，如果你写的函数不是test开头，</p><p>unittest是不会执行这个函数里面的脚本的，这个千万要记住，所有的测试函数都要test开头，记住是小写的哦。</p><h5 id="2-3测试套件（testsuite）"><a href="#2-3测试套件（testsuite）" class="headerlink" title="2.3测试套件（testsuite）"></a>2.3测试套件（testsuite）</h5><p>很简单，就是很多测试用例的集合，叫测试套件，一个测试套件可以随意管理多个测试用例。如果测试用例比作单个学生，测试套件就是好像是班级的概念。</p><h5 id="2-4测试执行器（testrunner）"><a href="#2-4测试执行器（testrunner）" class="headerlink" title="2.4测试执行器（testrunner）"></a>2.4测试执行器（testrunner）</h5><p>testrunner是一个用来执行加载测试用例，并执行用例，且提供测试输出的一个组建。testrunner可以加载testcase或者testsuite进行执行测试任务。</p><p>我们举例来，练习一下testfixture和testcase的使用，学习unittest的简单用法：</p><h5 id="2-5设计思路"><a href="#2-5设计思路" class="headerlink" title="2.5设计思路"></a>2.5设计思路</h5><p>1.新建一个testbaidu.py的文件</p><p>2.导入unittest模块</p><p>3.当前测试类继承unittest.TestCase，相当于当前利用unittest创建了一个testcase，这个testcase是能够被unittest直接识别。</p><p>4.写setUP(),主要是打开浏览器和打开站点</p><p>5.写一个test_search（）用例写搜索的代码</p><p>6.写tearDown(),主要是浏览器退出操作</p><p>相关脚本代码如下：</p><h6 id="2-5-1代码实现"><a href="#2-5-1代码实现" class="headerlink" title="2.5.1代码实现"></a>2.5.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/opYmCjUbqdrn1lz.png" alt="1232840-20191218134511218-2077873814.png"></p><h6 id="2-5-2参考代码"><a href="#2-5-2参考代码" class="headerlink" title="2.5.2参考代码"></a>2.5.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-06@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇2-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块importtimeimportunittestfromseleniumimportwebdriverclassBaiduSearch(unittest.TestCase):defsetUp(self):&quot;&quot;&quot;测试固件的setUp()的代码，主要是测试的前提准备工作:return:&quot;&quot;&quot;self.driver=webdriver.Chrome()self.driver.maximize_window()self.driver.implicitly_wait(8)self.driver.get(&quot;https://www.baidu.com&quot;)deftearDown(self):&quot;&quot;&quot;测试结束后的操作，这里基本上都是关闭浏览器:return:&quot;&quot;&quot;self.driver.implicitly_wait(8)self.driver.quit()deftest_baidu_search(self):&quot;&quot;&quot;这里一定要test开头，把测试逻辑代码封装到一个test开头的方法里。:return:&quot;&quot;&quot;self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;selenium&#39;)time.sleep(1)self.driver.find_element_by_id(&#39;su&#39;).click()time.sleep(3)try:assert&#39;selenium&#39;inself.driver.titleprint(&#39;TestPass.&#39;)exceptExceptionase:print(&#39;TestFail.&#39;,format(e))if__name__==&#39;__main__&#39;:unittest.main()</code></pre><h6 id="2-5-3运行结果"><a href="#2-5-3运行结果" class="headerlink" title="2.5.3运行结果"></a>2.5.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/wUKx64WObTHM1RF.png" alt="1232840-20191218113456097-1885317626.png"></p><p>解释：<br>最后结尾处的unittest.main(),添加这个是支持在cmd，里面，cd到这个脚本文件所在的目录，然后python脚本名.py执行，如果不添加这一段，是无法执行cmd里面运行脚本的，在PyCharm中，不添加最后一段，也可以通过，右键Run”unittestxxx”，来达到执行效果。</p><h4 id="3-什么是POM（PageObjectModel）"><a href="#3-什么是POM（PageObjectModel）" class="headerlink" title="3.什么是POM（PageObjectModel）"></a>3.什么是POM（PageObjectModel）</h4><p>　　前面我们介绍了Python中的单元测试框架unittest，以后我们所有的测试类文件，都采用unittest来辅助我们进行debug和脚本开发。搞定了debug机制和确定了unittest来进行创建和管理我们的自动化测试脚本，接下来我们来考虑下，框架设计中一种很普遍的设计</p><p>思想-POM（PageObjectModel）。</p><h5 id="3-1POM是什么"><a href="#3-1POM是什么" class="headerlink" title="3.1POM是什么"></a>3.1POM是什么</h5><p>PageObjectModel(POM)直译为“页面对象模型”，这种设计模式旨在为每个待测试的页面创建一个页面对象(class)，将那些繁琐的定位操作封装到这个页面对象中，只对外提供必要的操作接口。</p><h5 id="3-2POM有什么好处"><a href="#3-2POM有什么好处" class="headerlink" title="3.2POM有什么好处"></a>3.2POM有什么好处</h5><p>POM将页面定位和业务操作分开，分离了测试对象和测试脚本，如果UI更改页面，测试脚本不需要更改，只需要更改页面对象中的某些代码就可以，提高了可维护性。</p><p>POM，中文字母意思是，页面对象模型，POM是一种最近几年非常流行的自动化测试模型，或者思想，POM不是一个框架，就是一个解决问题的思想。采用POM的目的，是为了解决前端中UI变化频繁，从而造成测试自动化脚本维护的成本越来越大。下图，形</p><p>象描述了POM的好处。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/sQl5OejoT6Sbnmc.png" alt="1232840-20191218114227700-1160101342.png"></p><p>从上图看出，采取了POM设计思路和不采取的区别，左侧把测试代码和页面元素都写在一个类文件，如果需要更改页面，那么就要修改页面元素定位，从而要修改这个类中测试代码，这个看起来和混乱。右侧，采取POM后，主要的区别就是，把页面元素和业务</p><p>逻辑和测试脚本分离出来到两个不同类文件。ClassA只写页面元素定位，和业务逻辑代码操作的封装，ClassB只写测试脚本，不关心如何元素定位，只写调用ClassA的代码去覆盖不同的测试场景。如果前端页面发生变化，只需要修改ClassA的元素定位，而不需要去</p><p>修改ClassB中的测试脚本代码。</p><p>POM主要有以下优点：</p><p>1.把webui对象仓库从测试脚本分离，业务代码和测试脚本分离。</p><p>2.每一个页面对应一个页面类，页面的元素写到这个页面类中。</p><p>3.页面类主要包括该页面的元素定位，和和这些元素相关的业务操作代码封装的方法。</p><p>4.代码复用，从而减少测试脚本代码量。</p><p>5.层次清晰，同时支持多个编写自动化脚本开发，例如每个人写哪几个页面，不影响他人。</p><p>6.建议页面类和业务逻辑方法都给一个有意义的名称，方便他人快速编写脚本和维护脚本。</p><h5 id="3-3牛刀小试"><a href="#3-3牛刀小试" class="headerlink" title="3.3牛刀小试"></a>3.3牛刀小试</h5><p>比如测试一个登陆页面：新浪微博，执行测试的人员传递不同的数据到帐号、密码框就可以了，而不应该去顾虑：页面是否已经加载完成？怎样定位到帐号输入框？怎样定位到登陆按钮等等问题。</p><p>这些问题全部交由登陆页面的“页面对象”去解决并封装起来，只提供给测试人员三个接口方法：1.帐号输入接口、2.密码输入接口、3.提交接口。</p><p>首先定义一个基本页面BasePage类，定义基本的页面操作，提供给其他页面去继承，basePage.py内容如下：</p><h6 id="3-3-1代码实现"><a href="#3-3-1代码实现" class="headerlink" title="3.3.1代码实现"></a>3.3.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/opYmCjUbqdrn1lz.png" alt="1232840-20191218134511218-2077873814.png"></p><h6 id="3-3-2参考代码"><a href="#3-3-2参考代码" class="headerlink" title="3.3.2参考代码"></a>3.3.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-06@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇2-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块fromseleniumimportwebdriverfromselenium.webdriver.support.waitimportWebDriverWaitfromselenium.webdriver.supportimportexpected_conditionsasECclassBasePage(object):&quot;&quot;&quot;基础页面，提供给其他页面继承&quot;&quot;&quot;def__init__(self,driver,base_url,title):&quot;&quot;&quot;初始化&quot;&quot;&quot;self.driver=driverself.base_url=base_urlself.title=titledef_open(self,url):&quot;&quot;&quot;私有方法，打开url参数指定的页面,并检查打开是否正确&quot;&quot;&quot;self.driver.get(url)#显式等待10秒，如果打开页title与预期不符或者超时，抛出异常WebDriverWait(self.driver,10).until(EC.title_is(self.title))defopen(self):&quot;&quot;&quot;公共方法，调用私有方法_open()打开链接&quot;&quot;&quot;self._open(self.base_url)deffind_element(self,*loc):&quot;&quot;&quot;定位指定元素&quot;&quot;&quot;#显式等待元素，超过10秒未找到则抛出超时异常(TimeoutException)#presence_of_element_located：不关心元素是否可见，只关心元素是否存在在页面中#visibility_of_element_located：不仅找到元素，并且该元素必须可见WebDriverWait(self.driver,15).until(EC.visibility_of_element_located(loc))returnself.driver.find_element(*loc)if__name__==&#39;__main__&#39;:driver=webdriver.Chrome()driver.maximize_window()page=BasePage(driver,&#39;https://www.baidu.com/&#39;,&#39;百度一下，你就知道&#39;)page.open()driver.quit()</code></pre><h6 id="3-3-3运行结果"><a href="#3-3-3运行结果" class="headerlink" title="3.3.3运行结果"></a>3.3.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/FrN5GqoWIdfOt8A.png" alt="1232840-20191218142048727-708281067.png"></p><p>再定义一个LoginPage类继承BasePage类，向外提供测登陆方法。文件命名为xl_login.py，内容如下：</p><h6 id="3-3-4代码实现"><a href="#3-3-4代码实现" class="headerlink" title="3.3.4代码实现"></a>3.3.4代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/U56fJDkeZcQh1m2.png" alt="1232840-20191218141704612-561512086.png"></p><h6 id="3-3-5参考代码"><a href="#3-3-5参考代码" class="headerlink" title="3.3.5参考代码"></a>3.3.5参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-06@author:北京-宏哥QQ交流群：705269076Project:《《一头扎进》系列之Python+Selenium框架设计篇2-价值好几K的框架，不看别后悔，过时不候&#39;&#39;&#39;#3.导入模块fromseleniumimportwebdriverfromselenium.webdriver.common.byimportByfrombasePageimportBasePageclassLoginPage(BasePage):&quot;&quot;&quot;新浪微薄登陆页面继承自基础页面BasePage&quot;&quot;&quot;#定位帐号输入框username_loc=(By.ID,&#39;loginname&#39;)#定位密码输入框password_loc=(By.NAME,&#39;password&#39;)#定位登陆按钮submit_loc=(By.XPATH,&#39;.//*[@id=&quot;pl_login_form&quot;]/div/div[3]/div[6]/a&#39;)#定位提示信息，如：请输入验证码#不要迷信开发者工具提供的Xpath，#比如这里提供的Xpath：//*[@id=&quot;layer_15582553868501&quot;]/div/p/span[2]，#id是动态的，无法使用，需自行推到Xpathmessage_loc=(By.XPATH,&#39;//div[@class=&quot;contentlayer_mini_info&quot;]/p/span[2]&#39;)#输入用户名操作deftype_username(self,username):self.find_element(*self.username_loc).send_keys(username)#输入密码操作deftype_password(self,password):self.find_element(*self.password_loc).send_keys(password)#点击登陆按钮操作defsubmit(self):self.find_element(*self.submit_loc).click()#获取提示信息defget_message(self):returnself.find_element(*self.message_loc).textif__name__==&#39;__main__&#39;:#测试登陆#预打开页面base_url=&#39;https://weibo.com/&#39;#页面titletitle=&#39;微博-随时随地发现新鲜事&#39;#准备好待输入的用户名和密码username=&#39;haha&#39;password=&#39;hehe&#39;#打开Chrome浏览器driver=webdriver.Chrome()driver.maximize_window()#登陆页面初始化login=LoginPage(driver,base_url,title)#打开新浪微博页login.open()#输入用户名login.type_username(username)#输入密码login.type_password(password)#点击登陆login.submit()#打印提示信息print(login.get_message())</code></pre><h6 id="3-3-6运行结果"><a href="#3-3-6运行结果" class="headerlink" title="3.3.6运行结果"></a>3.3.6运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/B7jncD9aOxpuIQ8.png" alt="1232840-20191218141558260-772367539.png"></p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。有问题加群交流讨论</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试18</title>
      <link href="/2016/02/05/selenium/"/>
      <url>/2016/02/05/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《一头扎进》系列之Python+Selenium框架设计篇1-价值好几K的框架，不看别后悔，过时不候</strong></p><h4 id="1-什么是自动化测试框架"><a href="#1-什么是自动化测试框架" class="headerlink" title="1.什么是自动化测试框架"></a>1.什么是自动化测试框架</h4><p>　　在了解什么是自动化测试框架之前，先了解一下什么叫框架？框架是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面，而后者是从目的方面给出的定</p><p>义。从框架的定义可以了解，框架可以是被重用的基础平台；框架也可以是组织架构类的东西。其实后者更为贴切，因为框和架本来就是组织和归类所用的。</p><p>　　所以自动化测试框架的定义为：由一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。</p><p>　　按框架的定义来分，自动化测试框架可以分为：基础功能测试框架、管理执行框架；按不同的测试类型来分，可以分为：功能自动化测试框架、性能自动化测试框架；按测试阶段来分，可以分为：单元自动化测试框架、接口自动化测试框架、系统自动化测试框</p><p>架；按组成结构来分，可以分为：单一自动化测试框架、综合自动化测试框架；按部署方式来分，可以分为：单机自动化测试框架、分布式自动化测试框架。</p><p>　　在百度百科中是这样定义的：自动化测试框架，即是应用于自动化测试所用的框架。按照框架的定义，自动化测试框架要么是提供可重用的基础自动化测试模块，如：selenium[1]、watir等，它们主要提供最基础的自动化测试功能，比如打开一个程序，模拟鼠</p><p>标和键盘来点击或操作被测试对象，最后验证被测对象的属性以判断程序的正确性；要么是可以提供自动化测试执行和管理功能的架构模块，如：PhoenixFramework，robot[2]，STAF[3]等，它们本身不提供基础的自动化测试支持，只是用于组织、管理和执</p><p>行那些独立的自动化测试用例，测试完成后统计测试结果，通常这类框架一般都会集成一个基础自动化测试模块，如：robot框架就可以集成selenium[4]框架，PhoenixFramework集成的也是selenium框架。</p><p>　　简单来说，自动化测试框架就是由一些标准，协议，规则组成，提供脚本运行的环境。自动化测试框架能够提供很多便利给用户高效完成一些事情，例如，结构清晰开发脚本，多种方式、平台执行脚本，良好的报告去跟踪脚本执行结果。</p><p>框架具有以下一些优点：</p><p>1）代码复用</p><p>2）最大覆盖率</p><p>3）很低成本维护</p><p>4）很少人工干预</p><p>5）简单报告输出</p><h4 id="2-为什么要进行自动化测试？"><a href="#2-为什么要进行自动化测试？" class="headerlink" title="2.为什么要进行自动化测试？"></a>2.为什么要进行自动化测试？</h4><p>①、黑盒测试回归效率低</p><p>②、手动测试的偶然性和不确定性</p><p>③、回归的覆盖率不足</p><p>④、交付的产品质量无法保证，全靠评估</p><p>⑤、系统越复杂，问题越多</p><p>⑥、上线时间长、构件失败率高导致的蝴蝶效应（迭代快，加班多）</p><h4 id="3-自动化测试能解决什么问题？"><a href="#3-自动化测试能解决什么问题？" class="headerlink" title="3.自动化测试能解决什么问题？"></a>3.自动化测试能解决什么问题？</h4><p>①、提高出现问题后的响应速率</p><p>②、降低回归成本</p><p>③、提高回归覆盖率</p><p>④、提高回归效率</p><p>⑤、提高回归的稳定性</p><h4 id="4-自动化测试的不足有哪些？"><a href="#4-自动化测试的不足有哪些？" class="headerlink" title="4.自动化测试的不足有哪些？"></a>4.自动化测试的不足有哪些？</h4><p>①、无法减少成本投入，而是为了加快测试结果反馈，提升测试质量</p><p>②、自动化适用于回归和冒烟，而不是发现BUG</p><p>③、录制回放功能是鸡肋，可视化并不是一个很好的做法</p><p>④、不是所有所有系统所有功能都适合做自动化测试</p><h4 id="5-常见的测试框架分类"><a href="#5-常见的测试框架分类" class="headerlink" title="5.常见的测试框架分类"></a>5.常见的测试框架分类</h4><p>好多Selenium自动化测试开发人员是有QTP那边转过来的，所以，他们在早期设计的框架大致可分为以下几类：</p><p>1）基于模块的测试框架</p><p>2）基于库（Library）结构测试框架</p><p>3）数据驱动测试框架，和QTP很像</p><p>4）关键字驱动测试框架，也是QTP过来的</p><p>5）混合测试框，34和综合</p><p>6）行为驱动开发测试框架</p><p>这里我们不一一介绍这些框架，字面意思可以想象一些这些框架的背景和组件，本文只是对框架有一个基本了解。</p><h4 id="6-框架基本组件"><a href="#6-框架基本组件" class="headerlink" title="6.框架基本组件"></a>6.框架基本组件</h4><p>我们来思考下框架组成部分：</p><p>1）需要配置文件管理</p><p>2）业务逻辑代码和测试脚本分离</p><p>3）报告和日志文件输出</p><p>4）自定义的库的封装</p><p>5）管理、执行脚本方式</p><p>6）第三方插件引入</p><p>7）持续集成</p><p>解释：</p><p>我们需要一个配置文件去控制一些，环境信息，开关，配置文件可以是txt/xml/yaml/properties/ini，一般.properties使用较多在JAVA里，本文是Python系列，我可能会选择ini文件。</p><p>业务逻辑代码和测试脚本分离，不像我们刚开始学习Selenium那样，代码和脚本在一个类文件里演示。我们根本没有用到代码重构，复用。代码和用例文件分离后，更加清晰，去多人开发脚本，方便调试。</p><p>报告和日志文件输出，你执行了多少case，case结果如何，这都需要报告来展示，一般采用第三方插件来实现这个功能，好多报告格式是html，简单，明了的风格。日志输出也很重要，如果发生报错，脚本执行失败，通过日志快速定位发生问题位置。</p><p>用户自定义库，这个很好理解，我们很多功能需要重复调用，这样我们就写成一个公用方法，放到工具包下，每次方便调用，例如浏览器引擎类和basepage.py的封装。</p><p>管理和执行脚本的方式，例如Python中单元测试框架unittest使用率非常高。</p><p>第三方插件，有时候，我们一些功能，需要借助第三方插件，能够更好实现，例如AutoIT,来实现文件上传和下载。还有利用第三方报告插件生成基于html格式的测试报告。</p><p>持续集成，git,svn,ant,maven，jenkins，我们会把这整合到jenkins，达到持续集成，一键执行测试脚本。</p><h4 id="7-自动化框架概要设计"><a href="#7-自动化框架概要设计" class="headerlink" title="7.自动化框架概要设计"></a>7.自动化框架概要设计</h4><p>根据以上的框架基本组件特点介绍，宏哥大致用以下图来描述一下，一个简单的自动化测试框架，可能包含配置文件、框架的主要代码、产品业务页面、测试脚本集合、日志和报告和持续集成等等这些组成部分吧，目前想到的只有这么多，如果后期想到宏哥再进一步完善它。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/RrH1PSmTlodjE35.png" alt="1232840-20191217110122669-666536875.png"></p><h4 id="8-自动化框架详细设计"><a href="#8-自动化框架详细设计" class="headerlink" title="8.自动化框架详细设计"></a>8.自动化框架详细设计</h4><p>根据以上的框架概念设计的特点介绍，宏哥这里详细地用以下图来描述一下，一个简单而又实用的自动化测试框架，可能包含以下这些组成部分。宏哥目前细化到这里，后期会将这个框架的代码放到github上，欢迎有兴趣和有能力的大佬给出建议或者完善这个自动化测试框架。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/04/NPfxWpqgtcCMZvr.png" alt="1232840-20191217110646894-714823945.png"></p><h4 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h4><p>　　框架的简单介绍就到这里，有些人把框架想得太复杂了，框架无非就是一些软件的集合，达到特定的目的。这里我们上图画出来的框架，就是一个简单的自动化测试框架，别笑，这确实是一个简单但又包含必要的组件的自动化测试框架设计实例，如果你学会了这个设计思路和思想，那么，你已经达到了自动化测试第二个阶段的水平：能够简单设计自动化测试框架和维护框架的能力。</p><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试17</title>
      <link href="/2016/02/04/selenium/"/>
      <url>/2016/02/04/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列进阶篇之4-python+selenium自动化测试-python几种神操作你都知道吗？（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　今天分享和讲解的超神操作，对于菜鸟来说是超神的操作，对于大佬来说也就是几个简单方法的封装和调用。这里讲解和分享这部分主要是为了培养小伙伴们和童鞋们的面向对象的开发思维，对比这样做的好处让你自己身临其境的感受一番。</p><h4 id="2-自定义封装一个简单的Log类"><a href="#2-自定义封装一个简单的Log类" class="headerlink" title="2.自定义封装一个简单的Log类"></a>2.自定义封装一个简单的Log类</h4><p>　　本文介绍如何写一个Python日志类，用来输出不同级别的日志信息到本地文件夹下的日志文件里。为什么需要日志输出呢，我们需要记录我们测试脚本到底做了什么事情，最好的办法是写事件监听。这个事件监听，对我们现在来说，还是有点复杂去理解，所以我这里，选择封装一个简单的日志类，同样达到这个效果。</p><p>我们大概需要如下日志输出效果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/4QWxs5Jg6TGKN3S.png" alt="1232840-20191216131237292-2061030164.png"></p><h5 id="2-1问题分析"><a href="#2-1问题分析" class="headerlink" title="2.1问题分析"></a>2.1问题分析</h5><p>我们需要封装一个简单的日志类，主要有以下内容：</p><p>1.生成的日志文件格式是年月日时分秒.log</p><p>2.生成的xxx.log文件存储在项目根目录下Logs文件夹下</p><p>3.这个日志类，支持INFO,ERROR两种日志级别</p><p>4.日志里，每行日志输出，如上图，时间日期+执行类名称+日志级别+日志描述</p><h5 id="2-2解决问题思路"><a href="#2-2解决问题思路" class="headerlink" title="2.2解决问题思路"></a>2.2解决问题思路</h5><p>1.在根目录下新建一个Logs的文件夹，如何获取这个Log的相对路径，前面介绍过。</p><p>2.日志的保存命名，需要系统时间，前面也介绍过时间格式化输出</p><p>3.Python中有一个logging模块来支持我们自定义封装一个新日志类。</p><p>4.在脚本里，初始化一个日志类的实例对象，然后去控制输出INFO还是ERROR日志信息。</p><p>自定义日志类封装如下：logger.py，新建在test包下</p><h5 id="2-3代码实现"><a href="#2-3代码实现" class="headerlink" title="2.3代码实现"></a>2.3代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/yqYjMpcAH57NfT9.png" alt="1232840-20191216101846844-1513154920.png"></p><h5 id="2-4参考代码"><a href="#2-4参考代码" class="headerlink" title="2.4参考代码"></a>2.4参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-16@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之4-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importloggingimportos.pathimporttimeclassLogger(object):def__init__(self,logger):&quot;&quot;&quot;指定保存日志的文件路径，日志级别，以及调用文件将日志存入到指定的文件中:paramlogger:&quot;&quot;&quot;#创建一个loggerself.logger=logging.getLogger(logger)self.logger.setLevel(logging.DEBUG)#创建一个handler，用于写入日志文件rq=time.strftime(&#39;%Y%m%d%H%M&#39;,time.localtime(time.time()))print(os.getcwd())log_path=(os.path.dirname(os.getcwd()+&#39;\\Logs\\&#39;))print(log_path)log_name=log_path+rq+&#39;.log&#39;fh=logging.FileHandler(log_name)fh.setLevel(logging.INFO)#再创建一个handler，用于输出到控制台ch=logging.StreamHandler()ch.setLevel(logging.INFO)#定义handler的输出格式formatter=logging.Formatter(&#39;%(asctime)s-%(name)s-%(levelname)s-%(message)s&#39;)fh.setFormatter(formatter)ch.setFormatter(formatter)#给logger添加handlerself.logger.addHandler(fh)self.logger.addHandler(ch)defgetlog(self):returnself.logger</code></pre><h5 id="2-5新建日志测试类"><a href="#2-5新建日志测试类" class="headerlink" title="2.5新建日志测试类"></a>2.5新建日志测试类</h5><p>新写一个测试日志类，相关代码如下：</p><h6 id="2-5-1代码实现"><a href="#2-5-1代码实现" class="headerlink" title="2.5.1代码实现"></a>2.5.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/nBoWslEKuQV9XvS.png" alt="1232840-20191216102448575-825704069.png"></p><h6 id="2-5-2参考代码"><a href="#2-5-2参考代码" class="headerlink" title="2.5.2参考代码"></a>2.5.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-16@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之4-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverfromtest1.loggerimportLoggermylogger=Logger(logger=&#39;test_log&#39;).getlog()classTestMyLog(object):defprint_log(self):driver=webdriver.Chrome()mylogger.info(&quot;打开浏览器&quot;)driver.maximize_window()mylogger.info(&quot;最大化浏览器窗口。&quot;)driver.implicitly_wait(8)driver.get(&quot;https://www.baidu.com&quot;)mylogger.info(&quot;打开百度首页。&quot;)time.sleep(1)mylogger.info(&quot;暂停一秒。&quot;)driver.quit()mylogger.info(&quot;关闭并退出浏览器。&quot;)testlog=TestMyLog()testlog.print_log()</code></pre><h6 id="2-5-3运行结果"><a href="#2-5-3运行结果" class="headerlink" title="2.5.3运行结果"></a>2.5.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/zLeOB5iuTy4KbRE.png" alt="1232840-20191216101947770-1093539999.png"></p><h6 id="2-5-4文件保存结果"><a href="#2-5-4文件保存结果" class="headerlink" title="2.5.4文件保存结果"></a>2.5.4文件保存结果</h6><p>运行代码后，在Logs文件夹下可以看到日志文件，如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/ZRhqPedBJIr8G6V.png" alt="1232840-20191216114213955-1063657544.png"></p><p>在PyCharm里运行下这个测试类，会在根目录下的Logs文件下，新建一个日志文件，打开效果如文章开头的日志输出图。好了，关于自定义封装log类，自己好好去读下代码，理解下每行代码的意思，日志类的封装和调用就介绍到这里。</p><h4 id="3-把截图类方法封装到前面的BasePage-py"><a href="#3-把截图类方法封装到前面的BasePage-py" class="headerlink" title="3.把截图类方法封装到前面的BasePage.py"></a>3.把截图类方法封装到前面的BasePage.py</h4><p>本文介绍把截图类方法封装到BasePage.py文件里，这个文件是在前面Selenium方法二次封装文章里创建的，具体代码请到前面这篇里找。我们截图类写死了把截图图片保存到根目录下的Screenshots文件夹里，图片名称是当前系统时间，图片后缀名是png。</p><p>新的BasePage.py内容如下：</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/r9hboJWRd1Eg4DY.png" alt="1232840-20191216105010072-69579768.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-16@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之4-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importosimporttimefromtest1.loggerimportLoggermylog=Logger(logger=&#39;BasePage&#39;).getlog()classBasePage(object):&quot;&quot;&quot;主要是把常用的几个Selenium方法封装到BasePage这个类，我们这里演示以下几个方法back()forward()get()quit()&quot;&quot;&quot;def__init__(self,driver):&quot;&quot;&quot;写一个构造函数，有一个参数driver:paramdriver:&quot;&quot;&quot;self.driver=driverdefback(self):&quot;&quot;&quot;浏览器后退按钮:paramnone:&quot;&quot;&quot;self.driver.back()defforward(self):&quot;&quot;&quot;浏览器前进按钮:paramnone:&quot;&quot;&quot;self.driver.forward()defopen_url(self,url):&quot;&quot;&quot;打开url站点:paramurl:&quot;&quot;&quot;self.driver.get(url)defquit_browser(self):&quot;&quot;&quot;关闭并停止浏览器服务:paramnone:&quot;&quot;&quot;self.driver.quit()deftake_screenshot(self):&quot;&quot;&quot;截图并保存在根目录下的Screenshots文件夹下:paramnone:&quot;&quot;&quot;file_path=os.path.dirname(os.getcwd())+&#39;/Screenshots/&#39;rq=time.strftime(&#39;%Y%m%d%H%M%S&#39;,time.localtime(time.time()))screen_name=file_path+rq+&#39;.png&#39;try:self.driver.get_screenshot_as_file(screen_name)mylog.info(&quot;开始截图并保存&quot;)exceptExceptionase:mylog.error(&quot;出现异常&quot;,format(e))</code></pre><h5 id="3-3新建截图类"><a href="#3-3新建截图类" class="headerlink" title="3.3新建截图类"></a>3.3新建截图类</h5><p>主要看最后一个截图类方法的封装。</p><p>测试类相关代码如下：</p><h6 id="3-3-1代码实现"><a href="#3-3-1代码实现" class="headerlink" title="3.3.1代码实现"></a>3.3.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/7UHdRJNQF5cf6W9.png" alt="1232840-20191216105604312-1675755847.png"></p><h6 id="3-3-2参考代码"><a href="#3-3-2参考代码" class="headerlink" title="3.3.2参考代码"></a>3.3.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-16@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之4-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverfromblog.basepageimportBasePageclassTestScreenshot(object):driver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(10)basepage=BasePage(driver)deftest_take_screen(self):self.basepage.open_url(&quot;https://www.baidu.com&quot;)time.sleep(1)self.basepage.take_screenshot()self.basepage.quit_browser()test=TestScreenshot()test.test_take_screen()</code></pre><h6 id="3-3-3运行结果"><a href="#3-3-3运行结果" class="headerlink" title="3.3.3运行结果"></a>3.3.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/a1DbrgphyztcXKS.png" alt="1232840-20191216131823471-335187178.png"></p><h6 id="3-3-4截图保存结果"><a href="#3-3-4截图保存结果" class="headerlink" title="3.3.4截图保存结果"></a>3.3.4截图保存结果</h6><p>运行代码后，在Screenshots文件夹下可以看到截图文件，如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/kdyrt6ZaciN4SCb.png" alt="1232840-20191216132031181-770853364.png"></p><p>运行后，可以在根目录下Screenshots文件夹里找到百度首页截图。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/GTira7QS9qx4t3L.png" alt="1232840-20191216132152869-251258986.png"></p><p>本文就介绍了截图类方法添加到BasePage里，介绍了如何保存到根目录下的Screenshots文件夹。</p><h4 id="4-Python中的继承的使用"><a href="#4-Python中的继承的使用" class="headerlink" title="4.Python中的继承的使用"></a>4.Python中的继承的使用</h4><p>本文开始介绍一个面向对象设计领域里，很常见的一种思想，继承。继承有很多好处，常听到的一句话就是，子类能够直接使用父类的方法，这样就可以减少子类代码量。其实，在自动化测试框架设计过程中，是很有必要把继承加入到你的测试脚本中去。接下来我们，简单写一个Python文件，来演示下继承的基本使用。</p><h5 id="4-1新建classA-py"><a href="#4-1新建classA-py" class="headerlink" title="4.1新建classA.py"></a>4.1新建classA.py</h5><p>1.在test1包名下新建一个classA.py，这个就是我们的父类，里面有一个打开chrome浏览器和打开百度首页的方法。</p><h6 id="4-1-2代码实现："><a href="#4-1-2代码实现：" class="headerlink" title="4.1.2代码实现："></a>4.1.2代码实现：</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/qG82ricZtg1W6lK.png" alt="1232840-20191216132517031-1549000048.png"></p><h6 id="4-1-3参考代码"><a href="#4-1-3参考代码" class="headerlink" title="4.1.3参考代码"></a>4.1.3参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-16@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之4-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块fromseleniumimportwebdriverimporttimeclassClassA(object):defopen_baidu(self):driver=webdriver.Chrome()driver.maximize_window()driver.get(&quot;https://www.baidu.com&quot;)time.sleep(1)driver.quit()</code></pre><h5 id="4-2新建classB-py"><a href="#4-2新建classB-py" class="headerlink" title="4.2新建classB.py"></a>4.2新建classB.py</h5><p>1.在test2包下新建一个classB.py文件，这个继承classA.py里的ClassA类。</p><h6 id="4-2-1代码实现"><a href="#4-2-1代码实现" class="headerlink" title="4.2.1代码实现"></a>4.2.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/grnN3KHya8XLbPV.png" alt="1232840-20191216133656288-841765779.png"></p><h6 id="4-2-2参考代码"><a href="#4-2-2参考代码" class="headerlink" title="4.2.2参考代码"></a>4.2.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-16@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之4-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块fromtest1.classAimportClassAclassClassB(ClassA):deftest_inherit(self):self.open_baidu()test=ClassB()test.test_inherit()</code></pre><h6 id="4-2-3运行结果"><a href="#4-2-3运行结果" class="headerlink" title="4.2.3运行结果"></a>4.2.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/nAvXLSEfhe87Vkb.png" alt="1232840-20191216133739311-2034964165.png"></p><p>通过上面可以看出，只需要一句代码就可以实现ClassA中的方法，这个就是继承的好处，减少了很多代码的书写，提高代码的复用。在定义ClassB的时候就要指明ClassB的父类是ClassA.继承相关的话题就介绍到这里，将在后面自动化框架设计会再次提到。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><h5 id="5-1中文乱码"><a href="#5-1中文乱码" class="headerlink" title="5.1中文乱码"></a>5.1中文乱码</h5><p>遇到的问题：细心地小伙伴或者同学们会发现在日志文件中的内容或出现中文乱码，如下图示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/B8hlJPvInXuO3Hd.png" alt="1232840-20191216115134040-360680556.png"></p><p>解决办法：在FileHandler此处要设置encoding格式，</p><pre><code>fh=logging.FileHandler(log_name,encoding=&#39;utf-8&#39;)</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/LYij2yv5asm9npN.png" alt="1232840-20191216134345150-84642328.png"></p><p>修改后，运行代码日志文件内容如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/4QWxs5Jg6TGKN3S.png" alt="1232840-20191216131237292-2061030164.png"></p><h5 id="5-2路径问题"><a href="#5-2路径问题" class="headerlink" title="5.2路径问题"></a>5.2路径问题</h5><p>因为宏哥在代码实践的过程中这部分遇到小问题，就是日志文件和截图放不在指定的文件夹下，所以这里拿出来单独说一下。</p><pre><code>#创建一个handler，用于写入日志文件rq=time.strftime(&#39;%Y%m%d%H%M&#39;,time.localtime(time.time()))#当前目录print(os.getcwd())#根目录print(os.path.dirname(os.getcwd()))#log_path=(os.path.dirname(os.getcwd())+&#39;\\Logs\\&#39;)log_path=os.getcwd()+&#39;\\Logs\\&#39;print(log_path)</code></pre><p>代码说明：</p><pre><code>os.getcwd()：获取的当前最外层调用的脚本路径，即getPath所在的目录也可描述为起始的执行目录，A调用B，起始的是A，那么获取的就是A所在的目录路径。os.path.dirname()：去掉脚本的文件名，返回目录。</code></pre><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试16</title>
      <link href="/2016/02/03/selenium/"/>
      <url>/2016/02/03/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列进阶篇之3-python+selenium自动化测试-python几种骚操作你都知道吗？（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　这篇文章主要是给小伙伴或者童鞋们介绍和分享python几种骚操：读取配置文件、获取根目录的相对路径、获取系统时间和格式化时间显示、字符串切割等等操作。为后边的自动化框架打下一个结实的基础。</p><h4 id="2-Python读取配置文件内容"><a href="#2-Python读取配置文件内容" class="headerlink" title="2.Python读取配置文件内容"></a>2.Python读取配置文件内容</h4><p>　　本文来介绍下Python中如何读取配置文件。任何一个项目，都涉及到了配置文件和管理和读写，Python支持很多配置文件的读写，这里我们就介绍一种配置文件格式的读取数据，叫ini文件。Python中有一个类ConfigParser支持读ini文件。</p><h5 id="2-1新建一个文件夹"><a href="#2-1新建一个文件夹" class="headerlink" title="2.1新建一个文件夹"></a>2.1新建一个文件夹</h5><p>　　首先我们紧接着前边的内容，在项目下，新建一个文件夹，叫config，然后在这个文件夹下新建一个file类型的文件:config.ini</p><h6 id="2-1-1代码实现"><a href="#2-1-1代码实现" class="headerlink" title="2.1.1代码实现"></a>2.1.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/dOGc9toRvXaeQC2.png" alt="1232840-20191213110711592-768281467.png"></p><h6 id="2-1-2参考代码"><a href="#2-1-2参考代码" class="headerlink" title="2.1.2参考代码"></a>2.1.2参考代码</h6><pre><code>#thisisconfigfile,onlystorebrowsertypeandserverURL[browserType]#browserName=FirefoxbrowserName=Chrome#browserName=IE[testServer]URL=https://www.baidu.com#URL=http://www.google.com</code></pre><h5 id="2-2获取当前项目的根目录的相对路径"><a href="#2-2获取当前项目的根目录的相对路径" class="headerlink" title="2.2获取当前项目的根目录的相对路径"></a>2.2获取当前项目的根目录的相对路径</h5><p>　　然后百度搜索一下，python中如何获取当前项目的根目录的相对路径这里采用：</p><pre><code>os.path.dirname(os.path.abspath(&#39;.&#39;))</code></pre><h5 id="2-3新建测试类"><a href="#2-3新建测试类" class="headerlink" title="2.3新建测试类"></a>2.3新建测试类</h5><p>　　最后，在另外一个包下新建一个测试类，用来测试读取配置文件是否正常。</p><h6 id="2-3-1代码实现"><a href="#2-3-1代码实现" class="headerlink" title="2.3.1代码实现"></a>2.3.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/2PB5lIRmfxQX9yk.png" alt="1232840-20191213111711644-1167806660.png"></p><h6 id="2-3-2参考代码"><a href="#2-3-2参考代码" class="headerlink" title="2.3.2参考代码"></a>2.3.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-13@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之3-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importconfigparserimportosclassTestReadConfigFile(object):defget_value(self):root_dir=os.path.dirname(os.path.abspath(&#39;.&#39;))#获取项目根目录的相对路径print(root_dir)config=configparser.ConfigParser()file_path=os.path.dirname(os.path.abspath(&#39;.&#39;))+&#39;/config/config.ini&#39;config.read(file_path)browser=config.get(&quot;browserType&quot;,&quot;browserName&quot;)url=config.get(&quot;testServer&quot;,&quot;URL&quot;)return(browser,url)#返回的是一个元组trcf=TestReadConfigFile()print(trcf.get_value())</code></pre><h6 id="2-3-3运行结果"><a href="#2-3-3运行结果" class="headerlink" title="2.3.3运行结果"></a>2.3.3运行结果</h6><p>你可以试试更改config.ini的内容，看看测试打印出来是不是你更改的东西，在配置文件一般#表示注释，你想要哪行配置代码起作用，你就把前面的#去除，并且在注释其他同一个区域。在ini文件中中括号包裹起来的部分叫section，了解一下就可以。</p><p>修改成如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/GUjl4txH1EZ6CJv.png" alt="1232840-20191213111835635-90292050.png"></p><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/xU2ybtV4jXcr1Zs.png" alt="1232840-20191213111532181-1490993540.png"></p><h4 id="3-Python获取系统时间和格式化时间显示"><a href="#3-Python获取系统时间和格式化时间显示" class="headerlink" title="3.Python获取系统时间和格式化时间显示"></a>3.Python获取系统时间和格式化时间显示</h4><p>前面一篇文章介绍了，Python如何读取config.ini文件，还有如何获取当前项目根目录相对路径写法。在实际项目的开发，获取项目根路径的相对路径写法是很有必要的，不要去是绝对路径。因为，你自己开发的一个项目，如果拷贝到别的电脑里，发现运行不了，需要更改很多文件的路径，那是不是很失败。本篇文章介绍如何去获取和打印格式化系统时间，我们很多时候，看到一些日志，前面都会记录年月日，时分秒，甚至毫秒，然后才是日志描述。这一篇文章，介绍时间获取和格式化时间，就是为了后面，如何写一个简单的日志类做铺垫的。</p><p>在PyCharm下的一个包，右键，新建一个get_time.py文件，输入一下代码：</p><p>这里提醒一个小技巧：在输入导入包的时候，有些包你没有安装，不是系统自带的，可能会遇到红色下划线，你需要鼠标悬停在这个红色下划线，然后在这行的左侧有一个小灯泡，鼠标点击这个小灯泡，一般会有importthisxxx或者installxxx，根据提示来导入包或者安装第三方插件。</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/meIHFA3GSYbpn5i.png" alt="1232840-20191213112704653-714498712.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-13@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之3-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importtimeclassGetTime(object):defget_system_time(self):print(time.time())#time.time()获取的是从1970年到现在的间隔，单位是秒print(time.localtime())new_time=time.strftime(&#39;%Y-%m-%d%H:%M:%S&#39;,time.localtime())#格式化时间，按照2019-12-1313:46:32的格式打印出来print(new_time)gettime=GetTime()gettime.get_system_time()</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/h21a8qpTDZPngNv.png" alt="1232840-20191213112558754-990902586.png"></p><p>！！！你自己试试如何打印出这样的效果：20191213134750的效果。答案自己在文章最后查找。</p><h4 id="4-Python中字符串切割操作"><a href="#4-Python中字符串切割操作" class="headerlink" title="4.Python中字符串切割操作"></a>4.Python中字符串切割操作</h4><p>本文来介绍Python中字符串切割操作，在Python中自带的一个切割方法split(),这个方法不带参数，就默认按照空格去切割字段，如果带参数，就按照参数去切割。为了演示切割效果，我们用百度搜索一个关键字，然后去找一共找到了多个结果的数字。</p><p>例如，百度搜索“selenium”，查看找到了多少个结果，我们需要单独摘取出这个数字。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/H1x3Tmro5WOZER6.png" alt="1232840-20191213141031377-1408099098.png"></p><p>相关脚本代码如下：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/nixEb4pFXWYIfsa.png" alt="1232840-20191213113701448-198877901.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-13@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之3-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverclassGetSubString(object):defget_search_result(self):driver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(8)driver.get(&#39;https://www.baidu.com&#39;)driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;selenium&#39;)time.sleep(1)driver.find_element_by_id(&#39;su&#39;).click()time.sleep(1)search_result_string=driver.find_element_by_xpath(&quot;//*/div[@class=&#39;nums&#39;]&quot;).textprint(search_result_string)new_string=search_result_string.split(&#39;约&#39;)[1]#第一次切割得到xxxx个，[1]代表切割右边部分print(new_string)last_result=new_string.split(&#39;个&#39;)[0]#第二次切割，得到我们想要的数字[0]代表切割参照参数的左边部分print(last_result)getstring=GetSubString()getstring.get_search_result()</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/4Vfl8XiQoxnJdCp.png" alt="1232840-20191213113615877-2089935574.png"></p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><h5 id="5-1答案揭晓"><a href="#5-1答案揭晓" class="headerlink" title="5.1答案揭晓"></a>5.1答案揭晓</h5><h6 id="5-1-1参考代码"><a href="#5-1-1参考代码" class="headerlink" title="5.1.1参考代码"></a>5.1.1参考代码</h6><p>首先把上面的提问在这里把答案公布一下，其实很简单的，只需要修改一处地方即可以实现宏哥说的那种效果，聪明的你答对了没？？？</p><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-13@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之3-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importtimeclassGetTime(object):defget_system_time(self):print(time.time())#time.time()获取的是从1970年到现在的间隔，单位是秒print(time.localtime())new_time=time.strftime(&#39;%Y%m%d%H%M%S&#39;,time.localtime())#格式化时间，按照2017-04-1513:46:32的格式打印出来print(new_time)gettime=GetTime()gettime.get_system_time()</code></pre><h6 id="5-1-2代码运行效果"><a href="#5-1-2代码运行效果" class="headerlink" title="5.1.2代码运行效果"></a>5.1.2代码运行效果</h6><p>将上述代码运行后看一下是不是宏哥说的那种效果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/owTNQ5flzUrW2tv.png" alt="1232840-20191213113036462-1920487334.png"></p><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试15</title>
      <link href="/2016/02/02/selenium/"/>
      <url>/2016/02/02/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列进阶篇之2-python+ selenium自动化测试 - python基础扫盲（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　这篇文章主要是分享讲解一下，如何封装自己用到的方法和类。以便方便自己和别人的调用，这样就可以避免重复地再造轮子。</p><p>　　封装（Encapsulation）是面向对象的三大特征之一（另外两个是继承和多态），它指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。</p><p>就好比使用计算机，我们只需要使用计算机提供的键盘，就可以达到操作计算机的目的，至于在敲击键盘时计算机内部是如何工作，我们根本不需要知道。</p><p>封装机制保证了类内部数据结构的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。总的来说，对一个类或对象实现良好的封装，可以达到以下目的：</p><p>隐藏类的实现细节。</p><p>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对属性的不合理访问。</p><p>可进行数据检查，从而有利于保证对象信息的完整性。</p><p>便于修改，提高代码的可维护性。</p><p>为了实现良好的封装，需要从以下两个方面来考虑：</p><p>将对象的属性和实现细节隐藏起来，不允许外部直接访问。</p><p>把方法暴露出来，让方法来控制对这些属性进行安全的访问和操作。</p><p>因此，实际上封装有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。</p><h4 id="2-二次封装Selenium中几个方法"><a href="#2-二次封装Selenium中几个方法" class="headerlink" title="2.二次封装Selenium中几个方法"></a>2.二次封装Selenium中几个方法</h4><p>　　本文来介绍，如何把常用的几个webdriver的方法封装到自己写的一个类中去，这个封装过程叫二次封装Selenium方法。我们把打开站点，浏览器前进和后退，关闭和退出浏览器这这个方法封装到一个新写的类中去。<br>我们按照如下层次结构在PyCharm中新建两个包和两个.py文件：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/G3cQ4SZol7f5qR2.png" alt="1232840-20191212085659430-1620937194.png"></p><p>上图，baidu_search.py是我们编写测试脚本的python文件，具体测试代码写在这个文件。包test1下的basepage.py文件是这次我们介绍的二次封装selenium方法而新建的。这里提一下，python中默认规则，包名和文件名都是小写，类名称单词首字母大写，函数名称小写，多个字母下划线隔开。我们尽量遵守下这个不成文的约定。</p><p>来看看basepage.py的内容：</p><h5 id="2-1代码实现"><a href="#2-1代码实现" class="headerlink" title="2.1代码实现"></a>2.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/pH2GIV8hnXMyQDw.png" alt="1232840-20191212102853043-578232545.png"></p><h5 id="2-2参考代码"><a href="#2-2参考代码" class="headerlink" title="2.2参考代码"></a>2.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-02@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之2-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块classBasePage(object):&quot;&quot;&quot;主要是把常用的几个Selenium方法封装到BasePage这个类，我们这里演示以下几个方法back()forward()get()quit()&quot;&quot;&quot;def__init__(self,driver):&quot;&quot;&quot;写一个构造函数，有一个参数driver:paramdriver:&quot;&quot;&quot;self.driver=driverdefback(self):&quot;&quot;&quot;浏览器后退按钮:paramnone:&quot;&quot;&quot;self.driver.back()defforward(self):&quot;&quot;&quot;浏览器前进按钮:paramnone:&quot;&quot;&quot;self.driver.forward()defopen_url(self,url):&quot;&quot;&quot;打开url站点:paramurl:&quot;&quot;&quot;self.driver.get(url)defquit_browser(self):&quot;&quot;&quot;关闭并停止浏览器服务:paramnone:&quot;&quot;&quot;self.driver.quit()</code></pre><p>上面的’’’’’’是文档注释，一般在类的开始和函数的开始，用两个’’’’’’括起来，简单描述下这个类或者函数的功能。</p><h4 id="3-调用自己封装过的方法"><a href="#3-调用自己封装过的方法" class="headerlink" title="3.调用自己封装过的方法"></a>3.调用自己封装过的方法</h4><p>接下来看看，我们脚本文件中如何去调用我们自己封装过的方法。</p><p>baidu_search.py的内容如下：</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/aYK42rTq6zXDLFm.png" alt="1232840-20191212104748556-925099244.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-02@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之2-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverfromblog.basepageimportBasePageclassBaiduSearch(object):driver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(10)basepage=BasePage(driver)defopen_baidu(self):self.basepage.open_url(&quot;https://www.baidu.com&quot;)time.sleep(1)deftest_search(self):self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&quot;Selenium&quot;)time.sleep(1)self.basepage.back()self.basepage.forward()self.basepage.quit_browser()baidu=BaiduSearch()baidu.open_baidu()baidu.test_search()</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Cd2GXm7auY6sLUQ.png" alt="1232840-20191212104557256-1270842674.png"></p><p>上面self.basepage的几行代码就是调用我们自己封装的方法去执行相关webdriver操作。这个只是一个简单的封装介绍，等后面，我们介绍了字符串切割，我们会再次介绍二次封装Selenium方法，例如将会把八大find_element方法封装到一个方法里去。</p><h4 id="4-封装一个自己的类-浏览器引擎类"><a href="#4-封装一个自己的类-浏览器引擎类" class="headerlink" title="4.封装一个自己的类-浏览器引擎类"></a>4.封装一个自己的类-浏览器引擎类</h4><p>　　通过上边的一小节我们知道了，如何去封装几个简单的Selenium方法到我们自定义的类，所以我们趁热打铁：这次我们编写一个类，叫浏览器引擎类，通过更改一个字符串的值，利用if语句去判断和控制启动那个浏览器。这里我们暂时，支持三大浏览器</p><p>（IE,Chrome,Firefox）。这里有一个前提条件，在基础篇中，启动三大浏览器的driver文件，检查下你的Python安装路径下有没有这三个driver插件，如果没有，请回到基础篇的如何启动火狐和IE浏览器文章去看看如何做。</p><p>我们继续在test1这个包下新建一个browser_engine.py文件，然后在另外一个包下新建一个test.py文件去测试这个浏览器引擎类是否工作正常。这个浏览器引擎类，我们一开始写简单一点，只写启动浏览器。</p><p>先看看browser_engine.py中的代码：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><h6 id="4-1-1browser-engine-py"><a href="#4-1-1browser-engine-py" class="headerlink" title="4.1.1browser_engine.py"></a>4.1.1browser_engine.py</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/1WNB2f9nh4sjdvz.png" alt="1232840-20191212105917615-1811927608.png"></p><h6 id="4-1-2test-py"><a href="#4-1-2test-py" class="headerlink" title="4.1.2test.py"></a>4.1.2test.py</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Usfx93vVEuHGFq7.png" alt="1232840-20191212110121542-1233075946.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><h6 id="4-2-1browser-engine-py"><a href="#4-2-1browser-engine-py" class="headerlink" title="4.2.1browser_engine.py"></a>4.2.1browser_engine.py</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-02@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之2-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块fromseleniumimportwebdriverclassBrowserEngine(object):&quot;&quot;&quot;定义一个浏览器引擎类，根据browser_type的值去，控制启动不同的浏览器，这里主要是IE，Firefox,Chrome&quot;&quot;&quot;def__init__(self,driver):self.driver=driverbrowser_type=&quot;IE&quot;#maybeFirefox,Chrome,IEdefget_browser(self):&quot;&quot;&quot;通过if语句，来控制初始化不同浏览器的启动，默认是启动Chrome:return:driver&quot;&quot;&quot;ifself.browser_type==&#39;Firefox&#39;:driver=webdriver.Firefox()elifself.browser_type==&#39;Chrome&#39;:driver=webdriver.Chrome()elifself.browser_type==&#39;IE&#39;:driver=webdriver.Ie()else:driver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(10)returndriver</code></pre><h6 id="4-2-2test-py"><a href="#4-2-2test-py" class="headerlink" title="4.2.2test.py"></a>4.2.2test.py</h6><p>再看看test.py代码，进行测试，更改browser_engine.py中browser_type的值，去测试三大浏览器是否启动正常。</p><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-02@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之2-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块fromtest1.browser_engineimportBrowserEngineclassTestBrowserEngine(object):defopen_browser(self):browserengine=BrowserEngine(self)driver=browserengine.get_browser()tbe=TestBrowserEngine()tbe.open_browser()</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>再看看test.py代码，进行测试，更改browser_engine.py中browser_type的值，去测试三大浏览器是否启动正常。</p><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Cd2GXm7auY6sLUQ.png" alt="1232840-20191212104557256-1270842674.png"></p><p>目前，自定义的浏览器引擎类到这里就封装好了，只支持打开不同浏览器，需要手动修改，引擎类中browser_type的值。看起来功能简单，但是我们只是需要学习这种做事的方式和思维，在下一个部分，框架设计的时候，我会再告诉大家如何去加强这个引擎类</p><p>的功能，到时候去修改配置文件中的浏览器类型，而不是修改代码中的字段。通过修改配置文件，从而去打开不同浏览器，并开始测试相关脚本。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>　　好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试14</title>
      <link href="/2016/02/01/selenium/"/>
      <url>/2016/02/01/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列进阶篇之1-python+ selenium自动化测试 - python基础扫盲（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　如果你从一开始就跟着宏哥看博客文章到这里，基础篇和练习篇的文章。如果你认真看过，并且手动去敲过每一篇的脚本代码，那边恭喜你，至少说你算真正会利用Python+Selenium编写自动化脚本了，你基本掌握了Selenium中webdriver的大部分常用的方法函数。有大佬曾经说过，自动化测试大概可以分三个层次：</p><ol><li><p>手工测试用例转换成自动化测试脚本的过程</p></li><li><p>能设计自动化测试框架，至少能够维护自动化测试框架。</p></li><li><p>流程自动化方案设计，例如，一键打包，自动开始测试，自动发送测试报告，自动运维部署上线等。</p></li></ol><p>通过前边文章的基础和练习讲解，学习到这个时间节点，应该是完整介绍了手工测试用例装换成自动化测试脚本这一个初级水平，学到这里，你已经具备了能够编写自动化测试脚本的能力。</p><p>在开始介绍设计简单的自动化测试框架之前，我想在这个节点，插入一个新章节，叫Python+Selenium进阶篇，主要是介绍一些设计框架的前提技能和基本Python编写代码的能力。这些能力包括但不限于以下内容：</p><ol><li><p>主流Python开发IDE工具的基本使用，例如Pycharm</p></li><li><p>Python中模块，类和对象的具体代码讲解。</p></li><li><p>Selenium 常见方法的二次封装。</p></li><li><p>自定义方法的封装和方法的调用-浏览器引擎类。</p></li><li><p>Python读写配置文件介绍</p></li><li><p>Python如何获取系统时间和时间的格式化处理。</p></li><li><p>Python中常见字符串切割处理。</p></li><li><p>Python自定义一个日志生成方法封装。</p></li><li><p>Selenium中一个截图方法的封装。</p></li><li><p>Python中继承的使用。</p></li></ol><p>通过介绍以上进阶技能学习后，我们才可以，或者有能力去思考和动手去设计一个简单的自动化测试框架。</p><h4 id="2-pycharm安装"><a href="#2-pycharm安装" class="headerlink" title="2.pycharm安装"></a>2.pycharm安装</h4><p>　　在Python开发过程中，比较流行，很优秀的一款IDE工具-PyCharm，这里关于它的介绍就一句话，它就相当于Java开发中的Eclipse软件一样。有些人说，Eclipse上可以通过安装插件扩展来支持Python的代码编写，虽然可以这样，但是我强烈建议，你本来就是</p><p>学习，为啥不选择一个符合大众的选择工具呢，不管你用没有用户Eclipse，在这里，你将要用PyCharm进行自动化测试框架的开发。</p><p>这里宏哥就不废话也不啰嗦了，可以参考宏哥这篇文章:手把手的教你安装PyCharm–Pycharm安装详细教程（一）（非常详细，非常实用）里边有详细的安装步骤。</p><h4 id="3-pycharm简单使用"><a href="#3-pycharm简单使用" class="headerlink" title="3.pycharm简单使用"></a>3.pycharm简单使用</h4><h5 id="3-1创建一个包，或者文件夹，或者python文件"><a href="#3-1创建一个包，或者文件夹，或者python文件" class="headerlink" title="3.1创建一个包，或者文件夹，或者python文件"></a>3.1创建一个包，或者文件夹，或者python文件</h5><p>如何创建一个包，或者文件夹，或者python文件,请看下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/NI2v5SHmtQbPde9.png" alt="1232840-20191211113055856-127473304.png"></p><h5 id="3-2设置工作面板中的字体"><a href="#3-2设置工作面板中的字体" class="headerlink" title="3.2设置工作面板中的字体"></a>3.2设置工作面板中的字体</h5><p>如何设置工作面板中的字体：</p><p>点击File-Settings，调出设置面板：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/IUMuNDKmtqCvRQB.png" alt="1232840-20191211113106988-338809005.png"></p><h5 id="3-3设置代码面板中背景颜色"><a href="#3-3设置代码面板中背景颜色" class="headerlink" title="3.3设置代码面板中背景颜色"></a>3.3设置代码面板中背景颜色</h5><p>如何设置代码面板中背景颜色成绿豆色，据说绿豆色养眼，护眼，绿豆色用RGB表示：C7EDCC</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/dvtkYGIKMmO8nTf.png" alt="1232840-20191211113117929-1734382007.png"></p><h5 id="3-4多行注释快捷键"><a href="#3-4多行注释快捷键" class="headerlink" title="3.4多行注释快捷键"></a>3.4多行注释快捷键</h5><p>在PyCharm如何多行注释：选中多行代码，ctrl+/</p><h5 id="3-5运行代码"><a href="#3-5运行代码" class="headerlink" title="3.5运行代码"></a>3.5运行代码</h5><p>在PyCharm如何运行代码：点击菜单栏绿色三角或者，在代码面板，右键，选中Runxxx</p><p>好了这里就简单的介绍一下，自己慢慢的用着用着熟练就好了。用一时一时爽，一直用一直爽！！！</p><h4 id="4-Python中类-函数-模块的简单介绍和方法调用"><a href="#4-Python中类-函数-模块的简单介绍和方法调用" class="headerlink" title="4.Python中类/函数/模块的简单介绍和方法调用"></a>4.Python中类/函数/模块的简单介绍和方法调用</h4><p>　　前边小章节介绍了PyCharm的基本使用，接下来我们的脚本代码都在这个PyCharm这个编辑器里写。好处有很多，项目文件结构层次清晰，写代码的时候会自动化提示和补全。这里，我们在昨天创建的项目下，新建一个包，然后在包下面新建一个demo.py文件。抄写以下代码到你的环境里，尝试运行下，看看有没有问题。</p><p>关于Python中类和函数及方法的调用，我们写在这个demo.py文件，具体代码如下：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/XAVBjSQRZ92iCdx.png" alt="1232840-20191211142600258-1375633874.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-01@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之1-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块classClassA(object):string1=&quot;这是一个字符串。&quot;definstancefunc(self):print(&#39;这是一个实例方法。&#39;)print(self)@classmethoddefclassfunc(cls):print(&#39;这是一个类方法。&#39;)print(cls)@staticmethoddefstaticfun():print(&#39;这是一个静态方法。&#39;)test=ClassA()#初始化一个ClasssA的对象，test是类ClassA的实例对象test.instancefunc()#对象调用实例方法test.staticfun()#对象调用静态方法test.classfunc()#对象调用类方法print(test.string1)#对象调用类变量ClassA.instancefunc(test)#类调用实例方法，需要带参数，这里的test是一个对象参数ClassA.instancefunc(ClassA)#类调用实例方法，需要带参数，这里的ClassA是一个类参数ClassA.staticfun()#类调用静态方法ClassA.classfunc()#类调用类方法</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Efg6dtQXFk3vrmz.png" alt="1232840-20191211142654270-819091659.png"></p><p>备注：</p><p>先运行下代码是否会报错，然后尝试自己去理解下。主要有以下几点内容</p><p>1.类的定义，class开头的就表示这是一个类，小括号里面的，表示这个类的父类，涉及到继承，默认object是所有类的父类。python中定义类，小括号内主要有三种：1.具体一个父类，2.object3.空白</p><p>2.函数或方法的定义，def开头就表示定义一个函数，方法包括，实例方法，类方法，静态方法，注意看类方法和静态方法定义的时候上面有一个@标记。</p><p>3.对象调用方法和类调用方法的使用。</p><p>这篇讲的东西，确实比较难理解。如果学过java的人，可能会好理解类和对象，以及面向对象的概念。Python同时支持面向过程变成和面向对象编程，所有python中也有类和对象等概念。一般来说，概念的东西比较绕，如果你Python基础没有看到这部分，那边</p><p>请回去《看笨方法学python》中关于这块的介绍。如果有看过了，还是不理解，我只能告诉你，继续学下去，你现在哪怕死记住这些概念和他们的基本使用。等到后面，框架设计部分，你会慢慢体会到这些基本概念的实际用法，你跟着写了代码后，会有助于你自己</p><p>的理解和提高。</p><p>最后，来说下python中的模块，在python中，你新建一个demo.py文件，那么一个.py文件可以说是一个模块，一个模块中，可以定义多个class，模块中也可以直接定义函数。和java一样，访问不同包下的类和方法之前，需要导入相关路径下的包。例如from</p><p>seleniumimportwebdriver这个导入语句，我们知道webdriver这个接口是在selenium的模块下。</p><p>本小章节的学习目的，就是会用函数或者类来编写我们之前写过的脚本。那么接下来就和宏哥来体验一下吧。</p><h4 id="5-趁热打铁or牛刀小试"><a href="#5-趁热打铁or牛刀小试" class="headerlink" title="5.趁热打铁or牛刀小试"></a>5.趁热打铁or牛刀小试</h4><p>　　这里宏哥以下用百度搜索举例,模仿上面用类调用实例的方法来写这个脚本，可能看起来比较啰嗦，但是代码多了，你就会体会到类的作用，注意这里self指的是当前BaiduSearch这个类本身：</p><h5 id="5-1代码实现："><a href="#5-1代码实现：" class="headerlink" title="5.1代码实现："></a>5.1代码实现：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/6uKVbASHy3Fx92R.png" alt="1232840-20191211143714980-1280346234.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-02-01@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列进阶篇之1-python+selenium自动化测试-python基础扫盲&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverclassBaiduSearch(object):driver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(10)　　defopen_baidu(self):　　self.driver.get(&quot;https://www.baidu.com&quot;)　　time.sleep(1)　　deftest_search(self):　　self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&quot;selenium&quot;)　　time.sleep(1)　　print(self.driver.title)　　try:　　assert&#39;selenium&#39;inself.driver.title　　print(&#39;Testpass.&#39;)　　exceptExceptionase:　　print(&#39;Testfail.&#39;)self.driver.quit()baidu=BaiduSearch()baidu.open_baidu()baidu.test_search()</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/L5cjZrwnsdftbgW.png" alt="1232840-20191211144116797-541029423.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>　　好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试13</title>
      <link href="/2016/01/31/selenium/"/>
      <url>/2016/01/31/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之9-python+ selenium自动化测试-番外篇 - 最后一波啊！！！（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　本来上一篇就是练习篇的最后一篇文章了，但是有的小伙伴私下反映说是做了那么多练习，没有一个比较综合的demo练练手。因此宏哥在这里又补存了一些常见的知识点进行练习，在文章最后也通过实例给小伙伴们或者童鞋们进行了一个登录模块的自动化测试的实例，其他的你可以照猫画虎地轻松的搞定和实现。</p><h4 id="2-python-web自动化-三种等待方式"><a href="#2-python-web自动化-三种等待方式" class="headerlink" title="2.python-web自动化-三种等待方式"></a>2.python-web自动化-三种等待方式</h4><p>当有元素定位不到时，比如下拉框，弹出框等各种定位不到时；</p><p>一般是两种问题：1、有frame；2、没有加等待</p><p>下面学习三种等待方式：</p><h5 id="2-1强制等待sleep（xx）或者Time-sleep"><a href="#2-1强制等待sleep（xx）或者Time-sleep" class="headerlink" title="2.1强制等待sleep（xx）或者Time.sleep"></a>2.1强制等待sleep（xx）或者Time.sleep</h5><p>是在程序运行过程中使用time模块中的sleep进行代码的休眠进行强制等待，是显式等待中的一种极端情况。</p><p>这种方法简单粗暴，不管浏览器是否加载完，程序都要等待规定的xx时间，时间到了才继续执行下面的代码。</p><p>不建议总是用这种等待方式，会严重影响程序的执行速度。通过time模块中sleep进行代码的暂停，但是实际使用过程中，如果都以sleep进行控制严重影响了程序的运行。</p><h6 id="2-1-1参考代码1"><a href="#2-1-1参考代码1" class="headerlink" title="2.1.1参考代码1"></a>2.1.1参考代码1</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-10@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之9-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块importtime#强制等待——代码休眠fromseleniumimportwebdriverdriver=webdriver.Chrome()driver.get(&quot;https://www.baidu.com&quot;)time.sleep(3)driver.quit()</code></pre><h6 id="2-1-2参考代码2"><a href="#2-1-2参考代码2" class="headerlink" title="2.1.2参考代码2"></a>2.1.2参考代码2</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-10@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之9-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块fromseleniumimportwebdriverfromtimeimportsleepdriver=webdriver.Chrome()driver.get(&#39;https://www.baidu.com/&#39;)sleep(3)#强制性等待3s再执行以下代码print(driver.current_url)driver.quit()#退出驱动，关闭所有窗口</code></pre><h5 id="2-2隐性等待implicitly-wait-xx"><a href="#2-2隐性等待implicitly-wait-xx" class="headerlink" title="2.2隐性等待implicitly_wait(xx)"></a>2.2隐性等待implicitly_wait(xx)</h5><p>这种方法是设置一个最长的等待时间，如果在规定时间内网页全部元素加载完成，则执行下一步，否则一直等待时间截止才执行下一步。比强制性等待智能些</p><p>！隐性等待对整个driver的周期都起作用，所以只要设置一次即可</p><h6 id="2-2-1参考代码1"><a href="#2-2-1参考代码1" class="headerlink" title="2.2.1参考代码1"></a>2.2.1参考代码1</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-10@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之9-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块fromseleniumimportwebdriverfromselenium.common.exceptionsimportNoSuchElementExceptionfromtimeimportctimedriver=webdriver.Firefox()#设置隐式等待为10秒driver.implicitly_wait(10)driver.get(&quot;http://www.baidu.com&quot;)try:print(ctime())driver.find_element_by_id(&quot;kw22&quot;).send_keys(&#39;selenium&#39;)exceptNoSuchElementExceptionase:print(e)finally:print(ctime())driver.quit()</code></pre><p>这里可以看到在10秒内没有找到想要找到的元素，但是依旧执行了10秒，然后报错，如果修改代码为可以找到，代码执行非常迅速。</p><p>implicitly_wait()默认参数的单位为秒，本例中设置等待时长为10秒。首先这10秒并非一个固定的等待时间，它并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；如果元素定位</p><p>不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第6秒定位到了元素则继续执行，若直到超出设置时长（10秒）还没有定位到元素，则抛出异常。</p><h6 id="2-2-2参考代码2"><a href="#2-2-2参考代码2" class="headerlink" title="2.2.2参考代码2"></a>2.2.2参考代码2</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-10@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之9-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块fromseleniumimportwebdriverdriver=webdriver.Chrome()driver.get(&#39;https://www.baidu.com/&#39;)driver.implicitly_wait(30)#隐性等待,最长30sprint(driver.current_url)driver.quit()</code></pre><h5 id="2-3-显性等待WebDriverWait"><a href="#2-3-显性等待WebDriverWait" class="headerlink" title="2.3.显性等待WebDriverWait"></a>2.3.显性等待WebDriverWait</h5><p>WebDriverWait配合该类的until()和until_not()方法，根据条件灵活的等待</p><p>程序每隔xx秒看一眼，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出TimeoutException。</p><p>显式等待是你在代码中定义等待一定条件发生后再进一步执行你的代码。</p><p>A.使用前，先引用相关库</p><p>B.确定元素的定位表达式</p><p>C.使用expected_conditions对应的方法来生成判断条件</p><pre><code>WebDriverWait(driver,10,1).until(EC.visibility_of_element_located((By.ID,ele_locator)))WebDriverWait(driver,10,1).until(EC.visibility_of_element_located((By.XPATH,ele_locator)))</code></pre><p>D.调用WebDriverWait类设置等待总时长、轮询周期</p><h6 id="2-3-1参考代码1"><a href="#2-3-1参考代码1" class="headerlink" title="2.3.1参考代码1"></a>2.3.1参考代码1</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-10@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之9-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块#A.使用前，先引用相关库fromseleniumimportwebdriverfromselenium.webdriver.support.waitimportWebDriverWaitfromselenium.webdriver.supportimportexpected_conditionsasECfromselenium.webdriver.common.byimportBydriver=webdriver.Chrome()#打开Chrome浏览器driver.get(&#39;https://www.baidu.com/&#39;)#打开百度driver.find_element_by_xpath(&#39;//div[@id=&quot;u1&quot;]//a[@name=&quot;tj_login&quot;]&#39;).click()#点击【登录】；click()方法，可模拟在按钮上的一次鼠标单击。#B.确定元素的定位表达式ele_locator=&quot;TANGRAM__PSP_10__footerULoginBtn&quot;#通过id,确定‘用户名登录’元素#C.使用expected_conditions对应的方法来生成判断条件#EC.方法名(定位方式,定位表达式)#EC.visibility_of_element_located(By.ID,ele_locator)#元素可见#D.调用WebDriverWait类设置等待总时长、轮询周期#WebDriverWait(driver,超时时长,调用频率（默认0.5s）).until(可执行方法,超时时返回的信息)#等待10秒钟，每隔1秒去查看对应的元素是否可见；如果可见，继续下一步操作；如果不可见，则继续等待，直到10s结束，如果元素还是不可见，则抛出超时异常WebDriverWait(driver,10,1).until(EC.visibility_of_element_located((By.ID,ele_locator)))driver.find_element_by_id(&#39;TANGRAM__PSP_10__footerULoginBtn&#39;).click()#点击【用户名登录】driver.close()#关闭当前窗口</code></pre><h6 id="2-3-2参考代码2"><a href="#2-3-2参考代码2" class="headerlink" title="2.3.2参考代码2"></a>2.3.2参考代码2</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-10@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之9-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块fromtimeimportctimefromseleniumimportwebdriverfromselenium.webdriver.common.byimportByfromselenium.webdriver.support.uiimportWebDriverWaitfromselenium.webdriver.supportimportexpected_conditionsasECdr=webdriver.Chrome()dr.get(&#39;https://www.baidu.com&#39;)try:print(ctime())element=WebDriverWait(dr,10).until(EC.presence_of_element_located((By.ID,&quot;kw&quot;)))#WebDriverWait(driver=self.driver,timeout=300,poll_frequency=0.5,ignored_exceptions=None)#driver：浏览器驱动#timeout：最长超时等待时间#poll_frequency：检测的时间间隔，默认为500ms#ignore_exception：超时后抛出的异常信息，默认情况下抛NoSuchElementException异常print(&quot;我已找到&quot;)finally:print(ctime())dr.quit()</code></pre><p>执行结果：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/SaiOjFeMpKybECs.png" alt="1232840-20191210095812467-1566559149.png"></p><p>以上代码执行后就发现，整段代码执行速度非常快，即使我在WebDriverWait中设置10秒，也不会等待10秒的情况，因为在不到一秒内，已经完成了加载并定位id为“kw”的元素。</p><p>通过WebDriverWait和ExpectedCondition组合使用，让我们的代码执行只需要等待需要的时长，而不是固定的时长，这样最大限度的节省时间。</p><p>此外ExpectedCondition类中提供了很多预期条件判断方法，省去了再创建包的功夫：</p><pre><code>&quot;&quot;&quot;title_is：判断当前页面的title是否等于预期title_contains：判断当前页面的title是否包含预期字符串presence_of_element_located：判断某个元素是否被加到了dom树里，并不代表该元素一定可见visibility_of_element_located：判断某个元素是否可见.可见代表元素非隐藏，并且元素的宽和高都不等于0visibility_of：跟上面的方法做一样的事情，只是上面的方法要传入locator，这个方法直接传定位到的element就好了presence_of_all_elements_located：判断是否至少有1个元素存在于dom树中。举个例子，如果页面上有n个元素的class都是&#39;column-md-3&#39;，那么只要有1个元素存在，这个方法就返回Truetext_to_be_present_in_element：判断某个元素中的text是否包含了预期的字符串text_to_be_present_in_element_value：判断某个元素中的value属性是否包含了预期的字符串frame_to_be_available_and_switch_to_it：判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回Falseinvisibility_of_element_located：判断某个元素中是否不存在于dom树或不可见element_to_be_clickable-itisDisplayedandEnabled：判断某个元素中是否可见并且是enable的，这样的话才叫clickablestaleness_of：等某个元素从dom树中移除，注意，这个方法也是返回True或Falseelement_to_be_selected：判断某个元素是否被选中了,一般用在下拉列表element_located_to_be_selectedelement_selection_state_to_be：判断某个元素的选中状态是否符合预期element_located_selection_state_to_be：跟上面的方法作用一样，只是上面的方法传入定位到的element，而这个方法传入locatoralert_is_present：判断页面上是否存在alert&quot;&quot;&quot;</code></pre><p>另外这里使用了until()函数也可以使用until_not()</p><pre><code>　　until_not(method,message=&#39;&#39;)</code></pre><p>调用该方法体提供的回调函数作为一个参数，直到返回值为False</p><pre><code>　　until(method,message=&#39;&#39;)</code></pre><p>调用该方法体提供的回调函数作为一个参数，直到返回值为True</p><h4 id="3-下拉框or弹框"><a href="#3-下拉框or弹框" class="headerlink" title="3.下拉框or弹框"></a>3.下拉框or弹框</h4><p>通常情况下，在网页中会有一些下拉框进行选择或者给你一个弹框告诉你需要进行确认，遇到这样的情况如何解决呢，宏哥在这里就来简单地说一说……‘’</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/xRG2TZDMVoSytE8.png" alt="1232840-20191210102339912-363889200.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-09@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇8&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverfromselenium.webdriver.common.byimportByfromselenium.webdriver.common.keysimportKeysfromselenium.webdriver.common.action_chainsimportActionChainsfromselenium.webdriver.support.selectimportSelectdriver=webdriver.Chrome()driver.get(&quot;https://www.baidu.com&quot;)time.sleep(5)#driver.find_element(By.ID,&quot;kw&quot;).send_keys(&quot;selenium&amp;python&quot;)#driver.find_element(By.ID,&quot;su&quot;).click()#driver.find_element(By.XPATH,&#39;/html/body/div[1]/div[5]/div[1]/div[2]/div[1]/div[2]/div[1]&#39;).click()#driver.find_element(By.XPATH,&#39;/html/body/div[1]/div[5]/div[1]/div[2]/div[1]/div[1]/span[2]&#39;).click()#折腾半天才发现定位出来的不是下拉框……driver.find_element(By.LINK_TEXT,&#39;设置&#39;).click()driver.find_element(By.LINK_TEXT,&#39;搜索设置&#39;).click()time.sleep(2)sel=driver.find_element(By.XPATH,&#39;//*[@id=&quot;nr&quot;]&#39;)#定位下拉框Select(sel).select_by_value(&#39;50&#39;)#通过value的值进行选定条目driver.find_element(By.CLASS_NAME,&#39;prefpanelgo&#39;).click()time.sleep(2)driver.switch_to.alert.accept()#此处同意警告框提示内容time.sleep(2)driver.quit()</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/oFBblP2t3qj8zav.png" alt="1232840-20191210102542835-1737742273.png"></p><h5 id="3-4浏览器"><a href="#3-4浏览器" class="headerlink" title="3.4浏览器"></a>3.4浏览器</h5><p>浏览器跳转到设置页面，会提示“已记录下您的偏好”</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Ofd1KakH5y6NJsW.png" alt="1232840-20191210102706151-900086221.png"></p><p>在百度首页想要进行设置每次搜索页面显示的数目，就会有一个下拉框进行选择，这里可以导入Select这个模块进行对下拉框进行选择，通常下拉框的列表是包含一个值的，这样就可以通过value来选定，完成设置之后，当然是要保存设置啦，点击保存发现，居然有</p><p>一个弹框，这可如何是好，切换至alert之后接受吧……</p><p>通过在编辑器中的提示，我们同样可以给弹框发送一个值，当然这里设置中并没有出现这类情况。</p><p>这次对下拉框和弹框的处理过程中，折腾了不短时间，原因就是元素等待的问题，下回要仔细研究下元素等待的问题了。</p><h4 id="4-自动化测试demo"><a href="#4-自动化测试demo" class="headerlink" title="4.自动化测试demo"></a>4.自动化测试demo</h4><p>使用selenium进行测试，当然是需要进行验证的，此时结合python的断言函数就变得非常有用了。测试中设定好预期，当实际情况与预期有差别，给出错误信息，好像正是所希望的。</p><p>来一段简单的代码看下断言的基本使用:</p><pre><code>#coding:utf-8importtimefromseleniumimportwebdriverdr=webdriver.Chrome()dr.maximize_window()dr.get(&quot;https://www.baidu.com&quot;)print(dr.title)try:assert(dr.title==&quot;百度，你就知道&quot;)except:print(&#39;标题错误，请查看错误信息&#39;)time.sleep(5)dr.quit()</code></pre><p>获取页面的title是否符合我们的预期，当打开的网页title不是我们想要的，不仅从函数assert的提示信息看到原因，也可输出简单的提示信息。</p><p>Web登录测试是很常见的测试，手动测试大家再熟悉不过了，那如何进行自动化登录测试呢！本文就基于python+selenium结合unittest单元测试框架来进行一次简单但比较完整的cnblog自动化登录测试，可提供点参考！下面就包括测试代码和每种测试情况的截图。</p><p>另一种方式是结合python测试框架unittest进行验证。以下的代码只是为了演示：</p><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-10@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇9&#39;&#39;&#39;#3.导入模块importunittestfromseleniumimportwebdriverfromtimeimportsleep&#39;&#39;&#39;</code></pre><p>cnblog的登录测试，分下面几种情况：<br>(1)用户名、密码正确<br>(2)用户名正确、密码不正确<br>(3)用户名正确、密码为空<br>(4)用户名错误、密码正确<br>(5)用户名为空、密码正确（还有用户名和密码均为空时与此情况是一样的，这里就不单独测试了）</p><pre><code>&#39;&#39;&#39;classLoginCase(unittest.TestCase):defsetUp(self):self.dr=webdriver.Chrome()self.dr.maximize_window()#定义登录方法deflogin(self,username,password):self.dr.get(&#39;https://passport.cnblogs.com/user/signin&#39;)#cnblog登录页面self.dr.find_element_by_id(&#39;LoginName&#39;).send_keys(username)self.dr.find_element_by_id(&#39;Password&#39;).send_keys(password)self.dr.find_element_by_id(&#39;submitBtn&#39;).click()deftest_login_success(self):&#39;&#39;&#39;用户名、密码正确&#39;&#39;&#39;self.login(&#39;北京-宏哥&#39;,&#39;!qaz2wsx&#39;)#正确用户名和密码sleep(3)link=self.dr.find_element_by_id(&#39;lnk_current_user&#39;)self.assertTrue(&#39;北京-宏哥&#39;inlink.text)#用assertTrue(x)方法来断言bool(x)isTrue登录成功后用户昵称在lnk_current_user里self.dr.get_screenshot_as_file(&quot;D:\\cnblogtest\\login_success.jpg&quot;)#截图可自定义截图后的保存位置和图片命名deftest_login_pwd_error(self):&#39;&#39;&#39;用户名正确、密码不正确&#39;&#39;&#39;self.login(&#39;北京-宏哥&#39;,&#39;kemi&#39;)#正确用户名，错误密码sleep(2)error_message=self.dr.find_element_by_class_name(&#39;ajax-error-box&#39;).textself.assertIn(&#39;用户名或密码错误&#39;,error_message)#用assertIn(a,b)方法来断言ainb&#39;用户名或密码错误&#39;在error_message里self.dr.get_screenshot_as_file(&quot;D:\\cnblogtest\\login_pwd_error.jpg&quot;)deftest_login_pwd_null(self):&#39;&#39;&#39;用户名正确、密码为空&#39;&#39;&#39;self.login(&#39;北京-宏哥&#39;,&#39;&#39;)#密码为空error_message=self.dr.find_element_by_id(&#39;Password-error&#39;).textself.assertEqual(error_message,&#39;请输入密码&#39;)#用assertEqual(a,b)方法来断言a==b请输入密码等于error_messageself.dr.get_screenshot_as_file(&quot;D:\\cnblogtest\\login_pwd_null.jpg&quot;)deftest_login_user_error(self):&#39;&#39;&#39;用户名错误、密码正确&#39;&#39;&#39;self.login(&#39;北京-宏哥1&#39;,&#39;!qaz2wsx&#39;)#密码正确，用户名错误sleep(2)error_message=self.dr.find_element_by_id(&#39;ajax-error-box&#39;).textself.assertIn(&#39;用户名或密码错误&#39;,error_message)#用assertIn(a,b)方法来断言ainbself.dr.get_screenshot_as_file(&quot;D:\\cnblogtest\\login_user_error.jpg&quot;)deftest_login_user_null(self):&#39;&#39;&#39;用户名为空、密码正确&#39;&#39;&#39;self.login(&#39;&#39;,&#39;!qaz2wsx&#39;)#用户名为空，密码正确error_message=self.dr.find_element_by_id(&#39;LoginName-error&#39;).textself.assertEqual(error_message,&#39;请输入登录用户名&#39;)#用assertEqual(a,b)方法来断言a==bself.dr.get_screenshot_as_file(&quot;D:\\cnblogtest\\login_user_null.jpg&quot;)deftearDown(self):sleep(2)print(&#39;自动测试完毕！&#39;)self.dr.quit()if__name__==&#39;__main__&#39;:unittest.main()</code></pre><p>通过以上代码，我们可以看到使用selenium和unittest框架结合，已经可以对用户登陆的模块做一个简单的自动化测试。</p><p>但是现在博客园的登陆机制的改变有可能部分用例不成功，但是你知道怎么做就可以了。</p><p>测试截图如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/vXliHFn9tsWwS72.png" alt="1232840-20191210112143198-1158153495.png"></p><p>正确用户名和密码登录成功！</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/wgAKT6hseS8fLom.png" alt="1232840-20191210112206398-1659915471.png"></p><p>用户名正确，密码为空</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/csQL7ofS2TBgzZb.png" alt="1232840-20191210112254000-61190505.png"></p><p>用户名为空，密码正确</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/kyKFh25RipJ6uo3.png" alt="1232840-20191210112335159-716848504.png"></p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>好了，今天的分享就到这里吧！！！谢谢各位的耐心阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试12</title>
      <link href="/2016/01/30/selenium/"/>
      <url>/2016/01/30/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之8-python+ selenium自动化测试-压台篇（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　本文是练习篇的最后一篇文章，虽然练习篇的文章到此就要和大家说拜拜了，但是我们的学习之路才刚刚开始。不要停下你的脚步，大步朝前走吧！比你优秀的人还在走着，我们有什么理由停下自己的脚步了，生命不止，学习亦是如此。好了，宏哥的毒鸡汤好喝吧，喝够了就开始学习吧。<br>　　本文主要是练习如何处理iframe切换、处理alert弹窗、获取当前页面全部信息、获取页面href属性和如何截图保存等等内容，希望小伙伴或者童鞋们喜欢哈！！！</p><h4 id="2-处理iframe切换"><a href="#2-处理iframe切换" class="headerlink" title="2.处理iframe切换"></a>2.处理iframe切换</h4><p>　　本文介绍如何利用Selenium中方法，在不同iframe中切换。<br>问题：有时候我们发现元素定位没问题，在测试回放的过程，发现就是找不到元素报错。</p><h5 id="2-1示例一"><a href="#2-1示例一" class="headerlink" title="2.1示例一"></a>2.1示例一</h5><p>　　由于没有找到合适的iframe网站，这里不好用代码举例，简单文字加图片来介绍。但是宏哥辗转反侧的睡不着，最后实在是没招了。于是自己写了一个简陋比较low的网页，利用iframe网页框架，把网页分成上下两个不同iframe控制的页面，把下面html代码保存到<br>一个记事本，然后修改名称为index.html。</p><h5 id="2-2index-html"><a href="#2-2index-html" class="headerlink" title="2.2index.html"></a>2.2index.html</h5><pre><code>&lt;html&gt;&lt;head&gt;&lt;title&gt;iframetestpage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframeid=&quot;frame1&quot;src=&quot;https://www.baidu.com&quot;name=&quot;slider&quot;height=&quot;325&quot;width=&quot;550&quot;&gt;&lt;/iframe&gt;&lt;br&gt;&lt;iframeid=&quot;frame2&quot;src=&quot;http://example.com&quot;name=&quot;example&quot;height=&quot;325&quot;width=&quot;550&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>用本地浏览器打开如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/7BxdqnisvS6OmoA.png" alt="1232840-20191206103624347-982811508.png"></p><p>用firepath来获得百度文本输入框的XPath截图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/AxSKB3Ynzsj8uOG.png" alt="1232840-20191206103818467-1474136437.png"></p><p>看到了红圈位置不是显示TopWindow，说明你要定位的目标元素在一个iframe里，如果要操作这个元素，首先需要从默认的TopWindow，利用switch_to.frame(‘iframeid’)方法来切换到具体的iframe，然后才能去操作目标元素。</p><p>正常百度页面，文本输入框截图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/PIeBUjplXn7RZ98.png" alt="1232840-20191206104024140-983253540.png"></p><p>方法介绍：</p><pre><code>driver.switch_to.frame(&quot;iframe1&quot;)#操作目标元素，这个目标元素在iframe1里面，这里就是百度文本输入框输入文字driver.switch_to.default_content()</code></pre><p>如果有具体项目页面利用了iframe,自己动手写一下脚本。</p><h5 id="2-3示例二"><a href="#2-3示例二" class="headerlink" title="2.3示例二"></a>2.3示例二</h5><p>　　宏哥最后终于找到了一个合适的demo来给小伙伴们或者童鞋们来用代码实际演练的例子如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/SKTAE8qFPhZifX1.png" alt="1232840-20191209113905253-1041700613.png"></p><p>步骤：</p><p>1.先确认你要操作的元素，是否存在与iframe中，如果元素在iframe中就需要切换</p><p>2.找到该iframe</p><p>3.切换到该iframe（两种方式）</p><p>第一种方式：有三种方法，只是单纯的切换</p><pre><code>driver.switch_to.frame(1)#通过index（下标）driver.switch_to.frame(&#39;login_frame_qq&#39;)#通过namedriver.switch_to.frame(driver.find_element_by_xpath(&#39;//iframe[@name=&quot;login_frame_qq&quot;]&#39;))#通过webelement</code></pre><p>第两种方式：既等待元素可见又进行了iframe切换</p><pre><code>WebDriverWait(driver,20).until(EC.frame_to_be_available_and_switch_to_it(&#39;login_frame_qq&#39;))</code></pre><p>4.切换完后，就以这个iframe中的html为主html</p><p>5.返回默认的html页面，无论现在在那一层的iframe，执行一次即可。</p><pre><code>driver.switch_to.default_content()</code></pre><h6 id="2-3-1代码实现"><a href="#2-3-1代码实现" class="headerlink" title="2.3.1代码实现"></a>2.3.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/DVGzC3biqvmEX1F.png" alt="1232840-20191209092347831-595788387.png"></p><h6 id="2-3-2参考代码"><a href="#2-3-2参考代码" class="headerlink" title="2.3.2参考代码"></a>2.3.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-09@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇8&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverfromselenium.webdriver.support.waitimportWebDriverWaitfromselenium.webdriver.supportimportexpected_conditionsasECfromselenium.webdriver.common.byimportBydriver=webdriver.Chrome()driver.maximize_window()#登录腾讯课堂页面driver.get(&#39;https://ke.qq.com/course/list&#39;)#点击首页登录WebDriverWait(driver,20).until(EC.visibility_of_element_located((By.XPATH,&#39;//a[@id=&quot;js_login&quot;]&#39;)))driver.find_element_by_id(&quot;js_login&quot;).click()#登录弹窗点击QQ登录WebDriverWait(driver,20).until(EC.visibility_of_element_located((By.XPATH,&#39;//a[contains(@class,&quot;btns-enter-qq&quot;)]&#39;)))driver.find_element_by_xpath(&#39;//a[contains(@class,&quot;btns-enter-qq&quot;)]&#39;).click()#iframe切换#driver.switch_to.frame(&#39;login_frame_qq&#39;)#通过namedriver.switch_to.frame(driver.find_element_by_xpath(&#39;//iframe[@name=&quot;login_frame_qq&quot;]&#39;))#通过webelement#弹窗点击账户密码登录switcher_plogin#WebDriverWait(driver,20).until(EC.visibility_of_element_located((By.XPATH,&#39;//a[@id=&quot;switcher_plogin&quot;]&#39;)))time.sleep(10)driver.find_element_by_xpath(&#39;//a[@id=&quot;switcher_plogin&quot;]&#39;).click()</code></pre><h6 id="2-3-3运行结果"><a href="#2-3-3运行结果" class="headerlink" title="2.3.3运行结果"></a>2.3.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/EFINJ6mvUQsKkhL.png" alt="1232840-20191209090549797-1965612904.png"></p><h6 id="2-3-4浏览器运行结果"><a href="#2-3-4浏览器运行结果" class="headerlink" title="2.3.4浏览器运行结果"></a>2.3.4浏览器运行结果</h6><p>浏览器的运行过程，宏哥这里就不做屏幕录制了，这个我们看一下结果。浏览器运行结果如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/vASnEwsDPqmLtOf.png" alt="1232840-20191209092738118-991207600.png"></p><h4 id="3-处理Alert弹窗"><a href="#3-处理Alert弹窗" class="headerlink" title="3.处理Alert弹窗"></a>3.处理Alert弹窗</h4><p>本文来介绍如何通过Selenium方法去处理网页Alert弹窗，和处理iframe类似，都是通过switch_to方法。这里还是没有找到合适的alert弹窗网站，我们就自己创建一个吧，前面文章介绍了如何通过执行JS来增加一个弹窗。</p><p>（1）使用switch_to方法先切换到浏览器弹出框<br>driver.switch_to.alert<br>（2）Alert类提供了一系列的操作方法<br>dismiss():否<br>accept():是<br>text():获取弹出框里的文本内容<br>send_keys():在弹出框里输入文本</p><p>相关脚本代码如下：</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/tFbBZV7iUWl1fze.png" alt="1232840-20191206162720819-1573154394.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-09@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇8&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)time.sleep(1)driver.execute_script(&quot;window.alert(&#39;这是一个测试Alert弹窗&#39;);&quot;)time.sleep(2)driver.switch_to_alert().accept()#点击弹出里面的确定按钮#driver.switch_to_alert().dismiss()#点击弹出上面的X按</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/mhqsLlINjAkyJH4.png" alt="1232840-20191206162543872-1121124198.png"></p><p>注意：<br>driver.switch_to_alert().accept()</p><p>这是一个老方法，在有些编辑器（后面会介绍一款Python的IDE工具）会提示这个方法划横线，说明在最新Selenium在Pyhton支持包里，这个方法被丢弃，虽然还是可以用，现在新的方法是switch_to.alert(),用这个最新方法，我测试了下，无法模拟点击确定和点击关</p><p>闭弹窗按钮，所以这个地方选择了旧的方法switch_to_alert()</p><h4 id="4-获取当前页面全部图片信息"><a href="#4-获取当前页面全部图片信息" class="headerlink" title="4.获取当前页面全部图片信息"></a>4.获取当前页面全部图片信息</h4><p>本文来介绍下如何获取当前页面全部的图片信息，图片信息可能包括，图片名称，图片大小等。</p><p>相关脚本代码如下：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/9HTrQSvnKMgbuG3.png" alt="1232840-20191209093332225-902209360.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-09@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇8&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;http://news.baidu.com&quot;)time.sleep(1)forimageindriver.find_elements_by_tag_name(&quot;img&quot;):print(image.text)print(image.size)print(image.tag_name)</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/P4vZ5J8VUMRigtF.png" alt="1232840-20191209093243331-2083227649.png"></p><p>运行结果：</p><p>运行结果，发现没有图片名称打印出来，说明百度新闻页面，所有图片都没有给出text这个属性，前端的妹子没有写图片的text属性。不相信的同学或者小伙伴们可以通过F12查看一下图片是否有text这个属性。</p><h4 id="5-获取页面元素的href属性"><a href="#5-获取页面元素的href属性" class="headerlink" title="5.获取页面元素的href属性"></a>5.获取页面元素的href属性</h4><p>本文来介绍如何通过Selenium获取页面元素的某一个属性。一个元素可能有多个属性，例如class,id,name,text,href,vale等等。这里我们举例一个爬虫中经常需要处理的链接问题：找出当前页面所有的超链接。</p><p>已百度首页为例，打印所有包含href的元素的链接。</p><p>相关脚本代码如下：</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/cG1nS6eXHBl5u8s.png" alt="1232840-20191209094423839-1113523856.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-09@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇8&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)time.sleep(1)forlinkindriver.find_elements_by_xpath(&quot;//*[@href]&quot;):print(link.get_attribute(&#39;href&#39;))driver.quit()</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/qCgrwvnxAFds8Zb.png" alt="1232840-20191209094149221-303452327.png"></p><p>这里只是找元素的href属性，如果你需要其它属性，例如你需要查看页面所有元素具有id值的话，你可以这样写：print(link.get_attribute(‘id’))</p><h4 id="6-如何截图并保存"><a href="#6-如何截图并保存" class="headerlink" title="6.如何截图并保存"></a>6.如何截图并保存</h4><p>本文介绍如何利用Selenium的方法进行截图，在测试过程中，是有必要截图，特别是遇到错误的时候进行截图。在seleniumforpython中主要有三个截图方法，我们挑选其中最常用的一种。</p><pre><code>get_screenshot_as_file()</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/ATDEIsLlXWObBf9.png" alt="1232840-20191209101447375-197406823.png"></p><p>相关代码如下：</p><h5 id="6-1代码实现"><a href="#6-1代码实现" class="headerlink" title="6.1代码实现"></a>6.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/dN1yjCxJuBTmVH2.png" alt="1232840-20191209095134940-2095002700.png"></p><h5 id="6-2参考代码"><a href="#6-2参考代码" class="headerlink" title="6.2参考代码"></a>6.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-09@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇8&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)time.sleep(1)driver.get_screenshot_as_file(&quot;C:\\Users\\你的账户名\\Desktop\\baidu.png&quot;)driver.quit()</code></pre><h5 id="6-3运行结果"><a href="#6-3运行结果" class="headerlink" title="6.3运行结果"></a>6.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Hl1TLFidjsgSXvp.png" alt="1232840-20191209095005652-573588182.png"></p><h5 id="6-4执行结果"><a href="#6-4执行结果" class="headerlink" title="6.4执行结果"></a>6.4执行结果</h5><p>会在桌面保存一张百度首页的截图，图片后缀是png。注意路径是要两个\。如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/ZKwFp4jeRqgx2nL.png" alt="1232840-20191209094844053-1861319712.png"></p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><h5 id="7-1多个iframe的切换问题"><a href="#7-1多个iframe的切换问题" class="headerlink" title="7.1多个iframe的切换问题"></a>7.1多个iframe的切换问题</h5><pre><code>#如：有两个iframe：f1、f2#1.定位到f1driver.switch_to_frame(&quot;f1&quot;)#2.操作元素#······#3.退出iframedriver.switch_to_default_content()#4.定位到f2driver.switch_to_frame(&quot;f2&quot;)#······</code></pre><h5 id="7-2嵌套：f1中嵌套着f2"><a href="#7-2嵌套：f1中嵌套着f2" class="headerlink" title="7.2嵌套：f1中嵌套着f2"></a>7.2嵌套：f1中嵌套着f2</h5><pre><code>driver.switch_to_frame(&quot;f1&quot;)driver.switch_to_frame(&quot;f2&quot;)#操作元素</code></pre><h5 id="7-3退出iframe"><a href="#7-3退出iframe" class="headerlink" title="7.3退出iframe"></a>7.3退出iframe</h5><pre><code>#第一种方式：跳出所有iframe，回到主界面driver.switch_to_default_content()#第二种方式：回到f1（返回上一级）driver.switch_to.parent_frame()</code></pre><p>好了，今天的练习就到这里，希望大家好好的练习和理解。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试11</title>
      <link href="/2016/01/29/selenium/"/>
      <url>/2016/01/29/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之7-python+ selenium自动化测试-压轴篇（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>“压轴”原本是戏曲名词，指一场折子戏演出的倒数第二个剧目。在现代社会中有很多应用，比如“压轴戏”，但压轴也是人们知识的一个盲区。“压轴”本意是指倒数第二个节目，而不是人们常说的倒数第一个，倒数第一个节目称“压台”。想看“压台篇”，敬请关注宏哥等待压台篇发布。当然了，宏哥不是唱戏啊，而是分享技术类文章的。好了言归正传回归正题。<br>之前的文章中，针对元素的各种属性，进行了相对应的操作，而且对模拟键盘和鼠标的操作也有简单介绍。那么接下来由宏哥带着各位小伙伴和童鞋们来详细地看看selenium如何模拟操作键盘和鼠标；练习如何执行JavaScript、多窗口切换、处理iframe切换等知识和内容。</p><h4 id="2-键盘事件"><a href="#2-键盘事件" class="headerlink" title="2.键盘事件"></a>2.键盘事件</h4><p>webdriver可以模拟常规键盘上所有的按键操作，在导入包的源码中可以看到所有命令对应的按键。<br>以代码的形式来展示：</p><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon 2016-1-29@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之7-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverfromselenium.webdriver.common.byimportByfromselenium.webdriver.common.keysimportKeysdriver=webdriver.Chrome()driver.get(&quot;https://www.baidu.com&quot;)#键盘事件driver.find_element(By.ID,&#39;kw&#39;).send_keys(&quot;selenium&amp;python?&quot;)time.sleep(3)driver.find_element(By.ID,&#39;kw&#39;).send_keys(Keys.BACK_SPACE)#利用backspace键删除字符串最后一位time.sleep(3)driver.find_element(By.ID,&#39;kw&#39;).send_keys(Keys.SPACE)#在字符串后空格键添加空格driver.find_element(By.ID,&#39;kw&#39;).send_keys(&quot;学习&quot;)#继续在字符串后面添加字符串driver.find_element(By.ID,&#39;kw&#39;).send_keys(Keys.ENTER)#输入回车enter键进行搜索time.sleep(3)driver.find_element(By.ID,&#39;kw&#39;).send_keys(Keys.CONTROL,&#39;a&#39;)#全选搜索框中的内容driver.find_element(By.ID,&#39;kw&#39;).send_keys(Keys.CONTROL,&#39;x&#39;)#剪切搜索框中的内容，也可以使用c进行复制time.sleep(3)#打开另外一个搜索网站，输入刚刚剪切的内容driver.get(&quot;https://www.google.com&quot;)driver.find_element(By.ID,&#39;lst-ib&#39;).send_keys(Keys.CONTROL,&#39;v&#39;)#粘贴刚刚复制、剪切的内容driver.find_element(By.ID,&#39;lst-ib&#39;).submit()#提交搜索time.sleep(3)&quot;&quot;&quot;send_keys(Keys.BACK_SPACE)删除键（BackSpace）send_keys(Keys.SPACE)空格键(Space)send_keys(Keys.TAB)制表键(Tab)send_keys(Keys.ESCAPE)回退键（Esc）send_keys(Keys.ENTER)回车键（Enter）send_keys(Keys.CONTROL,‘a’)全选（Ctrl+A）send_keys(Keys.CONTROL,‘c’)复制（Ctrl+C）send_keys(Keys.CONTROL,‘x’)剪切（Ctrl+X）send_keys(Keys.CONTROL,‘v’)粘贴（Ctrl+V）send_keys(Keys.F1)键盘F1...send_keys(Keys.F12)键盘F12&quot;&quot;&quot;driver.quit()</code></pre><h4 id="3-鼠标事件"><a href="#3-鼠标事件" class="headerlink" title="3.鼠标事件"></a>3.鼠标事件</h4><p>上面的键盘事件比较好理解，鼠标事件的话直接看源代码或许就有些纠结了，但是源代码的注释说明其实对ActionChains说明的比较清楚。</p><p>ActionChains是一种自动执行低级别交互的方法，例如鼠标移动，鼠标按钮操作，按键和上下文菜单交互。这对于执行更复杂的操作非常有用，例如悬停和拖放。<br>用户操作。在ActionChains对象上调用操作方法时，操作将存储在ActionChains对象的队列中。当调用perform()时，事件将按它们排队的顺序触发。ActionChains可以用于链式或者可以将操作逐个排队，然后执行。无论哪种方式，动作都按照它们被调用的顺序执行，一个在另一个之后执行。<br>这里还是以代码展示部分功能吧：</p><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2016-1-29@author:北京-宏哥QQ交流群：705269076Project:《手把手教你》系列练习篇之7-python+selenium自动化测试&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverfromselenium.webdriver.common.byimportByfromselenium.webdriver.common.action_chainsimportActionChainsdriver=webdriver.Chrome()driver.get(&quot;https://www.baidu.com&quot;)time.sleep(3)#定位元素ele_1=driver.find_element(By.XPATH,&#39;//*[@id=&quot;u1&quot;]/a[9]&#39;)ele_2=driver.find_element(By.XPATH,&#39;//*[@id=&quot;u1&quot;]/a[8]&#39;)#将鼠标悬停在元素1上3秒后再次悬停到元素2上ActionChains(driver).move_to_element(ele_1).perform()time.sleep(3)ActionChains(driver).move_to_element(ele_2).perform()time.sleep(3)driver.quit()</code></pre><p>上述代码实现了在元素上进行悬停，再移动至另一元素上。<br>还有其他操作如下：</p><pre><code>&quot;&quot;&quot;click(on_element=None)——单击鼠标左键click_and_hold(on_element=None)——点击鼠标左键，不松开context_click(on_element=None)——点击鼠标右键double_click(on_element=None)——双击鼠标左键drag_and_drop(source,target)——拖拽到某个元素然后松开drag_and_drop_by_offset(source,xoffset,yoffset)——拖拽到某个坐标然后松开key_down(value,element=None)——按下某个键盘上的键key_up(value,element=None)——松开某个键move_by_offset(xoffset,yoffset)——鼠标从当前位置移动到某个坐标move_to_element(to_element)——鼠标移动到某个元素move_to_element_with_offset(to_element,xoffset,yoffset)——移动到距某个元素（左上角坐标）多少距离的位置perform()——执行链中的所有动作release(on_element=None)——在某个元素位置松开鼠标左键send_keys(*keys_to_send)——发送某个键到当前焦点的元素send_keys_to_element(element,*keys_to_send)——发送某个键到指定元素&quot;&quot;&quot;</code></pre><p>通过这些键盘和鼠标的操作，就可以做更多了</p><h4 id="4-执行JavaScript"><a href="#4-执行JavaScript" class="headerlink" title="4.执行JavaScript"></a>4.执行JavaScript</h4><p>前面文章介绍了ActionChains下的鼠标悬停和右键操作，其实ActionChains还有其他方法，你可以action=ActionChains,通过这，先初始化一个ActionChains实例对象，然后在action后面输入一个点号，查看支持哪些action方法。本文开始介绍如何执行JS脚本，会用两个例子说明。<br>示例一，执行js脚本触发一个alert弹出框。</p><p>相关脚本代码如下：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/xHrPc97T5e3skbY.png" alt="1232840-20191205103733793-382363550.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-05@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇5&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)time.sleep(1)driver.execute_script(&quot;window.alert(&#39;这是一个alert弹框。&#39;);&quot;)#注意这里的分号是英文输入法的分号，不能用中文</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/ScqHkLpzo2djbUy.png" alt="1232840-20191205103317471-37932605.png"></p><h5 id="4-4浏览器运行结果"><a href="#4-4浏览器运行结果" class="headerlink" title="4.4浏览器运行结果"></a>4.4浏览器运行结果</h5><p>为了看得清楚，我们这里还是不退出浏览器，浏览器运行后，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/5AEdLkhwY2bPDzC.png" alt="1232840-20191205102656468-696074781.png"></p><h5 id="4-5示例二"><a href="#4-5示例二" class="headerlink" title="4.5示例二"></a>4.5示例二</h5><p>执行js脚本来控制浏览器竖向滚动条</p><p>打开百度贴吧，然后拖动滚动条到左侧“地区”</p><h6 id="4-5-1代码实现"><a href="#4-5-1代码实现" class="headerlink" title="4.5.1代码实现"></a>4.5.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/MVIYNJ7cUESaZOd.png" alt="1232840-20191205103629465-491533796.png"></p><h6 id="4-5-2参考代码"><a href="#4-5-2参考代码" class="headerlink" title="4.5.2参考代码"></a>4.5.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2019-12-05@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇5&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://tieba.baidu.com/index.html&quot;)time.sleep(1)target_elem=driver.find_element_by_link_text(&quot;地区&quot;)driver.execute_script(&quot;returnarguments[0].scrollIntoView();&quot;,target_elem)#用目标元素参考去拖动#driver.execute_script(&quot;scroll(0,2400)&quot;)#这个是第二种方法，比较粗劣，大概的拖动</code></pre><h6 id="4-5-3运行结果"><a href="#4-5-3运行结果" class="headerlink" title="4.5.3运行结果"></a>4.5.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/n1DgyvNP2WSZuIV.png" alt="1232840-20191205104221133-408060687.png"></p><h6 id="4-5-4浏览器运行结果"><a href="#4-5-4浏览器运行结果" class="headerlink" title="4.5.4浏览器运行结果"></a>4.5.4浏览器运行结果</h6><p>为了看得清楚，我们这里还是不退出浏览器，浏览器运行后，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/vP1pIGT9lgitsSW.png" alt="1232840-20191205104020503-388179386.png"></p><h4 id="5-多窗口之间切换"><a href="#5-多窗口之间切换" class="headerlink" title="5.多窗口之间切换"></a>5.多窗口之间切换</h4><p>本文来介绍如何处理driver在多窗口之间切换，想一下这样的场景，在页面A点击一个连接，会触发在新Tab或者新窗口打开页面B，由于之前的driver实例对象在页面A，但是你接下来的脚本是操作页面B的元素，这样就造成了找不到元素的报错。本来介绍selenium中switch_to.window()方法来处理这个问题。<br>测试场景：打开百度新闻（页面A），点击热点新闻中第一个新闻链接（一般是国家领导人的新闻），会在第二个窗口打开这个新闻的具体详情页（页面B），测试需要去判断你点击这个这个新闻，在打开的详情页是否正确。<br>问题拆分：</p><p>1.我们已经知道switch_to.window()方法可以处理窗口切换的问题</p><p>2.在页面A跳转到页面B之前，我们需要用一个变量保存这个新闻的标题</p><p>3.切换到页面B后，我们获取这个新闻标题，然后和前面这个变量保存的值去对比，如果相等，那么就测试通过。</p><p>我们分两个步骤去解答这个测试需求：</p><p>1.先实现页面A切换到页面B</p><p>2.页面A和页面B两个新闻标题进行对比</p><p>先看看窗口切换的脚本代码：</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/MEwNQ29lZjPChFn.png" alt="1232840-20191205104928023-1295744114.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2016-1-29@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇5&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.get(&#39;http://news.baidu.com&#39;)time.sleep(1)driver.find_element_by_xpath(&quot;//*[@id=&#39;pane-news&#39;]/div/ul/li[1]/strong/a&quot;).click()print(driver.current_window_handle)#输出当前窗口句柄handles=driver.window_handles#获取当前全部窗口句柄集合print(handles)#输出句柄集合forhandleinhandles:#切换窗口ifhandle!=driver.current_window_handle:print(&#39;switchtosecondwindow&#39;,handle)driver.close()#关闭第一个窗口driver.switch_to.window(handle)#切换到第二个窗口</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/AmIvnlzMqo7dQC1.png" alt="1232840-20191205104812863-544771399.png"></p><h5 id="5-4浏览器运行结果"><a href="#5-4浏览器运行结果" class="headerlink" title="5.4浏览器运行结果"></a>5.4浏览器运行结果</h5><p>为了看得清楚，我们这里还是不退出浏览器，浏览器运行后，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/LCvQt1DiMYdbcPH.png" alt="1232840-20191205105147855-1538119501.png"></p><p>代码解释：<br>1.先打印当前窗口（页面A）句柄，一个长字符串</p><p>2.获取全部窗口句柄，这里我们有两个，打印出这两个句柄。</p><p>3.for循环遍历，当发现其中一个句柄和当前句柄不相等，这里做了三件事，第一件，打印一个语句，告诉你马上要切换到第二个窗口，第二件，关闭当前窗口，这里指页面A，第三，切换到页面B窗口。</p><p>这里在切换到第二个页面时候，我关闭之前的页面A,只是我个人测试习惯，你可以不关闭，但是你的要思路清晰，哪些元素在页面A还是在页面B，如果操作了页面B后还要操作页面A的元素，你还要切换到页面A，为了麻烦，建议你每次切换都把前面页面给关闭。</p><h5 id="5-5断言切换的是不是你刚刚点击的新闻"><a href="#5-5断言切换的是不是你刚刚点击的新闻" class="headerlink" title="5.5断言切换的是不是你刚刚点击的新闻"></a>5.5断言切换的是不是你刚刚点击的新闻</h5><p>判断在打开新页面显示的新闻标题是不是你刚刚点击的新闻，脚本代码如下：</p><h6 id="5-5-1代码实现"><a href="#5-5-1代码实现" class="headerlink" title="5.5.1代码实现"></a>5.5.1代码实现</h6><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/zxKIouNOqLhJPQ4.png" alt="1232840-20191205110618062-370841920.png"></p><h6 id="5-5-2参考代码"><a href="#5-5-2参考代码" class="headerlink" title="5.5.2参考代码"></a>5.5.2参考代码</h6><pre><code>#coding=utf-8🔥#1.先设置编码，utf-8可支持中英文，如上，一般放在第一行#2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Createdon2016-1-29@author:北京-宏哥QQ交流群：705269076Project:python+selenium自动化测试练习篇5&#39;&#39;&#39;#3.导入模块importtimefromseleniumimportwebdriverdriver=webdriver.Chrome()driver.maximize_window()driver.get(&#39;http://news.baidu.com&#39;)time.sleep(1)news_link=driver.find_element_by_xpath(&quot;//*[@id=&#39;pane-news&#39;]/div/ul/li[1]/strong/a&quot;)page1_title_string=news_link.text#得到页面A新闻标题print(&#39;page1_title_string&#39;+page1_title_string)news_link.click()#点击新闻链接time.sleep(1)handles=driver.window_handlesforhandleinhandles:#切换窗口（切换到搜狗）ifhandle!=driver.current_window_handle:print(&#39;switchtosecondwindow&#39;,handle)driver.close()#关闭第一个窗口driver.switch_to.window(handle)#切换到第二个窗口page2_title_string=driver.find_element_by_xpath(&quot;.//*[@id=&#39;title_area&#39;]/h1&quot;).text#详情页有一个原标题print(&#39;page2_title_string&#39;+page2_title_string)try:assertpage1_title_stringinpage2_title_string#判断页面B标题是否包含页面A标题print(&#39;TestPass.&#39;)exceptExceptionase:print(&#39;TestFail&#39;)</code></pre><h6 id="5-5-3运行结果"><a href="#5-5-3运行结果" class="headerlink" title="5.5.3运行结果"></a>5.5.3运行结果</h6><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/OaUHfcRLpxZoyMB.png" alt="1232840-20191205110714931-1694568771.png"></p><p>注意：很有可能遇到，页面A的标题是简短，页面B的标题是长标题，这个时候就需要采取，字符串包含的关系去断言，我这里刚好打开的详情页有一个叫“原标题：xxxx”，由于这个新闻具有时效性，等你看这篇文章，可能脚本运行不成功，需要调整下脚本，如果不</p><p>好断言，就放弃断言部分，本文只学窗口切换，至于测试断言技能，需要你不断去写脚本，去掌握和提高的部分。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>好了，今天的练习就到这里，希望大家好好的练习和理解。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试10</title>
      <link href="/2016/01/28/selenium/"/>
      <url>/2016/01/28/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之6-python+ selenium自动化测试（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天我们还是继续练习练习基本功，各位小伙伴要耐住住性子，要耐得住寂寞啊，不要急躁，后面你会感谢你在前边的不断练习的。前面文章我们了解了如何获取元素的text属性值，和判断元素是否显示在页面（is_displayed()方法），本文我们来学习下，判断一个控件是否被选中状态、获取页面元素的大小、组合键-全选文字、组合键-退格键删除文本和鼠标右键等练习的内容。</p><h4 id="2-验证控件是否被选中"><a href="#2-验证控件是否被选中" class="headerlink" title="2.验证控件是否被选中"></a>2.验证控件是否被选中</h4><p>还是以百度首页点击登录后，进入登录界面的“下次自动登录”举例：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/AfwylQFc8V7YCzb.png" alt="1232840-20191204145924503-1612461568.png"></p><p>由于这个”下次自动登录”是默认被选中状态，我们需要用脚本去判断是否被选中。</p><p>相关代码如下：</p><h5 id="2-1代码实现"><a href="#2-1代码实现" class="headerlink" title="2.1代码实现"></a>2.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/gWq3zhmTXlbHFAQ.png" alt="1232840-20191204155354527-1730785934.png"></p><h5 id="2-2参考代码"><a href="#2-2参考代码" class="headerlink" title="2.2参考代码"></a>2.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-28@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇6&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.get(&#39;https://www.baidu.com&#39;)driver.implicitly_wait(8)driver.find_element_by_xpath(&quot;//*[@id=&#39;u1&#39;]/a[7]&quot;).click()time.sleep(1)driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__footerULoginBtn&#39;]&quot;).click()time.sleep(1)try:    driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__memberPass&#39;]&quot;).is_selected()    print(&quot;Test Pass.&quot;)except Exception as e:    print(&#39;Test fail&#39;, format(e))</code></pre><h5 id="2-3运行结果"><a href="#2-3运行结果" class="headerlink" title="2.3运行结果"></a>2.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/V7tm5QSelNnzJuy.png" alt="1232840-20191204150403148-2007966275.png"></p><p>总结：</p><p>元素方法is_selected()返回是是布尔值，用来判断单选或者多选控件是否被选中，或者下拉选择菜单是否选择一个默认的option，都可以通过这个方法去判断。</p><h4 id="3-获取页面元素大小"><a href="#3-获取页面元素大小" class="headerlink" title="3.获取页面元素大小"></a>3.获取页面元素大小</h4><p>本文介绍如何通过Selenium方法去获取页面元素的大小。这个场景是可能在需要测试的，例如在前端测试过程中，需要去测试某一个控件是否和设计大小保持一致。<br>这里用百度首页的“百度一下”这个按钮举例，打印出这个按钮的大小。</p><p>相关脚本代码如下：</p><h5 id="3-1代码实现："><a href="#3-1代码实现：" class="headerlink" title="3.1代码实现："></a>3.1代码实现：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/5wENJ6BcRlCAFKT.png" alt="1232840-20191204155013523-1820368006.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-28@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com/&quot;)time.sleep(1)search_btn = driver.find_element_by_id(&#39;su&#39;)print (search_btn.size)</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Lan1OAf9dHTIYgw.png" alt="1232840-20191204154939650-173233911.png"></p><h4 id="4-组合键-全选文字"><a href="#4-组合键-全选文字" class="headerlink" title="4.组合键-全选文字"></a>4.组合键-全选文字</h4><p>本文开始介绍Selenium中Keys模块下的一些组合，或快捷键的使用。前面的一篇文章，介绍了如何新开一个tab，也是用到这块的知识。</p><p>本文介绍全选当前页面文字，快捷键是 Ctrl+a，主要还是用send_keys()方法输入组合键，这里用百度首页举例。</p><p>相关脚本代码如下：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/4Uj5oZdC2kRuQJF.png" alt="1232840-20191204155434031-1277144071.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-28@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Chrome()driver.maximize_window()driver.get(&#39;https://www.baidu.com&#39;)element = driver.find_element_by_tag_name(&#39;body&#39;)element.send_keys(Keys.CONTROL + &#39;a&#39;)</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/dfLamZKWOVvI52U.png" alt="1232840-20191204155220853-107597055.png"></p><h5 id="4-4百度首页如下"><a href="#4-4百度首页如下" class="headerlink" title="4.4百度首页如下"></a>4.4百度首页如下</h5><p>百度首页相当于我们按了键盘的组合键（Ctrl + A）</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/bHt29cuyxwTkFaS.png" alt="1232840-20191204155159159-407214535.png"></p><h4 id="5-组合键-退格键删除文字"><a href="#5-组合键-退格键删除文字" class="headerlink" title="5.组合键-退格键删除文字"></a>5.组合键-退格键删除文字</h4><p>前面一篇文章介绍了，常规清除文本输入框字符的方法clear(), 本文介绍</p><p>相关脚本代码如下，这里用百度首页搜索输入框举例：</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/j4iW29eaBnCM5NU.png" alt="1232840-20191204155958136-1402408848.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-28@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Chrome()driver.maximize_window()driver.get(&#39;https://www.baidu.com&#39;)element = driver.find_element_by_id(&#39;kw&#39;)element.send_keys(&quot;Selenium automation&quot;)time.sleep(1)element.send_keys(Keys.CONTROL+&#39;a&#39;)element.send_keys(Keys.BACKSPACE)</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/65vU9ARXEaBN2sf.png" alt="1232840-20191204160641580-1557575175.png"></p><h4 id="6-鼠标右键"><a href="#6-鼠标右键" class="headerlink" title="6.鼠标右键"></a>6.鼠标右键</h4><p>本文介绍如何使用Selenium中右键方法来操作网页元素。网页上有些元素是支持右键来触发新的菜单，这里找一个百度首页，百度logo的右键，查看图片动作来模拟这个场景。</p><p>问题拆分：</p><ol><li><p>打开百度首页，找到logo，右键鼠标</p></li><li><p>移动到菜单，查看图像，然后点击</p></li></ol><p>核心问题，如何右键操作，然后是如何选择查看图像这个菜单。在Selenium中，有一个ActionChains模块支持，右键，鼠标悬停，拖拽，双击等动作。我们可以通过键盘向下箭头来选择查看图像这个菜单，然后点击就可以达到目的。</p><p>相关脚本代码如下：</p><h5 id="6-1代码实现"><a href="#6-1代码实现" class="headerlink" title="6.1代码实现"></a>6.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/e5BVDQT7UFts4di.png" alt="1232840-20191204160715921-572004615.png"></p><h5 id="6-2参考代码"><a href="#6-2参考代码" class="headerlink" title="6.2参考代码"></a>6.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-28@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Chrome()driver.maximize_window()driver.get(&#39;https://www.baidu.com&#39;)time.sleep(2)element = driver.find_element_by_xpath(&quot;//*[@id=&#39;lg&#39;]/img&quot;)actionChains = ActionChains(driver)actionChains.context_click(element).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ENTER).perform()#actionChains.context_click(element).send_keys(&#39;i&#39;).perform()</code></pre><h5 id="6-3运行结果"><a href="#6-3运行结果" class="headerlink" title="6.3运行结果"></a>6.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/65vU9ARXEaBN2sf.png" alt="1232840-20191204160641580-1557575175.png"></p><p>注意：<br>ActionChains下相关方法在当前的firefox不工作，这个是一个已知的bug。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>好了，今天的练习就到这里，希望大家好好的练习和理解。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试9</title>
      <link href="/2016/01/27/selenium/"/>
      <url>/2016/01/27/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之5-python+ selenium自动化测试（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天我们还是继续练习练习基本功，各位小伙伴要耐住住性子，要耐得住寂寞啊，不要急躁，后面你会感谢你在前边的不断练习的。到后面也是检验你前边的学习成果的一次很好实践。所以今天我们继续前边的练习，学习和练习一下：如何使用webdriver方法获取操作复选框-CheckBox、测试不同的分辨率、如何断言title、如何获取某一个元素的text属性值等等，这些小练习，来巩固基础。</p><h4 id="2-操作复选框-Checkbox"><a href="#2-操作复选框-Checkbox" class="headerlink" title="2.操作复选框-Checkbox"></a>2.操作复选框-Checkbox</h4><p>本小节介绍Selenium中，如何操作复选框-Checkbox，最终的方法还是click()。<br>本来想还是继续采用for语句来把所有的复选框勾选一遍，例如这样的场景：注册一个网站勾选身份或者职业的时候，由于没有找到合适的demo网站。这里还是以百度举例，登录时，勾选下次自动登录：</p><p>（1）访问百度主页面，点击百度首页的“登录”，xpath定位如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/ANlu5b3goMFwvSx.png" alt="1232840-20191203163453967-1371821693.png"></p><p>（2）点击“用户名登录”，xpath定位如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/P5q4bcln2okLyaJ.png" alt="1232840-20191203163642344-302152905.png"></p><p>（3）点击下次自动登录点选按钮，xpath定位如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/g5l6QUOJ7qYGmSB.png" alt="1232840-20191204090447961-180890905.png"></p><p>相关脚本代码如下：</p><h5 id="2-1代码实现"><a href="#2-1代码实现" class="headerlink" title="2.1代码实现"></a>2.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/JZDfgVRFpI9AosN.png" alt="1232840-20191204090554945-233420252.png"></p><h5 id="2-2参考代码"><a href="#2-2参考代码" class="headerlink" title="2.2参考代码"></a>2.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-27@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.get(&#39;https://www.baidu.com&#39;)driver.implicitly_wait(8)driver.find_element_by_xpath(&quot;//*[@id=&#39;u1&#39;]/a[7]&quot;).click()time.sleep(1)driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__footerULoginBtn&#39;]&quot;).click()time.sleep(1)driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__memberPass&#39;]&quot;).click()time.sleep(1)driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__memberPass&#39;]&quot;).click()</code></pre><h5 id="2-3运行结果"><a href="#2-3运行结果" class="headerlink" title="2.3运行结果"></a>2.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/RSq8FBzkw2uPCHM.png" alt="1232840-20191204090625634-1461121970.png"></p><p>由于这个勾选是默认选中的，这里方便观察点击效果，点击了两次。如果有多个复选框，考虑用for循环，参考前面radio button的方法。</p><h4 id="3-测试不同分辨率"><a href="#3-测试不同分辨率" class="headerlink" title="3.测试不同分辨率"></a>3.测试不同分辨率</h4><p>本小节来学习下如何通过Selenium方法，设置符合不同测试场景浏览器窗口大小。例如，你有一台机器，最大支持1366*768，你完全可以利用这个机器测试不同分辨率下的场景。</p><p>相关测试脚本代码如下：</p><h5 id="3-1代码实现："><a href="#3-1代码实现：" class="headerlink" title="3.1代码实现："></a>3.1代码实现：</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/lnxItKm1uUC6psb.png" alt="1232840-20191204091406154-848281599.png"> </p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-27@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window() # 全屏driver.get(&#39;https://www.baidu.com&#39;)time.sleep(1)print (driver.get_window_size())driver.set_window_size(1280,800) # 分辨率 1280*800time.sleep(1)print (driver.get_window_size())driver.set_window_size(1024,768) # 分辨率 1024*768time.sleep(1)print (driver.get_window_size())</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/PsZ83cvCpuRmz5i.png" alt="1232840-20191204091323995-486168247.png"> </p><h4 id="4-title断言方法"><a href="#4-title断言方法" class="headerlink" title="4.title断言方法"></a>4.title断言方法</h4><p>本小节介绍一个Selenium中页面title断言方法，这个在以后的断言中会用到，大致都是换汤不换药，照猫画虎就可以了，但是在这里一定要认真学习和练习，后边应用起来才回得心应手。</p><p>相关脚本代码如下：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/vdeUp2IsoajEOcJ.png" alt="1232840-20191204092201697-1562549398.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-27@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.get(&#39;https://www.baidu.com&#39;)time.sleep(1)# 方法一try:    assert u&quot;百度一下&quot; in driver.title    print (&#39;Assertion test pass.&#39;)except Exception as e:    print (&#39;Assertion test fail.&#39;, format(e))# 方法二if u&quot;百度一下，你就知道&quot; == driver.title :    print (&#39;Assertion test pass.&#39;)else:    print (&#39;Assertion test fail.&#39;)print(driver.title)</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/xSq8actjVldvPCg.png" alt="1232840-20191204092058591-259140259.png"></p><p>方法一，是利用python中Assert方法，采用包含判断，方法二是通过if方法，采用完全相等方法，建议选择第一种方法。</p><p>u”百度一下，你就知道”</p><p>这u代表unicode的意思，由于我们这里采用了python 2, 如果你使用pyn3 就不需要，在Python3中，字符串默认采用unicode存储。</p><h4 id="5-获取某一个元素的text属性值"><a href="#5-获取某一个元素的text属性值" class="headerlink" title="5.获取某一个元素的text属性值"></a>5.获取某一个元素的text属性值</h4><p>　　本小节介绍如何通过Selenium方法来获取某一个元素的text属性值。在很多自动化测试脚本中，需要多次获取元素的text值，拿过来进行对比和匹配。例如，在一个登陆界面，如果不输入用户名和密码，直接点击登录，肯定会有相关错误提醒。这个错误，我们需要通过selenium抓取出来，和需求说明文档中的描述去进行匹配，如果匹配，测试成功，否则失败。<br>这里用百度登录举例：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/aAEBMwgmFxY4qte.png" alt="1232840-20191204132723067-1677693373.png"></p><p>需要通过Selenium脚本去自动判断是否显示错误文字“请您填写手机/邮箱/用户名”，前边已经定位到这个页面，这里就不再赘述了，这里需要定位“登录”按钮，定位text的属性值。</p><p>（1）定位“登录”按钮</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/tJ3lQxVhfM5k2A9.png" alt="1232840-20191204134039161-2063974330.png"></p><p>（2）定位text的属性值</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/IwyBdJ4LmVzHpge.png" alt="1232840-20191204134120053-290770356.png"></p><p>相关脚本代码如下：</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/HBh49Mxuk6tNvUV.png" alt="1232840-20191204135852911-579104209.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-27@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇5&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;http://www.baidu.com/&quot;)time.sleep(1)#点击百度首页“登录”按钮driver.find_element_by_xpath(&quot;//*[@id=&#39;u1&#39;]/a[7]&quot;).click()time.sleep(1)#点击“用户名登录”driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__footerULoginBtn&#39;]&quot;).click()#点击登录页面的“登录”按钮driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__submit&#39;]&quot;).click()# 断言方法一try :    error_message = driver.find_element_by_xpath(&quot;//*[@id=&#39;TANGRAM__PSP_10__error&#39; and text()=&#39;请您输入手机/邮箱/用户名&#39;]&quot;).is_displayed()    print (&quot;Test pass. the error message is display.&quot;)except Exception as e:    print (&quot;Test fail.&quot;, format(e))# 断言方法二，本文重点介绍方法error_mes = driver.find_element_by_xpath(&quot;.//*[@id=&#39;TANGRAM__PSP_10__error&#39;]&quot;).texttry:    assert error_mes == u&#39;请您输入手机/邮箱/用户名&#39;    print (&#39;Test pass.&#39;)except Exception as e:    print (&quot;Test fail.&quot;, format(e))</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/kCp3WeGZIFgRlcb.png" alt="1232840-20191204135738481-70636654.png"></p><p>总结：<br>要获取到目标元素的text的值，需要定义一个目标元素element，然后通过element.text方法得到字符串，注意不是element.text(),这个方法是没有带小括号的。上面介绍了两个方法，方法一是，直接把字段写入XPath表达式，如果通过该XPath能定位到元素，说明这个<br>错误字段已经在页面显示；方法二是通过该目标元素节点，然后通过element.text得到值，在拿得到的text值取和期待的结果去字符串匹配。建议在自动化测试脚本开发中，采用第二个方法。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>好了，今天的练习就到这里，希望大家好好的练习和理解。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试8</title>
      <link href="/2016/01/26/selenium/"/>
      <url>/2016/01/26/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之4-python+ selenium自动化测试（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天我们还是继续练习练习基本功，各位小伙伴要耐住住性子，要耐得住寂寞啊，不要急躁，后面你会感谢你在前边的不断练习的。到后面也是检验你前边的学习成果的一次很好实践。所以我们继续前边的练习，学习和练习一下：如何使用webdriver方法获取当前测试页面的URL、如何获取当前页面的title、如何打开浏览器的一个新建页面、如何操作单选按钮等等，这些小练习，来巩固基础。</p><h4 id="2-webdriver方法获取当前测试页面的URL"><a href="#2-webdriver方法获取当前测试页面的URL" class="headerlink" title="2.webdriver方法获取当前测试页面的URL"></a>2.webdriver方法获取当前测试页面的URL</h4><p>　　本小节介绍如何通过webdriver方法获取当前测试页面的URL。获取当前URL有什么用处呢，一般URL可以帮助我们判断跳转的页面是否正确，或者URL中部分字段可以作为我们自动化测试脚本期待结果的一部分。因为这里作为练习宏哥在这里提一下，为的是就是小伙伴或者童鞋们有个印象，在用到的时候知道怎么用即可。</p><p>相关脚本代码如下：</p><h5 id="2-1代码实现"><a href="#2-1代码实现" class="headerlink" title="2.1代码实现"></a>2.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/9Hx67YmMsuVyjEi.png" alt="1232840-20191203113307632-427440859.png"></p><h5 id="2-2参考代码"><a href="#2-2参考代码" class="headerlink" title="2.2参考代码"></a>2.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-26@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇4&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;http://www.baidu.com/&quot;)time.sleep(1)driver.find_element_by_link_text(&quot;新闻&quot;).click()time.sleep(1)print (driver.current_url) # current_url 方法可以得到当前页面的URLdriver.quit()</code></pre><h5 id="2-3运行结果"><a href="#2-3运行结果" class="headerlink" title="2.3运行结果"></a>2.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/sH5gM68hFLnfq3E.png" alt="1232840-20191203113427242-250951301.png"></p><h4 id="3-获取当前页面的title"><a href="#3-获取当前页面的title" class="headerlink" title="3.获取当前页面的title"></a>3.获取当前页面的title</h4><p>　　本小节介绍了如何获取当前页面的URL的值，本文介绍如何获取当前页面的title，这个也可以作为测试结果的依据，通过得到的title和预期的值对比，可以支持我们判断页面跳转正确。<br>相关脚本代码如下：</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/1s48ewigWmEByM2.png" alt="1232840-20191203113543404-418972668.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-26@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇4&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;http://www.baidu.com/&quot;)time.sleep(1)driver.find_element_by_link_text(&quot;新闻&quot;).click()time.sleep(1)print (driver.title) # title方法可以获取当前页面的标题显示的字段driver.quit()</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/rHv9nOfAMDX3zkW.png" alt="1232840-20191203114318292-2040288790.png"></p><h4 id="4-selenium方法打开一个新的tab"><a href="#4-selenium方法打开一个新的tab" class="headerlink" title="4.selenium方法打开一个新的tab"></a>4.selenium方法打开一个新的tab</h4><p>　　本小节介绍如selenium方法打开一个新的tab，我们知道在浏览器里，我们按住 ctrl+ t 就可以新打开一个tab。所以我们学习如何利用webdriver中send_key 的方法去触发ctrl+t的效果。我们利用火狐浏览器来演示。<br>相关代码如下：</p><p>主要是调用了keys模块下相关方法，可以通过这个方法，输入任何一个键盘上支持的字符或者快捷键。</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/QY3zUblpTIFXPRr.png" alt="1232840-20191203114507204-2084738455.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-26@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇4&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Firefox()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;http://www.baidu.com/&quot;)time.sleep(1)ele = driver.find_element_by_tag_name(&#39;body&#39;).send_keys(Keys.CONTROL + &#39;t&#39;) # 触发ctrl + ttime.sleep(1)</code></pre><h5 id="4-3运行结果"><a href="#4-3运行结果" class="headerlink" title="4.3运行结果"></a>4.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/kGsmrMfNTFtdyz5.png" alt="1232840-20191203142835987-730654285.png"></p><h5 id="4-4查看浏览器"><a href="#4-4查看浏览器" class="headerlink" title="4.4查看浏览器"></a>4.4查看浏览器</h5><p>为了看得清楚，我们把退出浏览器的代码去掉，可以清楚的看到打开了一个新的窗口，如下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/1egb6zNhs973xMD.png" alt="1232840-20191203144320419-1417769850.png"></p><h4 id="5-selenium中的方法去操作单选按钮"><a href="#5-selenium中的方法去操作单选按钮" class="headerlink" title="5.selenium中的方法去操作单选按钮"></a>5.selenium中的方法去操作单选按钮</h4><p>　　本小节介绍如何利用selenium中的方法去操作单选按钮（Radio Button）。</p><p>利用百度搜索设置页面两个单选按钮举例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/q1NLuJPiospwBgv.png" alt="1232840-20191203145616299-771830837.png"></p><p>默认是选择新闻全文，我试试在两者之前来回点击。</p><p>实际上，勾选一个单选按钮，也就是调用元素方法click()</p><p>我们利用for语句遍历这两个单选按钮，依次点击他们。</p><p>相关脚本代码如下：</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/HBFvyer6VTZmLCE.png" alt="1232840-20191203145844813-1993575235.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-26@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇4&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.get(&#39;http://www.baidu.com&#39;)driver.implicitly_wait(8)for i in driver.find_elements_by_xpath(&quot;.//*[@id=&#39;se-settting-1&#39;]/input[@type=&#39;radio&#39;]&quot;):    i.click()</code></pre><h5 id="5-3运行结果："><a href="#5-3运行结果：" class="headerlink" title="5.3运行结果："></a>5.3运行结果：</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/fGjBFCtYLkdiVTs.png" alt="1232840-20191203145758674-247321280.png"></p><p>注意：</p><p>1.这里我们第一次用到了find_elements，也就是找一组元素，返回的是一个列表</p><p>2.循环这个列表，点击所有的单选按钮，这里应该只有2个符合上面XPath定位方法的单选按钮</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>　　小结这部分今天主要是总结宏哥在练习过程中遇到的各种奇葩错误和解决办法。</p><h5 id="6-1没有浏览器驱动报错"><a href="#6-1没有浏览器驱动报错" class="headerlink" title="6.1没有浏览器驱动报错"></a>6.1没有浏览器驱动报错</h5><h6 id="6-1-1-报错关键字段如下"><a href="#6-1-1-报错关键字段如下" class="headerlink" title="6.1.1 报错关键字段如下"></a>6.1.1 报错关键字段如下</h6><pre><code>selenium.common.exceptions.WebDriverException: Message: &#39;geckodriver&#39; executable needs to be in PATH. </code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/SLqxWHmltT7Akjn.png" alt="1232840-20191203132853604-2080530186.png"></p><h6 id="6-1-2解决办法"><a href="#6-1-2解决办法" class="headerlink" title="6.1.2解决办法"></a>6.1.2解决办法</h6><p>去下载一个driver插件geckodriver.exe， 下载地址：<a href="https://github.com/mozilla/geckodriver/releases，下载好这个exe文件后，把这个文件放到你的python安装目录下，例如宏哥放的位置如下图：" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases，下载好这个exe文件后，把这个文件放到你的python安装目录下，例如宏哥放的位置如下图：</a></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/Rm5TzdGfe6HsDpo.png" alt="1232840-20191203133344568-695536207.png"></p><h5 id="6-2geckodriver和selenium版本不兼容报错"><a href="#6-2geckodriver和selenium版本不兼容报错" class="headerlink" title="6.2geckodriver和selenium版本不兼容报错"></a>6.2geckodriver和selenium版本不兼容报错</h5><p>这个有的人认为是浏览器和浏览器驱动的版本不匹配也会报这个错误。</p><h6 id="6-2-1报错关键字段如下"><a href="#6-2-1报错关键字段如下" class="headerlink" title="6.2.1报错关键字段如下"></a>6.2.1报错关键字段如下</h6><pre><code>selenium.common.exceptions.SessionNotCreatedException: Message: Unable to find a matching set of capabilities</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/mT8zvgAxU5dPNVH.png" alt="1232840-20191203133546286-356208693.png"></p><h6 id="6-2-2-解决办法"><a href="#6-2-2-解决办法" class="headerlink" title="6.2.2.解决办法"></a>6.2.2.解决办法</h6><p>查看selenium的版本号，下载可以兼容selenium的浏览器驱动即可；</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/uE2fwgRjWnOpQ4J.png" alt="1232840-20191203135414837-1529948079.png"></p><p>查看浏览器的版本号，下载可以匹配的浏览器驱动即可，一般浏览器的驱动都会标明对应的浏览器版本号或者浏览器版本号的范围。</p><h5 id="6-3依旧报错"><a href="#6-3依旧报错" class="headerlink" title="6.3依旧报错"></a>6.3依旧报错</h5><p>上边两个报错修改以后仍然报错。</p><h6 id="6-3-1报错关键字段"><a href="#6-3-1报错关键字段" class="headerlink" title="6.3.1报错关键字段"></a>6.3.1报错关键字段</h6><pre><code>selenium.common.exceptions.WebDriverException: Message: Expected browser binary location, but unable to find binary in default location, no &#39;moz:firefoxOptions.binary&#39; capability provided, and no binary flag set on the command line</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/08/03/ojsgkp1YNSrGQwL.png" alt="1232840-20191203135455079-1031625521.png"></p><h6 id="6-3-2解决办法："><a href="#6-3-2解决办法：" class="headerlink" title="6.3.2解决办法："></a>6.3.2解决办法：</h6><p>原因是：未找到浏览器的位置，宏哥这里提供解决办法有两种，仅供参考！！！</p><p>方法一：配置火狐浏览器的环境变量，这个宏哥在这里就不做赘述了，还是用老办法即可，看过宏哥的文章，应该知道老办法是什么，记住是老办法，不是老地方啊！！！</p><p>方法二：代码实现指引浏览器的位置</p><pre><code>from selenium.webdriver.firefox.firefox_binary import FirefoxBinarybinary = FirefoxBinary(&#39;D:\\software\\Firefox\\firefox.exe&#39;)driver = webdriver.Firefox(firefox_binary = binary)</code></pre><p>好了，今天的练习就到这里，希望大家好好的练习和理解。 但是今天火狐浏览器这块可能遇到的坑比较多，可以很好地锻炼一下自己哦！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试7</title>
      <link href="/2016/01/25/selenium/"/>
      <url>/2016/01/25/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之3-python+ selenium自动化测试（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天我们还是继续练习练习基本功，各位小伙伴要耐住住性子，要耐得住寂寞啊，不要急躁，后面你会感谢你在前边的不断练习的。到后面也是检验你前边的学习成果的一次很好实践。</p><p>​        前面介绍了，XPath, id , class , link text, partial link text, tag name, name 七大元素定位方法，本文介绍webdriver支持的最后一个方法：by_css。css和XPath类似，也需要掌握一些语法，才能写出正确的，完整的css选择表达式。相关w3c介绍，请点击这里。</p><h4 id="2-by-css定位元素"><a href="#2-by-css定位元素" class="headerlink" title="2.by_css定位元素"></a>2.by_css定位元素</h4><p>　　以百度首页的“百度一下”按钮为例，我们通过by_css来定位到这个按钮。如图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/BdC9W17sNDA6cIf.png" alt="1232840-20191129115020214-1594586879.png"></p><h5 id="2-1代码实现"><a href="#2-1代码实现" class="headerlink" title="2.1代码实现"></a>2.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/cxge5AP9r7O3Ezu.png" alt="1232840-20191129115139942-542399489.png"></p><h5 id="2-2参考代码"><a href="#2-2参考代码" class="headerlink" title="2.2参考代码"></a>2.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-11-29@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇3&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)try:    driver.find_element_by_css_selector(&quot;#su&quot;) # 找 百度一下 这个按钮    print (&#39;test pass: element found by css selector&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><h5 id="2-3运行结果"><a href="#2-3运行结果" class="headerlink" title="2.3运行结果"></a>2.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/zNUqrmt4MoC7Rgc.png" alt="1232840-20191129115305196-626563155.png"></p><p>　　总结：如果一开始没有接触css，感觉写css表达式有点困难，没关系。看个人喜好和适合哪个，例如，如果你掌握好了XPath的写法，那么就可以不去管css，毕竟大部分xpath表达式都能够定位到元素。有些人可能说了，css要比xpath表达式查找元素的速度要快，这个你不要去担心，对计算机来讲，你根本无法区分哪个更快，也不是自动化测试考虑的重点。</p><p>建议：一定要掌握好XPath或者css来定位元素，其他的几种了解就可以。毕竟在实际项目开发脚本阶段，很多元素是无法通过id ,css, text, name来直接定位这个网页元素，更多的还是根据XPath或者css表达式去定位。</p><h4 id="3-清除文本方法"><a href="#3-清除文本方法" class="headerlink" title="3.清除文本方法"></a>3.清除文本方法</h4><p>　　在前面的文章中，我们或多或少的用到了输入字符和点击按钮这样的操作。用send_keys()来输入字符串到文本输入框这样的页面元素，用click()来点击页面上支持点击的元素。有时候，我们需要清除一个文本输入框内的文字，然后重新输入新的字符串，那边清除这个方法如何实现呢。</p><p>调用webdriever中clear()方法：</p><p>相关代码如下，为了演示测试效果，我们运行完脚本，不关闭浏览器:</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/8XAeoxngJFIkYsm.png" alt="1232840-20191202093047475-1656905232.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-25@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇3&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;Selenium&quot;)try:    driver.find_element_by_id(&quot;kw&quot;).clear() # 调用clear()方法去清除    print (&#39;test pass: clean successful&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))</code></pre><h5 id="3-3-运行结果"><a href="#3-3-运行结果" class="headerlink" title="3.3  运行结果"></a>3.3  运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/oqFkdfD7H1SMEcR.png" alt="1232840-20191129120031878-1916612313.png"></p><h4 id="4-调用webdriver中刷新页面的方法"><a href="#4-调用webdriver中刷新页面的方法" class="headerlink" title="4.调用webdriver中刷新页面的方法"></a>4.调用webdriver中刷新页面的方法</h4><p>本小节宏哥给小伙伴们或者童鞋们来介绍如何调用webdriver中刷新页面的方法。其实前边已经说过，这个只不过是作为练习我们再来巩固一下而已。</p><p>相关脚本代码如下：</p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/MgX6NKGDexVOtYn.png" alt="1232840-20191202093632857-1377320331.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-25@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇3&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)time.sleep(2)try:    driver.refresh() # 刷新方法 refresh    print (&#39;test pass: refresh successful&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><h5 id="4-3-运行结果"><a href="#4-3-运行结果" class="headerlink" title="4.3 运行结果"></a>4.3 运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/RaUtO8WqykJBdAS.png" alt="1232840-20191202093744373-823763450.png"></p><h4 id="5-浏览器前进后退"><a href="#5-浏览器前进后退" class="headerlink" title="5.浏览器前进后退"></a>5.浏览器前进后退</h4><p>　　本小节来介绍上如何，利用webdriver中的方法来演示浏览器中地址栏旁边的前进和后退功能。其实这个前边也已经说过，这个只不过是作为练习我们再来巩固一下而已。</p><p>相关脚本代码如下：</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/rlLz7UtOTFApkhH.png" alt="1232840-20191202094443329-363592519.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-25@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇3&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)time.sleep(2)elem_news = driver.find_element_by_link_text(&quot;新闻&quot;)elem_news.click() # 点击进入到百度新闻time.sleep(2)driver.back() # 从百度新闻后退到百度首页print(&quot;从百度新闻后退到百度首页&quot;)time.sleep(2)driver.forward() # 百度首页前进到百度新闻print(&quot;百度首页前进到百度新闻&quot;)time.sleep(2)driver.quit()</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/nHEXNCVhrvymodg.png" alt="1232840-20191202094343449-941539784.png"></p><h4 id="6-webdriver方法获取浏览器的版本号"><a href="#6-webdriver方法获取浏览器的版本号" class="headerlink" title="6.webdriver方法获取浏览器的版本号"></a>6.webdriver方法获取浏览器的版本号</h4><p>　　本小节介绍，如何通过webdriver方法获取浏览器的版本号。看起来这个功能很鸡肋，不管怎么说，还是学习下，特别是在发送自动化测试报告的时候，还是可以通过这个方法来告诉别人，执行过的脚本是通过什么浏览器，什么版本跑的吧。</p><p>相关脚本代码如下</p><h5 id="6-1代码实现"><a href="#6-1代码实现" class="headerlink" title="6.1代码实现"></a>6.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/J6yYI5nTgBwpa3z.png" alt="1232840-20191202094811641-95305178.png"></p><h5 id="6-2参考代码"><a href="#6-2参考代码" class="headerlink" title="6.2参考代码"></a>6.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-25@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇3&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;http://www.baidu.com/&quot;)time.sleep(1)print(driver.capabilities[&#39;version&#39;]) # 打印浏览器version的值driver.quit()</code></pre><h5 id="6-3运行结果"><a href="#6-3运行结果" class="headerlink" title="6.3运行结果"></a>6.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/yLe6Rrz9MbJEnd1.png" alt="1232840-20191202094658664-1734810673.png"></p><h5 id="6-4查看浏览器版本"><a href="#6-4查看浏览器版本" class="headerlink" title="6.4查看浏览器版本"></a>6.4查看浏览器版本</h5><p>右上角——&gt;帮助——&gt;关于Google Chrome，点击后如下图：查看版本号一致。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/F9nzPRKbTJ4d2Bw.png" alt="1232840-20191202095353675-76988089.png"></p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p> 　　好了，今天的练习就到这里，希望大家好好的练习和理解。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试6</title>
      <link href="/2016/01/24/selenium/"/>
      <url>/2016/01/24/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之2-python+ selenium自动化测试（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　今天我们还是继续练习练习基本功，各位小伙伴要耐住住性子，要耐得住寂寞啊，不要急躁，后面你会感谢你在前边的不断练习的。到后面也是检验你前边的学习成果的一次很好实践。</p><p>本文介绍如何通过link text、partial link text、class name和name 来定位页面元素。</p><h4 id="2-link-text定位元素"><a href="#2-link-text定位元素" class="headerlink" title="2.link text定位元素"></a>2.link text定位元素</h4><p>我们打开网页，一些可以点击的链接跳转上面的文字，就是link text，用百度首页举例来看：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/BGyxzV8KrjLTIfa.png" alt="1232840-20191129090718060-1494196760.png"></p><p>在上面图中，这一排上面的文字都是link text，例如我们要通过“新闻”这个文本字段来定义这个跳转链接元素。</p><h5 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/CDhUX4KubfZrqv2.png" alt="1232840-20191129091411114-2033642373.png"></p><h5 id="2-2-参考代码"><a href="#2-2-参考代码" class="headerlink" title="2.2 参考代码"></a>2.2 参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-24@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇2&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)try:    driver.find_element_by_link_text(&quot;新闻&quot;)    print (&#39;test pass: element found by link text&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><h5 id="2-3运行结果"><a href="#2-3运行结果" class="headerlink" title="2.3运行结果"></a>2.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/85UxCLlNw41jueA.png" alt="1232840-20191129091935090-657135687.png"></p><p>总结：凡是看到链接元素上面有文字描述的都可以采取find_element_by_link_text（）方法来进行元素定位。这里提一下前面XPath定位中的知识，通过text()这个XPath中的函数也可以达到类似link text定位的目的。</p><p>这个“新闻”链接元素的XPath表达式可以这样写：//*/div[@id=’u1’]/a[text()=’新闻’]</p><h4 id="3-partial-link-text定位元素"><a href="#3-partial-link-text定位元素" class="headerlink" title="3.partial link text定位元素"></a>3.partial link text定位元素</h4><p>这里我们来介绍如何通过partial link text来定位页面元素。看到这个，有点和前一篇文字link text有点类似。字面意思，确实和link text相类似，partial link text就是选择这个元素的link text中一部分字段。</p><p> 还是用百度首页输入框下有一个添加首页“把百度设为主页”。</p><h5 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/gXIcTiJwZzDpMP9.png" alt="1232840-20191129092143907-1908559756.png"></p><h5 id="3-2参考代码"><a href="#3-2参考代码" class="headerlink" title="3.2参考代码"></a>3.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-24@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇2&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)try:    driver.find_element_by_partial_link_text(&quot;主页&quot;).click()    print (&#39;test pass: element found by partial link text&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><h5 id="3-3运行结果"><a href="#3-3运行结果" class="headerlink" title="3.3运行结果"></a>3.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/aZnIhrRmtVP8pJN.png" alt="1232840-20191129092422343-1996916318.png"></p><p>为了更好的验证是否找到了“把百度添加到首页”这个元素，我在这个地方添加了一个click(),运行代码，可以看到确实点击了这个元素，代表找到了这个元素。选择partial link text的时候，需要选择一个比较唯一的字段，来区分这个元素。</p><h4 id="4-class-name的值来定位页面元素"><a href="#4-class-name的值来定位页面元素" class="headerlink" title="4.class name的值来定位页面元素"></a>4.class name的值来定位页面元素</h4><p>有时候，我们在用firepath（不会的请点这里）查看元素的XPath信息，发现没有可以用来定位的id信息，这个时候我们就需要考虑用其他的可用的来定位元素。本文介绍如何通过元素节点中class name的值来定位页面元素。还是以百度首页，搜索输入框定位举例：</p><p>XPath截图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/fNjUmMbJxVsiKr1.png" alt="1232840-20191129093000406-133275055.png"></p><h5 id="4-1代码实现"><a href="#4-1代码实现" class="headerlink" title="4.1代码实现"></a>4.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/vO9sjBGuSkT5IwF.png" alt="1232840-20191129094222785-2023324744.png"></p><h5 id="4-2参考代码"><a href="#4-2参考代码" class="headerlink" title="4.2参考代码"></a>4.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-24@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇2&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)try:    driver.find_element_by_class_name(&quot;s_ipt&quot;)    print (&#39;test pass: element found by class name&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><h5 id="4-3-运行结果"><a href="#4-3-运行结果" class="headerlink" title="4.3 运行结果"></a>4.3 运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/edwcb6fiJYBsrha.png" alt="1232840-20191129093340095-1397538852.png"></p><p>参考意见：很多情况下，class利用要比id多，如果class中出现了太长的字符，和可变化的数字，那么请回到用XPath定位方法。</p><h4 id="5-name的值来定位元素"><a href="#5-name的值来定位元素" class="headerlink" title="5.name的值来定位元素"></a>5.name的值来定位元素</h4><p>这里介绍如何通过节点中name的值来定位这个web元素。还是来看百度首页搜索输入框，通过name的值来定位。</p><h5 id="5-1代码实现"><a href="#5-1代码实现" class="headerlink" title="5.1代码实现"></a>5.1代码实现</h5><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/lunYfH48UWtELKB.png" alt="1232840-20191129093924816-197814250.png"></p><h5 id="5-2参考代码"><a href="#5-2参考代码" class="headerlink" title="5.2参考代码"></a>5.2参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-24@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇2&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)try:    driver.find_element_by_name(&quot;wd&quot;) # 这里百度搜索输入框有name = &#39;wd&#39;这个节点信息    print (&#39;test pass: element found by name value&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><h5 id="5-3运行结果"><a href="#5-3运行结果" class="headerlink" title="5.3运行结果"></a>5.3运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/JVcDXSF9kuvTo1r.png" alt="1232840-20191129093830173-1570485091.png"></p><p>总结：name这个属性不是所有的节点都有，如果有建议采用name的值来定位，就和by_id, by_class一样的效果。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h4><p>好了，今天的练习就到这里，希望大家好好的练习和理解。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试5</title>
      <link href="/2016/01/23/selenium/"/>
      <url>/2016/01/23/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列练习篇之1-python+ selenium自动化测试（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>　　相信各位小伙伴或者同学们通过前面已经介绍了的Python+Selenium基础篇，通过前面几篇文章的介绍和练习,Selenium+Python的webUI自动化测试算是 一只脚已经迈入这个门槛了要想第二只脚也迈进来。那么就要继续跟随宏哥的脚步继续前行。接下来，宏哥<br>计划写第二个系列：练习篇，通过一些练习，了解和掌握一些Selenium常用的接口或者方法。同时也可以把各位小伙伴或者童鞋们的基础夯实一下、巩固一下。这样有助于小伙伴或者同学们更快的将自己在门外的第二只脚迈进来，加入自动化测试的队伍中。</p><p>　　本文通过练习三个知识点：正则提取关键字、ID和tag name定位web页面元素。</p><h4 id="2-练习场景"><a href="#2-练习场景" class="headerlink" title="2.练习场景"></a>2.练习场景</h4><p>　　例如：在某一个网页上有些字段或者关键字等信息是我们感兴趣的，我们希望将其摘取出来，进行其他操作。但是这些字段可能在一个网页的不同地方。例如，我们需要在关于百度页面-联系我们，摘取全部的邮箱。</p><h4 id="3-思路拆分"><a href="#3-思路拆分" class="headerlink" title="3.思路拆分"></a>3.思路拆分</h4><ol><li><p>首先，需要得到当前页面的source内容，就像，打开一个页面，右键-查看页面源代码。</p></li><li><p>找出规律，通过正则表达式去摘取匹配的字段，存储到一个字典或者列表。</p></li><li><p>循环打印字典或列表中内容，Python中用 for 语句实现。</p></li></ol><h4 id="4-技术角度实现相关方法"><a href="#4-技术角度实现相关方法" class="headerlink" title="4.技术角度实现相关方法"></a>4.技术角度实现相关方法</h4><ol><li><p>查看页面的源代码，在Selenium中有driver.page_source 这个方法得到</p></li><li><p>Python中利用正则，需要导入re模块</p></li><li><p>将字段通过下列代码打印出来</p></li></ol><pre><code>for email in emails :          print email</code></pre><h5 id="4-1-代码实现"><a href="#4-1-代码实现" class="headerlink" title="4.1 代码实现"></a>4.1 代码实现</h5><p>想法技术角度方法都找到，我们新建一个extract_email.py 文件，输入如下代码:</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/iVsjkLxu5A3HPqz.png" alt="1232840-20191128092919337-2143781537.png"></p><h5 id="4-2-参考代码"><a href="#4-2-参考代码" class="headerlink" title="4.2 参考代码"></a>4.2 参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-01-23@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇&#39;&#39;&#39;# 3.导入模块from selenium import webdriverimport redriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;http://home.baidu.com/contact.html&quot;)# 得到页面源代码doc = driver.page_sourceemails = re.findall(r&#39;[\w]+@[\w\.-]+&#39;, doc)  # 利用正则，找出 xxx@xxx.xxx 的字段，保存到emails列表# 循环打印匹配的邮箱for email in emails:    print(email)</code></pre><h5 id="4-3-解释说明"><a href="#4-3-解释说明" class="headerlink" title="4.3 解释说明"></a>4.3 解释说明</h5><p>在python正则表达式语法中，Python中字符串前面加上 r 表示原生字符串，用\w表示匹配字母数字及下划线。re模块下findall方法返回的是一个匹配子字符串的列表。</p><h5 id="4-4-运行结果"><a href="#4-4-运行结果" class="headerlink" title="4.4 运行结果"></a>4.4 运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/M2UGwohjL4YZtS6.png" alt="1232840-20191128094208608-612185650.png"></p><h4 id="5-利用ID定位元素"><a href="#5-利用ID定位元素" class="headerlink" title="5.利用ID定位元素"></a>5.利用ID定位元素</h4><p>　　在上边，我们介绍了如何摘取页面字段，通过正则进行匹配符合要求的字段。如果感觉有点困难，不能立马理解，没有关系。把字符串摘取放到第一篇，是因为自动化测试脚本，经常要利用字符串操作，字符串切割，查找，匹配等手段，得到新的字符串或字符串数组，然后根据新得到的字符串进行判断用例是否通过。<br>下面介绍如何通过元素节点信息ID来定位该元素，使用id来定位元素虽然效率要高于XPath，但是实际测试测项目，能直接通过id定位的元素还是比较少，以下来举例百度首页搜索输入框的id定位。</p><h5 id="5-1-代码实现"><a href="#5-1-代码实现" class="headerlink" title="5.1 代码实现"></a>5.1 代码实现</h5><p>我们新建一个test_baidu_id.py文件，输入如下代码：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/KG1bNuZItEgomxl.png" alt="1232840-20191128095039850-1891218843.png"></p><h5 id="5-2-参考代码"><a href="#5-2-参考代码" class="headerlink" title="5.2 参考代码"></a>5.2 参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2019-11-28@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)try:    driver.find_element_by_id(&quot;kw&quot;)    print (&#39;test pass: ID found&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><p>这里，我们通过try except语句块来进行测试断言，这个在实际自动化测试脚本开发中，经常要用到处理异常。本文，我们学习了可以利用find_element_by_id（）方法来定位网页元素对象。</p><h5 id="5-3-运行结果"><a href="#5-3-运行结果" class="headerlink" title="5.3 运行结果"></a>5.3 运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/EmQ9eJokL3pHz2t.png" alt="1232840-20191128095951410-1473777488.png"></p><h4 id="6-利用tag-name定位元素"><a href="#6-利用tag-name定位元素" class="headerlink" title="6.利用tag name定位元素"></a>6.利用tag name定位元素</h4><p>   前边介绍了如何通过元素的id值来定位web元素，本文介绍如何通过tag name来定位元素。个人认为，通过tag name来定位还是有很大缺陷，定位不够精确。主要是tag name有很多重复的，造成了选择tag name来定位页面元素不准确，所以使用这个方法定位web元素的机会很少。</p><p>什么是tag name? 还是以百度首页搜索输入框，在火狐浏览器，右键，通过firepath，检查元素，看下图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/Fce6lYT8M9HkaKW.png" alt="1232840-20191128095623886-1995975325.png"></p><pre><code>  上面图片中红色圈选区域的标签名称都是tag name；实际上我们目标元素是输入框，应该是input这个tag name，在图中蓝色高亮区域。但是如果只是通过input这个tag name来定位，发现上面有很多input的选项。所以我们扩大节点的参照选择，我们选择上面这个</code></pre><p>form来作为我们tag name。</p><h5 id="6-1-代码实现"><a href="#6-1-代码实现" class="headerlink" title="6.1 代码实现"></a>6.1 代码实现</h5><p>看看如何写定位form这个元素的脚本：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/Lqc8fPC43vknjVN.png" alt="1232840-20191128100258049-1119182024.png"></p><h5 id="6-2-参考代码"><a href="#6-2-参考代码" class="headerlink" title="6.2 参考代码"></a>6.2 参考代码</h5><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-23@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium自动化测试练习篇&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome()driver.maximize_window()driver.implicitly_wait(6)driver.get(&quot;https://www.baidu.com&quot;)try:    driver.find_element_by_tag_name(&quot;form&quot;)    print (&#39;test pass: tag name found&#39;)except Exception as e:    print (&quot;Exception found&quot;, format(e))driver.quit()</code></pre><h5 id="6-3-运行结果"><a href="#6-3-运行结果" class="headerlink" title="6.3 运行结果"></a>6.3 运行结果</h5><p>运行代码后，控制台打印如下图的结果</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/zeOf19PMQsqmyvn.png" alt="1232840-20191128100418503-374507135.png"></p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>总结：本文介绍了webdriver 八大定位元素方法中的driver.find_element_by_tag_name(“form”) # form是tag name从实际项目中自动化脚本开发来看，使用这个方法定位元素的机会比较少，知道有这么一种方法就好了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试4</title>
      <link href="/2016/01/22/selenium/"/>
      <url>/2016/01/22/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>🔥《手把手教你》系列基础篇之4-python+ selenium自动化测试-xpath使用（详细教程）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>俗话说：磨刀不误砍柴工，因此在我们要开始写自动化脚本之前，我们先来学习和了解几个基本概念，在完全掌握了这几个概念之后，有助于我们快速上手，如何去编写自动化测试脚本。</p><p>元素，在这个教程系列，我们说的元素之网页元素（web element）。在网页上面的文本输入框，按钮，多选，单选，标签，和文字都叫元素，总之，凡是能在页面显示的对象都可以作为页面元素对象。<br>元素定位，有时候也叫Locator，一个HTML页面元素，可以用很多方法去描述这个元素的位置。打个比方，生活中地址，一个大厦，正常的地址是 xx省xx市xx区xx街道xxx号，这个具体描述就是这个大厦的Locator。同样的道理，一个网页元素，也有位置，也可以通<br>过一些手段或者表达式去描述这个元素在页面对应的位置。<br>    XPath，XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力，XPath 很快的被开发者采用来当作小型查询语言。<br>    Selenium一共有八种元素定位方法，这个在上一篇文章中已经提到过，其中在实际开发自动化脚本过程中，XPath的使用是最多的、比较好用的一种方法，所以本文就着重来介绍如何通过XPath来元素定位。学习了XPath元素定位后，其他7中方法，很容易理解，甚至<br>已经学会了其中好几种方法。</p><h5 id="1-1-XPath工具安装"><a href="#1-1-XPath工具安装" class="headerlink" title="1.1 XPath工具安装"></a>1.1 XPath工具安装</h5><p>  为了提高抓取元素XPath的，我推荐在Firefox上安装一个firepath的插件，这个插件，可以帮我们快速获取网页元素的XPath表达式。</p><ol><li><p>打开火狐浏览器，如果没有安装，下载默认安装</p></li><li><p>点击右上角，菜单-附件组件-扩展</p></li><li><p>在搜索所有附件组件文本输入框输入：firebug</p></li><li><p>找到Firebug，点击 安装。重复步骤3和4，搜索和安装FirePath。</p></li><li><p>安装好了之后，会在火狐浏览器右上角显示一个虫子的图标。</p></li></ol><h5 id="1-2-XPath工具简单使用"><a href="#1-2-XPath工具简单使用" class="headerlink" title="1.2 XPath工具简单使用"></a>1.2 XPath工具简单使用</h5><p>我们用定位百度首页的搜索输入框这个元素定位来演示。</p><ol><li><p>打开百度首页</p></li><li><p>鼠标定位到搜索输入框</p></li><li><p>右键鼠标，选Inspect in FirePath</p></li><li><p>打开界面如下图</p></li></ol><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/6fRlqzQixmNTtBY.png" alt="1232840-20191126111057619-493525337.png"></p><p>①FirePath自动推荐该元素的XPath表达式</p><p>②该元素节点的详细信息，XPath表达式选取重点区域</p><p>③找到一个匹配元素</p><p>   一般来说，自动推荐的XPath表达式定位不够精确。我们大部分时候需要去步骤2中，找出能够识别这个唯一元素的节点信息。刚好上面通过id=kw只能找到一个匹配的元素，说明这个XPath可用，看起来也简洁。实际项目中，可能XPath表达式写得很长，或者附</p><p>近节点信息好多相同，不太好能够快速找到一个唯一的节点信息去定位这个目标元素。接下来，我介绍几种比较实用的XPath定位技巧，基本上能定位到所有的网页元素。</p><h5 id="1-3-XPath定位技巧之text-方法"><a href="#1-3-XPath定位技巧之text-方法" class="headerlink" title="1.3 XPath定位技巧之text()方法"></a>1.3 XPath定位技巧之text()方法</h5><p>以百度首页右上角“新闻”定位举例</p><p>XPath如下图</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/iOEBAFvVo1mKg2W.png" alt="1232840-20191127102629428-1851624063.png"></p><h5 id="1-4-XPath定位技巧之contains-方法"><a href="#1-4-XPath定位技巧之contains-方法" class="headerlink" title="1.4 XPath定位技巧之contains()方法"></a>1.4 XPath定位技巧之contains()方法</h5><p>  有时候，我们不喜欢写很长的XPath表达式，而且节点信息里面，有些信息是动态的，每次都获取都不一样，这个时候contains()方法就很好用。</p><p>JD首页左侧电脑菜单举例</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/oHPW5th3nzBpTad.png" alt="1232840-20191127140210376-325533407.png"></p><p>XPath写法推荐，这里用contains()方法来定位</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/ZC1ykdfas6zwOmJ.png" alt="1232840-20191127131922406-1984557571.png"></p><p>这里href = //diannao.jd.com， 如果我觉得这个href太长，我只取关键字diannao，利用contains()方法来定位就方便多了，推荐电脑这个元素的XPath：//*/a[contains(@href,’diannao’)]</p><h5 id="1-5-相对XPath路径写法"><a href="#1-5-相对XPath路径写法" class="headerlink" title="1.5 相对XPath路径写法"></a>1.5 相对XPath路径写法</h5><pre><code>  有时候，我们遇到目标元素节点的信息很少，不足够用来精确定位到目标元素，这个时候，我们就需要考虑，利用目标元素上下附件节点，通过确定附件的节点从而确定目标元素，这种方式就叫相对路径。</code></pre><p>这里用火狐浏览器百度首页的一个单选按钮来举例；</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/43qOXGo9eYdVbuZ.png" alt="1232840-20191127132524677-686731335.png"></p><p>火狐浏览器上firepath给出的推荐表达式是：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/9QsSAVd2xuc5E6D.png" alt="1232840-20191127132556776-61719620.png"></p><p>这里推荐的XPath是根据目标元素节点中id信息来定位的，这个通过id就能定位，当然好。有时候，如果这个id不能作为参考值，我们需要利用相对定位方法来定位这个新闻标题前面的单选按钮；</p><p>1）先根据value = google_web 或者text()=谷歌来定位“谷歌”这个标签。</p><p>2）根据相对定位来确定“谷歌”前面的这个radio按钮。</p><p>3）XPath的写法是：.//*/label[@value=’google_web’]/</p><p>此前使用webdriver对浏览器进行了一些基本操作，可以说是基本接触了这个工具了，接下来就应该做更多事情了。</p><p>打开了网页，接下来就需要对网页中的内容进行操作了，例如定位网页中的元素、读取网页元素中的内容、对内容进行操作。</p><h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h4><p>XPath 是一种在 XML 文档中定位元素的语言。因为 HTML 可以看做 XML 的一种实现，所以 selenium用户可是使用这种强大语言在 web 应用中定位元素。</p><h5 id="2-1-绝对路径定位："><a href="#2-1-绝对路径定位：" class="headerlink" title="2.1 绝对路径定位："></a>2.1 绝对路径定位：</h5><p>XPath 有多种定位策略，最简单和直观的就是写元素的绝对路径。如果仍然把一个元素看做一个人的话，那么现在有一个人，他没有任何属性特征，那么这个人一定会存在于某个地理位置，如：xx 省 xx 市xx 区 xx 路 xx 号。那么对于一个元素在一个页面当中也会有</p><p>这样的一个绝对地址。</p><p>参考 baidu.html 前端工具所展示的代码，我们可以用下面的方式来找到百度输入框和搜索按钮。</p><pre><code>find_element_by_xpath(&quot;/html/body/div/div[2]/div/div/div/from/span/input&quot;)find_element_by_xpath(&quot;/html/body/div/div[2]/div/div/div/from/span[2]/input&quot;)</code></pre><p>find_element_by_xpath()方法用于 XPath 语言定位元素。XPath 的绝对路径主要用标签名的层级关系来</p><p>定位元素的绝对路径。最外层为 html 语言，body 文本内，一级一级往下查找，如果一个层级下有多个相同的标签名，那么就按上下顺序确定是第几个，div[2]表示第二个 div 标签。</p><h5 id="2-2-利用元素属性定位："><a href="#2-2-利用元素属性定位：" class="headerlink" title="2.2 利用元素属性定位："></a>2.2 利用元素属性定位：</h5><p>除了使用绝对路径的以外，XPath 也可以使用使素的属性值来定位。同样以百度输入框和搜索按钮为例：</p><pre><code>find_element_by_xpath(&quot;//input[@id=&#39;kw&#39;]&quot;)find_element_by_xpath(&quot;//input[@id=&#39;su&#39;]&quot;)</code></pre><p>//表示当前页面某个目录下，input 表示定位元素的标签名，[@id=’kw’] 表示这个元素的 id 属性值等于kw。下面通过 name 和 class 属性值来定位。</p><pre><code>find_element_by_xpath(&quot;//input[@id=&#39;wd&#39;]&quot;)find_element_by_xpath(&quot;//input[@class=&#39;s_ipt&#39;]&quot;)find_element_by_xpath(&quot;//*[@class=&#39;bg s_btn&#39;]&quot;)</code></pre><p>如果不想指定签名也可以用星号（*）代替。当然，使用 XPath 不仅仅只局限在 id、name 和 class 这三个属性值，元素的任意属性值都可以使用，只要它能唯一的标识一个元素。</p><pre><code>find_element_by_xpath(&quot;//input[@maxlength=&#39;100&#39;]&quot;)find_element_by_xpath(&quot;//input[@autocomplete=&#39;off&#39;]&quot;)find_element_by_xpath(&quot;//input[@type=&#39;submit&#39;]&quot;)</code></pre><h5 id="2-3-层级与属性结合："><a href="#2-3-层级与属性结合：" class="headerlink" title="2.3 层级与属性结合："></a>2.3 层级与属性结合：</h5><p>如果一个元素本身并没有可以唯一标识这个元素的属性值，我们可以找其上一级元素，如果它的上级</p><p>有可以唯一标识属性的值，也可以拿来使用。参考 baidu.html 文本。</p><pre><code>……&lt;form id=&quot;form&quot; class=&quot;fm&quot; action=&quot;/s&quot; name=&quot;f&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;utf-8&quot; name=&quot;ie&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;8&quot; name=&quot;f&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;rsv_bp&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;rsv_idx&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; name=&quot;ch&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;02..&quot; name=&quot;tn&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; name=&quot;bar&quot;&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; autocomplete=&quot;off&quot;maxlength=&quot;100&quot; value=&quot;&quot; name=&quot;wd&quot;&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input id=&quot;su&quot; class=&quot;bg s_btn&quot; type=&quot;submit&quot;value=&quot;百度一下&quot;&gt;&lt;/span&gt;……</code></pre><p>假如百度输入框本身没有可利用的属性值，我们可以查找它的上一级属性。比如，“小明”刚出生的时候没有名字，没上户口（没身份证号），那么亲朋好友来找“小明”可以先到小明的爸爸，因为他爸爸是有很多属性特征的，找到了小明的爸爸，抱在怀里的一定就是小<br>明了。通过 XPath 描述如下：</p><pre><code>find_element_by_xpath(&quot;//span[@class=&#39;bg s_ipt_wr&#39;]/input&quot;)find_element_by_xpath(&quot;//span[@class=&#39;bg s_btn_wr&#39;]/input&quot;)</code></pre><p>span[@class=’bg s_ipt_wr’] 通过 class 属性定位到是父元素，后面/input 也就表示父元素下面标签名为input 的子元素。如果父元素没有可利用的属性值，那么可以继续向上查找“爷爷”元素。</p><pre><code>find_element_by_xpath(&quot;//form[@id=&#39;form&#39;]/span/input&quot;)find_element_by_xpath(&quot;//form[@id=&#39;form&#39;]/span[2]/input&quot;)</code></pre><p>我们可以通过这种方法一级一级的向上打找，直到找到最外层的<html>标签，那么就是一个绝对路径的写法了。</html></p><h5 id="2-4-使用逻辑运算符"><a href="#2-4-使用逻辑运算符" class="headerlink" title="2.4 使用逻辑运算符"></a>2.4 使用逻辑运算符</h5><p>如果一个属性不能唯一的区分一个元素，我们还可以使用逻辑运算符连接多个属性来区别于其它属性。</p><pre><code>……&lt;input id=&quot;kw&quot; class=&quot;su&quot; name=&quot;ie&quot;&gt;&lt;input id=&quot;kw&quot; class=&quot;aa&quot; name=&quot;ie&quot;&gt;&lt;input id=&quot;bb&quot; class=&quot;su&quot; name=&quot;ie&quot;&gt;……</code></pre><p>如上面的三行元素，假如我们现在要定位第一行元素，如果使用 id 将会与第二行元素重名，如果使用class 将会与第三行元素的重名。那么如果同时使用 id 和 class 就会唯一的标识这个元素。那么这个时候就可以通过逻辑运算符号连接。</p><pre><code>find_element_by_xpath(&quot;//input[@id=&#39;kw&#39; and @class=&#39;su&#39;]/span/input&quot;)</code></pre><p>当然，我们也可以用 and 连接更多的属性来唯一的标识一个元素。<br>我们在本书的第一章中介绍的 Firebug 前端调试工具和 FirePath 插件可以方便的辅助 XPath 语法。<br>打开 FireFox 浏览器的 FireBug 插件，点击插件左上角的鼠标箭头，再点击页面上需要定位的元素，在元<br>素行上右键弹出快捷菜单，选择“复制 XPath”，将会获得当前元素的 XPath 语法，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/9gJYiCOTL6NljqW.png" alt="1232840-20191127094252082-628658529.png"></p><p>FirePath插件的使用就更加方便和快捷了，选中元素后，直接在XPath的输入框中生成当前元素的XPath语法，如图：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/T2AU4CFmYnIvVls.png" alt="1232840-20191127094351690-14529659.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试3</title>
      <link href="/2016/01/21/selenium/"/>
      <url>/2016/01/21/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>《手把手教你》系列基础篇之3-python+ selenium自动化测试-驱动浏览器和元素定位大法（详细）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>上一篇中，只是简单地一带而过的说了一些驱动浏览器，这一篇继续说说驱动浏览器，然后再说一说元素定位的方法。<br>完成环境的安装并测试之后，我们对Selenium有了一定的了解了，接下来我们继续驱动浏览器做一些基本操作：<br>窗口尺寸设置、网页截图、刷新、前进和后退</p><h4 id="2-窗口尺寸设置"><a href="#2-窗口尺寸设置" class="headerlink" title="2.窗口尺寸设置"></a>2.窗口尺寸设置</h4><p>在测试过程中，我们可能会要求打开浏览器的窗口处于最大化或者设置为某一特定尺寸的大小，所以我们使用selenium驱动浏览器时设定窗口大小</p><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-21@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-驱动浏览器和元素定位大法&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome() # 启动chromedef get_size(driver):    &quot;&quot;&quot;    获取窗口尺寸并打印    &quot;&quot;&quot;    size = driver.get_window_size() # 获取窗口尺寸    print(size) # 打印窗口尺寸    time.sleep(3) # 暂停3秒driver.get(&quot;https://www.google.com&quot;) # 打开网页get_size(driver)driver.set_window_size(800,600) # 设置窗口尺寸为800*600get_size(driver)driver.minimize_window() # 窗口最小化，窗口尺寸未发生变化get_size(driver)driver.maximize_window() # 窗口最大化get_size(driver)driver.quit() # 停止进程</code></pre><h4 id="3-网页截图"><a href="#3-网页截图" class="headerlink" title="3. 网页截图"></a>3. 网页截图</h4><p>在完成打开网页时，我们对网页内容进行保存的方式的一种就是进行网页截图，webdriver中就提供了截图的选择</p><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-21@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-驱动浏览器和元素定位大法&#39;&#39;&#39;# 3.导入模块from selenium import webdriverdriver = webdriver.Chrome() # 创建driver对象，启动chromedriver.get(&quot;https://www.google.com&quot;) # 打开网页driver.get_screenshot_as_file(&quot;D:\\screenshot.png&quot;) # 截图driver.quit() # 停止进程</code></pre><h4 id="4-刷新、前进和后退"><a href="#4-刷新、前进和后退" class="headerlink" title="4.刷新、前进和后退"></a>4.刷新、前进和后退</h4><p>  如同在浏览器中进行常规按钮操作，依次打开多个网页后，需要对网页刷新，返回、前进</p><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-21@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-驱动浏览器和元素定位大法&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverdriver = webdriver.Chrome()# 打开两个网页driver.get(&quot;https://www.baidu.com&quot;) time.sleep(3)driver.get(&quot;https://www.google.com&quot;)time.sleep(3)# 进行后退、前进操作driver.back() # 后退time.sleep(3)driver.forward() # 前进time.sleep(3)# 对网页进行刷新driver.refresh()driver.quit()</code></pre><p>一些基本操作就完成了，接下来我们就可以做更多~</p><h4 id="5-定位大法"><a href="#5-定位大法" class="headerlink" title="5.定位大法"></a>5.定位大法</h4><p>webdriver 提供了八种元素定位方法：</p><pre><code>idnameclass nametag namelink textpartial link textxpathcss selector在 Python 语言中对应的定位方法如下：find_element_by_id()find_element_by_name()find_element_by_class_name()find_element_by_tag_name()find_element_by_link_text()find_element_by_partial_link_text()find_element_by_xpath()find_element_by_css_selector()</code></pre><p>下面我们就逐一的来看这些定位方法的使用。在此之前，我们拷取百度首页的前端代码，以定位页面上的元素为例进行讲解。</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;script&gt;&lt;div id=&quot;wrapper&quot; style=&quot;display: block;&quot;&gt;&lt;div id=&quot;debug&quot; style=&quot;display:block;position:..&quot;&gt;&lt;script&gt;&lt;div id=&quot;head&quot; class=&quot;s_down&quot;&gt;&lt;div class=&quot;head_wrapper&quot;&gt;&lt;div class=&quot;s_form&quot;&gt;&lt;div class=&quot;s_form_wrapper&quot;&gt;&lt;div id=&quot;lg&quot;&gt;&lt;a id=&quot;result_logo&quot; onmousedown=&quot;return ..&quot; href=&quot;/&quot;&gt;&lt;form id=&quot;form&quot; class=&quot;fm&quot; action=&quot;/s&quot; name=&quot;f&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;utf-8&quot; name=&quot;ie&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;8&quot; name=&quot;f&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;rsv_bp&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;rsv_idx&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; name=&quot;ch&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;02..&quot; name=&quot;tn&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; name=&quot;bar&quot;&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; autocomplete=&quot;off&quot;maxlength=&quot;100&quot; value=&quot;&quot; name=&quot;wd&quot;&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input id=&quot;su&quot; class=&quot;bg s_btn&quot; type=&quot;submit&quot;value=&quot;百度一下&quot;&gt;&lt;/span&gt;....&lt;/body&gt;&lt;/html&gt;hello</code></pre><p>注意这段代码并非百度首页的页面源代码，而是通过前端工具查看所得到页面代码与结构。那么这样的 HTML 结构有如下特征。</p><p>（1）它们由标签对组成：</p><pre><code>&lt;html&gt;&lt;/html&gt;&lt;body&gt;&lt;/body&gt;&lt;div&gt;&lt;/div&gt;&lt;form&gt;&lt;/form&gt;</code></pre><p>那么 html、div 就是标签的标签名。</p><p>（2）标签各种属性属性：</p><pre><code>&lt;div id=&quot;head&quot; class=&quot;s_down&quot;&gt;&lt;from class=&quot;well&quot;&gt;&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot;&gt;</code></pre><p>就像人一样也会有各种属性，身份证号（id）、姓名（name）、职业（class）等。</p><p>（3）标签对之间可以有文本数据。</p><pre><code>&lt;a&gt;新闻&lt;/a&gt;&lt;a&gt;hao123&lt;/a&gt;&lt;a&gt;地图&lt;/a&gt;</code></pre><p>（4）标签有由层级关系</p><pre><code>&lt;html&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;&lt;div&gt;    &lt;from&gt;        &lt;input /&gt;    &lt;/from&gt;&lt;div&gt;</code></pre><p>对于上面结构，如果把 input 看作是子标签，那么 form 就是它的父标签。<br>理解了上面这些特性是学习定位方法的基础。我们以百度输入框和百度搜索按钮为例来学习不同的定位方法，两个元素的代码如下。</p><pre><code>……&lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; autocomplete=&quot;off&quot; maxlength=&quot;100&quot; value=&quot;&quot;name=&quot;wd&quot;&gt;……&lt;input id=&quot;su&quot; class=&quot;bg s_btn&quot; type=&quot;submit&quot; value=&quot;百度一下&quot;&gt;</code></pre><h5 id="5-1-id-定位"><a href="#5-1-id-定位" class="headerlink" title="5.1 id 定位"></a>5.1 id 定位</h5><p>name 如果把页面上看元素看作一个人的话，如果我们想找一个人如何去找，那么这个人一定有其别于其它人的“属性”，比如他的身份证号一定和别人不一样，他的名字和别人不一样。那么我们就可以通过身证号和名字来找到一个人。那么 id 就可以看做是一个人的身<br>份号，当然这个 id 并不像我们现实中的身份证号有那么强的唯一性，如果在一个页面上发现有两个元素的 id=”kw”也是不足为奇的，这个取决前端代码的规范程度。<br>对百度首页上的输入框与百度搜索按钮来说，定位方法如下：</p><pre><code>find_element_by_id(&quot;kw&quot;)find_element_by_id(&quot;su&quot;)find_element_by_id()方法用于元素中 id 属性的定位。</code></pre><h5 id="5-2-name-定位"><a href="#5-2-name-定位" class="headerlink" title="5.2 name 定位"></a>5.2 name 定位</h5><p>name 的定位与 id 类似，每一个人都会有名字，那么 name 就可作是一个元素的名字。通过 name 定位输入框：</p><pre><code>find_element_by_name(&quot;wd&quot;)find_element_by_name()方法用于元素中 name 属性的定位，百度搜索按钮并没有提供 name 属性，那么我们就不能通过 name 去定位百度搜索按钮。</code></pre><h5 id="5-3-class-定位"><a href="#5-3-class-定位" class="headerlink" title="5.3 class 定位"></a>5.3 class 定位</h5><p>class 也是不少元素会有的一个属性，它的定位和 name 以及 id 类似，下面通过 class 去定位百度输入框和百度搜索按钮：</p><pre><code>find_element_by_class_name(&quot;s_ipt&quot;)find_element_by_class_name(&quot;bg s_btn&quot;)find_element_by_class_name()方法用于元素中 class 属性的定位。</code></pre><h5 id="5-4-tag-定位"><a href="#5-4-tag-定位" class="headerlink" title="5.4 tag 定位"></a>5.4 tag 定位</h5><p>tag 定位取的是一个元素的标签名，通过标签名去定位单个元素的唯一性最底，因为在一个页面中有太多的元素标签为<div>和<input>了，所以很难通过标签名去区分不同的元素。<br>通过标签名定位百度首页上的输入框与百度搜索按钮：</div></p><pre><code>find_element_by_tag_name(&quot;input&quot;)find_element_by_tag_name(&quot;input&quot;)find_element_by_tag_name()方法通过元素的 tag name 来定位元素。通过上面的例子，我们并不能区别不同的元素，因为在一个页面上标签名相同很难以避免。</code></pre><h5 id="5-5-link-定位"><a href="#5-5-link-定位" class="headerlink" title="5.5 link 定位"></a>5.5 link 定位</h5><p>link 定位与前面介绍的几种定位方法有所不同，它专门用来定位本链接。百度输入框上面的几个文本链接的代码如下：</p><pre><code>&lt;a class=&quot;mnav&quot; name=&quot;tj_trnews&quot; href=&quot;http://news.baidu.com&quot;&gt;新闻&lt;/a&gt;&lt;a class=&quot;mnav&quot; name=&quot;tj_trhao123&quot; href=&quot;http://www.hao123.com&quot;&gt;hao123&lt;/a&gt;&lt;a class=&quot;mnav&quot; name=&quot;tj_trmap&quot; href=&quot;http://map.baidu.com&quot;&gt;地图&lt;/a&gt;&lt;a class=&quot;mnav&quot; name=&quot;tj_trvideo&quot; href=&quot;http://v.baidu.com&quot;&gt;视频&lt;/a&gt;&lt;a class=&quot;mnav&quot; name=&quot;tj_trtieba&quot; href=&quot;http://tieba.baidu.com&quot;&gt;贴吧&gt;</code></pre><p>通过查看上面的代码，我们发现通过 name 属性定位是个不错的选择。不过我们这里为了要学习 link定位，通过 link 定位实现如下：</p><pre><code>find_element_by_link_text(&quot;新闻&quot;)find_element_by_link_text(&quot;hao123&quot;)find_element_by_link_text(&quot;地图&quot;)find_element_by_link_text(&quot;视频&quot;)find_element_by_link_text(&quot;贴吧&quot;)find_element_by_link_text()方法通过元素标签对之间的文本信息来定位元素。不过，需要强调的是Python 对于中文的支持并不好，如查 Python 在执行中文的地方出现在乱码，可以在中文件字符串的前面加个小“u”可以有效的避免乱码的问题，加 u 的作用是把中文字</code></pre><p>符串转换中 unicode 编码，如：</p><pre><code>find_element_by_link_text(u&quot;新闻&quot;)</code></pre><h5 id="5-6-partial-link-定位"><a href="#5-6-partial-link-定位" class="headerlink" title="5.6 partial link 定位"></a>5.6 partial link 定位</h5><p>parial link 定位是对 link 定们的一个种补充，有些文本连接会比较长，这个时候我们可以取文本链接的有一部分定位，只要这一部分信息可以唯一的标识这个链接。</p><pre><code>&lt;a class=&quot;mnav&quot; name=&quot;tj_lang&quot; href=&quot;#&quot;&gt;一个很长很长的文本链接&lt;/a&gt;</code></pre><p>通过 partial link 定位如下：</p><pre><code>find_element_by_partial_link_text(&quot;一个很长的&quot;)find_element_by_partial_link_text(&quot;文本连接&quot;)find_element_by_link_text()方法通过元素标签对之间的部分文本信息来定位元素。</code></pre><h4 id="6-定位元素"><a href="#6-定位元素" class="headerlink" title="6.定位元素"></a>6.定位元素</h4><p>selenium提供了多种方式进行定位元素： find_element_by_* </p><pre><code>1 find_element_by_id2 find_element_by_name3 find_element_by_xpath4 find_element_by_link_text5 find_element_by_partial_link_text6 find_element_by_tag_name7 find_element_by_class_name8 find_element_by_css_selector</code></pre><p>当然也可以一次定位多个元素： find_elements_by_* </p><pre><code>1 find_elements_by_name2 find_elements_by_xpath3 find_elements_by_link_text4 find_elements_by_partial_link_text5 find_elements_by_tag_name6 find_elements_by_class_name7 find_elements_by_css_selector</code></pre><p>因为id是唯一的，所以一次定位多个元素是没有办法通过id进行定位的。<br>同样，可以通过 find_element 和  find_elements ，不过使用之前需要导入by类， from selenium.webdriver.common.by import By 。</p><pre><code># coding=utf-8🔥# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-21@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-驱动浏览器和元素定位大法&#39;&#39;&#39;# 3.导入模块import timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()# 打开一个网页driver.get(&quot;https://www.zhihu.com/&quot;)# 查找一个元素的方法ele = driver.find_element_by_xpath(    &#39;//*[@id=&quot;root&quot;]/div/div[2]/header/div/nav/a[2]&#39;)ele.click() # 点击已定位的元素driver.back() # 退回time.sleep(5)ele = driver.find_element(    By.XPATH, &#39;//*[@id=&quot;root&quot;]/div/div[2]/header/div/nav/a[2]&#39;)# ID = &quot;id&quot;# XPATH = &quot;xpath&quot;# LINK_TEXT = &quot;link text&quot;# PARTIAL_LINK_TEXT = &quot;partial link text&quot;# NAME = &quot;name&quot;# TAG_NAME = &quot;tag name&quot;# CLASS_NAME = &quot;class name&quot;# CSS_SELECTOR = &quot;css selector&quot;ele.click()driver.back()# 查找多个元素的方法eles = driver.find_elements_by_class_name(&quot;Feed&quot;)print(eles)print(len(eles))time.sleep(5)eles = driver.find_elements(By.CLASS_NAME, &#39;Feed&#39;)# XPATH = &quot;xpath&quot;# LINK_TEXT = &quot;link text&quot;# PARTIAL_LINK_TEXT = &quot;partial link text&quot;# NAME = &quot;name&quot;# TAG_NAME = &quot;tag name&quot;# CLASS_NAME = &quot;class name&quot;# CSS_SELECTOR = &quot;css selector&quot;print(eles)print(len(eles))driver.quit()</code></pre><p>以上就是定位元素的一些方法。说明下xpath是比较好用的方式，之后可以多多练习使用xpath进行定位元素。<br>前面所介绍的几种定位方法相对来说比较简单，我们理想状态下在一个页面当中每一个元素都会有一个唯一 id 和 name 属性值，我们通过它的属性值来找到他们，但在实际的项目中并非想象的这般美好。有时候一个元素并没有 id 或 name 属性，或者会有多个元素的<br>id 和 name 属性值是一样的，又或者每一次刷新页面，id 的值都会随机变化。那么在这种情况下我们如何来定位元素呢？<br>下面一篇介绍 xpath 与 CSS 定位相比上面介绍的方式来说比较难理解，但他们的灵活的定位能力远比上面的几种方式要强大得多。<br>那么下面宏哥接下来就分享一下xpath的相关知识。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h4><p>　　好了，今天python+ selenium-驱动浏览器和元素定位大法就分享到这里。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium自动化测试2</title>
      <link href="/2016/01/20/selenium/"/>
      <url>/2016/01/20/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>《手把手教你》系列基础篇之2-python+ selenium自动化测试-打开和关闭浏览器（详细）</strong></p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>本节介绍如何初始化一个webdriver实例对象driver，然后打开和关闭firefox浏览器。要用selenium打开fiefox浏览器。首先需要去下载一个driver插件geckodriver.exe， 下载地址<a href="https://github.com/mozilla/geckodriver/releases，下载好这个exe文件后，把这个文件放到" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases，下载好这个exe文件后，把这个文件放到</a><br>你的python安装目录下，例如：C:\Python27\geckdriver.exe。<br>作为刚初学者，这里不建议使用Python IDE工具，选择一个功能强大的记事本编辑工具就好，例如Notepad++.等以后积累足够了，需要编写更多文件，或者后期简单框架设计，我们再来介绍和使用Pycharm这个IDE工具。<br>上一篇匆匆忙忙地将selenium安装以后也没有给小伙伴们介绍一下，今天就给不清楚的小伙伴和同学们普及一下selenium。</p><h4 id="2-Selenium-基本介绍"><a href="#2-Selenium-基本介绍" class="headerlink" title="2.Selenium 基本介绍"></a>2.Selenium 基本介绍</h4><p>Selenium是开源的自动化测试工具，它主要是用于Web 应用程序的自动化测试，不只局限于此，同时支持所有基于web 的管理任务自动化。</p><h5 id="2-1Selenium官网的介绍"><a href="#2-1Selenium官网的介绍" class="headerlink" title="2.1Selenium官网的介绍"></a>2.1Selenium官网的介绍</h5><p>Selenium is a suite of tools to automate web browsers across many platforms.runs in many browsers and operating systems can be controlled by many programming languages and testing frameworks.</p><p>Selenium 官网：<a href="http://seleniumhq.org/" target="_blank" rel="noopener">http://seleniumhq.org/</a></p><p>Selenium Github 主页：<a href="https://github.com/SeleniumHQ/selenium" target="_blank" rel="noopener">https://github.com/SeleniumHQ/selenium</a></p><p>Selenium 是用于测试 Web 应用程序用户界面 (UI) 的常用框架。它是一款用于运行端到端功能测试的超强工具。您可以使用多个编程语言编写测试，并且 Selenium 能够在一个或多个浏览器中执行这些测试。</p><p>Selenium 经历了三个版本：Selenium 1，Selenium 2 和 Selenium 3。Selenium 也不是简单一个工具，而是由几个工具组成，每个工具都有其特点和应用场景。<br>Selenium 诞生于 2004 年，当在 ThoughtWorks 工作的 Jason Huggins 在测试一个内部应用时。作为一个聪明的家伙，他意识到相对于每次改动都需要手工进行测试，他的时间应该用得更有价值。他开发了一个可以驱动页面进行交互的 Javascript 库，能让多浏览器自动返回测试结果。那个库最终变成了 Selenium 的核心，它是 Selenium RC（远程控制）和 Selenium IDE 所有功能的基础。Selenium RC 是开拓性的，因为没有其他产品能让你使用自己喜欢的语言来控制浏览器。这就是 Selenium 1。<br>然而，由于它使用了基于 Javascript 的自动化引擎，而浏览器对 Javascript 又有很多安全限制，有些事情就难以实现。更糟糕的是，网站应用正变得越来越强大，它们使用了新浏览器提供的各种特性，都使得这些限制让人痛苦不堪。在 2006 年，一名 Google 的工程师， Simon Stewart 开始基于这个项目进行开发，这个项目被命名为 WebDriver。此时，Google 早已是 Selenium 的重度用户，但是测试工程师们不得不绕过它的限制进行工具。Simon 需要一款能通过浏览器和操作系统的本地方法<br>直接和浏览器进行通话的测试工具，来解决Javascript 环境沙箱的问题。WebDriver 项目的目标就是要解决 Selenium 的痛点。<br>到了 2008 年，Selenium 和 WebDriver 两个项目合并。Selenium 有着丰富的社区和商业支持，但 WebDriver 显然代表着未来的趋势。两者的合并为所有用户提供了一组通用功能，并且借鉴了一些测试自动化领域最闪光的思想。这就是 Selenium 2。<br>2016 年，Selenium 3 诞生。移除了不再使用的 Selenium 1 中的 Selenium RC，并且官方重写了所有的浏览器驱动。</p><h5 id="2-2Selenium-工具集"><a href="#2-2Selenium-工具集" class="headerlink" title="2.2Selenium 工具集"></a>2.2Selenium 工具集</h5><h6 id="2-2-1Selenium-IDE"><a href="#2-2-1Selenium-IDE" class="headerlink" title="2.2.1Selenium IDE"></a>2.2.1Selenium IDE</h6><p>Selenium IDE (集成开发环境) 是一个创建测试脚本的原型工具。它是一个 Firefox 插件，实现简单的浏览器操作的录制与回放功能，提供创建自动化测试的建议接口。Selenium IDE 有一个记录功能，能记录用户的操作，并且能选择多种语言把它们导出到一个可重用<br>的脚本中用于后续执行。</p><h6 id="2-2-2-Selenium-RC"><a href="#2-2-2-Selenium-RC" class="headerlink" title="2.2.2 Selenium RC"></a>2.2.2 Selenium RC</h6><p>Selenium RC 是selenium 家族的核心工具，Selenium RC 支持多种不同的语言编写自动化测试脚本，通过selenium RC 的服务器作为代理服务器去访问应用从而达到测试的目的。<br>selenium RC 使用分Client Libraries 和Selenium Server。<br>Client Libraries 库主要主要用于编写测试脚本，用来控制selenium Server 的库。<br>Selenium Server 负责控制浏览器行为，总的来说，Selenium Server 主要包括3 个部分：Launcher、Http Proxy、Core。</p><h6 id="2-2-3-Selenium-Grid"><a href="#2-2-3-Selenium-Grid" class="headerlink" title="2.2.3 Selenium Grid"></a>2.2.3 Selenium Grid</h6><p>Selenium Grid 使得 Selenium RC 解决方案能提升针对大型的测试套件或者哪些需要运行在多环境的测试套件的处理能力。Selenium Grid 能让你并行的运行你的测试，也就是说，不同的测试可以同时跑在不同的远程机器上。这样做有两个有事，首先，如果你有一个<br>大型的测试套件，或者一个跑的很慢的测试套件，你可以使用 Selenium Grid 将你的测试套件划分成几份同时在几个不同的机器上运行，这样能显著的提升它的性能。同时，如果你必须在多环境中运行你的测试套件，你可以获得多个远程机器的支持，它们将同时运行<br>你的测试套件。在每种情况下，Selenium Grid 都能通过并行处理显著地缩短你的测试套件的处理时间。</p><h6 id="2-2-4-Selenium-WebDriver"><a href="#2-2-4-Selenium-WebDriver" class="headerlink" title="2.2.4 Selenium WebDriver"></a>2.2.4 Selenium WebDriver</h6><p>WebDriver 是 Selenium 2 主推的工具，事实上WebDriver是Selenium RC的替代品，因为Selenium需要保留向下兼容性的原因，在 Selenium 2 中， Selenium RC才没有被彻底的抛弃，如果使用Selenium开发一个新的自动化测试项目，那么我们强烈推荐使用<br>Selenium2 的 WebDriver进行编码。另外， 在Selenium 3 中，Selenium RC 被移除了。</p><h4 id="3-浏览器驱动driver安装"><a href="#3-浏览器驱动driver安装" class="headerlink" title="3.浏览器驱动driver安装"></a>3.浏览器驱动driver安装</h4><h5 id="3-1浏览器驱动driver的下载"><a href="#3-1浏览器驱动driver的下载" class="headerlink" title="3.1浏览器驱动driver的下载"></a>3.1浏览器驱动driver的下载</h5><p>driver的下载应该是比较坑的部分，一定需要注意浏览器版本。</p><p>从selenium官网进入下载界面，这个时候请往下拉，虽然第三方的浏览器都不是selenium官方开发的，但是你可以在selenium官网找到selenium支持的浏览器相对应的驱动driver下载链接，因为我在本地使用的浏览器版本都是比较新的，所以对应的driver版本也都下载最新版即可。</p><p>以下是三大常用浏览器的下载链接：</p><p>Google Chrome driver：<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></p><p>Mozilla GeckoDriver：<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></p><p>Internet Explorer Driver：<a href="http://selenium-release.storage.googleapis.com/3.13/IEDriverServer_x64_3.13.0.zip" target="_blank" rel="noopener">http://selenium-release.storage.googleapis.com/3.13/IEDriverServer_x64_3.13.0.zip</a></p><h5 id="3-2浏览器驱动driver的安装"><a href="#3-2浏览器驱动driver的安装" class="headerlink" title="3.2浏览器驱动driver的安装"></a>3.2浏览器驱动driver的安装</h5><p>下载下来的zip文件解压至python安装目录中，可以放置在：C:\Users\Administrator\AppData\Local\Programs\Python\Python36中，但是推荐放置在scripts目录中：C:\Users\Administrator\AppData\Local\Programs\Python\Python36\Scripts</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/nwqkD7ZMIm4vAGi.png" alt="1196630-20180704095308704-1620635076.png"></p><h4 id="4-测试驱动浏览器"><a href="#4-测试驱动浏览器" class="headerlink" title="4.测试驱动浏览器"></a>4.测试驱动浏览器</h4><h5 id="4-1CMD中启动python并从selenium引入webdriver包"><a href="#4-1CMD中启动python并从selenium引入webdriver包" class="headerlink" title="4.1CMD中启动python并从selenium引入webdriver包"></a>4.1CMD中启动python并从selenium引入webdriver包</h5><p><code>from selenium import webdriver</code></p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/sHaojLSFeBE1M6W.png" alt="1196630-20180704101237824-1245397003.png"></p><h5 id="4-2驱动chrome浏览器"><a href="#4-2驱动chrome浏览器" class="headerlink" title="4.2驱动chrome浏览器"></a>4.2驱动chrome浏览器</h5><p>打开Chrome浏览器，访问谷歌网址，然后再关闭Chrome浏览器。</p><h6 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-20@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-打开和关闭浏览器&#39;&#39;&#39;# 3.导入模块from selenium import webdriverCh_driver = webdriver.Chrome()Ch_driver.get(&quot;https://www.google.com&quot;)Ch_driver.quit() # 使用quit()关闭了chrome并结束了此次测试，如果是close()只是关闭chrome，后台仍在进行。</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/Y1X9JSeTtUPnpZ3.png" alt="1196630-20180704101630657-1814386536.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/a1ufl8GovkYLCEg.png" alt="1196630-20180704100807496-347760964.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/W75NLwEK9sM2QY1.png" alt="1196630-20180704100857370-284197383.png"></p><h5 id="4-3驱动Firefox浏览器"><a href="#4-3驱动Firefox浏览器" class="headerlink" title="4.3驱动Firefox浏览器"></a>4.3驱动Firefox浏览器</h5><p>打开Firefox浏览器，访问谷歌网址，然后再关闭Firefox浏览器。</p><h6 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-20@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-打开和关闭浏览器&#39;&#39;&#39;# 3.导入模块from selenium import webdriverFi_driver = webdriver.Firefox()Fi_driver.get(&quot;https://www.google.com&quot;)Fi_driver.quit()</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/iG892kx7FANnUTu.png" alt="1196630-20180704103046654-2141193591.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/QTi4h81sl97bAKq.png" alt="1196630-20180704103057910-1845587517.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/BRsDUIXfwV752WM.png" alt="1196630-20180704103113580-1652103038.png"></p><h5 id="4-4驱动IE浏览器"><a href="#4-4驱动IE浏览器" class="headerlink" title="4.4驱动IE浏览器"></a>4.4驱动IE浏览器</h5><p>打开IE浏览器，访问谷歌网址，然后再关闭IE浏览器。</p><h6 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h6><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-20@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-打开和关闭浏览器&#39;&#39;&#39;# 3.导入模块from selenium import webdriverIe_driver = webdriver.Ie()Ie_driver.get(&quot;https://www.google.com&quot;)Ie_driver.quit()</code></pre><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/FcdzXN7k6fDulZU.png" alt="1196630-20180704103637539-1818569735.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/QMJtbzV69pujxlL.png" alt="1196630-20180704103702229-1094809754.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/31/voT7tkyMSUcpJ5h.png" alt="1196630-20180704103648309-1601883642.png"></p><p>看起来都正常驱动浏览器并打开了网页，然后关闭退出浏览器。这样我们就完成了selenium自动化测试的打开和关闭浏览器的准备工作~</p><p>注意:可能出现的报错</p><p>Exception: Message: Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones.</p><p>解决办法：Internet选项-&gt;安全; 把Internet站点，本地Intrant,受信任站点 三个地方的安全界面都设置相同等级，例如都设置中； 再次运行代码就可以用IE打开百度了。</p><p>总结：目前，由于IE的不稳定性和速度问题，建议采用火狐或者谷歌浏览器来测试和debug自动化脚本。</p><h5 id="4-5总结"><a href="#4-5总结" class="headerlink" title="4.5总结"></a>4.5总结</h5><p>以上代码可以写在一个文件然后执行这个文件即可。细心的小伙伴或者是童鞋觉得刚打开浏览器时窗口有点小的话，你可以通过代码最大化一下浏览器。<br>用Notepad++打开一个空白文件，输入如下代码，保存为first.py</p><pre><code># coding=utf-8# 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行# 2.注释：包括记录创建时间，创建人，项目名称。&#39;&#39;&#39;Created on 2016-1-20@author: 北京-宏哥   QQ交流群：705269076Project: python+ selenium-打开和关闭浏览器&#39;&#39;&#39;# 3.导入模块from selenium import webdriver # 导入webdriver包driver = webdriver.Firefox() # 初始化一个火狐浏览器实例：driverdriver.maximize_window() # 最大化浏览器driver.get(&quot;https://www.baidu.com&quot;) # 通过get()方法，打开一个url站点driver.quit() #关闭并退出浏览器</code></pre><p>打开cmd窗口，cd到first.py所在的路径，在cmd中输入命令: python first.py回车，可以看看是否打开火狐，打开百度，关闭火狐的效果。</p><h5 id="4-6小结"><a href="#4-6小结" class="headerlink" title="4.6小结"></a>4.6小结</h5><p>通过上面代码，和本文，基本了解了如何打开和关闭浏览器。如果想打开IE或者Chrome浏览器，也需要下载对应浏览器的driver.exe文件，放到python安装目录。</p><p>注意：可能会遇到一些报错</p><ol><li><p>geckodriver.exe没有放到python安装目录下，这一类报错。</p></li><li><p>python first.py执行后，找到文件，说明没有通过cd命令切换到first.py所在的文件夹路径。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+ selenium自动化测试1</title>
      <link href="/2016/01/19/selenium/"/>
      <url>/2016/01/19/selenium/</url>
      
        <content type="html"><![CDATA[<p><strong>《手把手教你》系列基础篇之1-python+selenium自动化测试-环境搭建（详细）</strong></p><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><p>基于python3和selenium3做自动化测试，俗话说：工欲善其事必先利其器；没有金刚钻就不揽那瓷器活，磨刀不误砍柴工，因此你必须会搭建基本的开发环境，掌握python基本的语法和一个IDE来进行开发，这里通过详细的讲解，介绍怎么搭建python3和selenium3开发环境，并提供一个基本入门的代码，后续逐步提供系列实践文章。</p><h4 id="2-安装包"><a href="#2-安装包" class="headerlink" title="2.安装包"></a>2.安装包</h4><h5 id="2-1python"><a href="#2-1python" class="headerlink" title="2.1python"></a>2.1python</h5><p>笔者使用python3.6.4，请根据机器是64位还是32位来选择对应的python版本。（相信绝大部分人都可以很从容的来查看自己机器的位数，在这里就不赘述了，如果不清楚自己可以百度一下就可以）</p><p>可以去python官网：<a href="https://www.python.org/下载对应机器的安装包。" target="_blank" rel="noopener">https://www.python.org/下载对应机器的安装包。</a></p><h5 id="2-2安装包下载"><a href="#2-2安装包下载" class="headerlink" title="2.2安装包下载"></a>2.2安装包下载</h5><p>第一步：进入python官网，点击download，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/TlYDRcL6zuZJCSe.png" alt="1232840-20180122184511350-1226324994.png"></p><p>第二步：选择对应的操作系统和python版本，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/MfQ6oJaLtBZEhqV.png" alt="20200728134233.png"></p><p>第三步：点击要下载的python版本，即可下载安装包，如下图所示：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/W87paxquvHeKAiZ.png" alt="1232840-20180122184938053-209714012.png"></p><h4 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3.开发工具"></a>3.开发工具</h4><h5 id="3-1笔者使用pyCharm开源版本"><a href="#3-1笔者使用pyCharm开源版本" class="headerlink" title="3.1笔者使用pyCharm开源版本"></a>3.1笔者使用pyCharm开源版本</h5><p><a href="https://download.jetbrains.com/python/pycharm-community-2017.3.2.exe" target="_blank" rel="noopener">https://download.jetbrains.com/python/pycharm-community-2017.3.2.exe</a></p><h5 id="3-2python安装过程"><a href="#3-2python安装过程" class="headerlink" title="3.2python安装过程"></a>3.2python安装过程</h5><p>第一步：双击已下载的python安装包，出现如下图所示的界面，点击运行</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/VtjJcSOofzFnxvQ.png" alt="1232840-20180125081923959-820008667.png"></p><p>第二步：然后出现如下界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/ip5RMkcHGOeYnaF.png" alt="1232840-20180125081947522-576250013.png"></p><p>第三步：在这里我选择的是自定义安装（Customize installation）,一定要勾选Add_Python 3.6 to PATH,防止手工添加环境变量 ，添加到环境变量也可以等安装完成之后手动添加到环境变量中，如果不添加环境变量运行python时则会出现如下界面：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/3b8Y1ZAqRJj4CSM.png" alt="1232840-20180125082242600-913202133.png"> </p><p>第四步：在这里我没有选择添加到环境变量中，后面会手动配置继续下一步界面如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/hx35TDX6WCReKIO.png" alt="1232840-20180125082347334-519542621.png"> </p><p>第五步：选择安装的属性，Documentation、pip、tcl/tk and IDLE 必须安装，tcl/tk and IDLE是Python环境的开发环境窗口，pip用来安装numpy等package。 我选择的是全部安装继续下一步</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/IFNQjPE17sXbulT.png" alt="1232840-20180125082415600-1532368620.png"></p><p>第六步：ok了，点击install进行安装，在这里我安装的目录是D盘，D:\Python36  目录名可以自定义</p><p>注意我在这里依旧没有选择添加到环境变量，不想麻烦的话，可以直接选择添加到环境变量中</p><p>第七步：安装中</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/UyrAwOIkpejDoiY.png" alt="1232840-20180125082501475-844336595.png"></p><p>第八步：安装成功：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/vHXF3AdWhTk47nf.png" alt="1232840-20180125082519694-720723869.png"></p><p>第九步：验证是否安装成功，使用系统的cmd命令：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/dDBXGAzmqUr2CZH.png" alt="1232840-20180125082535647-2065919964.png"></p><p>第十步：验证失败，如果在安装的过程你选择了添加到环境变量中，输入python就会直接进入python的环境中，现在开始演示手动添加到环境变量：</p><p>第十一步：首先，点击计算机-&gt;属性-&gt;高级系统设置</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/Azp7krclQd8B9Wt.png" alt="1232840-20180125082606944-1472431185.png"><br><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/PrCnxc5qFsyTBlm.png" alt="1232840-20180125082557522-658702405.png"></p><p>第十二步：选择环境变量</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/7wy8C5eLZa4x1MB.png" alt="1232840-20180125082626022-2002003945.png"></p><p>第十三步：新建 PATH </p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/g8QH1acnhTGvZRB.png" alt="1232840-20180125082658662-41383109.png"></p><p>第十四步：点击确定，接下来进行验证python是否安装成功：</p><p>依然是cmd命令下输入python，效果如下：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/C4IQVtBW3z1RmxO.png" alt="1232840-20180125082719537-789506861.png"></p><p>当你输入python出现如下命令时则表示python环境已经安装好了，就可以进行python之旅了。</p><h5 id="3-2下载Selenium-for-python"><a href="#3-2下载Selenium-for-python" class="headerlink" title="3.2下载Selenium for python"></a>3.2下载Selenium for python</h5><p>1） 下载 Selenium for python<br>到 <a href="https://pypi.python.org/pypi/selenium#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium#downloads</a> 下载最新版本，当前是3.0.2</p><p>下载tar.gz的包</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/jL1MmZNOrGUSwTJ.png" alt="1232840-20191125092123429-102402650.png"> </p><p>下载完解压：</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/8BzQ2JPnqr61kag.png" alt="1232840-20191125092139868-1937955939.png"></p><p>2） 安装Selenium<br>打开cmd，然后cd到解压包当前路径，输入 python setup.py install ，cmd窗口会出现解压滚动屏幕，直到安装完成。如下图。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/zZKXksIwYx4NvB9.png" alt="1232840-20191125092158909-574405322.png"> </p><p>验证selenium安装成功办法：</p><p>在cmd输入python进入python环境，然后输入 from selenium import webdriver，如果不报错就代表selenium安装成功。</p><p><img src="/images/loading.gif" data-original="https://i.loli.net/2020/07/28/Xu5STilMtUq9vxk.png" alt="1232840-20191125092213199-461961242.png"></p><p>3） 第二个安装selenium方式</p><p>还有一种安装方式，在线安装，在cmd输入 python -m pip install selenium，然后回车，自动安装。</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>好了，还是那句老话，好多人都死在环境搭建的路上，幸运的你是否已经搭建成功，跟着宏哥的脚步继续砥砺前行。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
